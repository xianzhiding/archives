<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xianzhiding.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="很难追踪 JavaScript（ECMAScript）中的新功能。 想找到有用的代码示例更加困难。 因此，在本文中，我将介绍 TC39 已完成 ES2016，ES2017 和 ES2018（最终草案）提案中所有添加的 18 个功能，并展示有用的示例。 很难跟踪各种版本的ECMAScript中的新内容，而且如果没有跳转就更难获得有用的示例。因此，在本文中，我将介绍在ES2016，ES2017和ES2">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMAScript 2016,2017和2018中所有新功能的示例">
<meta property="og:url" content="https://xianzhiding.github.io/2018/07/22/ecmascript-20162017%E5%92%8C2018%E4%B8%AD%E6%89%80%E6%9C%89%E6%96%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E7%A4%BA%E4%BE%8B/index.html">
<meta property="og:site_name" content="前端开发 大前端 W3Cbest">
<meta property="og:description" content="很难追踪 JavaScript（ECMAScript）中的新功能。 想找到有用的代码示例更加困难。 因此，在本文中，我将介绍 TC39 已完成 ES2016，ES2017 和 ES2018（最终草案）提案中所有添加的 18 个功能，并展示有用的示例。 很难跟踪各种版本的ECMAScript中的新内容，而且如果没有跳转就更难获得有用的示例。因此，在本文中，我将介绍在ES2016，ES2017和ES2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_OhhFTNabUEz8ZeI4vaCIJw.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_c1k1vgBgGaam7XA8xAp49w.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_OkcC2Sozg0MKvkaqZWxmnw.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_23RYJzstZ7iMxKNYbfAAWg.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_XAXiVkw2zKyBio4OX6DQoQ.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_KLrT9Xmh43cIi2MFUmIfcw.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_fLXPci_E_yXK9uSqLz-axQ.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_7r4pk8hfx5VQ9-ERu--xCw.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_gvlG4DfnkiOrlgPsQrjLfg.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_-SKZCxQdf8Rk48SSaPtDGg.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_L3FZ0onbBD4ay6UhZvPoMw.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_ylheY6gJawprWEVNL68mRQ.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_VEF_Sq067Liq4lfTV8Xv0A.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_iP84ax2TOt5dbaIjW7kzcw.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_Bkls3dXMIRGKAwFN2r--qg.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_hhkv5ZBOUYViCL2UP0sv5Q.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_4EizdrE9LlRZ5GXRq4G3Yw.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_PfeJ5R0h6SHx6SxSkPCLmg.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_t5xegqe5su6XgRDcBObyDw.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_1ORiZapMHp_SV5gvOVT2WA.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_O6i-gXHBifD27qD73Sw7TA.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_weBLy9CAXFnWNwUqcwNMAg.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_Uh4-1F3aeoy5k3hq8nVlfQ.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_43kFc4JJy8DSQiA_zQXZZA.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_QmSUhdHQiXaXL9vdE27Djg.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_MJuEF0dePb_NE8DHFm0XNw.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_e1N-waOWBc3ykLRFCIzXSA.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_c-bRDN8WERPUYevc38jZMg.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_DwP_VN4VUp7osFQC-I9OsQ.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_DsQryeDlp8fAKBS8k_ohqw.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_P1V6c1ncEjeCgtS6zzR0gg.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_tSbu3kZCkoGpXaWDuP6MPA.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_kB6Ar5YJoAlwwhFqzMGBGg.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_wCcbabJsS8UbFclumSISqg.png">
<meta property="og:image" content="http://file.w3cbest.com/file/images/1_liLeNfWxZ3x1sqrVmRUdRQ.png">
<meta property="article:published_time" content="2018-07-22T08:00:31.000Z">
<meta property="article:modified_time" content="2021-08-30T02:43:26.857Z">
<meta property="article:author" content="Tom">
<meta property="article:tag" content="javascript教程">
<meta property="article:tag" content="ECMAScript2016">
<meta property="article:tag" content="ECMAScript教程">
<meta property="article:tag" content="js教程">
<meta property="article:tag" content="ECMAScript">
<meta property="article:tag" content="ECMAScript 2017">
<meta property="article:tag" content="ECMAScript 2018">
<meta property="article:tag" content="ES教程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://file.w3cbest.com/file/images/1_OhhFTNabUEz8ZeI4vaCIJw.png">

<link rel="canonical" href="https://xianzhiding.github.io/2018/07/22/ecmascript-20162017%E5%92%8C2018%E4%B8%AD%E6%89%80%E6%9C%89%E6%96%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E7%A4%BA%E4%BE%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>ECMAScript 2016,2017和2018中所有新功能的示例 | 前端开发 大前端 W3Cbest</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">前端开发 大前端 W3Cbest</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个专注 WEB 开发的技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/07/22/ecmascript-20162017%E5%92%8C2018%E4%B8%AD%E6%89%80%E6%9C%89%E6%96%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E7%A4%BA%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ECMAScript 2016,2017和2018中所有新功能的示例
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-22 16:00:31" itemprop="dateCreated datePublished" datetime="2018-07-22T16:00:31+08:00">2018-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 10:43:26" itemprop="dateModified" datetime="2021-08-30T10:43:26+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>很难追踪 JavaScript（ECMAScript）中的新功能。 想找到有用的代码示例更加困难。 因此，在本文中，我将介绍 TC39 已完成 ES2016，ES2017 和 ES2018（最终草案）提案中所有添加的 18 个功能，并展示有用的示例。 很难跟踪各种版本的ECMAScript中的新内容，而且如果没有跳转就更难获得有用的示例。因此，在本文中，我将介绍在ES2016，ES2017和ES2018（最终草案）中添加的TC39完成提案中列出的所有18个功能，并向他们展示有用的示例。</p>
<h2 id="ECMAScript-2016"><a href="#ECMAScript-2016" class="headerlink" title="ECMAScript 2016"></a>ECMAScript 2016</h2><h3 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1.Array.prototype.includes"></a>1.Array.prototype.includes</h3><p>includes 是 Array 上的一个简单实例方法，有助于轻松查找某项元素是否在数组中（包括NaN ,与 indexOf不同）。 <img src="http://file.w3cbest.com/file/images/1_OhhFTNabUEz8ZeI4vaCIJw.png"> 人们想要 contains 来命名该规范，但显然 Mootools 已经使用过这个命名，所以使用了 includes。</p>
<h3 id="2-指数运算符"><a href="#2-指数运算符" class="headerlink" title="2.指数运算符"></a>2.指数运算符</h3><p>加法和减法等数学运算分别具有 + 和 - 等中缀运算符。与它们类似，** 中缀运算符通常用于指数运算。在 ECMAScript 2016 中，引入了 ** 代替 Math.pow 。 <img src="http://file.w3cbest.com/file/images/1_c1k1vgBgGaam7XA8xAp49w.png"></p>
<h2 id="ECMAScript-2017"><a href="#ECMAScript-2017" class="headerlink" title="ECMAScript 2017"></a>ECMAScript 2017</h2><h3 id="1-Object-values"><a href="#1-Object-values" class="headerlink" title="1.Object.values()"></a>1.Object.values()</h3><p>Object.values() 是一个与 Object.keys() 类似的新函数，但返回 Object 自身属性的所有值，不包括原型链中的任何值。 <img src="http://file.w3cbest.com/file/images/1_OkcC2Sozg0MKvkaqZWxmnw.png"></p>
<h3 id="2-Object-entries"><a href="#2-Object-entries" class="headerlink" title="2.Object.entries()"></a>2.Object.entries()</h3><p>Object.entries() 与 Object.keys 相关，但它不仅仅返回 keys ，而是以数组方式返回 keys 和 values 。这使得在循环中使用对象或将对象转换为 Maps 等操作变得非常简单。 <img src="http://file.w3cbest.com/file/images/1_23RYJzstZ7iMxKNYbfAAWg.png"> <img src="http://file.w3cbest.com/file/images/1_XAXiVkw2zKyBio4OX6DQoQ.png"></p>
<h3 id="3-字符串填充"><a href="#3-字符串填充" class="headerlink" title="3.字符串填充"></a>3.字符串填充</h3><p>String 中添加了两个实例方法，String.prototype.padStart 和 String.prototype.padEnd – 允许将空字符串或其他字符串附加到原始字符串的开头或结尾。</p>
<p>‘someString’.padStart(numberOfCharcters [,stringForPadding]);<br>‘5’.padStart(10) // ‘ 5’<br>‘5’.padStart(10, ‘=*‘) //‘=*=*=*=*=5’<br>‘5’.padEnd(10) // ‘5 ‘<br>‘5’.padEnd(10, ‘=*‘) //‘5=*=*=*=*=’</p>
<h4 id="3-1-padStart-示例"><a href="#3-1-padStart-示例" class="headerlink" title="3.1 padStart 示例"></a>3.1 padStart 示例</h4><p>在下面的示例中，我们列出了不同长度的数字。我们希望前置“0”，以便所有项具有相同的 10 位数长度显示。我们可以使用 padStart(10, ‘0’) 轻松实现这一目标。 <img src="http://file.w3cbest.com/file/images/1_KLrT9Xmh43cIi2MFUmIfcw.png"></p>
<h4 id="3-2-padEnd-示例"><a href="#3-2-padEnd-示例" class="headerlink" title="3.2 padEnd 示例"></a>3.2 padEnd 示例</h4><p>当我们打印不同长度的多个项并希望正确对齐它们时，padEnd 真的很方便。 下面的示例是 padEnd，padStart 和 Object.entries 组合在一起以产生漂亮输出的一个很好的现实示例。 <img src="http://file.w3cbest.com/file/images/1_fLXPci_E_yXK9uSqLz-axQ.png"></p>
<p>const cars = {<br>    ‘?BMW’: ‘10’,<br>    ‘?Tesla’: ‘5’,<br>    ‘?Lamborghini’: ‘0’<br>}<br>Object.entries(cars).map(([name, count]) =&gt; {<br>    //padEnd appends ‘ -‘ until the name becomes 20 characters<br>    //padStart prepends ‘0’ until the count becomes 3 characters.<br>    console.log(`${name.padEnd(20, ‘ -‘)} Count: ${count.padStart(3, ‘0’)}`)<br>});<br>//Prints..<br>// ?BMW - - - - - - -  Count: 010<br>// ?Tesla - - - - - -  Count: 005<br>// ?Lamborghini - - -  Count: 000</p>
<h4 id="3-3-⚠️padStart-和-padEnd-用于-Emojis-表情和其他双字节字符"><a href="#3-3-⚠️padStart-和-padEnd-用于-Emojis-表情和其他双字节字符" class="headerlink" title="3.3 ⚠️padStart 和 padEnd 用于 Emojis 表情和其他双字节字符"></a>3.3 ⚠️padStart 和 padEnd 用于 Emojis 表情和其他双字节字符</h4><p>Emojis 和其他双字节字符使用多个字节的 unicode 表示。 所以 padStart 和 padEnd 可能无法按预期工作！⚠️ 例如：假设我们把字符串 heart 通过 emoji表情 ❤️ 使用 padStart 延长到十个字节，这个时候我们得到如下的输出：</p>
<p>//Notice that instead of 5 hearts, there are only 2 hearts and 1 heart that looks odd!<br>‘heart’.padStart(10, “❤️”); // prints.. ‘❤️❤️❤heart’</p>
<p>这是因为 ❤️ 本身占据两个字节（\u2764\uFE0F），而 heart 本身有 5 个字节，所以我们只剩 5 个字节的位置可以填充，JS使用\u2764\uFE0F 来填充两颗心并产生 ❤️❤️ 。对于最后一个，它只使用 heart \u2764 的第一个字节产生 ❤ 所以我们最终得到：❤️❤️❤heart</p>
<h4 id="4-Object-getOwnPropertyDescriptors"><a href="#4-Object-getOwnPropertyDescriptors" class="headerlink" title="4.Object.getOwnPropertyDescriptors"></a>4.Object.getOwnPropertyDescriptors</h4><p>此方法返回给定对象的所有属性的所有详细信息（包括 getter get 和 setter set方法）。 添加它的主要动机是允许浅复制/克隆对象到另一个对象，该对象也复制 getter 和 setter 函数而不像 Object.assign。 <strong>Object.assign 浅复制除原始源对象的 getter 和 setter 函数之外的所有信息。</strong> 下面的示例显示了 Object.assign 和 Object.getOwnPropertyDescriptors 以及 Object.defineProperties 之间的区别，以将原始对象 Car 复制到新对象 ElectricCar 中。 你将看到，通过使用 Object.getOwnPropertyDescriptors，discount getter 和 setter 函数也会复制到目标对象中。 之前… <img src="http://file.w3cbest.com/file/images/1_7r4pk8hfx5VQ9-ERu--xCw.png"> 以后… <img src="http://file.w3cbest.com/file/images/1_gvlG4DfnkiOrlgPsQrjLfg.png"></p>
<p>var Car = {<br>    name: ‘BMW’,<br>    price: 1000000,<br>    set discount(x) {<br>        this.d = x;<br>    },<br>    get discount() {<br>        return this.d;<br>    },<br>};<br>//Print details of Car object’s ‘discount’ property<br>console.log(Object.getOwnPropertyDescriptor(Car, ‘discount’));<br>//prints..<br>// {<br>//   get: [Function: get],<br>//   set: [Function: set],<br>//   enumerable: true,<br>//   configurable: true<br>// }<br>//Copy Car’s properties to ElectricCar using Object.assign<br>const ElectricCar = Object.assign({}, Car);<br>//Print details of ElectricCar object’s ‘discount’ property<br>console.log(Object.getOwnPropertyDescriptor(ElectricCar, ‘discount’));<br>//prints..<br>// {<br>//   value: undefined,<br>//   writable: true,<br>//   enumerable: true,<br>//   configurable: true </p>
<p>// }<br>//⚠️Notice that getters and setters are missing in ElectricCar object for ‘discount’ property !??<br>//Copy Car’s properties to ElectricCar2 using Object.defineProperties<br>//and extract Car’s properties using Object.getOwnPropertyDescriptors<br>const ElectricCar2 = Object.defineProperties({}, Object.getOwnPropertyDescriptors(Car));<br>//Print details of ElectricCar2 object’s ‘discount’ property<br>console.log(Object.getOwnPropertyDescriptor(ElectricCar2, ‘discount’));<br>//prints..<br>// { get: [Function: get],  ??????<br>//   set: [Function: set],  ??????<br>//   enumerable: true,<br>//   configurable: true<br>// }<br>// Notice that getters and setters are present in the ElectricCar2 object for ‘discount’ property!</p>
<h3 id="5-在函数参数中添加尾逗号"><a href="#5-在函数参数中添加尾逗号" class="headerlink" title="5.在函数参数中添加尾逗号"></a>5.在函数参数中添加尾逗号</h3><p>这是一个小更新，允许我们在函数最后一个参数后面有逗号。 为什么？ 帮助使用像 git blame 这样的工具，防止添加一个参数却需要修改两行代码。 以下示例显示了问题和解决方案。 <img src="http://file.w3cbest.com/file/images/1_-SKZCxQdf8Rk48SSaPtDGg.png"></p>
<h3 id="6-Async-Await"><a href="#6-Async-Await" class="headerlink" title="6. Async/Await"></a>6. Async/Await</h3><p>到目前为止，这个特性应该是目前为止是最重要和最有用的功能。async 函数解决了回调地狱的问题，并使整个代码看起来简单。 async 关键字告诉 JavaScript 编译器以不同方式处理函数。 只要到达该函数中的 await 关键字，编译器就会暂停。 它假定 await 之后的表达式返回一个 promise 并等待，直到 promise 被 resolved 或被 rejected ，然后才继续执行。 在下面的示例中，getAmount 函数调用两个异步函数 getUser 和 getBankBalance。 我们可以用 Promise 做到这一点，但是使用 async await 更加优雅和简单。 <img src="http://file.w3cbest.com/file/images/1_L3FZ0onbBD4ay6UhZvPoMw.png"></p>
<h4 id="6-1-Async-函数本身返回一个-Promise-。"><a href="#6-1-Async-函数本身返回一个-Promise-。" class="headerlink" title="6.1 Async 函数本身返回一个 Promise 。"></a>6.1 Async 函数本身返回一个 Promise 。</h4><p>如果你正在等待 async 函数的结果，则需要使用 Promise 的 then 语法来捕获其结果。 在以下示例中，我们希望使用 console.log 但不在 doubleAndAdd 中记录结果。 所以我们想等待并使用 then 语法将结果传递给console.log 。 <img src="http://file.w3cbest.com/file/images/1_ylheY6gJawprWEVNL68mRQ.png"></p>
<h4 id="6-2-并行调用-async-await"><a href="#6-2-并行调用-async-await" class="headerlink" title="6.2 并行调用 async/await"></a>6.2 并行调用 async/await</h4><p>在前面的例子中，我们调用 await 两次，但每次我们等待一秒钟（总共2秒）。相反，我们可以并行调用它，因为使用 Promise.all 并行调用 a 和 b 。 <img src="http://file.w3cbest.com/file/images/1_VEF_Sq067Liq4lfTV8Xv0A.png"></p>
<h4 id="6-3-async-await-函数的错误处理"><a href="#6-3-async-await-函数的错误处理" class="headerlink" title="6.3 async/await 函数的错误处理"></a>6.3 async/await 函数的错误处理</h4><p>使用 async/await 时，有多种方法可以处理错误。</p>
<h5 id="选项1-在函数中使用try-catch"><a href="#选项1-在函数中使用try-catch" class="headerlink" title="选项1-在函数中使用try catch"></a>选项1-在函数中使用try catch</h5><p><img src="http://file.w3cbest.com/file/images/1_iP84ax2TOt5dbaIjW7kzcw.png"></p>
<p>//Option 1 - Use try catch within the function<br>async function doubleAndAdd(a, b) {<br>    try {<br>        a = await doubleAfter1Sec(a);<br>        b = await doubleAfter1Sec(b);<br>    } catch (e) {<br>        return NaN; //return something<br>    }<br>    return a + b;<br>}<br>//?Usage:<br>doubleAndAdd(‘one’, 2).then(console.log); // NaN<br>doubleAndAdd(1, 2).then(console.log); // 6<br>function doubleAfter1Sec(param) {<br>    return new Promise((resolve, reject) =&gt; {<br>        setTimeout(function() {<br>            let val = param * 2;<br>            isNaN(val) ? reject(NaN) : resolve(val);<br>        }, 1000);<br>    });<br>}</p>
<h5 id="选项2-捕获-Catch-await-表达式"><a href="#选项2-捕获-Catch-await-表达式" class="headerlink" title="选项2-捕获(Catch) await 表达式"></a>选项2-捕获(Catch) await 表达式</h5><p>由于每一个 await 表达式返回的都是 Promise，我们可以直接在每一行上面添加 catch。 <img src="http://file.w3cbest.com/file/images/1_Bkls3dXMIRGKAwFN2r--qg.png"></p>
<p>//Option 2 - *Catch* errors on  every await line<br>//as each await expression is a Promise in itself<br>async function doubleAndAdd(a, b) {<br>    a = await doubleAfter1Sec(a).catch(e =&gt; console.log(‘“a” is NaN’)); // ?<br>    b = await doubleAfter1Sec(b).catch(e =&gt; console.log(‘“b” is NaN’)); // ?<br>    if (!a  !b) {<br>        return NaN;<br>    }<br>    return a + b;<br>}<br>//?Usage:<br>doubleAndAdd(‘one’, 2).then(console.log); // NaN  and logs:  “a” is NaN<br>doubleAndAdd(1, 2).then(console.log); // 6<br>function doubleAfter1Sec(param) {<br>    return new Promise((resolve, reject) =&gt; {<br>        setTimeout(function() {<br>            let val = param * 2;<br>            isNaN(val) ? reject(NaN) : resolve(val);<br>        }, 1000);<br>    });<br>}</p>
<h5 id="选项3-捕获-Catch-整个async-await函数"><a href="#选项3-捕获-Catch-整个async-await函数" class="headerlink" title="选项3-捕获(Catch) 整个async-await函数"></a>选项3-捕获(Catch) 整个async-await函数</h5><p><img src="http://file.w3cbest.com/file/images/1_hhkv5ZBOUYViCL2UP0sv5Q.png"></p>
<p>//Option 3 - Dont do anything but handle outside the function<br>//since async / await returns a promise, we can catch the whole function’s error<br>async function doubleAndAdd(a, b) {<br>    a = await doubleAfter1Sec(a);<br>    b = await doubleAfter1Sec(b);<br>    return a + b;<br>}<br>//?Usage:<br>doubleAndAdd(‘one’, 2)<br>    .then(console.log)<br>    .catch(console.log); // ???&lt;——- use “catch”<br>function doubleAfter1Sec(param) {<br>    return new Promise((resolve, reject) =&gt; {<br>        setTimeout(function() {<br>            let val = param * 2;<br>            isNaN(val) ? reject(NaN) : resolve(val);<br>        }, 1000);<br>    });<br>}</p>
<h2 id="ECMAScript-2018"><a href="#ECMAScript-2018" class="headerlink" title="ECMAScript 2018"></a>ECMAScript 2018</h2><h3 id="1-共享内存和-atomics"><a href="#1-共享内存和-atomics" class="headerlink" title="1. 共享内存和 atomics"></a>1. 共享内存和 atomics</h3><p>这是一个巨大的，非常先进的功能，并且是对 JS 引擎的核心增强。 这个特性的主要目的是给 JavaScript 提供多线程功能，以便JS开发人员通过自己管理内存来编写高性能的并发程序，而不是让JS引擎管理内存。 这是通过一种名为<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffer</a>的新型全局对象完成的，该对象实质上将数据存储在共享内存空间中。因此，这些数据可以在主JS线程和 Web-worker 线程之间共享。 之前，如果我们想在主JS线程和 web-worker 之间共享数据，我们必须复制数据并使用postMessage将其发送到另一个线程。 现在，你只需使用SharedArrayBuffer，主线程和多个web-worker线程都可以立即访问数据。 但是在线程之间共享内存会导致竞争条件(即多个进程同时操作一个内存)。为了帮助避免竞争条件，引入了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics">Atomics</a>全局对象。 Atomics提供了各种方法来在线程使用其数据时锁定共享内存。它还提供了安全地更新共享内存中的此类数据的方法。 建议通过某个库使用此功能，但是现在没有基于此功能构建的库。 如果你有兴趣，我建议阅读：</p>
<ol>
<li> <a target="_blank" rel="noopener" href="http://lucasfcosta.com/2017/04/30/JavaScript-From-Workers-to-Shared-Memory.html"><em>From Workers to Shared Memor</em></a>_y — _<a target="_blank" rel="noopener" href="http://lucasfcosta.com/"><em>lucasfcosta</em></a></li>
<li> <a target="_blank" rel="noopener" href="https://hacks.mozilla.org/category/code-cartoons/a-cartoon-intro-to-sharedarraybuffers/"><em>A cartoon intro to SharedArrayBuffers</em></a>_ — _<a target="_blank" rel="noopener" href="https://medium.com/@linclark"><em>Lin Clark</em></a></li>
<li> <a target="_blank" rel="noopener" href="http://2ality.com/2017/01/shared-array-buffer.html"><em>Shared memory and atomics</em></a>_ — _<a target="_blank" rel="noopener" href="http://rauschma.de/"><em>Dr. Axel Rauschmayer</em></a></li>
</ol>
<h3 id="2-移除了标记模板字面量的限制"><a href="#2-移除了标记模板字面量的限制" class="headerlink" title="2.移除了标记模板字面量的限制"></a>2.移除了标记模板字面量的限制</h3><p>首先，我们需要澄清“标记模板字面量”是什么，以便我们更好地理解这个功能。 在 ES2015+ 中，有一个称为标记模板文字的功能，允许开发人员自定义字符串的插值方式。 例如，在标准方式中，字符串被插入如下… <img src="http://file.w3cbest.com/file/images/1_4EizdrE9LlRZ5GXRq4G3Yw.png"> 在标记的字面量中，你可以编写一个函数来接收字符串字面量的硬编码部分，例如 [‘Hello’，’！’] 并且替换变量，例如 [‘Raja’] ，作为参数进入一个自定义函数（例如 greet ），并从该自定义函数返回任何你想要的内容。 下面的示例显示我们的自定义 “Tag” 函数 greet，如“Good Morning” “Good afternoon”，等等，取决于当天到字符串字面量的时间，并返回自定义字符串。 <img src="http://file.w3cbest.com/file/images/1_PfeJ5R0h6SHx6SxSkPCLmg.png"></p>
<p>//A “Tag” function returns a custom string literal.<br>//In this example, greet calls timeGreet() to append Good //Morning/Afternoon/Evening depending on the time of the day.<br>function greet(hardCodedPartsArray, …replacementPartsArray) {<br>    console.log(hardCodedPartsArray); //[ ‘Hello ‘, ‘!’ ]<br>    console.log(replacementPartsArray); //[ ‘Raja’ ]<br>    let str = ‘’;<br>    hardCodedPartsArray.forEach((string, i) =&gt; {<br>        if (i &lt; replacementPartsArray.length) {<br>            str += `${string} ${replacementPartsArray[i]  ‘’}`;<br>        } else {<br>            str += `${string} ${timeGreet()}`; //&lt;– append Good morning/afternoon/evening here<br>        }<br>    });<br>    return str;<br>}<br>//?Usage:<br>const firstName = ‘Raja’;<br>const greetings = greet `Hello ${firstName}!`; //??&lt;– Tagged literal<br>console.log(greetings); //‘Hello  Raja! Good Morning!’ ?<br>function timeGreet() {<br>    const hr = new Date().getHours();<br>    return hr &lt; 12 ?<br>        ‘Good Morning!’ :<br>        hr &lt; 18 ? ‘Good Afternoon!’ : ‘Good Evening!’;<br>}</p>
<p>现在我们讨论了 “Tagged” 函数是什么，许多人想要在不同的场景下中使用此功能，例如在终端中使用命令和 HTTP 请求来编写 URI ，等等。</p>
<h4 id="⚠️标签字符串模版存在的问题"><a href="#⚠️标签字符串模版存在的问题" class="headerlink" title="⚠️标签字符串模版存在的问题"></a>⚠️标签字符串模版存在的问题</h4><p>ES2015 和 ES2016 规范不允许使用转义字符，如 \u（unicode），\x（十六进制），除非它们看起来完全像 \u00A9 或 \u{2F804} 或 \xA9 。 因此，如果你有一个内部使用其他域规则（如终端规则）的 Tagged 函数，可能需要使用 \ubla123abla ，而不能是 \u0049 或 \u{@F804} ，这样你会得到一个语法错误。 在 ES2018 中，只要 Tagged 函数返回具有 “cooked” 属性（无效字符为 “undefined” ）的对象中的值，然后是 “raw” 属性（ 无论你想要什么）。</p>
<p>function myTagFunc(str) { return { “cooked”: “undefined”, “raw”: str.raw[0] }} var str = myTagFunc `hi \</p>
<h3 id="3-正则表达式中的-‘dotall’-标记"><a href="#3-正则表达式中的-‘dotall’-标记" class="headerlink" title="3. 正则表达式中的 ‘dotall’ 标记"></a>3. 正则表达式中的 ‘dotall’ 标记</h3><p>目前在RegEx中，点(“.”)可以表示任何的单一字符，但它不能与 \n ， \r，\f 等换行符匹配。 例如：</p>
<p>//Before<br>/first.second/.test(‘first\nsecond’); //false</p>
<p>此增强功能使点运算符可以匹配任何单个字符。为了确保不会破坏任何内容，我们需要在创建RegEx时使用 \s 标记才能使其正常工作。</p>
<p>//ECMAScript 2018<br>/first.second/s.test(‘first\nsecond’); //true Notice: /s ??</p>
<p><img src="http://file.w3cbest.com/file/images/1_t5xegqe5su6XgRDcBObyDw.png"></p>
<h3 id="4-正则表达式捕获命名组"><a href="#4-正则表达式捕获命名组" class="headerlink" title="4. 正则表达式捕获命名组"></a>4. 正则表达式捕获命名组</h3><p>这个增强功能带来了其他语言（如Python，Java等）的有用 RegExp 功能，称为“命名组”。这个功能允许允许正则表达式给每一个捕获组起一个名字(?<name>…)，然后，我们可以使用该名称轻松获取我们需要的任何群组。</p>
<h4 id="4-1-基本的命名组例子"><a href="#4-1-基本的命名组例子" class="headerlink" title="4.1 基本的命名组例子"></a>4.1 基本的命名组例子</h4><p>在下面的例子中，我们使用(?<year>) (?<month>) and (?year)来为正则表达式中的不同部分分组，结果对象中会包含一个 groups 属性，其拥有 year month day 三个对象。 <img src="http://file.w3cbest.com/file/images/1_1ORiZapMHp_SV5gvOVT2WA.png"></p>
<h4 id="4-2-在正则表达式本身内使用命名组"><a href="#4-2-在正则表达式本身内使用命名组" class="headerlink" title="4.2 在正则表达式本身内使用命名组"></a>4.2 在正则表达式本身内使用命名组</h4><p>我们可以使用\k<group name>格式来反向引用正则表达式本身中的组。以下示例显示了它的工作原理。 <img src="http://file.w3cbest.com/file/images/1_O6i-gXHBifD27qD73Sw7TA.png"></p>
<h4 id="4-3-在-String-prototype-replace-中使用命名组"><a href="#4-3-在-String-prototype-replace-中使用命名组" class="headerlink" title="4.3 在 String.prototype.replace 中使用命名组"></a>4.3 在 String.prototype.replace 中使用命名组</h4><p>命名组也可以在 String 的 replace 方法中使用，比如用来交换一个字符串中各个部分的位置。 例如，将firstName, lastName 更改为 lastName, firstName。 <img src="http://file.w3cbest.com/file/images/1_weBLy9CAXFnWNwUqcwNMAg.png"></p>
<h3 id="5-对象的剩余属性"><a href="#5-对象的剩余属性" class="headerlink" title="5. 对象的剩余属性"></a>5. 对象的剩余属性</h3><p>Rest 运算符 …（三个点）允许我们提取 Object 的剩余属性。</p>
<h4 id="5-1-我们可以使用展开运算符展开我们想要的属性："><a href="#5-1-我们可以使用展开运算符展开我们想要的属性：" class="headerlink" title="5.1 我们可以使用展开运算符展开我们想要的属性："></a>5.1 我们可以使用展开运算符展开我们想要的属性：</h4><p><img src="http://file.w3cbest.com/file/images/1_Uh4-1F3aeoy5k3hq8nVlfQ.png"></p>
<h4 id="5-2-或者我们借助展开运算符，移除我们不想要的属性"><a href="#5-2-或者我们借助展开运算符，移除我们不想要的属性" class="headerlink" title="5.2 或者我们借助展开运算符，移除我们不想要的属性 ??"></a>5.2 或者我们借助展开运算符，移除我们不想要的属性 ??</h4><p><img src="http://file.w3cbest.com/file/images/1_43kFc4JJy8DSQiA_zQXZZA.png"></p>
<h2 id="6-展开对象的属性"><a href="#6-展开对象的属性" class="headerlink" title="6.展开对象的属性"></a>6.展开对象的属性</h2><p>展开属性看起来就像 Rest 运算符，都是三个点 …，但不同之处在于你使用展开操作符来创建（重构）新对象。 提示：展开（spread）运算符用于等号的右侧。剩余（Rest）运算符用在等号的左侧。 <img src="http://file.w3cbest.com/file/images/1_QmSUhdHQiXaXL9vdE27Djg.png"></p>
<h2 id="7-正则表达式后行断言-Lookbehind"><a href="#7-正则表达式后行断言-Lookbehind" class="headerlink" title="7.正则表达式后行断言(Lookbehind)"></a>7.正则表达式后行断言(Lookbehind)</h2><p>这是 RegEx 的一个增强，它允许我们确保某些子字符串恰好出现在某些子字符串之前。 你现在可以使用一个组 (?&lt;=…)（问号，小于，等于）来查看先行断言。 此外，你可以使用 (?&lt;!…)（问号，小于，感叹号）来查看后行断言。基本上，只要-ve断言通过，这将匹配。 肯定断言：假设我们要确保 # 符号存在于 winning 之前（即：#winning），并希望正则表达式只返回字符串 “winning” 。下面是我们的做法： <img src="http://file.w3cbest.com/file/images/1_MJuEF0dePb_NE8DHFm0XNw.png"> 否定断言：假设我们想要从具有 € 符号的行中提取数字，而不是 $ 。 <img src="http://file.w3cbest.com/file/images/1_e1N-waOWBc3ykLRFCIzXSA.png"></p>
<h2 id="8-RegExp-Unicode属性转义"><a href="#8-RegExp-Unicode属性转义" class="headerlink" title="8. RegExp Unicode属性转义"></a>8. RegExp Unicode属性转义</h2><p>编写 RegEx 以匹配各种 unicode 字符并不容易。像 \w，\W，\d 等只匹配英文字符和数字。但是其他语言中的数字如印地语，希腊语等等该怎么办呢？ 这就是 Unicode 属性转义的用武之地。事实证明，Unicode 为每个符号（字符）添加元数据属性，并使用它来分组或表征各种符号。 例如，Unicode 数据库将所有印地语字符（??????）归为一个名为 Script 的属性，其值为 Devanagari ，另一个属性为Script_Extensions，其值为 Devanagari 。所以我们可以搜索 Script=Devanagari 并获得所有印地语字符。 梵文可以用于各种印度语言，如马拉地语，印地语，梵语等。 从 ECMAScript 2018 开始，我们可以使用 \p 来转义字符以及 {Script = Devanagari} 以匹配所有这些印度字符。也就是说，我们可以在 RegEx 中使用：\p{Script=Devanagari} 来匹配所有梵文字符。 <img src="http://file.w3cbest.com/file/images/1_c-bRDN8WERPUYevc38jZMg.png"></p>
<p>//The following matches multiple hindi character<br>/^\p{Script=Devanagari}+$/u.test(‘हिन्दी’); //true<br>//PS:there are 3 hindi characters h</p>
<p>同样，Unicode 数据库将 Script_Extensions（和 Script ）属性下的所有希腊字符组合为希腊语。 所以我们可以使用 Script_Extensions=Greek 或 Script=Greek 搜索所有希腊字符。 也就是说，我们可以在RegEx中使用： \p{Script=Greek} 来匹配所有希腊字符。 <img src="http://file.w3cbest.com/file/images/1_DwP_VN4VUp7osFQC-I9OsQ.png"></p>
<p>//The following matches a single Greek character<br>/\p{Script_Extensions=Greek}/u.test(‘π’); // true</p>
<p>此外，Unicode数据库在布尔属性 Emoji ，Emoji_Component， Emoji_Presentation ，Emoji_Modifier 和 Emoji_Modifier_Base 下存储各种类型的 Emojis，其属性值为 true。 因此，我们只需选择 Emoji 符号即可搜索所有表情符号。 也就是说，我们可以使用：\p{Emoji}，\Emoji_Modifier 等来匹配各种 Emojis 。 以下示例将使一切清楚。 <img src="http://file.w3cbest.com/file/images/1_DsQryeDlp8fAKBS8k_ohqw.png"></p>
<p>//The following matches an Emoji character<br>/\p{Emoji}/u.test(‘❤️’); //true<br>//The following fails because yellow emojis don’t need/have Emoji_Modifier!<br>/\p{Emoji}\p{Emoji_Modifier}/u.test(‘✌️’); //false<br>//The following matches an emoji character\p{Emoji} followed by \p{Emoji_Modifier}<br>/\p{Emoji}\p{Emoji_Modifier}/u.test(‘✌?’); //true<br>//Explaination:<br>//By default the victory emoji is yellow color.<br>//If we use a brown, black or other variations of the same emoji, they are considered<br>//as variations of the original Emoji and are represented using two unicode characters.<br>//One for the original emoji, followed by another unicode character for the color.<br>//<br>//So in the below example, although we only see a single brown victory emoji,<br>//it actually uses two unicode characters, one for the emoji and another<br>// for the brown color.<br>//<br>//In Unicode database, these colors have Emoji_Modifier property.<br>//So we need to use both \p{Emoji} and \p{Emoji_Modifier} to properly and<br>//completely match the brown emoji.<br>/\p{Emoji}\p{Emoji_Modifier}/u.test(‘✌?’); //true</p>
<p>最后，我们可以使用大写“P”（ \P ）转义字符,而不是小写“p”（ \p ）来否定匹配。 参考阅读：</p>
<ol>
<li> <a target="_blank" rel="noopener" href="https://mathiasbynens.be/notes/es-unicode-property-escapes"><em>ECMAScript 2018 Proposal</em></a></li>
<li> <a target="_blank" rel="noopener" href="https://mathiasbynens.be/notes/es-unicode-property-escapes"><em>https://mathiasbynens.be/notes/es-unicode-property-escapes</em></a></li>
</ol>
<h2 id="9-Promise-prototype-finally"><a href="#9-Promise-prototype-finally" class="headerlink" title="9.Promise.prototype.finally()"></a>9.Promise.prototype.finally()</h2><p>finally() 是一个添加到 Promise 实例的新方法。 主要考虑是允许在 resolve 或 reject 调用之后执行一些清理性质的代码。finally 被执行的时候不会被传入任何函数，并且无论什么时候都会被执行。 我们来看看各种情况。 <img src="http://file.w3cbest.com/file/images/1_P1V6c1ncEjeCgtS6zzR0gg.png"> <img src="http://file.w3cbest.com/file/images/1_tSbu3kZCkoGpXaWDuP6MPA.png"> <img src="http://file.w3cbest.com/file/images/1_kB6Ar5YJoAlwwhFqzMGBGg.png"> <img src="http://file.w3cbest.com/file/images/1_wCcbabJsS8UbFclumSISqg.png"></p>
<h2 id="10-异步迭代"><a href="#10-异步迭代" class="headerlink" title="10.异步迭代"></a>10.异步迭代</h2><p>这是一个非常有用的特性。 基本上它允许我们轻松创建异步代码循环！ 此特性添加了一个新的“for-await-of”循环，允许我们在循环中调用返回 promises（或带有一堆 promise 的 Arrays ）的异步函数。 循环会等待每个 Promise 在进行下一个循环之前 resolve 。 <img src="http://file.w3cbest.com/file/images/1_liLeNfWxZ3x1sqrVmRUdRQ.png"></p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul>
<li>  <a href="/p/r1WOgVw-7/javascript-fundamentals-for-absolute-beginners-2018">JavaScript Fundamentals for Absolute Beginners 2018</a></li>
<li>  <a href="/p/Skiy3aabX/top-10-javascript-questions">Top 10 JavaScript Questions</a></li>
<li>  <a href="/p/B1DhjT6bQ/developing-in-html5-with-javascript-and-css3">Developing in HTML5 with JavaScript and CSS3</a></li>
<li>  <a href="/p/ByuSrSU07/object-oriented-programming-in-javascript">Object-Oriented Programming in JavaScript</a></li>
<li>  <a href="/p/SkzXrVzA7/javascript-tutorial-learn-javascript-apps-like-an-expert">JavaScript Tutorial Learn JavaScript Apps Like An Expert</a></li>
<li>  <a href="/p/Hk6qojzyM/functional-programming-in-javascript">Functional Programming In JavaScript</a></li>
</ul>
<p>文章来源：<a target="_blank" rel="noopener" href="https://school.geekwall.in/p/BkEFDtfoM/examples-of-everything-new-in-ecmascript-2016-2017-and-2018">https://school.geekwall.in</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javascript%E6%95%99%E7%A8%8B/" rel="tag"># javascript教程</a>
              <a href="/tags/ECMAScript2016/" rel="tag"># ECMAScript2016</a>
              <a href="/tags/ECMAScript%E6%95%99%E7%A8%8B/" rel="tag"># ECMAScript教程</a>
              <a href="/tags/js%E6%95%99%E7%A8%8B/" rel="tag"># js教程</a>
              <a href="/tags/ECMAScript/" rel="tag"># ECMAScript</a>
              <a href="/tags/ECMAScript-2017/" rel="tag"># ECMAScript 2017</a>
              <a href="/tags/ECMAScript-2018/" rel="tag"># ECMAScript 2018</a>
              <a href="/tags/ES%E6%95%99%E7%A8%8B/" rel="tag"># ES教程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/07/20/get%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA%E3%80%81get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E5%9C%A8%E7%BC%93%E5%AD%98%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="prev" title="http和https的区别, get和post的区别, cookie、sessionStorage、localStorage的区别">
      <i class="fa fa-chevron-left"></i> http和https的区别, get和post的区别, cookie、sessionStorage、localStorage的区别
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/08/11/%E6%98%BE%E5%BC%8F%E7%BD%91%E6%A0%BC%E5%92%8C%E9%9A%90%E5%BC%8F%E7%BD%91%E6%A0%BC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%ABgrid-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B/" rel="next" title="显式网格和隐式网格之间的区别[Grid 网格布局教程]">
      显式网格和隐式网格之间的区别[Grid 网格布局教程] <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ECMAScript-2016"><span class="nav-number">1.</span> <span class="nav-text">ECMAScript 2016</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Array-prototype-includes"><span class="nav-number">1.1.</span> <span class="nav-text">1.Array.prototype.includes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.</span> <span class="nav-text">2.指数运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ECMAScript-2017"><span class="nav-number">2.</span> <span class="nav-text">ECMAScript 2017</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Object-values"><span class="nav-number">2.1.</span> <span class="nav-text">1.Object.values()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Object-entries"><span class="nav-number">2.2.</span> <span class="nav-text">2.Object.entries()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A1%AB%E5%85%85"><span class="nav-number">2.3.</span> <span class="nav-text">3.字符串填充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-padStart-%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.3.1.</span> <span class="nav-text">3.1 padStart 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-padEnd-%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.3.2.</span> <span class="nav-text">3.2 padEnd 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E2%9A%A0%EF%B8%8FpadStart-%E5%92%8C-padEnd-%E7%94%A8%E4%BA%8E-Emojis-%E8%A1%A8%E6%83%85%E5%92%8C%E5%85%B6%E4%BB%96%E5%8F%8C%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6"><span class="nav-number">2.3.3.</span> <span class="nav-text">3.3 ⚠️padStart 和 padEnd 用于 Emojis 表情和其他双字节字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Object-getOwnPropertyDescriptors"><span class="nav-number">2.3.4.</span> <span class="nav-text">4.Object.getOwnPropertyDescriptors</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%9C%A8%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%B0%BE%E9%80%97%E5%8F%B7"><span class="nav-number">2.4.</span> <span class="nav-text">5.在函数参数中添加尾逗号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Async-Await"><span class="nav-number">2.5.</span> <span class="nav-text">6. Async&#x2F;Await</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-Async-%E5%87%BD%E6%95%B0%E6%9C%AC%E8%BA%AB%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-Promise-%E3%80%82"><span class="nav-number">2.5.1.</span> <span class="nav-text">6.1 Async 函数本身返回一个 Promise 。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E5%B9%B6%E8%A1%8C%E8%B0%83%E7%94%A8-async-await"><span class="nav-number">2.5.2.</span> <span class="nav-text">6.2 并行调用 async&#x2F;await</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-async-await-%E5%87%BD%E6%95%B0%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">2.5.3.</span> <span class="nav-text">6.3 async&#x2F;await 函数的错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E9%A1%B91-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8try-catch"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">选项1-在函数中使用try catch</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E9%A1%B92-%E6%8D%95%E8%8E%B7-Catch-await-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">选项2-捕获(Catch) await 表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E9%A1%B93-%E6%8D%95%E8%8E%B7-Catch-%E6%95%B4%E4%B8%AAasync-await%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.3.3.</span> <span class="nav-text">选项3-捕获(Catch) 整个async-await函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ECMAScript-2018"><span class="nav-number">3.</span> <span class="nav-text">ECMAScript 2018</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%92%8C-atomics"><span class="nav-number">3.1.</span> <span class="nav-text">1. 共享内存和 atomics</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%A7%BB%E9%99%A4%E4%BA%86%E6%A0%87%E8%AE%B0%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">3.2.</span> <span class="nav-text">2.移除了标记模板字面量的限制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9A%A0%EF%B8%8F%E6%A0%87%E7%AD%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E7%89%88%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.1.</span> <span class="nav-text">⚠️标签字符串模版存在的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84-%E2%80%98dotall%E2%80%99-%E6%A0%87%E8%AE%B0"><span class="nav-number">3.3.</span> <span class="nav-text">3. 正则表达式中的 ‘dotall’ 标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8D%95%E8%8E%B7%E5%91%BD%E5%90%8D%E7%BB%84"><span class="nav-number">3.4.</span> <span class="nav-text">4. 正则表达式捕获命名组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%91%BD%E5%90%8D%E7%BB%84%E4%BE%8B%E5%AD%90"><span class="nav-number">3.4.1.</span> <span class="nav-text">4.1 基本的命名组例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%9C%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9C%AC%E8%BA%AB%E5%86%85%E4%BD%BF%E7%94%A8%E5%91%BD%E5%90%8D%E7%BB%84"><span class="nav-number">3.4.2.</span> <span class="nav-text">4.2 在正则表达式本身内使用命名组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E5%9C%A8-String-prototype-replace-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%91%BD%E5%90%8D%E7%BB%84"><span class="nav-number">3.4.3.</span> <span class="nav-text">4.3 在 String.prototype.replace 中使用命名组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%89%A9%E4%BD%99%E5%B1%9E%E6%80%A7"><span class="nav-number">3.5.</span> <span class="nav-text">5. 对象的剩余属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B1%95%E5%BC%80%E6%88%91%E4%BB%AC%E6%83%B3%E8%A6%81%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="nav-number">3.5.1.</span> <span class="nav-text">5.1 我们可以使用展开运算符展开我们想要的属性：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E6%88%96%E8%80%85%E6%88%91%E4%BB%AC%E5%80%9F%E5%8A%A9%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E7%A7%BB%E9%99%A4%E6%88%91%E4%BB%AC%E4%B8%8D%E6%83%B3%E8%A6%81%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">3.5.2.</span> <span class="nav-text">5.2 或者我们借助展开运算符，移除我们不想要的属性 ??</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%B1%95%E5%BC%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">6.展开对象的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80-Lookbehind"><span class="nav-number">5.</span> <span class="nav-text">7.正则表达式后行断言(Lookbehind)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-RegExp-Unicode%E5%B1%9E%E6%80%A7%E8%BD%AC%E4%B9%89"><span class="nav-number">6.</span> <span class="nav-text">8. RegExp Unicode属性转义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-Promise-prototype-finally"><span class="nav-number">7.</span> <span class="nav-text">9.Promise.prototype.finally()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3"><span class="nav-number">8.</span> <span class="nav-text">10.异步迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB"><span class="nav-number">9.</span> <span class="nav-text">相关阅读</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Tom</p>
  <div class="site-description" itemprop="description">w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">348</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">W3Cbest前端开发</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
