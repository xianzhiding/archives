<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xianzhiding.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="我们平时如何挂载脚本?众所周知，在web应用中，我们时常需要使用js脚本对应用做这样或者那样的操作。而仙贝们为了解放大家的双手，降低大家的开发成本，创造了很多具有各种用途，或者针对对应问题的解决方案。这些解决方案，被称作框架和库。 而作为这些脚本的使用者，我们只需要简单而又传统的将脚本使用script标签插入我们的应用中就行了。     test       如上文所说，这是简单而又传统的使用方法">
<meta property="og:type" content="article">
<meta property="og:title" content="jquery脚本的动态加载">
<meta property="og:url" content="https://xianzhiding.github.io/2018/09/14/jquery%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/index.html">
<meta property="og:site_name" content="前端开发 大前端 W3Cbest">
<meta property="og:description" content="我们平时如何挂载脚本?众所周知，在web应用中，我们时常需要使用js脚本对应用做这样或者那样的操作。而仙贝们为了解放大家的双手，降低大家的开发成本，创造了很多具有各种用途，或者针对对应问题的解决方案。这些解决方案，被称作框架和库。 而作为这些脚本的使用者，我们只需要简单而又传统的将脚本使用script标签插入我们的应用中就行了。     test       如上文所说，这是简单而又传统的使用方法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.w3cbest.com/wp-content/uploads/2018/09/lhtfg.jpg">
<meta property="article:published_time" content="2018-09-14T06:29:10.000Z">
<meta property="article:modified_time" content="2021-08-30T02:43:26.830Z">
<meta property="article:author" content="Tom">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="jquery">
<meta property="article:tag" content="动态加载">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.w3cbest.com/wp-content/uploads/2018/09/lhtfg.jpg">

<link rel="canonical" href="https://xianzhiding.github.io/2018/09/14/jquery%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>jquery脚本的动态加载 | 前端开发 大前端 W3Cbest</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">前端开发 大前端 W3Cbest</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个专注 WEB 开发的技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/14/jquery%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          jquery脚本的动态加载
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-14 14:29:10" itemprop="dateCreated datePublished" datetime="2018-09-14T14:29:10+08:00">2018-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 10:43:26" itemprop="dateModified" datetime="2021-08-30T10:43:26+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="我们平时如何挂载脚本"><a href="#我们平时如何挂载脚本" class="headerlink" title="我们平时如何挂载脚本?"></a>我们平时如何挂载脚本?</h4><p>众所周知，在web应用中，我们时常需要使用js脚本对应用做这样或者那样的操作。而仙贝们为了解放大家的双手，降低大家的开发成本，创造了很多具有各种用途，或者针对对应问题的解决方案。这些解决方案，被称作框架和库。 而作为这些脚本的使用者，我们只需要简单而又传统的将脚本使用script标签插入我们的应用中就行了。</p>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>test</title>
</head>
<body>
<script src="myscript.js"></script>
</body>
</html>

<p>如上文所说，这是简单而又传统的使用方法。事实上在技术快速迭代的今天，传统方式有时候并不能满足我们的需求。当一个webapp含有过多的功能的时候，我们的脚本可能越来越大。而用户的体验则是：这网站打开真慢啊～～～ 然而事实上我们功能做得相当的多，效果做得相当的好，大部分用户其实只是使用了其中的某几个基础功能而已。但只是为了所有功能能够使用而增加了加载量，似乎有些得不偿失。</p>
<h4 id="然后，我们有了动态加载脚本的想法"><a href="#然后，我们有了动态加载脚本的想法" class="headerlink" title="然后，我们有了动态加载脚本的想法"></a>然后，我们有了动态加载脚本的想法</h4><p>从_Netscape Navigator 4.0_为起点，浏览器厂商们都开始支持起了不同形态的动态html。通过dom api，程序猿们可以轻松的对节点进行各种操作。于是对我们来说，又有了新的方法去加载脚本。</p>
<p>var script = document.createElement(‘script’);<br>script.async = true;<br>script.src = ‘myScript.js’;<br>document.getElementsByTagName(‘head’)[0].appendChild(script);</p>
<p>当然了，这样的写法是最基础的增加方法。在这样的写法下，我们无法得知脚本到底有没有加载完，如果依赖脚本没有加载并解释完毕，那么我们加载它就没有任何意义，还会因此阻断所有相关操作。 谢天谢地，天无绝人之路，浏览器老板们还是给我们提供了方法对脚本加载情况进行探知。我们所知的onreadystatechange事件和onload事件可以帮我们判断脚本是否加载完毕～</p>
<p>script.onreadystatechange = script.onload = function (evt) {<br>var evt = evt ? evt : window.event;<br>if (!evt.readyState  evt.readyState === ‘loaded’  evt.readyState === ‘complete’) {<br>cb &amp;&amp; cb();<br>script.onreadystatechange = script.onload ＝ null;<br>script.parent.removeChild(script);<br>script = null;<br>}<br>}</p>
<h4 id="作为一个正常人，我们想不想加载更多东西呢？"><a href="#作为一个正常人，我们想不想加载更多东西呢？" class="headerlink" title="作为一个正常人，我们想不想加载更多东西呢？"></a>作为一个正常人，我们想不想加载更多东西呢？</h4><p>想！当然想。作为一个正常人，我们极其希望也load别的东西过来，那现在我们还有什么东西可以通过动态加载呢？css／picture／function都可以成为我们的加载对象。这时候，我们就该有一个简单的加载器了，聚合我们想要的功能，让我们解放双手！</p>
<p>var handler = {<br>js: jsHandler,<br>css: cssHandler,<br>fn: fnHandler<br>};</p>
<p>var Loader = function (src, type) {</p>
<p>if (src === undefined) {<br>throw new Error(‘木有参数’);<br>}<br>// 修正参数<br>if (!type) {<br>if (typeof src === ‘string’) {<br>if (/\.css$\.css\?/i.test(src)) {<br>type = ‘css’;<br>}<br>if (/\.js$\.js\?/i.test(src)) {<br>type = ‘js’;<br>}<br>}<br>if (typeof src === ‘function’) {<br>type = ‘fn’<br>}<br>}<br>type = type  ‘js’;</p>
<p>handler[type](src);<br>};</p>
<p>function jsHandler(src) {}</p>
<p>function cssHandler(href) {}</p>
<p>function fnHandler(fn) {}</p>
<h4 id="如何填充我们的函数"><a href="#如何填充我们的函数" class="headerlink" title="如何填充我们的函数"></a>如何填充我们的函数</h4><p><img data-src="http://www.w3cbest.com/wp-content/uploads/2018/09/lhtfg.jpg"> 我们有了处理不同类型加载项的逻辑，但首先，我们还是要完善jsHandler函数</p>
<h4 id="获取head元素"><a href="#获取head元素" class="headerlink" title="获取head元素"></a>获取head元素</h4><p>var doc = document;<br>var head = doc.head  doc.getElementsByTagName(“head”)[0]  doc.documentElement;</p>
<p>将document和head缓存起来，以便多次使用，这可以提高一点点的性能… 为jsHandler完善加载部分</p>
<p>function jsHandler(src, callback) {<br>var script = doc.createElement(‘script’);<br>script.async = true;<br>script.src = src;</p>
<p>// 对支持onload事件的浏览器做处理<br>var hasOnload = ‘onload’ in script;<br>if (hasOnload) {<br>script.onload = jsOnload;<br>script.onerror = function () {<br>jsOnload(true);<br>}<br>}</p>
<p>// 对支持onreadystatechange的浏览器做处理<br>else {<br>script.onreadystatechange = function() {<br>if (/loadedcomplete/.test(script.readyState)) {<br>jsOnload();<br>}<br>}<br>}</p>
<p>head.appendChild(script);</p>
<p>// 当事件<br>function jsOnload(error) {<br>isTimeout = false;<br>script.onload = script.onerror = script.onreadystatechange = null;<br>head.removeChild(script);<br>script = null;<br>callback(error);<br>}<br>}</p>
<p>在上面这段代码中，我们为加载js做了一系列处理，由于浏览器厂商的实现问题，我们要对脚本是否加载成功或失败作出判断，这是个很麻烦的事情，尤其是对需要向下兼容的同学来说。 从<a target="_blank" rel="noopener" href="http://qianduanblog.com/post/headjs.html">headjs</a>这篇文章的注释来看，脚本是否加载完毕依赖于onload事件，而ie9及以下依赖于对状态标志进行load或者complete字符的检测。</p>
<p>// IE 7/8 (2 events on 1st load)<br>// 1) event.type = readystatechange, s.readyState = loading<br>// 2) event.type = readystatechange, s.readyState = loaded</p>
<p>// IE 7/8 (1 event on reload)<br>// 1) event.type = readystatechange, s.readyState = complete</p>
<p>// event.type === ‘readystatechange’ &amp;&amp; /loaded¦complete/.test(s.readyState)</p>
<p>// IE 9 (3 events on 1st load)<br>// 1) event.type = readystatechange, s.readyState = loading<br>// 2) event.type = readystatechange, s.readyState = loaded<br>// 3) event.type = load , s.readyState = loaded</p>
<p>// IE 9 (2 events on reload)<br>// 1) event.type = readystatechange, s.readyState = complete<br>// 2) event.type = load , s.readyState = complete</p>
<p>// event.type === ‘load’ &amp;&amp; /loaded¦complete/.test(s.readyState)<br>// event.type === ‘readystatechange’ &amp;&amp; /loaded¦complete/.test(s.readyState)</p>
<p>// IE 10 (3 events on 1st load)<br>// 1) event.type = readystatechange, s.readyState = loading<br>// 2) event.type = load , s.readyState = complete<br>// 3) event.type = readystatechange, s.readyState = loaded</p>
<p>// IE 10 (3 events on reload)<br>// 1) event.type = readystatechange, s.readyState = loaded<br>// 2) event.type = load , s.readyState = complete<br>// 3) event.type = readystatechange, s.readyState = complete</p>
<p>// event.type === ‘load’ &amp;&amp; /loaded¦complete/.test(s.readyState)<br>// event.type === ‘readystatechange’ &amp;&amp; /complete/.test(s.readyState)</p>
<p>// Other Browsers (1 event on 1st load)<br>// 1) event.type = load, s.readyState = undefined</p>
<p>// Other Browsers (1 event on reload)<br>// 1) event.type = load, s.readyState = undefined</p>
<p>// event.type == ‘load’ &amp;&amp; s.readyState = undefined</p>
<p>当然，如果遇到了既不支持onload又不支持onreadystatechange的浏览器的时候，我们只能另寻他法了。 如果要加载的脚本是你写的，那你自己可以处理～如果加载的脚本不是你写的～哦喽，不在本文讨论范围之内～</p>
<h4 id="当你需要jsHandler检测加载是否超时的时候"><a href="#当你需要jsHandler检测加载是否超时的时候" class="headerlink" title="当你需要jsHandler检测加载是否超时的时候"></a>当你需要jsHandler检测加载是否超时的时候</h4><p>我们为jsHandler增加一个参数timeout，并在函数中实现如下逻辑</p>
<p>function jsHandler(src, callback, timeout) {<br>…<br>// 检测是否超时的标志<br>var isTimeout = true;<br>…</p>
<p>if (timeout) {<br>setTimeout(timeoutHandler, timeout);<br>}</p>
<p>head.appendChild(script);</p>
<p>function jsOnload(error) {<br>// 当在时间内完成操作时，不管是否成功，将超时标志设为false<br>isTimeout = false;<br>script.onload = script.onerror = script.onreadystatechange = null;<br>head.removeChild(script);<br>script = null;<br>callback(error);<br>}</p>
<p>function timeoutHandler() {<br>// 如果标志未改变，认为其超时<br>if (isTimeout) {<br>jsOnload(true);<br>}<br>}<br>}</p>
<h4 id="当我们同步执行代码的时候"><a href="#当我们同步执行代码的时候" class="headerlink" title="当我们同步执行代码的时候"></a>当我们同步执行代码的时候</h4><p>当我们需要加载一个或者多个脚本的时候，我们会发现，“奥我次奥，怎么请求了那么多次呢？这不科学。” 这是因为我们的loader在多处被调用或同步调用了，于是我们想啊，搞个map纪录缓存算了。于是乎： － 我们需要一些变量</p>
<p>// 用作存储脚本信息<br>var cache = {};<br>// 用作生成不重复的客户端id<br>var _cid = 0;<br>// 用作存储其他loader实例需要运行的脚本任务<br>var processCache = {};</p>
<p>// 加载状态标识<br>var DONE = ‘done’;<br>var REJECTED = ‘rejected’;<br>var PENDING = ‘pending’;<br>我们需要产生不同的存储id<br>/**<br>* 产生客户端id<br>* @return {Number} [description]<br>*/<br>function cid() {<br>return _cid++;<br>}</p>
<p>我们需要创建一个Script类，new一个实例用于存储任务的基本信息</p>
<p>/**<br>* Script对象，储存需要加载的任务的基本信息<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>*/<br>function Script(uri, type) {<br>this.uri = uri;<br>this.type = type;<br>this.cid = cid();<br>this.status = PENDING;<br>}</p>
<p>－ 当我们寻找缓存中的任务对象的时候，因该返回正确的对象。怎么寻找缓存呢，当然是通过地址来索引啦</p>
<p>/**<br>* 从缓存中获取需要的Script对象<br>* 如果没有，新建一个<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>* @return {Object} 需要的Script对象<br>*/<br>function get(uri, type) {<br>// 如果不存在于缓存中，创建一个新的Script对象<br>return cache[uri]  (cache[uri] = new Script(uri, type));<br>}</p>
<h4 id="如果我们的脚本或函数有别名怎么办！"><a href="#如果我们的脚本或函数有别名怎么办！" class="headerlink" title="如果我们的脚本或函数有别名怎么办！"></a>如果我们的脚本或函数有别名怎么办！</h4><p>var alias = {};<br>/**<br>* 获取有别名的Script对象<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>* @return {Object} Script Object<br>*/<br>function getCache(uri, type) {<br>var src = getAlias(uri);<br>return src ? get(src) : get(uri, type);<br>}</p>
<p>/**<br>* 获取真实地址<br>* @param {String} name [description]<br>* @return {[type]} return uri<br>*/<br>function getAlias(name) {<br>return alias[name];<br>}</p>
<p>别名的用途在于我们不用多次输入同样长度的uri,或者说是函数。</p>
<h4 id="现在，该填充我们的Loader类了。"><a href="#现在，该填充我们的Loader类了。" class="headerlink" title="现在，该填充我们的Loader类了。"></a>现在，该填充我们的Loader类了。</h4><p>我们要很清楚的知道，Loader需要做什么。 一个简单的Loader应该可以多次添加需要加载的内容，then或者add方法可以让用户添加任务。那它应该有一个内置的list，可以存储这些待添加的任务。 它也应该可以在全部脚本加载完的时候执行我们的callback，那么我们应该实现一个方法接受一个回调，在任务执行完时调用。 我们也要可以对某些地址进行别名命名，也需要设置超时时间 实现Loader类</p>
<p>/**<br>* Loader类<br>*/<br>var Loader = function () {<br>this.list = [];<br>this.timeout = 0;<br>this.callback = null;<br>};</p>
<p>实现then方法，使用then的时候应该可以连续使用</p>
<p>/**<br>* 实现的then方法<br>* @param {String} src 地址<br>* @param {String} type 类型<br>* @return {Object} Loader对象<br>*/<br>Loader.prototype.then = function(src, type) {<br>if (src === undefined) {<br>throw new Error(‘木有参数’);<br>}</p>
<p>// 修正参数<br>if (!type) {<br>if (typeof src === ‘string’) {<br>if (/\.css$\.css\?/i.test(src)) {<br>type = ‘css’;<br>}<br>if (/\.js$\.js\?/i.test(src)) {<br>type = ‘js’;<br>}<br>}<br>if (typeof src === ‘function’) {<br>type = ‘fn’<br>}<br>}</p>
<p>type = type  ‘js’;<br>this.list.push(getCache(src, type));<br>return this;<br>};</p>
<p>实现done方法</p>
<p>/**<br>* done方法，接受一个callback，在所有任务完成时调用<br>* @param {Function} cb 完成后的回调<br>* @return {Object} 第一次调用done后返回一个新的对象<br>*/<br>Loader.prototype.done = function(cb) {<br>if (this.callback === null) {<br>this.callback = cb;<br>}<br>if (!this.list.length) {<br>this.callback &amp;&amp; this.callback();<br>return;<br>}<br>var script = this.list.shift();<br>handler[script.type](this, script);<br>if (!this.called) {<br>this.called = true;<br>return new Loader();<br>}<br>};</p>
<p>实现config配置</p>
<p>Loader.prototype.config = function (opts) {<br>this.timeout = opts.timeout  0;<br>if (opts.alias &amp;&amp; !opts.alias.length) {<br>for (var i = opts.alias.length - 1; i &gt;= 0; i–) {<br>alias[i] = opts.alias[i];<br>}<br>}<br>}</p>
<h4 id="如何让错误集中显示"><a href="#如何让错误集中显示" class="headerlink" title="如何让错误集中显示"></a>如何让错误集中显示</h4><p>我们需要接入一个resolve方法，Loader类也应该有一个errors的列表来储存每次错误的信息，最后放到callback中集中显示。</p>
<p>function resolve(loader, s) {<br>if (s.error) {<br>loader.errors.push(s);<br>}<br>loader.done();<br>var cache = processCache[s.cid];<br>if (cache &amp;&amp; !cache.length) {<br>for (var i = 0, len = cache.length; i &lt; len; i++) {<br>cache.shift().loader.done();<br>}<br>}<br>}</p>
<p>var Loader = function () {<br>this.list = [];<br>this.timeout = 0;<br>this.errors = [];<br>this.callback = null;<br>};</p>
<p>最终，我们将所有的思路组装起来</p>
<p>(function (root, factory) {<br>if (typeof define === ‘function’ &amp;&amp; define.amd) {<br>// AMD. Register as an anonymous module.<br>define(factory);<br>} else {<br>// Browser globals<br>root.Loader = factory();<br>}<br>}(this, function () {</p>
<p>// 用作存储脚本信息<br>var cache = {};<br>// 用作生成不重复的客户端id<br>var _cid = 0;<br>// 用作存储其他loader实例需要运行的脚本任务<br>var processCache = {};<br>// 用作储存别名<br>window.alias = {};</p>
<p>// 加载状态标识<br>var DONE = ‘done’;<br>var REJECTED = ‘rejected’;<br>var PENDING = ‘pending’;</p>
<p>// 获取document,head<br>var doc = document;<br>var head = doc.head  doc.getElementsByTagName(“head”)[0]  doc.documentElement;</p>
<p>/**<br>* 产生客户端id<br>* @return {Number} [description]<br>*/<br>function cid() {<br>return _cid++;<br>}</p>
<p>/**<br>* Script对象，储存需要加载的任务的基本信息<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>*/<br>function Script(uri, type) {<br>this.uri = uri;<br>this.type = type;<br>this.cid = cid();<br>this.status = PENDING;<br>}</p>
<p>/**<br>* 从缓存中获取需要的Script对象<br>* 如果没有，新建一个<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>* @return {Object} 需要的Script对象<br>*/<br>function get(uri, type) {<br>// 如果不存在于缓存中，创建一个新的Script对象<br>return cache[uri]  (cache[uri] = new Script(uri, type));<br>}</p>
<p>/**<br>* 获取真实地址<br>* @param {String} name [description]<br>* @return {[type]} return uri<br>*/<br>function getAlias(name) {<br>return alias[name];<br>}</p>
<p>function getCache(uri, type) {<br>var opts = getAlias(uri);<br>return opts ? get(opts.uri, opts.type) : get(uri, type);<br>}</p>
<p>// 处理<br>var handler = {<br>js: jsHandler,<br>css: cssHandler,<br>fn: fnHandler<br>};</p>
<p>// 对函数的处理<br>function fnHandler(context, s) {<br>// 函数不需要判断是否为正在加载状态<br>try {<br>s.uri();<br>resolve(context, s);<br>}<br>catch (e) {<br>s.error = e.message;<br>resolve(context, s);<br>}<br>}</p>
<p>// 对css请求的处理<br>function cssHandler(context, s) {<br>// 当其他Loader实体中的任务已经完成时<br>if (s.status !== PENDING) {<br>resolve(context, s);<br>return;<br>}<br>var link = document.createElement(‘link’);<br>link.type = ‘text/css’;<br>link.rel = ‘stylesheet’<br>link.href = s.uri;<br>head.appendChild(link);<br>resolve(context, s);<br>};</p>
<p>// 对js动态加载的处理<br>function jsHandler(context, s) {</p>
<p>// 处理已完成任务<br>if (s.status !== PENDING) {<br>resolve(context, s);<br>return;<br>}</p>
<p>// 如果非第一个加载，将剩余的任务和任务关联的上下文塞进正在进行的进程中<br>if (s.changeState) {<br>processCache[s.cid] = processCache[s.cid]  [];<br>processCache[s.cid].push({ loader: context, s: s });<br>return;<br>}</p>
<p>s.changeState = true;</p>
<p>// 设置超时标志<br>var isTimeout = true;<br>var script = document.createElement(‘script’);<br>script.async = true;<br>script.src = s.uri;</p>
<p>// 如果支持onload事件<br>var hasOnload = ‘onload’ in script;</p>
<p>if (hasOnload) {<br>script.onload = jsOnload;<br>script.onerror = function () {<br>jsOnload(‘ScriptError’);<br>}<br>}<br>else {<br>script.onreadystatechange = function() {<br>if (/loadedcomplete/.test(script.readyState)) {<br>jsOnload();<br>}<br>}<br>}</p>
<p>// 如果设置了超时，启动一个计时器<br>if (context.timeout) {<br>setTimeout(timeoutHandler, context.timeout);<br>}</p>
<p>head.appendChild(script);</p>
<p>function jsOnload(error) {<br>isTimeout = false;<br>script.onload = script.onerror = script.onreadystatechange = null;<br>head.removeChild(script);<br>script = null;<br>if (error &amp;&amp; typeof error === ‘string’) {<br>s.error = error;<br>}<br>resolve(context, s);<br>}</p>
<p>function timeoutHandler() {<br>if (isTimeout) {<br>console.log(‘timeout’);<br>jsOnload(‘RequestTimeout’);<br>}<br>}<br>}</p>
<p>function resolve(loader, s) {<br>if (s.error) {<br>loader.errors.push(s);<br>}<br>loader.done();<br>var cache = processCache[s.cid];<br>if (cache &amp;&amp; !cache.length) {<br>for (var i = 0, len = cache.length; i &lt; len; i++) {<br>cache.shift().loader.done();<br>}<br>}<br>}</p>
<p>var Loader = function () {<br>this.list = [];<br>this.errors = [];<br>this.timeout = [];<br>this.callback = null;<br>};</p>
<p>Loader.prototype.then = function(src, type) {<br>if (src === undefined) {<br>throw new Error(‘木有参数’);<br>}</p>
<p>// 修正参数<br>if (!type) {<br>if (typeof src === ‘string’) {<br>if (/\.css$\.css\?/i.test(src)) {<br>type = ‘css’;<br>}<br>if (/\.js$\.js\?/i.test(src)) {<br>type = ‘js’;<br>}<br>}<br>if (typeof src === ‘function’) {<br>type = ‘fn’<br>}<br>}</p>
<p>type = type  ‘js’;<br>this.list.push(getCache(src, type));<br>return this;<br>};</p>
<p>Loader.prototype.done = function(cb) {<br>if (this.callback === null) {<br>this.callback = cb;<br>}<br>if (!this.list.length) {<br>this.callback &amp;&amp; this.callback(this.errors);<br>return;<br>}<br>var script = this.list.shift();<br>handler[script.type](this, script);<br>if (!this.called) {<br>this.called = true;<br>return new Loader();<br>}<br>};</p>
<p>Loader.prototype.config = function (opts) {<br>this.timeout = opts.timeout  0;<br>if (opts.alias &amp;&amp; !opts.alias.length) {<br>for (var i in alias) {</p>
<p>}<br>for (var i = opts.alias.length - 1; i &gt;= 0; i–) {<br>alias[i] = opts.alias[i]<br>}<br>}<br>return this;<br>};</p>
<p>return Loader;<br>}));</p>
<p>除了此类常规的写法，我们其实还可以使用其他更多的方法来实现脚本动态加载，比如自定义事件，比如模块化加载的实现，比如promise实现等等 这篇文章的意义在于开阔思维，回顾基础。 下面的observer对象实现了一个简单的事件注册，监听，销毁的功能，对模式有过研究或者码力深厚的同学肯定不陌生。</p>
<p>var observer = (function () {</p>
<p>var list = {};</p>
<p>var on = function (evt, cb) {<br>if (!list[evt]) {<br>list[evt] = [];<br>}<br>list[evt].push(cb);<br>};</p>
<p>var trigger = function () {<br>var evtName = Array.prototype.shift.call(arguments);<br>callbacks = list[evtName];<br>if (!callbacks  callbacks.length === 0) {<br>return;<br>}<br>for (var i = 0, len = callbacks.length; i &lt; len; i++) {<br>callbacks[i].apply(this, arguments);<br>}<br>};</p>
<p>var off = function (evt, fn) {<br>var callbacks = list[evt];<br>if (!callbacks) {<br>return;<br>}<br>if (!fn) {<br>callbacks &amp;&amp; callbacks.length = 0;<br>return;<br>}<br>for (var i = 0, len = callbacks.length i &lt; len; i++) {<br>if (fn === callbacks[i]) {<br>callbacks.splice(i, 1);<br>}<br>}<br>};</p>
<p>// 暴露对外接口<br>return {<br>trigger: trigger,<br>on: on,<br>off: off<br>}<br>})();</p>
<p>转载：<a target="_blank" rel="noopener" href="http://eux.baidu.com/blog">http://eux.baidu.com/blog</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>坚持技术创作分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="Tom 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Tom 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Tom
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://xianzhiding.github.io/2018/09/14/jquery%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/" title="jquery脚本的动态加载">https://xianzhiding.github.io/2018/09/14/jquery脚本的动态加载/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"><i class="fa fa-tag"></i> javascript</a>
              <a href="/tags/jquery/" rel="tag"><i class="fa fa-tag"></i> jquery</a>
              <a href="/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/" rel="tag"><i class="fa fa-tag"></i> 动态加载</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/09/13/%E4%BD%BF%E7%94%A8javascript%E6%9B%B4%E6%96%B0css%E5%8F%98%E9%87%8F/" rel="prev" title="使用JavaScript更新CSS变量">
      <i class="fa fa-chevron-left"></i> 使用JavaScript更新CSS变量
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/09/14/%E5%88%A9%E7%94%A8jquery%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/" rel="next" title="利用jQuery实现简单的数据双向绑定">
      利用jQuery实现简单的数据双向绑定 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E5%B9%B3%E6%97%B6%E5%A6%82%E4%BD%95%E6%8C%82%E8%BD%BD%E8%84%9A%E6%9C%AC"><span class="nav-number">1.</span> <span class="nav-text">我们平时如何挂载脚本?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%84%B6%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9C%89%E4%BA%86%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E8%84%9A%E6%9C%AC%E7%9A%84%E6%83%B3%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">然后，我们有了动态加载脚本的想法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%B8%B8%E4%BA%BA%EF%BC%8C%E6%88%91%E4%BB%AC%E6%83%B3%E4%B8%8D%E6%83%B3%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A%E4%B8%9C%E8%A5%BF%E5%91%A2%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">作为一个正常人，我们想不想加载更多东西呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A1%AB%E5%85%85%E6%88%91%E4%BB%AC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">如何填充我们的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96head%E5%85%83%E7%B4%A0"><span class="nav-number">5.</span> <span class="nav-text">获取head元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E4%BD%A0%E9%9C%80%E8%A6%81jsHandler%E6%A3%80%E6%B5%8B%E5%8A%A0%E8%BD%BD%E6%98%AF%E5%90%A6%E8%B6%85%E6%97%B6%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">6.</span> <span class="nav-text">当你需要jsHandler检测加载是否超时的时候</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E6%88%91%E4%BB%AC%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">7.</span> <span class="nav-text">当我们同步执行代码的时候</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E7%9A%84%E8%84%9A%E6%9C%AC%E6%88%96%E5%87%BD%E6%95%B0%E6%9C%89%E5%88%AB%E5%90%8D%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%81"><span class="nav-number">8.</span> <span class="nav-text">如果我们的脚本或函数有别名怎么办！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%B0%E5%9C%A8%EF%BC%8C%E8%AF%A5%E5%A1%AB%E5%85%85%E6%88%91%E4%BB%AC%E7%9A%84Loader%E7%B1%BB%E4%BA%86%E3%80%82"><span class="nav-number">9.</span> <span class="nav-text">现在，该填充我们的Loader类了。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E9%94%99%E8%AF%AF%E9%9B%86%E4%B8%AD%E6%98%BE%E7%A4%BA"><span class="nav-number">10.</span> <span class="nav-text">如何让错误集中显示</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Tom</p>
  <div class="site-description" itemprop="description">w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">338</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">W3Cbest前端开发</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
