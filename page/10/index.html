<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xianzhiding.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
<meta property="og:type" content="website">
<meta property="og:title" content="前端开发 大前端 W3Cbest">
<meta property="og:url" content="https://xianzhiding.github.io/page/10/index.html">
<meta property="og:site_name" content="前端开发 大前端 W3Cbest">
<meta property="og:description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tom">
<meta property="article:tag" content="前端开发,es5,es6,es10,css,javascript,html,flexbox,grid,echarts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xianzhiding.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>前端开发 大前端 W3Cbest</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">前端开发 大前端 W3Cbest</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个专注 WEB 开发的技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/10/05/%E4%BD%BF%E7%94%A8css3-%E9%80%89%E6%8B%A9%E5%99%A8target%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BC%B8%E7%BC%A9%E7%9A%84%E5%AF%BC%E8%88%AA%E8%8F%9C%E5%8D%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/05/%E4%BD%BF%E7%94%A8css3-%E9%80%89%E6%8B%A9%E5%99%A8target%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BC%B8%E7%BC%A9%E7%9A%84%E5%AF%BC%E8%88%AA%E8%8F%9C%E5%8D%95/" class="post-title-link" itemprop="url">使用CSS3 选择器:target制作一个可伸缩的导航菜单</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-05 20:00:14" itemprop="dateCreated datePublished" datetime="2018-10-05T20:00:14+08:00">2018-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 10:43:26" itemprop="dateModified" datetime="2021-08-30T10:43:26+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们使用CSS3 选择器:target制作一个可伸缩的导航菜单。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target">先理解一下:target</a></p>
<h4 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h4><p>URL 带有后面跟有锚名称 #，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)。 :target 选择器可用于选取当前活动的目标元素。 那么我就看一下代码如何做可伸缩的导航菜单</p>
<nav id="menu">
<ul id="menu-closed">
<li><a href="#">首页</a></li>
<li><a href="#">html/css</a></li>
<li><a href="#">javascript</a></li>
<li><a href="#">vue</a></li>
<li><a href="#">anjular</a></li>
<li><a href="#">react</a></li>
<li><a href="#">php</a></li>
<li><a href="#">python</a></li>
<li><a href="#">highcharts</a></li>
<li><a href="#">echarts</a></li>
<li><a href="#menu-closed">&#215;</a></li>
<li><a href="#menu">&#9776;</a></li>
</ul>
</nav>

<p>CSS代码</p>
<p>nav {<br>font-size: 12px;<br>background-color: rgb(19, 51, 61);<br>box-shadow: 0 1px 2px rgba(19, 51, 61, 0.5);<br>margin: 3em 0 6em;<br>padding: 0 1em;<br>height: 44px;<br>overflow: hidden;<br>}</p>
<p>nav ul {<br>margin: 0;<br>padding: 0;<br>list-style-type: none;<br>max-height: 88px;<br>position: relative;<br>}</p>
<p>nav li {<br>display: inline-block;<br>}</p>
<p>nav a {<br>display: inline-block;<br>padding: 0 1em;<br>color: rgb(236, 236, 236);<br>font-weight: 700;<br>letter-spacing: 0.1em;<br>text-decoration: none;<br>text-transform: uppercase;<br>white-space: nowrap;<br>line-height: 44px;<br>height: 44px;<br>}</p>
<p>nav a:hover {<br>background-color: rgba(255, 255, 255, 0.08);<br>}</p>
<p>nav li:last-child {<br>/* 菜单按钮 */<br>position: absolute;<br>right: 0;<br>bottom: 44px;<br>background-image: linear-gradient(to right, rgba(19, 51, 61, 0) 0, rgba(19, 51, 61, 1) 2em);<br>padding-left: 3em;<br>}</p>
<p>nav li:nth-last-child(2) {<br>/* 先关闭按钮 */<br>display: none;<br>}</p>
<p>nav#menu:target {<br>height: auto;<br>padding: 0;<br>}</p>
<p>nav#menu:target ul {<br>max-height: none;<br>}</p>
<p>nav#menu:target li {<br>display: block;<br>}</p>
<p>nav#menu:target a {<br>display: block;<br>padding: 0 2em;<br>background-color: rgba(255, 255, 255, 0.05);<br>}</p>
<p>nav#menu:target a:hover {<br>background-color: rgba(255, 255, 255, 0.08);<br>}</p>
<p>nav#menu:target li:not(:first-child) {<br>margin-top: 2px;<br>}</p>
<p>nav#menu:target li:last-child {<br>display: none;<br>}</p>
<p>nav#menu:target li:nth-last-child(2) {<br>display: inline-block;<br>position: absolute;<br>top: 0;<br>right: 0;<br>margin: 0;<br>border-left: 2px solid rgb(19, 51, 61);<br>}</p>
<p><a target="_blank" rel="noopener" href="https://jshare.com.cn/temp/HpJ1bg/share/pure">查看demo</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/10/05/javascript-prototype%E5%8E%9F%E5%9E%8B-%E5%88%9D%E5%AD%A6%E8%80%85%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/05/javascript-prototype%E5%8E%9F%E5%9E%8B-%E5%88%9D%E5%AD%A6%E8%80%85%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">JavaScript Prototype(原型) 初学者指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-05 08:00:48" itemprop="dateCreated datePublished" datetime="2018-10-05T08:00:48+08:00">2018-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 10:43:26" itemprop="dateModified" datetime="2021-08-30T10:43:26+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果不处理对象，您就无法在 JavaScript 方面取得很大进展。它们几乎是 JavaScript 编程语言的所有方面的基础。事实上，学习如何创建对象可能是你刚开始学习的第一件事。话虽如此，为了最有效地学习 JavaScript 中的原型，我们将从基础开始。 首先，对象是键/值对。创建对象的最常用方法是使用花括号{}，并使用点表示法向对象添加属性和方法。</p>
<p>let animal = {}<br>animal.name = ‘Leo’<br>animal.energy = 10</p>
<p>animal.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>
<p>animal.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>
<p>animal.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>
<p>这个很简单。现在，我们在应用程序中我们需要创建多个动物。很自然地，下一步就是将逻辑封装到一个函数中，以便我们在需要创建新动物时调用这个函数。我们将调用这个模式 <code>Functional Instantiation</code>(函数实例化)，并将函数本身称为 <code>constructor function</code>(构造函数) ，因为它负责“构造”一个新对象。</p>
<h2 id="Functional-Instantiation-函数实例化"><a href="#Functional-Instantiation-函数实例化" class="headerlink" title="Functional Instantiation (函数实例化)"></a>Functional Instantiation (函数实例化)</h2><p>function Animal(name, energy) {<br>    let animal = {}<br>    animal.name = name<br>    animal.energy = energy</p>
<pre><code>animal.eat = function(amount) &#123;
    console.log(\`$&#123;this.name&#125; is eating.\`)
    this.energy += amount
&#125;

animal.sleep = function(length) &#123;
    console.log(\`$&#123;this.name&#125; is sleeping.\`)
    this.energy += length
&#125;

animal.play = function(length) &#123;
    console.log(\`$&#123;this.name&#125; is playing.\`)
    this.energy -= length
&#125;

return animal
</code></pre>
<p>}</p>
<p>const leo = Animal(‘Leo’, 7)<br>const snoop = Animal(‘Snoop’, 10)</p>
<p>现在，每当我们想要创建一种新动物（或者更广泛地说是一种新的“实例”）时，我们所要做的就是调用我们的 <code>Animal</code> 函数，将动物的 <code>name</code> 和<code>energy</code> 传递给这个函数。这非常有效，而且非常简单。但是，你有发现这种模式的不足之处吗？我们要尝试解决的最大的问题与三种方法有关 – <code>eat</code>，<code>sleep</code> 和 <code>play</code>。这些方法中的每一种都不仅是动态的，而且它们也是完全通用的。这意味着没有理由重新创建这些方法，正如我们在创建新动物时所做的那样。我们只是在浪费内存，让每个动物物体都比它需要的更大。你能想到一个解决方案吗？ 如果我们每次创建一个新动物时不需要重新创建这些方法，而是将它们移动到它们自己的对象上，那么我们就可以让每个动物引用那个对象了?我们可以把这种模式称为 <code>Functional Instantiation with Shared Methods</code>(共享方法的函数实例化) 。描述起来有点啰嗦。</p>
<h3 id="Functional-Instantiation-with-Shared-Methods-共享方法的函数实例化"><a href="#Functional-Instantiation-with-Shared-Methods-共享方法的函数实例化" class="headerlink" title="Functional Instantiation with Shared Methods (共享方法的函数实例化)"></a>Functional Instantiation with Shared Methods (共享方法的函数实例化)</h3><p>const animalMethods = {<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`)<br>        this.energy += amount<br>    },<br>    sleep(length) {<br>        console.log(`${this.name} is sleeping.`)<br>        this.energy += length<br>    },<br>    play(length) {<br>        console.log(`${this.name} is playing.`)<br>        this.energy -= length<br>    }<br>}</p>
<p>function Animal(name, energy) {<br>    let animal = {}<br>    animal.name = name<br>    animal.energy = energy<br>    animal.eat = animalMethods.eat<br>    animal.sleep = animalMethods.sleep<br>    animal.play = animalMethods.play</p>
<pre><code>return animal
</code></pre>
<p>}</p>
<p>const leo = Animal(‘Leo’, 7)<br>const snoop = Animal(‘Snoop’, 10)</p>
<p>通过将共享方法移动到它们自己的对象并在 <code>Animal</code> 函数中引用该对象，我们现在已经解决了内存浪费和动物对象过大的问题。</p>
<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><p>让我们使用 <code>Object.create</code> 再次改进我们的例子。 简而言之，<code>Object.create</code> 允许您创建一个对象，该对象将在查找失败时委托给另一个对象。 换句话说，<code>Object.create</code> 允许您创建一个对象，只要该对象上的属性查找失败，它就可以查询另一个对象，以查看另一个对象中是否具有该属性。 说清楚需要很多文字， 我们来看一些代码。</p>
<p>const parent = {<br>    name: ‘Stacey’,<br>    age: 35,<br>    heritage: ‘Irish’<br>}</p>
<p>const child = Object.create(parent),<br>child.name = ‘Ryan’,<br>child.age = 7;</p>
<p>console.log(child.name); // Ryan<br>console.log(child.age); // 7<br>console.log(child.heritage); // Irish</p>
<p>在上面的示例中，因为 <code>child</code> 是通过 <code>Object.create(parent)</code> 创建的，所以每当在 <code>child</code> 中查找属性失败时，JavaScript 就会将该查找委托给 <code>parent</code> 对象。这意味着即使 <code>child</code> 没有 <code>heritage</code> 属性，当你查找 <code>child.heritage</code> 时你会得到 <code>parent</code> 的<code>heritage</code> 属性，即 <code>Irish</code>。 现在，通过使用 <code>Object.create</code> ，我们该如何使用它来简化之前的 <code>Animal</code> 代码呢？好吧，我们可以使用 <code>Object.create</code> 委托给<code>animalMethods</code> 对象，而不是像我们之前一样逐个将所有共享方法添加到 <code>Animal</code> 中。 为了听起来很智能，让我们称之为 <code>Functional Instantiation with Shared Methods and Object.create</code>(使用共享方法和Object.create进行函数实例化)。</p>
<h2 id="Functional-Instantiation-with-Shared-Methods-and-Object-create-使用共享方法和Object-create进行函数实例化"><a href="#Functional-Instantiation-with-Shared-Methods-and-Object-create-使用共享方法和Object-create进行函数实例化" class="headerlink" title="Functional Instantiation with Shared Methods and Object.create (使用共享方法和Object.create进行函数实例化)"></a>Functional Instantiation with Shared Methods and Object.create (使用共享方法和Object.create进行函数实例化)</h2><p>const animalMethods = {<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`);<br>        this.energy += amount;<br>    },<br>    sleep(length) {<br>        console.log(`${this.name} is sleeping.`);<br>        this.energy += length;<br>    },<br>    play(length) {<br>        console.log(`${this.name} is playing.`);<br>        this.energy -= length;<br>    }<br>}</p>
<p>function Animal(name, energy) {<br>    let animal = Object.create(animalMethods);<br>    animal.name = name;<br>    animal.energy = energy;</p>
<pre><code>return animal;
</code></pre>
<p>}</p>
<p>const leo = Animal(‘Leo’, 7);<br>const snoop = Animal(‘Snoop’, 10);</p>
<p>leo.eat(10);<br>snoop.play(5);</p>
<p>所以现在当我们调用 <code>leo.eat</code> 时，JavaScript 会在 <code>leo</code> 对象上查找 <code>eat</code> 方法。 这个查找将失败，因为使用了 <code>Object.create</code>，它将委托给 <code>animalMethods</code> 对象，然后在这里将找到 <code>eat</code> 方法。 到现在为止还挺好的。 尽管如此，我们仍然可以做出一些改进。 为了跨实例共享方法，必须管理一个单独的对象（<code>animalMethods</code>）似乎有点“hacky”。 这似乎是您希望在语言本身中实现的常见功能。 事实证明，这就是你看这篇文章的原因 – prototype(原型) 。 那么究竟什么是 JavaScript 的 prototype（原型）呢？ 简单地说，JavaScript 中的每个函数都有一个引用对象的 prototype 属性。 我们来亲自测试一下。</p>
<p>function doThing () {};<br>console.log(doThing.prototype); // {}</p>
<p>如果不是创建一个单独的对象（比如我们正在使用的 <code>animalMethods</code> ）来管理我们的方法，也就是我们只是将每个方法放在 <code>Animal</code> 函数的 prototype(原型) 对象上，该怎么办呢？我们所要做的就是不使用 <code>Object.create</code> 委托给 <code>animalMethods</code>，我们可以用使用来委托<code>Animal.prototype</code>。 我们将这种模式称为 <code>Prototypal Instantiation</code>(原型实例化)。</p>
<h2 id="Prototypal-Instantiation-原型实例化"><a href="#Prototypal-Instantiation-原型实例化" class="headerlink" title="Prototypal Instantiation (原型实例化)"></a>Prototypal Instantiation (原型实例化)</h2><p>function Animal(name, energy) {<br>    let animal = Object.create(Animal.prototype);<br>    animal.name = name;<br>    animal.energy = energy;</p>
<pre><code>return animal;
</code></pre>
<p>}</p>
<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`);<br>    this.energy += amount;<br>}</p>
<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`);<br>    this.energy += length;<br>}</p>
<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`);<br>    this.energy -= length;<br>}</p>
<p>const leo = Animal(‘Leo’, 7);<br>const snoop = Animal(‘Snoop’, 10);</p>
<p>leo.eat(10);<br>snoop.play(5);</p>
<p>这里你可以为自己鼓掌鼓励一下了。 同样，原型只是 JavaScript 中每个函数都具有的属性，并且如上所述，它允许我们在函数的所有实例之间共享方法。 我们所有的功能仍然相同，但现在我们不必为所有方法管理一个单独的对象，我们可以使用另一个内置于 <code>Animal</code> 函数本身的对象<code>Animal.prototype</code>。</p>
<h2 id="更深的，走起！"><a href="#更深的，走起！" class="headerlink" title="更深的，走起！"></a>更深的，走起！</h2><p>首先，我们需要知道三件事：</p>
<ol>
<li> 如何创建构造函数。</li>
<li> 如何将方法添加到构造函数的原型中。</li>
<li> 如何使用 <code>Object.create</code> 将失败的查找委托给函数的原型。</li>
</ol>
<p>这三个任务似乎是任何编程语言的基础。 JavaScript 是否真的那么糟糕，没有更简单，“内置”的方式来完成同样的事情？ 正如你可能已经猜测的那样，它是通过使用 <code>new</code> 关键字。 我们采用的这种缓慢而有条理的方法的好处是，您现在可以深入了解 JavaScript 中的 <code>new</code> 关键字在幕后的作用。 回顾一下我们的 <code>Animal</code> 构造函数，最重要的两个部分是创建对象并返回它。 如果不使用 <code>Object.create</code>创建对象，我们将无法在查找失败时委托给函数的原型。 如果没有 <code>return</code> 语句，我们将永远不会返回创建的对象。</p>
<p>function Animal(name, energy) {<br>    let animal = Object.create(Animal.prototype);<br>    animal.name = name;<br>    animal.energy = energy;<br>    return animal;<br>}</p>
<p><code>new</code> 有一个很酷的地方——当您使用 <code>new</code> 关键字调用函数时，注释掉的这两行代码是隐式(引擎)完成的，创建的对象称为 <code>this</code>。 使用注释来显示在幕后发生的事情并假设使用 <code>new</code> 关键字调用 <code>Animal</code> 构造函数，可以将其重写为这样：</p>
<p>function Animal(name, energy) {<br>    // const this = Object.create(Animal.prototype)<br>    this.name = name<br>    this.energy = energy<br>    // return this<br>}<br>const leo = new Animal(‘Leo’, 7)<br>const snoop = new Animal(‘Snoop’, 10)</p>
<p>去掉注释后：</p>
<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}<br>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}<br>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}<br>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}<br>const leo = new Animal(‘Leo’, 7)<br>const snoop = new Animal(‘Snoop’, 10)</p>
<p>同样，这样做以及为我们创建 <code>this</code> 对象的原因是，我们使用 <code>new</code> 关键字调用构造函数。如果在调用函数时不使用 <code>new</code> ，则该对象永远不会创建，也不会隐式返回。我们可以在下面的例子中看到这个问题。</p>
<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}<br>const leo = Animal(‘Leo’, 7)<br>console.log(leo) // undefined</p>
<p>此模式的名称是 <code>Pseudoclassical Instantiation</code>(伪类实例化) 。 如果 JavaScript 不是您的第一种编程语言，您可能会有点不安。</p>
<blockquote>
<p>“WTF这个家伙只是重新创造了一个更糟糕的版本” – 你</p>
</blockquote>
<p>对于那些不熟悉的人，Class(类) 允许您为对象创建模板。然后，无论何时创建该类的实例，都会获得一个具有模板中定义的属性和方法的对象。 听起来有点熟悉？这基本上就是我们对上面的 <code>Animal</code> 构造函数所做的事情。但是对于 <code>Animal</code> 构造函数，我们只使用常规的旧 JavaScript 函数来重新创建相同的功能，而不是使用 <code>class</code> 关键字。当然，它需要一些额外的工作以及一些关于 JavaScript “引擎” 所处理的事情的相关知识，但结果是一样的。 这是个好消息。 JavaScript 不是一种 “死” 语言。它不断得到改进，并由 <a target="_blank" rel="noopener" href="https://tylermcginnis.com/videos/ecmascript/">TC-39委员会</a> 不断的制定标准。这意味着即使 JavaScript 的初始版本不支持类，也不影响后续将它们添加到官方规范中。事实上，这正是TC-39委员会所做的事情。 2015年，发布了 EcmaScript（官方JavaScript规范）6 ，支持 Classes(类) 和 <code>class</code> 关键字。让我们看看上面的 <code>Animal</code> 构造函数如何使用新的 class(类) 语法。</p>
<p>class Animal {<br>    constructor(name, energy) {<br>        this.name = name<br>        this.energy = energy<br>    }<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`)<br>        this.energy += amount<br>    }<br>    sleep(length) {<br>        console.log(`${this.name} is sleeping.`)<br>        this.energy += length<br>    }<br>    play(length) {<br>        console.log(`${this.name} is playing.`)<br>        this.energy -= length<br>    }<br>}<br>const leo = new Animal(‘Leo’, 7)<br>const snoop = new Animal(‘Snoop’, 10)</p>
<p>很干净是吧？ 因此，如果这是创建类的新方法，为什么我们前面花了这么多时间来讨论旧的方式呢？ 原因是新的方式（使用 <code>class</code> 关键字）只是经典伪类模式的 “语法糖”。 为了完全理解 ES6 类的便捷语法，首先必须理解经典的伪类模式。 我们已经介绍了 JavaScript 原型的基础知识。 本文的其余部分将致力于加深理解相关知识的主题。 在另一篇文章中，我们将看看如何利用这些基础知识并使用它们来理解 JavaScript 中继承的工作原理。</p>
<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>我们在上面深入讨论了如何在类的实例之间共享方法，您应该将这些方法放在类（或函数）原型上。 如果我们查看 <code>Array</code> 类，我们可以看到相同的模式。 从历史上看，您可能已经创建了这样的数组：</p>
<p>const friends = []</p>
<p>事实证明，这只是创建一个新的 <code>Array</code> 类实例的语法糖。</p>
<p>const friendsWithSugar = []<br>const friendsWithoutSugar = new Array()</p>
<p>您可能从未想过：数组的每个实例是如何具有所有内置方法的（<code>splice</code> , <code>slice</code>, <code>pop</code> 等）？ 正如您现在所知，这是因为这些方法存在于 <code>Array.prototype</code> 上，当您创建一个新的 <code>Array</code> 实例时，您使用 <code>new</code> 关键字在查找失败时将该委托设置为 <code>Array.prototype</code> 。 我们可以通过简单地 <code>console.log(Array.prototype)</code> 来查看所有数组的方法。</p>
<p>console.log(Array.prototype)<br>/*<br>  concat: ?n concat()<br>  constructor: ?n Array()<br>  copyWithin: ?n copyWithin()<br>  entries: ?n entries()<br>  every: ?n every()<br>  fill: ?n fill()<br>  filter: ?n filter()<br>  find: ?n find()<br>  findIndex: ?n findIndex()<br>  forEach: ?n forEach()<br>  includes: ?n includes()<br>  indexOf: ?n indexOf()<br>  join: ?n join()<br>  keys: ?n keys()<br>  lastIndexOf: ?n lastIndexOf()<br>  length: 0n<br>  map: ?n map()<br>  pop: ?n pop()<br>  push: ?n push()<br>  reduce: ?n reduce()<br>  reduceRight: ?n reduceRight()<br>  reverse: ?n reverse()<br>  shift: ?n shift()<br>  slice: ?n slice()<br>  some: ?n some()<br>  sort: ?n sort()<br>  splice: ?n splice()<br>  toLocaleString: ?n toLocaleString()<br>  toString: ?n toString()<br>  unshift: ?n unshift()<br>  values: ?n values()<br>*/</p>
<p>Objects(对象) 也是完全相同的逻辑。 所有对象将在查找失败时委托给 <code>Object.prototype</code> ，这就是所有对象都有 <code>toString</code> 和<code>hasOwnProperty</code> 等方法的原因。</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>到目前为止，我们已经介绍了为什么，以及如何在类的实例之间共享方法。 但是，如果我们有一个对 Class 很重要但不需要又跨实例共享的方法，该怎么办呢？ 例如，如果我们有一个函数，它接收一系列 <code>Animal</code> 实例并决定下一个需要喂食的对象，会怎样? 我们将其称为 <code>nextToEat</code>。</p>
<p>function nextToEat(animals) {<br>    const sortedByLeastEnergy = animals.sort((a, b) =&gt; {<br>        return a.energy - b.energy<br>    })<br>    return sortedByLeastEnergy[0].name<br>}</p>
<p>我们不希望在所有实例之间共享它，所以在 <code>Animal.prototype</code> 上使用 <code>nextToEat</code> 是没有意义的。 相反，我们可以将其视为辅助方法。 所以如果 <code>nextToEat</code> 不应该存在于 <code>Animal.prototype</code> 中，我们应该把它放在哪里呢？ 那么显而易见的答案是我们可以将 <code>nextToEat</code> 放在与 <code>Animal</code> 类相同的作用域中，然后像我们平常那样，在需要时引用它。</p>
<p>class Animal {<br>    constructor(name, energy) {<br>        this.name = name<br>        this.energy = energy<br>    }<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`)<br>        this.energy += amount<br>    }<br>    sleep(length) {<br>        console.log(`${this.name} is sleeping.`)<br>        this.energy += length<br>    }<br>    play(length) {<br>        console.log(`${this.name} is playing.`)<br>        this.energy -= length<br>    }<br>}<br>function nextToEat(animals) {<br>    const sortedByLeastEnergy = animals.sort((a, b) =&gt; {<br>        return a.energy - b.energy<br>    })</p>
<pre><code>return sortedByLeastEnergy\[0\].name
</code></pre>
<p>}<br>const leo = new Animal(‘Leo’, 7)<br>const snoop = new Animal(‘Snoop’, 10)<br>console.log(nextToEat([leo, snoop])) // Leo</p>
<p>现在这可行，但有更好的方法。 只要有一个特定于类本身的方法，但不需要在该类的实例之间共享，就可以将其添加为类的 <code>static</code>(静态) 属性。</p>
<p>class Animal {<br>    constructor(name, energy) {<br>        this.name = name<br>        this.energy = energy<br>    }<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`)<br>        this.energy += amount<br>    }<br>    sleep(length) {<br>        console.log(`${this.name} is sleeping.`)<br>        this.energy += length<br>    }<br>    play(length) {<br>        console.log(`${this.name} is playing.`)<br>        this.energy -= length<br>    }<br>    static nextToEat(animals) {<br>        const sortedByLeastEnergy = animals.sort((a, b) =&gt; {<br>            return a.energy - b.energy<br>        })</p>
<pre><code>    return sortedByLeastEnergy\[0\].name
&#125;
</code></pre>
<p>}</p>
<p>现在，因为我们在类上添加了 <code>nextToEat</code> 作为 <code>static</code>(静态) 属性，所以它存在于 <code>Animal</code> 类本身（而不是它的原型）中，并且可以使用 <code>Animal.nextToEat</code> 进行访问。</p>
<p>const leo = new Animal(‘Leo’, 7) const snoop = new Animal(‘Snoop’, 10) console.log(Animal.nextToEat([leo, snoop])) // Leo</p>
<p>因为我们在这篇文章中都遵循了类似的模式，让我们来看看如何使用 ES5 完成同样的事情。 在上面的例子中，我们看到了如何使用 <code>static</code> 关键字将方法直接放在类本身上。 使用ES5，同样的模式就像手动将方法添加到函数对象一样简单。</p>
<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>
<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>
<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>
<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>
<p>Animal.nextToEat = function(nextToEat) {<br>    const sortedByLeastEnergy = animals.sort((a, b) =&gt; {<br>        return a.energy - b.energy<br>    })</p>
<pre><code>return sortedByLeastEnergy\[0\].name
</code></pre>
<p>}</p>
<p>const leo = new Animal(‘Leo’, 7)<br>const snoop = new Animal(‘Snoop’, 10)</p>
<p>console.log(Animal.nextToEat([leo, snoop])) // Leo</p>
<h2 id="获取对象的原型"><a href="#获取对象的原型" class="headerlink" title="获取对象的原型"></a>获取对象的原型</h2><p>无论您使用哪种模式创建对象，都可以使用 <code>Object.getPrototypeOf</code> 方法完成获取该对象的原型。</p>
<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>
<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>
<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>
<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>
<p>const leo = new Animal(‘Leo’, 7)<br>const prototype = Object.getPrototypeOf(leo)</p>
<p>console.log(prototype)<br>// {constructor: ?, eat: ?, sleep: ?, play: ?}</p>
<p>prototype === Animal.prototype // true</p>
<p>上面的代码有两个要点。 首先，你会注意到 <code>proto</code> 是一个对象，有4种方法，<code>constructor</code>，<code>eat</code>，<code>sleep</code>，和<code>play</code>。那讲得通。我们将实例传递给<code>getPrototypeOf</code>，<code>leo</code> 获取了实例的原型，这里是所有的方法。这提示我们，关于原型的另外一件事我们还没有讨论过。默认情况下，原型对象将具有 <code>constructor</code> 属性，该属性指向原始函数或创建实例的类。这也意味着 JavaScript 默认在原型上放置 <code>constructor</code> 属性，所以任何实例都可以通过 <code>instance.constructor</code> 访问它们的构造函数。 上面的第二个要点是 <code>Object.getPrototypeOf(leo) === Animal.prototype</code> 。这也是有道理的。 <code>Animal</code> 构造函数有一个 prototype(原型) 属性，我们可以在所有实例之间共享方法，<code>getPrototypeOf</code> 允许我们查看实例本身的原型。</p>
<p>function Animal(name, energy) {<br>this.name = name<br>this.energy = energy<br>}</p>
<p>const leo = new Animal(‘Leo’, 7)<br>console.log(leo.constructor) // Logs the constructor function</p>
<p>为了配合我们之前使用 <code>Object.create</code> 所讨论的内容，其工作原因是因为任何 <code>Animal</code> 实例都会在查找失败时委托给 <code>Animal.prototype</code>。 因此，当您尝试访问 <code>leo.prototype</code> 时， <code>leo</code> 没有 <code>prototype</code> 属性，因此它会将该查找委托给<code>Animal.prototype</code>，它确实具有 <code>constructor</code> 属性。 如果这段没有看懂，请回过头来阅读上面的 <code>Object.create</code> 。 您可能以前看到过使用 <code>__proto__</code> 获取实例的原型。 这是过去的遗物。 现在，如上所述使用 <code>Object.getPrototypeOf(instance)</code> 获取实例的原型。</p>
<h2 id="确定属性是否存在于原型上"><a href="#确定属性是否存在于原型上" class="headerlink" title="确定属性是否存在于原型上"></a>确定属性是否存在于原型上</h2><p>在某些情况下，您需要知道属性是否存在于实例本身上，还是存在于对象委托的原型上。 我们可以通过循环我们创建的 <code>leo</code> 对象来知道这一点。假设目标是循环 <code>leo</code> 并记录其所有键和值。使用 <code>for in</code> 循环，可能看起来像这样。</p>
<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>
<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>
<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>
<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>
<p>const leo = new Animal(‘Leo’, 7)</p>
<p>for (let key in leo) {<br>    console.log(`Key: ${key}. Value: ${leo[key]}`)<br>}</p>
<p>你期望看到什么？最有可能的是，它是这样的 –</p>
<p>Key: name. Value: Leo<br>Key: energy. Value: 7</p>
<p>但是，如果你运行代码，你看到的是这样的 –</p>
<p>Key: name.Value: Leo<br>Key: energy.Value: 7<br>Key: eat.Value: function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}<br>Key: sleep.Value: function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}<br>Key: play.Value: function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>
<p>这是为什么？ <code>for in</code> 循环将循环遍历对象本身以及它所委托的原型的所有 <strong>可枚举属性</strong> 。 因为默认情况下，您添加到函数原型的任何属性都是可枚举的，我们不仅会看到<code>name</code> 和 <code>energy</code> ，还会看到原型上的所有方法 – <code>eat</code>，<code>sleep</code> 和 <code>play</code> 。 要解决这个问题，我们需要指定所有原型方法都是不可枚举的，或者如果属性在 <code>leo</code> 对象本身上而不是 <code>leo</code> 查找失败时委托给的原型上。 <code>hasOwnProperty</code> 可以帮助我们实现这个需求。 <code>hasOwnProperty</code> 是每个对象上的一个属性，它返回一个布尔值，指示对象是否具有指定的属性作为其自身的属性，而不是对象委托给的原型。 这正是我们所需要的。 现在有了这些新知识，我们可以修改我们的代码，以便利用 <code>for in</code> 循环中的 <code>hasOwnProperty</code> 。</p>
<p>…</p>
<p>const leo = new Animal(‘Leo’, 7)</p>
<p>for (let key in leo) {<br>    if (leo.hasOwnProperty(key)) {<br>        console.log(`Key: ${key}. Value: ${leo[key]}`)<br>    }<br>}</p>
<p>而现在我们看到的只是 <code>leo</code> 对象本身的属性，而不是 <code>leo</code> 原型中的方法。</p>
<p>Key: name. Value: Leo<br>Key: energy. Value: 7</p>
<p>如果你仍然对 <code>hasOwnProperty</code> 感到困惑，这里有一些代码可以帮你消除困惑。</p>
<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>
<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>
<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>
<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>
<p>const leo = new Animal(‘Leo’, 7)</p>
<p>leo.hasOwnProperty(‘name’) // true<br>leo.hasOwnProperty(‘energy’) // true<br>leo.hasOwnProperty(‘eat’) // false<br>leo.hasOwnProperty(‘sleep’) // false<br>leo.hasOwnProperty(‘play’) // false</p>
<h2 id="检查对象是否是类的实例"><a href="#检查对象是否是类的实例" class="headerlink" title="检查对象是否是类的实例"></a>检查对象是否是类的实例</h2><p>有时您想知道对象是否是指定类的实例。 为此，您可以使用 <code>instanceof</code> 运算符。 用例非常简单，但如果您以前从未见过它，实际的语法有点奇怪。 它的工作原理如下</p>
<p>object instanceof Class</p>
<p>如果 <code>object</code> 是 <code>Class</code> 的实例，则上面的语句将返回 <code>true</code> ，否则返回 <code>false</code> 。回到我们的 <code>Animal</code> 示例，我们会有类似的东西。</p>
<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>
<p>function User() {}</p>
<p>const leo = new Animal(‘Leo’, 7)</p>
<p>leo instanceof Animal // true<br>leo instanceof User // false</p>
<p><code>instanceof</code> 的工作方式是检查对象原型链中是否存在 <code>constructor.prototype</code> 。 在上面的例子中，<code>leo instanceof Animal</code> 为 <code>true</code> ，因为<code>Object.getPrototypeOf(leo) === Animal.prototype</code>。 另外，<code>leo instanceof User</code> 为 <code>false</code> ，因为 <code>Object.getPrototypeOf(leo) !== User.prototype</code>。</p>
<h2 id="创建新的不可知构造函数"><a href="#创建新的不可知构造函数" class="headerlink" title="创建新的不可知构造函数"></a>创建新的不可知构造函数</h2><p>你能发现下面代码中的错误吗？</p>
<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>
<p>const leo = Animal(‘Leo’, 7)</p>
<p>即使是经验丰富的 JavaScript 开发人员有时也会因为上面的例子而被绊倒。 因为我们正在使用之前学过的 <code>pseudoclassical pattern</code>(经典伪类模式)，所以当调用 <code>Animal</code> 构造函数时，我们需要确保使用 <code>new</code> 关键字调用它。 如果我们不这样做，则不会创建 <code>this</code> 关键字，也不会隐式返回。 作为复习，注释掉的行是在函数上使用 <code>new</code> 关键字时幕后所做的事情。</p>
<p>function Animal(name, energy) {<br>    // const this = Object.create(Animal.prototype)</p>
<pre><code>this.name = name
this.energy = energy

// return this
</code></pre>
<p>}</p>
<p>这似乎是一个非常重要的细节，让其他开发人员记住。 假设我们正在与其他开发人员合作，有没有办法确保我们的 <code>Animal</code> 构造函数始终使用 <code>new</code> 关键字调用呢？ 事实证明，它是通过使用我们之前学到的 <code>instanceof</code> 运算符来实现的。 如果使用 <code>new</code> 关键字调用构造函数，那么构造函数体的内部将是构造函数本身的实例。 那是很多文字才能说清楚的。 这是一些代码。</p>
<p>function Animal(name, energy) {<br>    if (this instanceof Animal === false) {<br>        console.warn(‘Forgot to call Animal with the new keyword’)<br>    }<br>    this.name = name<br>    this.energy = energy<br>}</p>
<p>现在，如果我们使用 <code>new</code> 关键字重新调用函数，而不是只向函数的使用者打印警告，会发生什么呢？</p>
<p>function Animal(name, energy) {<br>    if (this instanceof Animal === false) {<br>        return new Animal(name, energy)<br>    }<br>    this.name = name<br>    this.energy = energy<br>}</p>
<p>现在无论是否使用 <code>new</code> 关键字调用 <code>Animal</code>，它都可以正常工作。</p>
<h2 id="重新创建-Object-create"><a href="#重新创建-Object-create" class="headerlink" title="重新创建 Object.create"></a>重新创建 Object.create</h2><p>在这篇文章中，我们非常依赖于 <code>Object.create</code> 来创建委托给构造函数原型的对象。 此时，您应该知道如何在代码中使用 <code>Object.create</code> ，但您可能没有想到的一件事是<code>Object.create</code> 实际上是如何工作的。 为了让您真正了解 <code>Object.create</code> 的工作原理，我们将重新创建它。 首先，我们对 <code>Object.create</code> 的工作原理了解多少？</p>
<ol>
<li> 它接受一个对象作为参数。</li>
<li> 它创建一个对象，该对象在查找失败时委托给参数对象。</li>
<li> 它返回新创建的对象。</li>
</ol>
<p>让我们从第1点开始吧。</p>
<p>Object.create = function (objToDelegateTo) {}</p>
<p>很简单。 现在第2点 – 我们需要创建一个对象，该对象将在查找失败时委托给参数对象。 这个有点棘手。 为此，我们将使用我们对 <code>new</code> 关键字和原型如何在 JavaScript 中工作的知识。首先，在 <code>Object.create</code> 实现的主体中，我们将创建一个空函数。 然后，我们将该空函数的原型设置为参数对象。然后，为了创建一个新对象，我们将使用 <code>new</code> 关键字调用空函数。如果我们返回新创建的对象，也会完成第3点。</p>
<p>Object.create = function(objToDelegateTo) {<br>    function Fn() {}<br>    Fn.prototype = objToDelegateTo<br>    return new Fn()<br>}</p>
<p>有点野蛮是吧？让我们来看看吧。 当我们在上面的代码中创建一个新函数 <code>Fn</code> 时，它带有一个 <code>prototype</code> 属性。 当我们使用 <code>new</code> 关键字调用它时，我们知道我们将得到的是一个对象，该对象将在查找失败时委托给函数的原型。 如果我们覆盖函数的原型，那么我们可以决定在查找失败时委托给哪个对象。 所以在我们上面的例子中，我们用调用 <code>Object.create</code> 时传入的对象覆盖 <code>Fn</code>的原型，我们称之为 <code>objToDelegateTo</code>。 请注意，我们只支持 <code>Object.create</code> 的单个参数。官方实现还支持第二个可选参数，该参数允许您向创建的对象添加更多属性。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数没有自己的 <code>this</code> 关键字。因此，箭头函数不能用于构造函数，如果您尝试使用 <code>new</code> 关键字调用箭头函数，它将抛出错误。</p>
<p>const Animal = () =&gt; {}<br>const leo = new Animal() // Error: Animal is not a constructor</p>
<p>另外，因为我们在上面证明了 <code>pseudoclassical pattern</code>(经典伪类模式) 不能与箭头函数一起使用，所以箭头函数也没有 <code>prototype</code>(原型) 属性。</p>
<p>const Animal = () =&gt; {}<br>console.log(Animal.prototype) // undefined</p>
<p>  原文地址：<a target="_blank" rel="noopener" href="https://tylermcginnis.com/beginners-guide-to-javascript-prototype/">https://tylermcginnis.com/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/10/03/%E5%88%A9%E7%94%A8javascript%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%87%E6%8D%A2%EF%BC%88%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/03/%E5%88%A9%E7%94%A8javascript%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%87%E6%8D%A2%EF%BC%88%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F%EF%BC%89/" class="post-title-link" itemprop="url">利用JavaScript实现密码可见性切换（显示和隐藏）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-03 17:22:46" itemprop="dateCreated datePublished" datetime="2018-10-03T17:22:46+08:00">2018-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 11:38:47" itemprop="dateModified" datetime="2021-08-30T11:38:47+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%B5%84%E6%BA%90/" itemprop="url" rel="index"><span itemprop="name">资源</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于密码的可见性切换经常会在移动端见到，由于移动端输入体验不是很好，经常会输入密码的时候出现错误，反正我是有这样的体验，所以衍生出了密码的显示和隐藏的切换，那么在pc端会出现这种问题吗？答案是会的，特别是在重置密码的时候要输入两次，就会出现输入错误的问题，我是程序员我的解决方法是查看源码。把input的type类型的password改变成text或置空，就显示密码了，这是我经常使用的惯例，所以你在使用浏览器的时候千万不要让浏览器记住密码，很危险的。</p>
<p>那么我们的用户是否也可以看到密码呢，答案是有的，实现原理就是通过js将input 标签 type=”password”改变为type=”text”，在 Chrome、FireFox 等浏览器中通过修改 input 标签的 type 属性轻松实现该效果，但是 IE 下就会报错。如果你需要兼容IE，就必须考虑其他方案。下面看例子：</p>
<h2 id="例子一：用复选框作为介质来切换显示隐藏"><a href="#例子一：用复选框作为介质来切换显示隐藏" class="headerlink" title="例子一：用复选框作为介质来切换显示隐藏"></a>例子一：用复选框作为介质来切换显示隐藏</h2><p>最常见的实现是位于密码输入框下的复选框和标签。切换复选框后，密码变为可见。</p>
<iframe src="https://code.hcharts.cn/temp/ZBh1b7/share/result,js,html,css" width="100%" height="450" frameborder="0" allowfullscreen="allowfullscreen"></iframe>

<p>对于上面提到的安全问题，我已经在密码输入上禁用了自动完成功能。交互非常简单，JavaScript将监听复选框输入的更改。切换后，密码字段将从type属性更改password为text。</p>
<p>在功能方面，这种实现很好。但是有个问题是，“显示密码”复选框文本乍一看就像登录表单更常见的“记住我”选项，不可取。</p>
<h2 id="例子二：用一个按钮实现"><a href="#例子二：用一个按钮实现" class="headerlink" title="例子二：用一个按钮实现"></a>例子二：用一个按钮实现</h2><p>实现密码可见性切换的另一种方法是在密码字段本身上设置一个按钮。你也可以用图标来表示。</p>
<iframe src="https://code.hcharts.cn/temp/FeMwrG/share/result,js,html,css" width="100%" height="450" frameborder="0" allowfullscreen="allowfullscreen"></iframe>

<p>实现与复选框示例没有太大差别，主要区别在于文本根据密码字段的状态而变化。</p>
<p>我更喜欢这种方法的原因是因为像按钮的作用，至少它看起来不像是“记住我”复选框，它仍然有相同的安全问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/30/%E4%BD%BF%E7%94%A8css-content%E7%9A%84attr%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE%E6%8F%90%E7%A4%BA%EF%BC%88tooltip%EF%BC%89%E6%95%88%E6%9E%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/30/%E4%BD%BF%E7%94%A8css-content%E7%9A%84attr%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE%E6%8F%90%E7%A4%BA%EF%BC%88tooltip%EF%BC%89%E6%95%88%E6%9E%9C/" class="post-title-link" itemprop="url">使用CSS content的attr实现鼠标悬浮提示（tooltip）效果</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-30 16:09:31" itemprop="dateCreated datePublished" datetime="2018-09-30T16:09:31+08:00">2018-09-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 10:43:26" itemprop="dateModified" datetime="2021-08-30T10:43:26+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当你的用户需要漂亮的图标给出额外的文字信息时，亦或是当他们在点击了按钮之后需要确认自己没点错时，又或是带图片和字幕的复活节彩蛋，提示框是用来增强用户界面的绝佳手段。现在，让我们来做几个动画提示框，没有别的，只有HTML和CSS。 样例 这是我们之后要做的：</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/xianzhiding/pen/BGRKEE/">CSS Tooltip Magic</a> by xianzhiding (<a target="_blank" rel="noopener" href="https://codepen.io/xianzhiding">@xianzhiding</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>在我们沉浸在写代码的过程中之前，让我们先来看看我们的意图是什么。主要目的是为了获得一种简单的添加提示框的方法，这样一来，我们之后就能够通过增加一个自定义的 tooltip 属性来做到这一点。</p>
<p><span tooltip="message">visible text or icon, etc.</span></p>
<h2 id="让我们设定几个预期"><a href="#让我们设定几个预期" class="headerlink" title="让我们设定几个预期"></a>让我们设定几个预期</h2><ul>
<li>  不需要JavaScript</li>
<li>  我们将会使用属性选择器（而不是类名），以及CSS内建的模式匹配</li>
<li>  加到现有的DOM元素（你的标签中不需要新的元素）</li>
<li>  代码例子中是没有前缀的（如有需要，为你的目标浏览器加上供应商前缀）</li>
<li>  假设通过 mouseover/hover 来触发提示框</li>
<li>  仅仅是纯文本提示框（HTML，图片等等都不支持）</li>
<li>  当唤起提示框时，有巧妙的动画</li>
</ul>
<h2 id="好了，老司机要开车了！"><a href="#好了，老司机要开车了！" class="headerlink" title="好了，老司机要开车了！"></a>好了，老司机要开车了！</h2><p>哦，等等。我们还要先处理一个问题，是关于”不需要额外标签”的。毕竟，这很巧妙。 我们的提示框真的不需要额外的DOM元素，因为它们完全是基于伪元素的（::before 和 ::after），我们可以通过CSS来控制。 如果你已经在其它样式集中使用了一个元素的伪元素，又希望在这个元素是加一个提示框，那么你可能需要稍稍做一些重构。 没什么比得上来一场提示框盛会了！ 等等。小坏蛋！还有一个警告：CSS定位。为了提示框正常运作，它们的父元素（我们把提示框添加在它后面）需要是</p>
<ul>
<li>  <code>position: relative</code>，或者</li>
<li>  <code>position: absolute</code>，或</li>
<li>  <code>position: fixed</code></li>
</ul>
<p>基本上，什么都行，只要不是 position: static — 这是浏览器赋给几乎所有元素的默认定位模式。提示框是绝对定位的，所以它们需要知道它们的绝对值在什么边界内是有意义的。 默认的定位指令 static 不会声明它的边界，也不会给我们的提示框以上下文来进行相对定位。所以提示框会使用之后，最近的，有声明边界的父元素。 你还需要根据你如何使用提示框来决定哪个定位指令最为合适。这篇教程假设父元素是 postion: relative 如果你的UI依靠一个绝对定位的元素，那么在那个元素上部署一个提示框，也会需要一些重构（额外的标签）。 让我们开始吧。</p>
<h2 id="属性选择器：快速回顾"><a href="#属性选择器：快速回顾" class="headerlink" title="属性选择器：快速回顾"></a>属性选择器：快速回顾</h2><p>大多数CSS规则印象中都是用类名写的，比如 .this-thing ,但是CSS有几个类型的选择器。我们巧妙的提示框打算使用属性选择器——也就是方括号表示法。</p>
<p>[foo] {<br>background: rgba(0, 0, 0, 0.8);<br>color: #fff;<br>}</p>
<p>当浏览器看到诸如此类的东西时：</p>
<p><span foo>Check it out!</span></p>
<p>浏览器会知道，它需要应用 [foo] 规则了，因为 <span> 标签有一个叫做 foo 的属性。在这个例子中，span自身会有一个半透明的黑色背景，以及白色文字。 HTML元素有着各种各样的内置属性，但是我们也可以给出我们自己的属性。比如 foo ，又或者是 tooltip 。默认情况下，HTML不知道这些东西是什么意思，但是有了CSS，我们可以告诉HTML这些自定义属性是什么意思。</p>
<h2 id="为什么用属性选择器？"><a href="#为什么用属性选择器？" class="headerlink" title="为什么用属性选择器？"></a>为什么用属性选择器？</h2><p>我们后面会使用属性选择器，主要是出于侧重分离的目的。使用属性而不是类名，并不会让我们在详细程度上获得更多益处，类和属性在详细程度上是相同的。 然而，通过使用属性，我们可以把我们的内容放在一块儿，因为HTML属性可以有值，而类名没有值。 在这个例子的代码中，来权衡一下类名 .tooltip 对比属性 [tooltip] 。类名是 [class] 属性的值中的一个，而tooltip属性可以存放一个值，它就是我们要显示的文字。</p>
<p><span class="tooltip another-classname">lorem ipsum</span><br><span tooltip="sit dolar amet">lorem ipsum</span></p>
<h2 id="现在让我们来看看提示框炼金术"><a href="#现在让我们来看看提示框炼金术" class="headerlink" title="现在让我们来看看提示框炼金术"></a>现在让我们来看看提示框炼金术</h2><p>我们的提示框会使用两种不同的属性：</p>
<ul>
<li>  tooltip: 这个属性存放了提示框的内容（一个纯文本字符串）</li>
<li>  flow: 可选；这个属性允许我们控制如何显示提示框。我们可以支持很多方位，但是我们会覆盖4各常用方位： 上，左，右，下</li>
</ul>
<p>现在，让我们为所有的提示框做好准备工作。步骤1-5的规则会应用到所有的提示框上，无论我们给 flow 属性什么值。步骤6-7对于不同的 flow 值会有所区分。</p>
<h3 id="1-相对性"><a href="#1-相对性" class="headerlink" title="1. 相对性"></a>1. 相对性</h3><p>这是用在提示框的父元素上的。让我们来给定一个定位指令，这样提示框的组成部分（即::before 和 ::after 伪元素）的绝对定位就可以以父元素做参照进行定位，而不是以整个页面或祖父元素或DOM树上方的其它外围元素作为参照进行定位。</p>
<p>[tooltip] {<br>position: relative;<br>}</p>
<h3 id="2-伪元素准备时间"><a href="#2-伪元素准备时间" class="headerlink" title="2. 伪元素准备时间"></a>2. 伪元素准备时间</h3><p>是时候准备伪元素了。在这里，我们要对 ::before 和 ::after 设置常用属性。content 属性是真正让伪元素工作的属性，不过我们稍后再讨论它。</p>
<p>[tooltip]::before,<br>[tooltip]::after {<br>line-height: 1;<br>user-select: none;<br>pointer-events: none;<br>position: absolute;<br>display: none;<br>opacity: 0;</p>
<p>/* opinions */<br>text-transform: none;<br>font-size: .9em;<br>}</p>
<h3 id="3-丁克帽"><a href="#3-丁克帽" class="headerlink" title="3. 丁克帽"></a>3. 丁克帽</h3><p>我不知道丁克帽是不是说得通，我只是一直这么叫它。它是一个尖尖的小三角形，通过指向它的调用者，为提示框提供对话气泡的感觉。 注意到我们在边界颜色这一块，使用了 tranparent ；由于上色要根据提示框的 flow 值来，所以之后再加上颜色。</p>
<p>[tooltip]::before {<br>content: ‘’;<br>z-index: 1001;<br>border: 5px solid transparent;<br>}</p>
<p>content: ‘’;声明中的值是一个空字符串，这并不是笔误。字符串里面，我们不想要任何东西，但是我们需要这个属性，使得伪元素得以存在。 为了生成一个三角形，我们定义了一个实现边框，在空的盒子（没有内容）上加了一些厚度，而不设定盒子的宽度和高度，仅仅对盒子的每一条边都给一个边框颜色。</p>
<h3 id="4-气泡！"><a href="#4-气泡！" class="headerlink" title="4. 气泡！"></a>4. 气泡！</h3><p>这里是重点了。注意到 content: attr(tooltip) 这一部分是说：“这个伪类应该使用 tooltip 属性的值作为这个伪类的内容。”这也是为什么使用属性而不是类名会这么赞的原因。</p>
<p>[tooltip]::after {<br>content: attr(tooltip); /* magic! */<br>z-index: 1000;</p>
<p>/* most of the rest of this is opinion */<br>font-family: Helvetica, sans-serif;<br>text-align: center;</p>
<p>/*<br>Let the content set the size of the tooltips<br>but this will also keep them from being obnoxious<br>*/<br>min-width: 3em;<br>max-width: 21em;<br>white-space: nowrap;<br>overflow: hidden;<br>text-overflow: ellipsis;</p>
<p>/* visible design of the tooltip bubbles */<br>padding: 1ch 1.5ch;<br>border-radius: .3ch;<br>box-shadow: 0 1em 2em -.5em rgba(0, 0, 0, 0.35);<br>background: #333;<br>color: #fff;<br>}</p>
<p>注意看丁克帽和气泡的 z-index 值。这些值可以是任意的。但是要记住，z-index 值是相对的。 解释：一个z-index值为1001的元素，在一个z-index为3的元素内部。仅仅意味着，z-index: 3 容器内部，1001元素是最顶层的元素。 气泡的z-index应该至少比丁克帽的z-index低一档。如果它和丁克的一样高，或更高的话，如果你提示框使用了 box-shadow 的话，结果在丁克帽上回得到不一致的颜色效果。</p>
<h3 id="5-交互动作"><a href="#5-交互动作" class="headerlink" title="5. 交互动作"></a>5. 交互动作</h3><p>我们的提示框是通过把鼠标移动到带提示框的元素上面，来激活的。差不多是这样。</p>
<p>[tooltip]:hover::before,<br>[tooltip]:hover::after {<br>display: block;<br>}</p>
<p>如果你回顾在第2不中的样式部分，你会看到我们对提示框的组成部分，使用了 opacity: 0; 以及 display: none; 。我们这么做是为了当提示框显示和隐藏时，可以使用CSS动画效果。 display属性是不能做成动画的，但是opacity属性可以！我们留到最后来处理动画的问题。如果你对动画提示框没兴趣，只要把第2步中的 opacity: 0; 删掉，无视第7步即可。 最后一件要应用到所有提示框上的是，如果提示框没有内容，能有一个方法来抑制提示框。如果你使用某种动态系统（Vue.js, Angular, 或者 React, PHP等等）来生成提示框的话，我们就不需要笨笨的空白气泡了！</p>
<p>/* don’t show empty tooltips */<br>[tooltip=’’]::before,<br>[tooltip=’’]::after {<br>display: none !important;<br>}</p>
<h3 id="6-流控制"><a href="#6-流控制" class="headerlink" title="6. 流控制"></a>6. 流控制</h3><p>这一步会变得更加复杂，因为我们会使用一些不那么常见的选择器，来帮助我们的提示框基于 flow 值（或没有flow属性）来确定位置。 在我们写样式之前，让我们看看将要用到一些选择器模式。</p>
<p>[tooltip]:not([flow])::before,<br>[tooltip][flow^=”up”]::before {<br>/* …<br>properties: values<br>… */<br>}</p>
<p>这是在告诉浏览器：“对于所有带有 tooltip 属性来说，其中没有 flow 属性的元素，或者有flow元素，但它的值是以’up’开头的：将这些样式套用到这类元素的::before伪元素上。” 我们在这里使用了一个模式，这样一来，这些东西可以扩展到其它流上，而步需要重复这么多的CSS。这个模式 flow^=”up” 使用了 ^= （开头）匹配符。 如果你想增加其它流控制的话，通过这个模式，也可以将样式应用在 up-right 和 up-left 方向上（代码中）。我们在这里不会讨论这些流控制，不过你可以在CodePen上，我原来的提示框演示中看到如何使用它们。 以下是教程中所讲到的4个流所对应的CSS代码块。 上（这是默认的方向）</p>
<p>/* ONLY the ::before */<br>[tooltip]:not([flow])::before,<br>[tooltip][flow^=”up”]::before {<br>bottom: 100%;<br>border-bottom-width: 0;<br>border-top-color: #333;<br>}</p>
<p>/* ONLY the ::after */<br>[tooltip]:not([flow])::after,<br>[tooltip][flow^=”up”]::after {<br>bottom: calc(100% + 5px);<br>}</p>
<p>/* Both ::before &amp; ::after */<br>[tooltip]:not([flow])::before,<br>[tooltip]:not([flow])::after,<br>[tooltip][flow^=”up”]::before,<br>[tooltip][flow^=”up”]::after {<br>left: 50%;<br>transform: translate(-50%, -.5em);<br>}</p>
<h4 id="下"><a href="#下" class="headerlink" title="下:"></a>下:</h4><p>[tooltip][flow^=”down”]::before {<br>top: 100%;<br>border-top-width: 0;<br>border-bottom-color: #333;<br>}</p>
<p>[tooltip][flow^=”down”]::after {<br>top: calc(100% + 5px);<br>}</p>
<p>[tooltip][flow^=”down”]::before,<br>[tooltip][flow^=”down”]::after {<br>left: 50%;<br>transform: translate(-50%, .5em);<br>}</p>
<h4 id="左"><a href="#左" class="headerlink" title="左:"></a>左:</h4><p>[tooltip][flow^=”left”]::before {<br>top: 50%;<br>border-right-width: 0;<br>border-left-color: #333;<br>left: calc(0em - 5px);<br>transform: translate(-.5em, -50%);<br>}</p>
<p>[tooltip][flow^=”left”]::after {<br>top: 50%;<br>right: calc(100% + 5px);<br>transform: translate(-.5em, -50%);<br>}</p>
<h4 id="右"><a href="#右" class="headerlink" title="右:"></a>右:</h4><p>[tooltip][flow^=”right”]::before {<br>top: 50%;<br>border-left-width: 0;<br>border-right-color: #333;<br>right: calc(0em - 5px);<br>transform: translate(.5em, -50%);<br>}</p>
<p>[tooltip][flow^=”right”]::after {<br>top: 50%;<br>left: calc(100% + 5px);<br>transform: translate(.5em, -50%);<br>}</p>
<h3 id="7-让一切都动起来"><a href="#7-让一切都动起来" class="headerlink" title="7. 让一切都动起来"></a>7. 让一切都动起来</h3><p>动画是很神奇的。动画可以做到： 让用户感觉舒服 让用户感受到你的用户界面的空间感 注意到该看到的东西 让用户界面中本来非黑即白的生硬效果变得柔和 我们的提示框属于最后那一种。如果仅仅是让一个文字泡泡出现然后突然消失，效果是不令人满意的，我们可以让它更柔和一些。 关键帧 (@keyframes) 我们需要两个关键帧 (@keyframe) 动画。向上/向下提示框要用到tooltips-vert关键帧，而向左/向右提示框使用tooltips-horz关键帧。 注意，在这些关键帧中，我们只定义了提示框所需的终止状态。我们并不需要知道它们从何处来 (提示框本身就有状态信息)。我们只想控制它们要到哪儿去。</p>
<p>@keyframes tooltips-vert {<br>to {<br>opacity: .9;<br>transform: translate(-50%, 0);<br>}<br>}</p>
<p>@keyframes tooltips-horz {<br>to {<br>opacity: .9;<br>transform: translate(0, -50%);<br>}<br>}</p>
<p>现在，当一个用户的鼠标移到触发元素 (具有[tooltip]属性的元素) 上时，我们需要将这些关键帧应用到提示框上。因为我们采用了不同的流来控制提示框的显示方式，我们需要在样式中对它们进行定义。 使用:hover将控制传递给动画</p>
<p>[tooltip]:not([flow]):hover::before,<br>[tooltip]:not([flow]):hover::after,<br>[tooltip][flow^=”up”]:hover::before,<br>[tooltip][flow^=”up”]:hover::after,<br>[tooltip][flow^=”down”]:hover::before,<br>[tooltip][flow^=”down”]:hover::after {<br>animation:<br>tooltips-vert<br>300ms<br>ease-out<br>forwards;<br>}</p>
<p>[tooltip][flow^=”left”]:hover::before,<br>[tooltip][flow^=”left”]:hover::after,<br>[tooltip][flow^=”right”]:hover::before,<br>[tooltip][flow^=”right”]:hover::after {<br>animation:<br>tooltips-horz<br>300ms<br>ease-out<br>forwards;<br>}</p>
<p>我们不能对display属性进行动画，但是可以通过操作opacity属性，在提示框上加上淡入效果。我们也可以动画transform属性，它可以给提示框加上微妙的动作，触发的元素就像飞入某点的一样。 主要forward关键词在动画的声明中，这告诉动画当完成时不重置，而是继续停留在结束。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>棒极了！我们在这个教程里已经覆盖了很多，一堆提示框效果。 我们仅仅摸索了用css做提示框的表面。好好享受它们，继续试验，调制出你自己的方子！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/29/css%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/29/css%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/" class="post-title-link" itemprop="url">CSS中的变量：自定义属性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-29 16:01:57" itemprop="dateCreated datePublished" datetime="2018-09-29T16:01:57+08:00">2018-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 10:43:26" itemprop="dateModified" datetime="2021-08-30T10:43:26+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>多年来，变量是最常请求的CSS功能之一。变量可以更轻松地管理颜色，字体，大小和动画值，并确保它们在代码库中的一致性。 花了几年时间研究语法的细节，并决定变量如何适应控制级联和继承的现有规则。现在，它们以CSS“自定义属性”的形式供开发人员使用。 在本章中，我们将讨论CSS自定义属性的语法。我们来看看：</p>
<ul>
<li>  如何定义属性并为这些属性设置默认值 级联和继承的规则如何与自定义属性一起使用 如何在媒体查询中使用自定义属性 最后，您应该很好地掌握如何在项目中使用自定义属性。</li>
</ul>
<p>注意：浏览器对自定义变量的支持非常强大，存在于每个主要浏览器的最新版本中。但是，旧版但最近发布的浏览器版本仍然不支持这些版本，这些版本可能仍会被您网站的受众广泛使用。15之前的Microsoft Edge版本和9.1版之前的Safari版本完全缺乏支持。任何版本的Internet Explorer都是如此。Microsoft Edge 15有支持，但也有一些记录的错误。</p>
<h4 id="定义自定义属性"><a href="#定义自定义属性" class="headerlink" title="定义自定义属性"></a>定义自定义属性</h4><p>要定义自定义属性，请选择一个名称，并使用两个连字符作为前缀。任何字母数字字符都可以是名称的一部分。也允许使用连字符（-）和下划线（_）字符。广泛的unicode字符可以是自定义属性名称的一部分，包括emojis。为了清晰和可读性，请坚持使用字母数字名称。 这是一个例子：</p>
<p>--primarycolor: #0ad0f9ff; /* Using #rrggbbaa color notation */</p>
<p>该–指示的CSS解析器，这是一个自定义属性。无论将属性用作变量，属性的值都将替换该属性。 自定义属性名称区分大小写。换句话说，–primaryColor并且–primarycolor被认为是两个不同的属性名称。这与传统的CSS背道而驰，其中财产和价值案例并不重要。但是，它与ECMAScript处理变量的方式一致。 与其他属性（如displayor）一样font，必须在声明块中定义CSS自定义属性。一种常见的模式是在规则:root集中定义使用psuedo-element作为选择器的自定义属性：</p>
<p>:root {<br>–primarycolor: #0ad0f9ff;<br>}</p>
<p>:root是一个伪元素，它引用文档的根元素。对于HTML文档，这是html元素。对于SVG文档，它是svg元素。通过使用:root，可以在整个文档中立即获得属性。</p>
<h4 id="使用自定义属性"><a href="#使用自定义属性" class="headerlink" title="使用自定义属性"></a>使用自定义属性</h4><p>要将自定义属性值用作变量，我们需要使用该var()函数。例如，如果我们想将–primarycolor自定义属性用作背景颜色，我们将使用以下内容：</p>
<p>body {<br>background-color: var(–primarycolor);<br>}</p>
<p>我们的自定义属性的值将成为属性的计算值background-color。 到目前为止，自定义属性只能用作变量来设置标准CSS属性的值。例如，您不能将属性名称存储为变量，然后重复使用它。以下CSS不起作用：</p>
<p>:root {<br>–top-border: border-top; /* Can’t set a property as custom property’s value */<br>var(–top-border): 10px solid #bc84d8 /* Can’t use a variable as a property */<br>}</p>
<p>您也不能将属性 - 值对存储为变量并重用它。以下示例也无效：</p>
<p>:root {<br>–text-color: ‘color: orange’; /* Invalid property value */<br>}<br>body {<br>var(–text-color); /* Invalid use of a property */<br>}</p>
<p>最后，您也无法将变量连接为值字符串的一部分：</p>
<p>:root {<br>–base-font-size: 10;<br>}<br>body {<br>font: var(–base-font-size)px / 1.25 sans-serif; /* Invalid CSS syntax. */<br>}</p>
<p>自定义属性被设计为用作根据CSS规范解析的属性。如果浏览器供应商采用CSS扩展规范，我们有一天可能会使用自定义属性来创建自定义选择器组或自定义规则。但是，目前我们仅限于将它们用作变量来设置标准属性值。</p>
<h4 id="设置后备值"><a href="#设置后备值" class="headerlink" title="设置后备值"></a>设置后备值</h4><p>该var()函数实际上最多接受两个参数。第一个参数应该是自定义属性名称。第二个参数是可选的，但应该是声明值。如果尚未定义自定义属性值，则此声明值将用作一种回退值。 我们来看下面的CSS：</p>
<p>.btn__call-to-action {<br>background: var(–accent-color, salmon);<br>}</p>
<p>如果–accent-color已定义 - 让我们说它的值是#f30- 然后具有.btn__call-to-actionclass属性的任何路径的填充颜色将具有红橙色填充。如果没有定义，填充将是鲑鱼。 声明值也可以嵌套。换句话说，您可以使用变量作为var函数的回退值：</p>
<p>body {<br>background-color: var(–books-bg, var(–arts-bg));<br>}</p>
<p>在上面的CSS中，如果–books-bg已定义，则背景颜色将设置为–books-bg属性的值。如果没有，背景颜色将改为分配给的任何值–arts-bg。如果这两个都没有定义，那么背景颜色将是属性的初始值 - 在这种情况下transparent。 当自定义属性被赋予对其所使用的属性无效的值时，会发生类似的事情。考虑以下CSS：</p>
<p>:root {<br>–footer-link-hover: #0cg; /* Not a valid color value. */<br>}<br>a:link {<br>color: blue;<br>}<br>a:hover {<br>color: red;<br>}<br>footer a:hover {<br>color: var(–footer-link-hover);<br>}</p>
<p>在这种情况下，–footer-link-hover属性的值不是有效颜色。在Microsoft Edge中，页脚链接的悬停状态颜色将从a:hover选择器继承。在大多数其他浏览器中，悬停状态颜色将从body元素的文本颜色继承。 自定义属性和级联 自定义属性也遵循级联规则。后续规则可以覆盖它们的值：</p>
<p>:root {<br>–text-color: #190736; /* navy */<br>}<br>body {<br>–text-color: #333; /* Dark gray */<br>}<br>body {<br>color: var(–text-color);<br>}</p>
<p>在上面的示例中，我们的正文将为深灰色。我们还可以基于每个选择器重置值。让我们为这个CSS添加更多规则：</p>
<p>:root {<br>–text-color: #190736; /* navy */<br>}<br>body {<br>–text-color: #333; /* Dark gray */<br>}<br>p {<br>–text-color: #f60; /* Orange */<br>}<br>body {<br>color: var(–text-color);<br>}<br>p {<br>color: var(–text-color)<br>}</p>
<p>在这种情况下，包含在p元素标记中的任何文本都将为橙色。但是内部div或其他元素中的文本仍然是深灰色的。 也可以使用style属性设置自定义属性的值- 例如，style=”–brand-color: #9a09af”- 这在基于组件的前端体系结构中很有用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/28/%E5%A6%82%E4%BD%95%E5%9C%A8css%E4%B8%AD%E4%BD%BF%E7%94%A82d-transformation%E5%8A%9F%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/28/%E5%A6%82%E4%BD%95%E5%9C%A8css%E4%B8%AD%E4%BD%BF%E7%94%A82d-transformation%E5%8A%9F%E8%83%BD/" class="post-title-link" itemprop="url">如何在CSS中使用2D Transformation功能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-28 15:57:04" itemprop="dateCreated datePublished" datetime="2018-09-28T15:57:04+08:00">2018-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 10:43:26" itemprop="dateModified" datetime="2021-08-30T10:43:26+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Transforms允许我们创建不可能的效果和交互。与过渡和动画结合使用时，我们可以创建旋转，dance和zoom的元素和界面。特别是三维变换使得模仿物体成为可能。在本文中，我们将介绍2D变换函数（此处介绍了3D函数）。 有四种主要的二维变换函数：rotate，scale，skew，和translate。其他六个函数让我们在一个维度上转换元素：scaleX和scaleY; skewX和skewY; 和translateX和translateY。</p>
<h2 id="rotate"><a href="#rotate" class="headerlink" title="rotate()"></a>rotate()</h2><p>旋转变换围绕该transform-origin点围绕指定的角度旋转元素。使用rotate()顺时针（正角度值）或逆时针（负角度值）倾斜元素。它的效果很像风车或风车，如下所示。 紫色框从其起始位置旋转了55度，如虚线所示 <img data-src="http://file.w3cbest.com/file/images/1TransformRotate.png"> 该rotate()函数接受角度单位的值。角度单位由CSS值和单位模块级别3定义。这些可以是deg（度），rad（弧度），grad（梯度）或turn单位。一个完整旋转等于360deg，6.28rad，400grad，或1turn。 超过一个旋转（例如，540deg或1.5turn）的旋转值将根据其剩余值进行渲染，除非设置为动画或过渡。换句话说，540deg渲染与180deg（540度减去360度）相同，并且渲染与（1.5-1）1.5turn相同.5turn。但是，从一个过渡或动画0deg来540deg或1turn以1.5turn将旋转元素一个和倍半。</p>
<h2 id="2D缩放功能：scale，scaleX，和scaleY"><a href="#2D缩放功能：scale，scaleX，和scaleY" class="headerlink" title="2D缩放功能：scale，scaleX，和scaleY"></a>2D缩放功能：scale，scaleX，和scaleY</h2><p>使用缩放功能，我们可以在X维度（scaleX），Y维度（scaleY）或两者（scale）中增加或减少元素的渲染大小。缩放如下图所示，其中边框表示框的原始边界，+标记其中心点。 一个方框（左）缩放2倍（右） <img data-src="http://file.w3cbest.com/file/images/2TransformScale.png"> 每个比例函数都接受乘数或因子作为其参数。这个乘数可以是任何正数或负数。不支持百分比值。正乘数大于1增加元素的大小。例如，scale(1.5)将元素在X和Y方向上的尺寸增加1.5倍。之间的正乘数0和1将降低元素的大小。 小于的值0也会导致元素向上或向下缩放并创建反射（翻转）变换。 警告：使用scale(0)将导致元素消失，因为将数字乘以零会产生零。 使用scale(1)创建标识转换，这意味着它被绘制到屏幕，就像没有应用缩放转换一样。使用scale(-1)不会更改元素的绘制大小，但负值将导致元素被反射。即使元素没有出现变换，它仍会触发新的堆叠上下文并包含块。 可以使用该scale功能分别缩放X和Y尺寸。只需传递两个参数：scale(1.5, 2)。第一个参数缩放X维度; 第二个缩放Y维度。例如，我们可以单独使用X轴反射物体scale(-1, 1)。传递单个参数可以按相同因子缩放两个维度。</p>
<h2 id="2D转换功能：translateX，translateY，和translate"><a href="#2D转换功能：translateX，translateY，和translate" class="headerlink" title="2D转换功能：translateX，translateY，和translate"></a>2D转换功能：translateX，translateY，和translate</h2><p>平移元素会将其绘制位置与布局位置偏移指定的距离。如同其它变换，平移一个元件不改变其offsetLeft或offsetTop位置。但是，它会影响它在屏幕上的可视位置。 每个2D平移函数translateX- translateY，和 - translate接受参数的长度或百分比。长度单位包括像素（px）， ，em，rem和视口单元（vw和vh）。 该translateX函数更改元素的水平渲染位置。如果元素位于左侧零像素处，则将transform: transitionX(50px)其渲染位置移动50个像素到其起始位置的右侧。同样，translateY更改元素的垂直渲染位置。transform: transitionY(50px)将元素垂直偏移50个像素的变换。 使用translate()，我们可以使用单个函数垂直和水平移动元素。它最多接受两个参数：X转换值和Y转换值。下图显示了一个元件与效果transform的值translate(120%, -50px)，其中，所述左绿色正方形是在原来的位置，而右侧绿色正方形水平平移120％，并从它的含有元素（虚线框）垂直-50px。 <img data-src="http://file.w3cbest.com/file/images/3Translate.png"> 具有转换值为translate的元素的效果（120％， - 50px） 传递单个参数translate相当于使用translateX; Y转换值将设置为0。使用translate()是更简洁的选择。申请translate(100px, 200px)相当于translateX(100px) translateY(200px)。 正转换值将元素向右移动（for translateX）或向下移动（for translateY）。负值将元素移动到左（translateX）或向上（translateY）。 翻译对于向左，向右，向上或向下移动项目特别有用。更新的值left，right，top，和bottom属性强制浏览器重新计算整个文档布局信息。但是在计算布局之后计算变换。它们影响其中的元素出现在屏幕上，而不是他们的实际尺寸。是的，将文档布局和渲染视为单独的概念是很奇怪的，但就浏览器而言，它们是。 转换属性可能会到达您附近的浏览器 在CSS的最新版本来变换规范增加translate，rotate以及scale 性能的CSS。变换属性的工作方式与其对应的变换函数非常相似，但值是以空格分隔的，而不是以逗号分隔的。例如，我们可以transform: rotate3d(1, 1, 1, 45deg)使用该rotate属性表达：rotate: 1 1 1 45deg。同样，translate: 15% 10% 300px在视觉上与之相同transform: translate3d(15%, 10%, 300px)并且scale: 1.5 1.5 3相同transform: scale3d(1.5, 1.5, 3)。通过这些属性，我们可以与其他转换分开管理旋转，平移或缩放转换。 在撰写本文时，浏览器对转换属性的支持仍然非常稀少。Chrome和三星互联网支持开箱即用。在Firefox 60及更高版本中，支持隐藏在标志后面; 访问about: config并设置layout.css.individual-transform.enabled为true。</p>
<h2 id="skew，skewX和skewY"><a href="#skew，skewX和skewY" class="headerlink" title="skew，skewX和skewY"></a>skew，skewX和skewY</h2><p>歪斜变换会使点之间的角度和距离发生偏移，同时将它们保持在同一平面内。歪斜变换也称为剪切变换，它们会扭曲元素的形状，如下所示，其中虚线表示元素的原始边界框。 矩形沿其X维度倾斜45度 <img data-src="http://file.w3cbest.com/file/images/4TransformSkew.png"> 偏斜函数skew- skewX，和 - skewY接受大多数角度单位作为参数。度，渐变和弧度是倾斜函数的有效角度单位，而转弯单位可能显然不是。 该skewX功能在X或水平方向上剪切元素（参见下面的图像）。它接受一个参数，该参数也必须是一个角度单位。正值将元素向左移动，负值将元素向右移动。 左图像未被变换，而右图像显示变换的效果：skewX（30deg） <img data-src="http://file.w3cbest.com/file/images/5skewX.png"> 同样，skewY剪切Y或垂直方向的元素。下图显示了效果transform: skewY(30deg)。原点右侧的点向下移动，带有正值。负值将这些点向上移动。 同样，左图像保持未变换，右图像垂直偏斜30度 <img data-src="http://file.w3cbest.com/file/images/6skewY.png"> 这带给我们的skew功能。该skew函数需要一个参数，但最多可接受两个参数。第一个参数在X方向上扭曲一个元素，第二个参数在Y方向上扭曲它。如果只提供一个参数，则假定第二个值为零，使其相当于单独在X方向上的倾斜。换句话说，skew(45deg)渲染相同skewX(45deg)。</p>
<h2 id="当前变换矩阵"><a href="#当前变换矩阵" class="headerlink" title="当前变换矩阵"></a>当前变换矩阵</h2><p>到目前为止，我们已经分别讨论了变换函数，但它们也可以组合在一起。想要缩放和旋转对象？没问题：使用转换列表。例如：</p>
<p>.rotatescale {<br>transform: rotate(45deg) scale(2);<br>}</p>
<p>这将产生您在下面看到的结果。 <img data-src="http://file.w3cbest.com/file/images/7ScaleAndRotate.png"> 应用原始元素（左）和组合旋转和缩放变换后（右） 使用转换函数时，顺序很重要。这是一个比谈论更好的一点，所以让我们看一个例子来说明。以下CSS倾斜并旋转元素：</p>
<p>.transformEl {<br>transform: skew(10deg, 15deg) rotate(45deg);<br>}</p>
<p>它为我们提供了您在下面看到的结果。 <img data-src="http://file.w3cbest.com/file/images/8SkewAndRotate.png"> 歪斜变换后的元素（10度，15度）旋转（45度） 如果首先旋转元素然后将其倾斜会发生什么？</p>
<p>.transformEl {<br>transform: rotate(45deg) skew(10deg, 15deg);<br>}</p>
<p>如下所示，效果完全不同。 <img data-src="http://file.w3cbest.com/file/images/9RotateThenSkew.png"> 旋转后然后倾斜的元素 这些变换中的每一个具有由其变换函数的顺序创建的不同的当前变换矩阵。为了完全理解为什么这样，我们需要学习一点矩阵乘法。这也有助于我们理解matrix和matrix3d功能。 矩阵乘法和矩阵函数 甲矩阵是排列成行和列的矩形号码或表达式的阵列。所有变换可以使用4×4矩阵表示，如下所示。 <img data-src="http://file.w3cbest.com/file/images/1536071956matrix4x4.png"> 用于3D变换的4×4矩阵 该矩阵对应于matrix3d函数，该函数接受16个参数，每个参数用于4×4矩阵的每个值。二维变换也可以使用3×3矩阵表示，如下所示。 <img data-src="http://file.w3cbest.com/file/images/1536071982matrix.png"> 用于2D变换的3×3矩阵 该3×3矩阵对应于matrix变换函数。该matrix()函数接受六个参数，每个参数对应于值a到f。 可以使用矩阵和/ matrix或matrix3d函数来描述每个变换函数。下图显示了scale3d函数的4×4矩阵，其中sx，sy和sz分别是X，Y和Z维度的缩放因子。 <img data-src="http://file.w3cbest.com/file/images/1536072012scalingmatrix4x4.png"> 当我们组合变换时 - 例如transform: scale(2) translate(30px, 50px)- 浏览器将每个函数的矩阵相乘以创建新矩阵。这个新矩阵是应用于元素的。 但这是关于矩阵乘法的事情：它不是可交换的。使用简单值，3×2的乘积与2×3相同。但是，对于矩阵，A × B的乘积不一定与B × A的乘积相同。我们来看一个例子。我们将计算出的矩阵乘积transform: scale(2) translate(30px, 50px)。 <img data-src="http://file.w3cbest.com/file/images/1536072046ScaleAndTranslate.png"> 我们的元素按比例缩放了两倍，然后水平翻译60像素，垂直翻译100像素。我们也可以使用以下matrix功能表达此产品：transform: matrix(2, 0, 0, 2, 60, 100)。现在让我们切换这些变换的顺序 - 即transform: translate(30px, 50px) scale(2)。结果如下所示。 <img data-src="http://file.w3cbest.com/file/images/1536072076TranslateAndScale.png"> 用于平移（30px，50px）和刻度（2）的矩阵的乘积 请注意，我们的对象仍然按比例缩放了两倍，但在这里它被水平翻译了30个像素而垂直翻译了50个像素。使用该matrix函数表示，这是transform: matrix(2, 0, 0, 2, 30, 50)。 值得注意的是，继承转换的功能与转换列表类似。每个子变换乘以应用于其父变换的任何变换。例如，请使用以下代码：</p>
<div style="transform: skewX(25deg)">
<p style="transform: rotate(-15deg)"></p>
</div>

<p>这与以下内容相同：</p>
<div>
<p style="transform: skewX(25deg) rotate(-15deg)"></p>
</div>

<p>p在两种情况下，元素的当前变换矩阵都是相同的。虽然到目前为止我们专注于2D变换，但上述内容也适用于3D变换。第三个维度增加了深度的幻觉。它还以新功能和属性的形式带来了一些额外的复杂性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/28/css3%E4%B8%AD%E7%9A%84-scroll-snap%EF%BC%9A%E6%8E%A7%E5%88%B6%E6%BB%9A%E5%8A%A8%E5%8A%A8%E4%BD%9C%EF%BC%88%E7%B1%BB%E4%BC%BC%E6%BB%9A%E5%8A%A8%E5%9B%BE%E7%89%87%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/28/css3%E4%B8%AD%E7%9A%84-scroll-snap%EF%BC%9A%E6%8E%A7%E5%88%B6%E6%BB%9A%E5%8A%A8%E5%8A%A8%E4%BD%9C%EF%BC%88%E7%B1%BB%E4%BC%BC%E6%BB%9A%E5%8A%A8%E5%9B%BE%E7%89%87%EF%BC%89/" class="post-title-link" itemprop="url">CSS3中的 Scroll Snap：控制滚动动作（类似滚动图片）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-28 15:33:27" itemprop="dateCreated datePublished" datetime="2018-09-28T15:33:27+08:00">2018-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 10:43:26" itemprop="dateModified" datetime="2021-08-30T10:43:26+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%B5%84%E6%BA%90/" itemprop="url" rel="index"><span itemprop="name">资源</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>随着Web平台的发展，它也获得了类似原生应用的特点。其中一个功能是<a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-scroll-snap-1/">CSS Scroll Snap Module</a>。Scroll snap允许开发人员定义界面在滚动操作期间应该移动的距离。您可以使用它来构建幻灯片放映或分页界面 - 目前需要JavaScript和DOM操作才能完成。 Scroll snap作为一项功能经历了很多变化。早期的2013版规范 - 当时称为Scroll Snap Points–定义了一种基于坐标和像素的方法来指定滚动距离。此版本的规范是在Microsoft Edge，Internet Explorer 11和Firefox中实现的。 Chrome 69+和Safari 11+实现了规范的最新版本，该版本使用了盒子对齐模型。这就是我们将在本节中关注的内容。 警告： 当前浮动在Web上的许多滚动快照教程都基于早期的CSS Scroll Snap Points规范。标题中“points”一词的出现是教程可能依赖于旧规范的一个标志。然而，更可靠的指标是存在scroll-snap-points-x或scroll-snap-points-y属性。 由于滚动捕捉非常适合幻灯片放映布局，这就是我们要构建的内容。这是我们的标记。</p>
<div class="slideshow">
<img data-src="avocado-and-bacon-salad.jpg">
<img data-src="salad-eggs-and-scallops.jpg">
<img data-src="seafood-and-noodles.jpg">
<img data-src="grilled-salmon-and-side-salad.jpg">
<img data-src="avocado-toast-with-egg.jpg">
</div>

<p>这就是我们所需要的一切。我们不需要具有外部包裹元件和内部滑动容器。我们也不需要任何JavaScript。 现在我们的CSS：</p>
<p>* {<br>box-sizing: border-box;<br>}</p>
<p>html, body {<br>padding: 0;<br>margin: 0;<br>}</p>
<p>.slideshow {<br>scroll-snap-type: x mandatory; /* Indicates scroll axis and behavior */<br>overflow-x: auto; /* Should be either `scroll` or `auto` */<br>display: flex;<br>height: 100vh;<br>}</p>
<p>.slideshow img {<br>width: 100vw;<br>height: 100vh;<br>scroll-snap-align: center;<br>}</p>
<p>添加scroll-snap-type以.slideshow创建滚动容器。此属性的值x mandatory描述了我们要滚动的方向以及滚动快照严格性。在这种情况下，该mandatory值告诉浏览器，当没有活动的滚动操作时，它必须捕捉到捕捉位置。使用display: flex只是确保我们的所有图像水平堆叠。 现在我们需要的另一个属性是scroll-snap-align。此属性指示如何在滚动容器的捕捉端口内对齐每个图像的滚动捕捉区域。它接受三个值：start，end，和center。在这种情况下，我们使用了center这意味着每个图像将在视口中居中，如下所示。 <img data-src="http://www.w3cbest.com/wp-content/uploads/2018/09/ScrollSnap.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/26/art-template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%B9%8B%E5%81%B6%E6%95%B0%E5%A5%87%E6%95%B0%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/26/art-template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%B9%8B%E5%81%B6%E6%95%B0%E5%A5%87%E6%95%B0%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">artTemplate模板引擎之偶数奇数解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-26 13:57:18" itemprop="dateCreated datePublished" datetime="2018-09-26T13:57:18+08:00">2018-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 11:21:09" itemprop="dateModified" datetime="2021-08-30T11:21:09+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果有一个数组，我们只取其中的偶数或奇数该如何取值呢，下面一组数据是我们通过接口拿到的，其实我们只要奇数的一部分，1，3，5，7…等，如图：</p>
<pre class="language-none"><code class="language-none">\[&quot;1701班&quot;,11,0,&quot;0%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,1,&quot;9.09%&quot;,7,&quot;63.64%&quot;,2,&quot;18.18%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,1,&quot;9.09%&quot;\]

!\[](http:&#x2F;&#x2F;www.w3cbest.com&#x2F;wp-content&#x2F;uploads&#x2F;2018&#x2F;09&#x2F;20180926133157.jpg) 我们只要一个if条件判断就可以了，操作如下： js

res &#x3D; &#123;&quot;data&quot;:&#123;
  &quot;head&quot;:\[&quot;人数&quot;,&quot;比例&quot;\],
  &quot;datas&quot;:\[
  &#123;&quot;data&quot;:\[&quot;1701班&quot;,11,0,&quot;0%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,1,&quot;9.09%&quot;,7,&quot;63.64%&quot;,2,&quot;18.18%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,1,&quot;9.09%&quot;\]&#125;,
  &#123;&quot;data&quot;:\[&quot;班级平均&quot;,21,&quot;0&quot;,&quot;0%&quot;,&quot;0&quot;,&quot;0%&quot;,&quot;0&quot;,&quot;0%&quot;,&quot;3&quot;,&quot;28.57%&quot;,&quot;5&quot;,&quot;47.62%&quot;,&quot;1.5&quot;,&quot;14.29%&quot;,&quot;0&quot;,&quot;0%&quot;,&quot;0&quot;,&quot;0%&quot;,&quot;0.5&quot;,&quot;4.76%&quot;,&quot;0.5&quot;,&quot;4.76%&quot;\]&#125;,
  &#123;&quot;data&quot;:\[&quot;全年级&quot;,21,0,&quot;0%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,6,&quot;28.57%&quot;,10,&quot;47.62%&quot;,3,&quot;14.29%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,1,&quot;4.76%&quot;,1,&quot;4.76%&quot;\]&#125;
  \],
  &quot;title&quot;:\[&quot;90以下&quot;,&quot;90 ~ 97&quot;,&quot;97 ~ 104&quot;,&quot;104 ~ 111&quot;,&quot;111 ~ 118&quot;,&quot;118 ~ 125&quot;,&quot;125 ~ 132&quot;,&quot;132 ~ 139&quot;,&quot;139 ~ 146&quot;,&quot;146以上&quot;\]
  &#125;
&#125;
document.getElementById(&#39;id&#39;).innerHTML &#x3D; template(&#39;tpl&#39;, res);</code></pre>
<p>template</p>
<pre class="language-none"><code class="language-none">&lt;script id&#x3D;&quot;tpl&quot; type&#x3D;&quot;text&#x2F;html&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;班级&lt;&#x2F;th&gt;
      &#123;&#123;each title value i&#125;&#125;
      &lt;th&gt;&#123;&#123;value&#125;&#125;&lt;&#x2F;th&gt;
      &#123;&#123;&#x2F;each&#125;&#125;
    &lt;&#x2F;tr&gt;
&lt;&#x2F;thead&gt;
&lt;tbody&gt;
  &#123;&#123;each datas item&#125;&#125;
  &lt;tr&gt;
    &#123;&#123;each item.data value i&#125;&#125;
    &#123;&#123;if (i % 2 &#x3D;&#x3D; 0)&#125;&#125;
    &lt;td&gt;&#123;&#123;value&#125;&#125;&lt;&#x2F;td&gt;
    &#123;&#123;&#x2F;if&#125;&#125;
    &#123;&#123;&#x2F;each&#125;&#125;
  &lt;&#x2F;tr&gt;
  &#123;&#123;&#x2F;each&#125;&#125;
&lt;&#x2F;tbody&gt;
&lt;&#x2F;script&gt;</code></pre>
<p>其实很简单，就跟跟平时普通的if判断一样，都是取模，但是要注意在这里面要有始有终，有<code>&#123;&#123;if&#125;&#125;</code>就得有对应的<code>&#123;&#123;/if&#125;&#125;</code>，有<code>&#123;&#123;each&#125;&#125;</code>就得有对应的<code>&#123;&#123;/each&#125;&#125;</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/25/css-%E9%80%89%E6%8B%A9%E5%99%A8%E6%8A%80%E8%83%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/25/css-%E9%80%89%E6%8B%A9%E5%99%A8%E6%8A%80%E8%83%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">CSS 选择器技能使用指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-25 09:07:13" itemprop="dateCreated datePublished" datetime="2018-09-25T09:07:13+08:00">2018-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 10:43:26" itemprop="dateModified" datetime="2021-08-30T10:43:26+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我已经使用CSS多年了，但直到最近我还没有深入研究过关于 CSS 选择器的主题。 为什么我需要学习 CSS 选择器呢？ 我们现在知道了所有的内部选择器了吗？ 问题是(至少对我来说是这样)随着时间的推移，很容易习惯在每个项目上使用相同的习惯的选择器集合来完成你要做的事情。 因此，我自己对 CSS 选择器知识进行了深入的审查，并发现了一些有趣的内容，这些内容对我来说是新的，或者是以前我从来没有想过这些使用方式。 我还发现了一些很酷的新选择器，将来可用，但还没有广泛使用。 我们一起来深入研究一下各种类型的 CSS 选择器吧。 您在日常工作中已经使用了，或者本文没涉及到的 CSS 选择器技能欢迎留言告诉我。 准备好提升你的 CSS 选择器技能了吗？我们一起 GO！</p>
<h2 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h2><p>让我们从熟悉的选择器开始。组合选择器用于选择子元素和兄弟元素，并且相信大家已经使用了很长一段时间了吧。</p>
<ul>
<li>  一般子元素选择器（空格）。例如A B。</li>
<li>  直接子元素选择器。例如 A &gt; B 。</li>
<li>  相邻兄弟元素选择器。例如 A + B。</li>
<li>  一般兄弟元素选择器。例如 A ~ B。</li>
</ul>
<p>您应该熟悉相邻兄弟元素选择器 A + B ，他会选择紧跟 A 的 B 元素。但是一般兄弟元素选择器 A~B 呢？ 他将选择跟随 A 的所有兄弟 B 元素： 以下是实例：</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/RyvYXd/">Combinator Selectors</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>第二行 New York 行被选中是因为它紧跟在第一行之后 table tbody tr:first-child + tr，并且最后两个城市被高亮显示，因为他们被一般兄弟选择器 table tbody tr:nth-child(4) ~ tr 匹配，也就是第四行之后的所有行。</p>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>我非常喜欢属性选择器。当您需要将包含某个属性的元素与特定值匹配时，它们可以非常灵活。</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/MGLZEK/">Attribute Selectors #1</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>此示例演示如何选择所有复选框元素并将样式应用于其匹配标签，以使其变为粗体和蓝色。 然后，我们覆盖具有特定名称的 chk2 复选框的样式，并将其匹配的标签着色为红色。 请注意其他表单元素标签如何不受影响且未应用标签样式。 属性选择器不仅适用于表单元素，它们还可以定位任何元素的属性。 您可以匹配任何属性，而不仅仅是官方支持的属性。 此外，您可以检查属性是否存在，如下所示：</p>
<p>button[icon]</p>
<p>这匹配包含 icon 属性的 <button> 元素。它将匹配 icon 属性，无论 icon 属性是空值还是设置为特定值。 更多例子：</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/pVGGye/">Attribute Selectors #2</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>第一个链接没有 target 属性，因此不匹配。 接下来的两个链接是匹配的，因为它们的 target 属性具有空值或特定值的属性。 最后，最后一个链接设置为粉红色，因为它 fluffy 属性匹配。 它的值无关紧要，只需要与 a[fluffy] 选择器相匹配即可。 一个实际的例子可能是突出显示没有alt属性的图像。 此属性对于网页的可访问性来说是所必需的，因此对于SEO而言，确保所有图像元素都包含此属性非常重要。 我们可以使用以下规则来实现此目的：</p>
<p>img:not([alt]) {<br>border: 2px red dashed;<br>}</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/OZdqLp/">Attribute Selectors #3</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>如果要匹配属性值的特定部分，则可以使用一些非常有用的选择器。</p>
<ul>
<li>  A[attr^=val] – 属性值以 val 开头。</li>
<li>  A[attr=val] – 属性值以 val 开头，或者以 val- 开头。</li>
<li>  A[attr$=val] – 属性值以 val 结尾。</li>
<li>  A[attr*=val] – 属性值中包含 val 。</li>
<li>  A[attr~=val] – 匹配用空格分隔的属性值列表，并且列表中包含 val 。</li>
</ul>
<p>以下是每个例子：</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/MGLdvE/">Attribute Selectors #4</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>前两个示例非常相似，不同之处是 A[attr=val] 匹配后跟一个 - 字符串的值。 这对于匹配语言属性 lang 很有用。 例如 <p lang ="en-us">。 使用 A[attr$=”val”] 可以轻松匹配文件扩展名，并且与 ::after 相结合你可以轻松显示匹配文件。 注意使用 attr() 方法和 content 属性将它与静态字符串连接起来。 A[attr*=val] 显示了无论使用何种协议或子域，您都可以匹配特定域 mysite.com。 最后，A[attr<del>=val]，它非常适合匹配由空格分隔的值列表组成的属性中的值。 这只匹配整个单词而不是单词片段，而 *= 匹配单词片段，因此单词复数形式将不匹配。这个有点不好理解：例如某 div 元素的 categories 属性为 <div categories="table wooden maple">，其 categories 属性用空格分隔。那么 div[categories</del>=”table”] 将匹配各元素，还有一个特别要注意的是， <div categories="wooden maple table"> 也将被匹配。而 <div categories="wooden maple tables"> 或者 <div categories="wooden tableee maple"> 都不会被 div[categories~=”table”] 匹配。 以上所有属性选择器示例都区分大小写。 但是我们有一个技巧。 如果我们在结束方括号之前插入一个 i ，我们可以启用区分大小写的匹配，这有点类似于 JavaScript 中的正则表达式匹配。</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/LmaYzp/">Attribute Selectors #5</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>除 Internet Explorer 和 Microsoft Edge 外，大多数主流浏览器都支持不区分大小写的匹配。</p>
<h2 id="用户交互选择器"><a href="#用户交互选择器" class="headerlink" title="用户交互选择器"></a>用户交互选择器</h2><p>如果您处理过表单样式，那么您之前无疑会遇到这些类型的伪类选择器：</p>
<ul>
<li>  :enabled</li>
<li>  :disabled</li>
<li>  :checked</li>
</ul>
<p>例如，我们可以使用 :checked 来设置一个简单的待办事项列表。</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/BxbjoO/">User Interface Selectors #1</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>这是非常标准的，但我们可以使用其他一些有趣的伪类。 :default 匹配一个或多个元素，这些元素是一组相关元素中的默认元素。这也可以与复位按钮类型组合使用。</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/ELMoNK/">User Interface Selectors #2</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>我们可以使用伪类选择器来匹配输入值是否与 CSS 直接有效，以及在提交表单之前检查是否需要任何元素。</p>
<ul>
<li>  :valid</li>
<li>  :invalid</li>
<li>  :required</li>
<li>  :optional (即不必须)</li>
</ul>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/qYvpMP/">User Interface Selectors #3</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>如果您开始输入个人 email 输入字段，则必须检查有效性。 但是，工作 email 地址始终是必需的，并且需要有效检查有效性，因此不能留空。 还要注意我们可以链接伪类选择器（例如 :required:invalid ）来实现我们所需要的。 接下来，如果表单元素（支持 min 和 max 属性）在范围内，我们有两个可以匹配的伪类。</p>
<ul>
<li>  :in-range</li>
<li>  :out-of-range</li>
</ul>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/Jvzpgz/">User Interface Selectors #4</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>同样，我们可以使用重置按钮类型来重置数字输入元素的默认值。 为了完善本节，我们来看看 :read-only ，:read-write 和 :placeholder-shown 的伪类。</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/ZoPREB/">User Interface Selectors #5</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>使用这些可以轻松匹配只读或可写（可编辑）的元素。 匹配元素不必是表单输入字段，如示例中所示。 最后，:placeholder-shown 将匹配尚未与之交互的元素，并仍显示默认占位符文本。 应谨慎使用此特定选择器，因为它尚未得到广泛支持。</p>
<h2 id="结构选择器"><a href="#结构选择器" class="headerlink" title="结构选择器"></a>结构选择器</h2><p>结构选择器非常强大，基于它们在DOM中的位置匹配元素。 它们使您可以灵活地将元素与CSS完全匹配，否则需要 JavaScript 执行相同的操作。 这种类型的选择器与显示的选择器不同，因为其中一些选择器允许您传入参数来修改选择器的工作方式。 例如：nth-child() 接收一个值，该值将匹配特定子元素相对于其父容器的值。 因此，如果我们有一个项目列表，则以下选择器将匹配第三个项目：</p>
<p>ul:nth-child(3)</p>
<p>但是，参数不是必须是简单的数字，它可以是一个简单的表达式，而使伪类更强大。 有效表达式有：</p>
<ul>
<li>  ul:nth-child(2) – 匹配第 2 个子元素</li>
<li>  ul:nth-child(4n) – 匹配每 4th 个子元素（4,8,12，…）</li>
<li>  ul:nth-child(2n + 1) – 匹配每 2n + 1 个子元素偏移一个（1,3,5，…）</li>
<li>  ul:nth-child(3n - 1) – 匹配每 3n – 1 个子元素偏移负数1（2,5,8，…）</li>
<li>  ul:nth-child(odd) – 匹配奇数元素（1,3,5，…）</li>
<li>  ul:nth-child(even) – 匹配偶数元素（2,4,6，…）</li>
</ul>
<p>表达式变量 n 总是从零开始，因此确切地计算出哪些元素将匹配，n 从 0 开始，然后 n 为 1 ，依此类推以编译元素列表。 这里还有 1 个简单而实用的小技巧，我们把n当做负数来用，会发生什么呢？</p>
<ul>
<li>  ul li:nth-child(-n+3) – 匹配第 1 到 第 3 个 li 子元素 （1,2,3）</li>
<li>  ul li:nth-child(-2n+6) – 匹配每 2th 个子元素，最多不超过第 8 个 li 子元素 （2,4,6，8）</li>
<li>  ul li:nth-child(n + 10):nth-child(-n + 12) – 匹配第 10 到 第 12 个 li 子元素 （10,11,12）</li>
</ul>
<p>例如：</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/w3cbest/pen/mveKRe/">把`n` 当做负数来用</a> by w3cbest.com (<a target="_blank" rel="noopener" href="https://codepen.io/w3cbest">@w3cbest</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>您可以将简单表达式与以下结构选择器一起使用：</p>
<ul>
<li>  :nth-child()</li>
<li>  :nth-last-child()</li>
<li>  :nth-of-type()</li>
<li>  :nth-last-of-type()</li>
</ul>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/MGxzEq/">Structural Selectors #1</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>:nth-last-child() 和 :nth-last-of-type() 非常类似于 :nth-child() 和 nth-of-type() ，唯一区别是 :nth-last-child() 和 :nth-last-of-type() 是从最后一个元素开始匹配，而不是第一个元素开始匹配。 通过玩各种组合，您可以通过选择器获得相当多的创意。 例如，之前的示例包含选择器：</p>
<p>ul:last-of-type li:nth-last-of-type(2)::after {<br>content: “(2nd from end)”;<br>/* Other styles… */<br>}</p>
<p>这匹配第 2 个无序列表中最后一个列表项之后的伪元素。 如果你一直在努力解码一个复杂的选择器，那么最好从右到左阅读它，这样它就可以在逻辑上解构。 下一组选择器是专用的结构选择器，因为它们只匹配特定的子元素。 您无法将表达式传递给它们以修改其行为。</p>
<ul>
<li>  :first-child</li>
<li>  :last-child</li>
<li>  :only-child</li>
<li>  :first-of-type</li>
<li>  :last-of-type</li>
</ul>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/JvzwJE/">Structural Selectors #2</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>乍一看，这里有很多事情，你在使用这些类型的选择器时需要小心，因为你可能得到你没想到的结果。 例如，您可能想知道为什么在 <section> 标记内的等等……文本是蓝色的。 实际上所有部分内容都是蓝色的，因为它是主 div 容器的最后一个子节点。 其他部分元素通过其他选择器覆盖自己的颜色，使单个段落变为蓝色。 如果你觉得这些结构选择器还不够，或者你觉得记不住，使用起来很麻烦，那么你可以使用 Family.scss – 轻松搞定这些 :nth-child 伪类 :nth-child</p>
<h2 id="否定、排除选择器"><a href="#否定、排除选择器" class="headerlink" title="否定、排除选择器"></a>否定、排除选择器</h2><p>CSS 否定伪类选择器 :not(X)，是以一个简单的以选择器 X 为参数的功能性标记函数，将从匹配的元素集合中排除选择器 X 所匹配的元素。选择器 X 中不能包含另外一个 :not 选择器。</p>
<ul>
<li>  :not() 伪类的优先级即为它参数选择器的优先级。 可以利用这个伪类提高规则的优先级。例如， #foo:not(#bar) 和 #foo 会匹配相同的元素。 但是前者的优先级更高。但是 :not() 伪类不像其它伪类，它不会增加选择器的优先级。</li>
<li>  :not() 伪类可以将一个或多个以逗号分隔的选择器作为其参数。但是以多个以逗号分隔的选择器作为参数是实验性的，尚未广泛支持。</li>
</ul>
<p>:not() 伪类时我们得选择器组合更加灵活，我们来看一些简单应用：</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/w3cbest/pen/JxYZWz/">:not() 伪类</a> by w3cbest.com (<a target="_blank" rel="noopener" href="https://codepen.io/w3cbest">@w3cbest</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>上例中，.content :not(.notice) em 匹配了 .content 中所有的 em 元素，但是排除了 .content .notice 中 em 元素。 我们再来看看 :not() 和其他伪类选择器结合的例子：</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/feiwen8772/pen/kkELxa/">:not伪类</a> by feiwen8772 (<a target="_blank" rel="noopener" href="https://codepen.io/feiwen8772">@feiwen8772</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>在做一个有间隔线的列表时，我们通常会去除最后一个 li 下的横线。li:not(:last-child) 表示除了最后一个 li 元素之外的所有其他 li 元素。</p>
<h2 id="内容选择器"><a href="#内容选择器" class="headerlink" title="内容选择器"></a>内容选择器</h2><p>这些属于用于匹配内容的一组专用选择器。我们可以立即使用的是：</p>
<ul>
<li>  ::first-line</li>
<li>  ::first-letter</li>
<li>  ::selection</li>
</ul>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/xjBBqN/">Content Selectors #1</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>::first-line 和 ::first-letter 仅在应用于块级元素时才起作用。另外要小心只在特定元素上使用 ::first-letter ，否则每个段落都可能会应用。 目前还没有一些令人兴奋的内容选择器，但是当它们得到支持时，它们将开启各种可能性。 以下是需要注意的内容选择器列表：</p>
<ul>
<li>  ::inactive-selection?—?非活动窗口内的选定内容</li>
<li>  ::spelling-error?—?检查可编辑元素的拼写和语法</li>
<li>  ::grammar-error?—?匹配语法错误</li>
<li>  ::marker?—?匹配列表项标记</li>
<li>  ::placeholder?—?匹配表单元素的 placeholder 文本样式；</li>
</ul>
<h2 id="其他选择器"><a href="#其他选择器" class="headerlink" title="其他选择器"></a>其他选择器</h2><p>我们接下来提到其他几个选择器不适合不适合归类到上面任何类别。 别担心我们差不多完成了！ 不幸的是，其中大部分是实验性的，所以你必须等待一段时间才能在生产中使用它们。 :target 选择器的目标是一个 id 与当前 URL 的一部分匹配的元素。 比如下面 URL 匹配该URL页面中 id 为 part1 的元素：</p>
<p><a target="_blank" rel="noopener" href="https://www.w3cbest.com/#part1">https://www.w3cbest.com#part1</a></p>
<p>我们可以将该元素应用以下样式：</p>
<p>:target { border: 1px red solid; }</p>
<p>其实 :target 选择器目前可以用于一些特殊的用例，欢迎查看： :target 伪类使用技巧 如果你有一个很大的选择器，那么 :matches() 可以帮助简化它。例如，如果您有以下选择器：</p>
<p>nav p.content,<br>header p.content,<br>main p.content,<br>sidebar p.content,<br>footer p.content {<br>margin: 15px;<br>padding: 10px;<br>}</p>
<p>然后可以通过 :matches() 简化，相当于： 太好了！这将有助于使样式表更具可读性。 接下来我们还有一个 :any-link 选择器，这个选择器是:link 和 :visited 组合的简写。 所以下面这两个选择器实际上是相同的：</p>
<p>:any-link {<br>color: red;<br>}</p>
<p>:link, :visited {<br>color: red;<br>}</p>
<p>本文中最后两个选择器：</p>
<ul>
<li>  :dir()</li>
<li>  :lang()</li>
</ul>
<p>这些都与您网站的语言有关。 :dir() 接受参数 ltr 或 rtl ，具体取决于您要匹配的文本的方向，目前仅 Firefox 支持。 所以：:dir(rtl) 会匹配所有具有 RTL 方向内容的元素。 HTML文档中的每个元素都可以使用 lang 属性设置自己的单独语言。</p>
<div lang="en">The language of this element is set to English.</div>
<div lang="el">Η γλ?σσα αυτο? του στοιχε?ου ?χει οριστε? στα ελληνικ?.</div>
<div lang="is">Tungumál ?essa ?áttar er sett á íslensku.</div>

<p>将相同的基本文本输入到三个 <div> 标记中，但将特定国家/地区添加到内容的末尾。此外，lang 属性中使用的国家代码代表相应的国家/地区。</p>
<ul>
<li>  :lang(en) { color: red; }</li>
<li>  :lang(el) { color: green; }</li>
<li>  :lang(is) { color: blue; }</li>
</ul>
<p>演示：</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/dgwyer/pen/xjBoNG/">Misc Selectors</a> by David Gwyer (<a target="_blank" rel="noopener" href="https://codepen.io/dgwyer">@dgwyer</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>好消息是所有主流浏览器都支持 :lang() 选择器。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>如果你试图查找一个选择器，或者需要深入研究CSS规范，那么你可能需要查看一些有用的资源：</p>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/">MDN Web Docs</a></li>
<li>  <a target="_blank" rel="noopener" href="https://www.w3.org/Style/CSS/specs.en.html">CSS Specifications</a></li>
<li>  <a target="_blank" rel="noopener" href="https://caniuse.com/">Can I Use</a></li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我希望你会发现这篇文章很有用。 可以帮助刷新你的CSS选择器技能，并尝试各种可能性。 使用纯 CSS 可以做很多很酷的事情，这在几年前是不可能实现的。 对于能够在纯 CSS 中进行一些非常高级的样式和动画的设计师来说，这是令人兴奋的，并且所有人都看不到一行 JavaScript 。 文章来源 <a target="_blank" rel="noopener" href="https://blog.logrocket.com/level-up-your-css-selector-skills-5d7bb45ddd37">https://blog.logrocket.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/22/css-grid-%E5%B8%83%E5%B1%80%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/22/css-grid-%E5%B8%83%E5%B1%80%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">CSS Grid 布局完全指南教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-22 11:21:34" itemprop="dateCreated datePublished" datetime="2018-09-22T11:21:34+08:00">2018-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 10:43:26" itemprop="dateModified" datetime="2021-08-30T10:43:26+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CSS Grid 布局是 CSS 中最强大的布局系统。与 <a target="_blank" rel="noopener" href="http://www.w3cbest.com/490.html">flexbox</a> 的一维布局系统不同，CSS Grid 布局是一个二维布局系统，也就意味着它可以同时处理列和行。通过将 CSS 规则应用于 父元素 (成为 Grid Container 网格容器)和其 子元素（成为 Grid Items 网格项），你就可以轻松使用 Grid(网格) 布局。 这篇文章最初是从<a target="_blank" rel="noopener" href="http://chris.house/blog/a-complete-guide-css-grid-layout/">Chris House</a>的指南中移植过来的，并且一直由CSS-Tricks工作人员和付费作家保持最新。 CSS网格布局(又称“网格”)，是一个二维的基于网格的布局系统，旨在完全改变我们设计基于网格的用户界面的方式。CSS一直被用来布局我们的网页，但它从来没有做得很好。一开始我们用表格（table），然后是浮动（float），再是定位（postion）和内嵌块（inline-block），但是所有这些方法本质上都是一些技巧，忽略了许多重要的功能(例如，垂直居中)。Flexbox 的出现很大程度上改善了我们的布局方式，但它的目的是为了解决更简单的一维布局，而不是复杂的二维布局(Flexbox和Grid实际上配合得很好)。Grid是第一个专门为解决布局问题而创建的CSS模块，自从我们创建网站以来，我们一直在努力解决布局问题。 有两个主要因素激发了我创建本指南的灵感。第一个是 Rachel Andrew 出色的书籍 为 <a target="_blank" rel="noopener" href="http://abookapart.com/products/get-ready-for-css-grid-layout">CSS Grid</a> 布局做好准备。这本书对 Grid 布局做了全面，清晰的介绍 ，也是本指南的基础。我强烈建议你购买并阅读。另一个灵感来自 Chris Coyier 的 <a target="_blank" rel="noopener" href="http://www.w3cbest.com/490.html">Flexbox 布局完整指南</a>，这也是我学习 flexbox 首选的资源。这篇文章是帮助了很多人，这点从 Google “flexbox” 排名第一就可以看出来。你会发现那篇文章和我的文章有很多相似之处，为什么不跟随最好的文章呢？ 本指南的目的是介绍存在于最新版本的规范中 Grid(网格) 概念。所以我不会覆盖过时的 IE 语法，而且随着规范的逐渐成熟，我会尽我最大的努力去更新这个指南。</p>
<h2 id="基础知识和浏览器支持"><a href="#基础知识和浏览器支持" class="headerlink" title="基础知识和浏览器支持"></a>基础知识和浏览器支持</h2><p>首先，你必须使用 display: grid 将容器元素定义为一个 grid(网格) 布局，使用 grid-template-columns 和 grid-template-rows 设置 列 和 行 的尺寸大小，然后通过 grid-column 和 grid-row 将其子元素放入这个 grid(网格) 中。与 flexbox 类似，网格项（grid items）的源(HTML结构)顺序无关紧要。你的 CSS 可以以任何顺序放置它们，这使得使用 媒体查询（media queries）重新排列网格变得非常容易。定义整个页面的布局，然后完全重新排列布局以适应不同的屏幕宽度，这些都只需要几行 CSS ，想象一下就让人兴奋。Grid(网格) 布局是有史以来最强大的 CSS 模块之一。 截至2017年3月，许多浏览器都提供了对 CSS Grid 的原生支持，而且无需加浏览器前缀：Chrome（包括 Android ），Firefox，Edge，Safari（包括iOS）和 Opera 。 另一方面，Internet Explorer 10和11支持它，但是是一个过时的语法实现。 现在是时候使用 Grid 布局网页了！ 这个浏览器支持数据来自Caniuse，它有更多细节。数字表示浏览器支持该版本及以上版本的功能。</p>
<p>复制代码</p>
<h2 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h2><p>在深入了解 Grid 的概念之前，理解术语是很重要的。由于这里涉及的术语在概念上都很相似，如果不先记住 Grid 规范定义的含义，很容易混淆它们。但是别担心，术语并不多。</p>
<h3 id="网格容器-Grid-Container"><a href="#网格容器-Grid-Container" class="headerlink" title="网格容器(Grid Container)"></a>网格容器(Grid Container)</h3><p>应用 display: grid 的元素。这是所有 网格项（grid item）的直接父级元素。在这个例子中，container 就是 网格容器(Grid Container)。</p>
<div class="container">
  <div class="item item-1"></div>
  <div class="item item-2"></div>
  <div class="item item-3"></div>
</div>

<h3 id="网格项-Grid-Item"><a href="#网格项-Grid-Item" class="headerlink" title="网格项(Grid Item)"></a>网格项(Grid Item)</h3><p>网格容器（Grid Container）的子元素（例如直接子元素）。这里 item 元素就是网格项(Grid Item)，但是 sub-item 不是。</p>
<div class="container">
  <div class="item"></div> 
  <div class="item">
    <p class="sub-item"></p>
  </div>
  <div class="item"></div>
</div>

<h3 id="网格线-Grid-Line"><a href="#网格线-Grid-Line" class="headerlink" title="网格线(Grid Line)"></a>网格线(Grid Line)</h3><p>构成网格结构的分界线。它们既可以是垂直的（“列网格线(column grid lines)”），也可以是水平的（“行网格线(row grid lines)”），并位于行或列的任一侧。例如，这里的黄线就是一条列网格线。 <img data-src="http://file.w3cbest.com/file/images/terms-grid-line.svg"></p>
<h3 id="网格轨道-Grid-Track"><a href="#网格轨道-Grid-Track" class="headerlink" title="网格轨道(Grid Track)"></a>网格轨道(Grid Track)</h3><p>两条相邻网格线之间的空间。你可以把它们想象成网格的列或行。下图是第二条和第三条 行网格线 之间的 网格轨道(Grid Track)。 <img data-src="http://file.w3cbest.com/file/images/terms-grid-track.svg"></p>
<h3 id="网格单元格-Grid-Cell"><a href="#网格单元格-Grid-Cell" class="headerlink" title="网格单元格(Grid Cell)"></a>网格单元格(Grid Cell)</h3><p>两个相邻的行和两个相邻的列网格线之间的空间。这是 Grid(网格) 系统的一个“单元”。下图是第 1 至第 2 条 行网格线 和第 2 至第 3 条 列网格线 交汇构成的 网格单元格(Grid Cell)。 <img data-src="http://file.w3cbest.com/file/images/terms-grid-cell.svg"></p>
<h3 id="网格区域-Grid-Area"><a href="#网格区域-Grid-Area" class="headerlink" title="网格区域(Grid Area)"></a>网格区域(Grid Area)</h3><p>4条网格线包围的总空间。一个 网格区域(Grid Area) 可以由任意数量的 网格单元格(Grid Cell) 组成。下图是 行网格线1和3，以及列网格线1和3 之间的网格区域。 <img data-src="http://file.w3cbest.com/file/images/terms-grid-area.svg"></p>
<h3 id="Grid-网格-属性目录"><a href="#Grid-网格-属性目录" class="headerlink" title="Grid(网格) 属性目录"></a>Grid(网格) 属性目录</h3><p>网格容器(Grid Container) 属性</p>
<p>格项(Grid Items) 属性</p>
<p><a href="#prop-display">display</a></p>
<p><a href="#prop-grid-column-row-start-end">grid-column-start</a></p>
<p><a href="#prop-grid-template-columns-rows">grid-template-columns</a></p>
<p><a href="#prop-grid-column-row-start-end">grid-column-end</a></p>
<p><a href="#prop-grid-template-columns-rows">grid-template-rows</a></p>
<p><a href="#prop-grid-column-row-start-end">grid-row-start</a></p>
<p><a href="#prop-grid-template-areas">grid-template-areas</a></p>
<p><a href="#prop-grid-column-row-start-end">grid-row-end</a></p>
<p><a href="#prop-grid-template">grid-template</a></p>
<p><a href="#prop-grid-column-row">grid-column</a></p>
<p><a href="#prop-grid-column-row-gap">grid-column-gap</a></p>
<p><a href="#prop-grid-column-row">grid-row</a></p>
<p><a href="#prop-grid-column-row-gap">grid-row-gap</a></p>
<p><a href="#prop-grid-area">grid-area</a></p>
<p><a href="#prop-justify-items">justify-items</a></p>
<p><a href="#prop-justify-self">justify-self</a></p>
<p><a href="#prop-justify-items">justify-items</a></p>
<p><a href="#prop-align-self">align-self</a></p>
<p><a href="#prop-justify-items">justify-items</a></p>
<p><a href="#prop-place-self">place-self</a></p>
<p><a href="#prop-align-items">align-items</a></p>
<p><a href="#prop-place-items">place-items</a></p>
<p><a href="#prop-justify-content">justify-content</a></p>
<p><a href="#prop-align-content">align-content</a></p>
<p><a href="#prop-place-content">place-content</a></p>
<p><a href="#prop-grid-auto-columns-rows">grid-auto-columns</a></p>
<p><a href="#prop-grid-auto-columns-rows">grid-auto-rows</a></p>
<p><a href="#prop-grid-auto-flow">grid-auto-flow</a></p>
<p><a href="#prop-grid">grid</a></p>
<h3 id="父元素-网格容器-Grid-Container-属性"><a href="#父元素-网格容器-Grid-Container-属性" class="headerlink" title="父元素 网格容器(Grid Container) 属性"></a>父元素 网格容器(Grid Container) 属性</h3><p> </p>
<h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>将元素定义为网格容器，并为其内容建立新的 网格格式上下文。 值：</p>
<ul>
<li>  <strong>grid</strong> ：生成一个块级网格</li>
<li>  <strong>inline-grid</strong> ：生成一个内联网格</li>
</ul>
<p>.container {<br>  display: grid  inline-grid;<br>}</p>
<p>注意：通过嵌套元素（也称为子网格，即 subgrid ）向下传递网格参数的能力已移至<a target="_blank" rel="noopener" href="https://www.w3.org/TR/css-grid-2/#subgrids">CSS Grid 规范的Level 2</a> 版本。这里有<a target="_blank" rel="noopener" href="https://css-tricks.com/grid-level-2-and-subgrid/">一个快速解释</a>。</p>
<h3 id="grid-template-columns-grid-template-rows"><a href="#grid-template-columns-grid-template-rows" class="headerlink" title="grid-template-columns/grid-template-rows"></a>grid-template-columns/grid-template-rows</h3><p>使用空格分隔的值列表，用来定义网格的列和行。这些值表示 网格轨道(Grid Track) 大小，它们之间的空格表示网格线。 值：</p>
<ul>
<li>  <track-size>： 可以是长度值，百分比，或者等份网格容器中可用空间（使用 fr 单位）</li>
<li>  <line-name>：你可以选择的任意名称</li>
</ul>
<p>.container {<br>  grid-template-columns: <track-size> …  <line-name> <track-size> …;<br>  grid-template-rows: <track-size> …  <line-name> <track-size> …;<br>}</p>
<p>例子： 当你在 网格轨道(Grid Track) 值之间留出空格时，网格线会自动分配正数和负数名称：</p>
<p>.container {<br>  grid-template-columns: 40px 50px auto 50px 40px;<br>  grid-template-rows: 25% 100px auto;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/template-columns-rows-01.svg"> 但是你可以明确的指定网格线(Grid Line)名称，例如 <line-name> 值。请注意网格线名称的括号语法：</p>
<p>.container {<br>  grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];<br>  grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/template-column-rows-02.svg"> 请注意，一条网格线(Grid Line)可以有多个名称。例如，这里的第二条 行网格线(row grid lines) 将有两个名字：row1-end 和 row2-start ：</p>
<p>.container {<br>  grid-template-rows: [row1-start] 25% [row1-end row2-start] 25% [row2-end];<br>}</p>
<p>如果你的定义包含多个重复值，则可以使用 repeat() 表示法来简化定义：</p>
<p>.container {<br>  grid-template-columns: repeat(3, 20px [col-start]);<br>}</p>
<p>上面的代码等价于：</p>
<p>.container {<br>  grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start];<br>}</p>
<p>如果多行共享相同的名称，则可以通过其网格线名称和计数来引用它们。</p>
<p>.item {<br>  grid-column-start: col-start 2;<br>}</p>
<p>fr 单元允许你用等分网格容器剩余可用空间来设置 网格轨道(Grid Track) 的大小 。例如，下面的代码会将每个网格项设置为网格容器宽度的三分之一：</p>
<p>.container {<br>  grid-template-columns: 1fr 1fr 1fr;<br>}</p>
<p>剩余可用空间是除去所有非灵活网格项 之后 计算得到的。在这个例子中，可用空间总量减去 50px 后，再给 fr 单元的值 3 等分：</p>
<p>.container {<br>  grid-template-columns: 1fr 50px 1fr 1fr;<br>}</p>
<h3 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h3><p>通过引用 grid-area 属性指定的 网格区域(Grid Area) 名称来定义网格模板。重复网格区域的名称导致内容跨越这些单元格。一个点号（.）代表一个空单元格。这个语法本身可视作网格的可视化结构。 值：</p>
<ul>
<li>  <grid-area-name>：由网格项的 grid-area 指定的网格区域名称</li>
<li>  .（点号） ：代表一个空的网格单元</li>
<li>  none：不定义网格区域</li>
</ul>
<p>.container {<br>  grid-template-areas:<br>    “<grid-area-name>  .  none  …”<br>    “…”;<br>}</p>
<p>示例：</p>
<p>.item-a {<br>  grid-area: header;<br>}<br>.item-b {<br>  grid-area: main;<br>}<br>.item-c {<br>  grid-area: sidebar;<br>}<br>.item-d {<br>  grid-area: footer;<br>}</p>
<p>.container {<br>  grid-template-columns: 50px 50px 50px 50px;<br>  grid-template-rows: auto;<br>  grid-template-areas:<br>    “header header header header”<br>    “main main . sidebar”<br>    “footer footer footer footer”;<br>}</p>
<p>上面的代码将创建一个 4 列宽 3 行高的网格。整个顶行将由 header 区域组成。中间一排将由两个 main 区域，一个是空单元格，一个 sidebar 区域组成。最后一行全是 footer 区域组成。 <img data-src="http://file.w3cbest.com/file/images/dddgrid-template-areas.svg"> 你的声明中的每一行都需要有相同数量的单元格。 你可以使用任意数量的相邻的 点. 来声明单个空单元格。 只要这些点.之间没有空隙隔开，他们就代表一个单独的单元格。 注意你 不能 用这个语法来命名网格线，只是命名 网格区域 。当你使用这种语法时，区域两端的网格线实际上会自动命名。如果你的网格区域的名字是 foo，该区域的起始行网格线 和 起始列网格线 的名称将为 foo-start，而最后一条行网格线 和 最后一条列网格线 的名称将为 foo-end。这意味着某些网格线可能有多个名字，如上例中最左边的网格线，它将有三个名称：header-start，main-start 和 footer-start 。 </p>
<h3 id="grid-template"><a href="#grid-template" class="headerlink" title="grid-template"></a>grid-template</h3><p>用于定义grid-template-rows ，grid-template-columns ，grid-template-areas 简写属性。 值：</p>
<ul>
<li>  none：将所有三个属性设置为其初始值</li>
<li>  <grid-template-rows> / <grid-template-columns>：将 grid-template-columns 和 grid-template-rows 设置为相应地特定的值，并且设置grid-template-areas为none</li>
</ul>
<p>.container {<br>  grid-template: none  <grid-template-rows> / <grid-template-columns>;<br>}</p>
<p>这个属性也接受一个更复杂但非常方便的语法来指定三个上诉属性。这里有一个例子：</p>
<p>.container {<br>  grid-template:<br>    [row1-start] “header header header” 25px [row1-end]<br>    [row2-start] “footer footer footer” 25px [row2-end]<br>    / auto 50px auto;<br>}</p>
<p>等价于：</p>
<p>.container {<br>  grid-template-rows: [row1-start] 25px [row1-end row2-start] 25px [row2-end];<br>  grid-template-columns: auto 50px auto;<br>  grid-template-areas:<br>    “header header header”<br>    “footer footer footer”;<br>}</p>
<p>由于 grid-template 不会重置 隐式 网格属性（grid-auto-columns， grid-auto-rows， 和 grid-auto-flow），这可能是你想在大多数情况下做的，建议使用 grid 属性而不是 grid-template。</p>
<h3 id="grid-column-gap-grid-row-gap"><a href="#grid-column-gap-grid-row-gap" class="headerlink" title="grid-column-gap / grid-row-gap"></a>grid-column-gap / grid-row-gap</h3><p>指定网格线(grid lines)的大小。你可以把它想象为设置列/行之间间距的宽度。 值：</p>
<ul>
<li>  <line-size> ：长度值</li>
</ul>
<p>.container {<br>  grid-column-gap: <line-size>;<br>  grid-row-gap: <line-size>;<br>}</p>
<p>示例：</p>
<p>.container {<br>  grid-template-columns: 100px 50px 100px;<br>  grid-template-rows: 80px auto 80px;<br>  grid-column-gap: 10px;<br>  grid-row-gap: 15px;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/dddgrid-gap.svg"> 只能在 列/行 之间创建间距，网格外部边缘不会有这个间距。 注意：这两个属性将删除 grid- 前缀，就是将 grid-column-gap 和 grid-row-gap重命名为 column-gap 和 row-gap。 Chrome 68+，Safari 11.2 Release 50+ 和Opera 54+ 已经支持无前缀的属性。  </p>
<h3 id="grid-gap"><a href="#grid-gap" class="headerlink" title="grid-gap"></a>grid-gap</h3><p>grid-column-gap 和 grid-row-gap 的简写语法 值：</p>
<ul>
<li>  <grid-row-gap> <grid-column-gap>：长度值</li>
</ul>
<p>.container {<br>  grid-gap: <grid-row-gap> <grid-column-gap>;<br>}</p>
<p>示例：</p>
<p>.container {<br>  grid-template-columns: 100px 50px 100px;<br>  grid-template-rows: 80px auto 80px;<br>  grid-gap: 15px 10px;<br>}</p>
<p>如果grid-row-gap没有定义，那么就会被设置为等同于 grid-column-gap 的值。例如下面的代码是等价的：</p>
<p>.container{<br>  /* 设置 grid-column-gap 和 grid-row-gap */<br>  grid-column-gap: 10px;<br>  grid-row-gap: 10px; </p>
<p>  /* 等价于 */<br>  grid-gap: 10px 10px;</p>
<p>  /* 等价于 */<br>  grid-gap: 10px;<br>}</p>
<p>注意：这个属性将删除 grid- 前缀，就是将 grid-gap 重命名为 gap。 Chrome 68+，Safari 11.2 Release 50+ 和Opera 54+ 已经支持无前缀的属性。</p>
<h3 id="justify-items"><a href="#justify-items" class="headerlink" title="justify-items"></a>justify-items</h3><p>沿着 inline（行）轴线对齐网格项(grid items)（相反的属性是 align-items 沿着 block（列）轴线对齐）。此值适用于容器内的所有网格项。 值：</p>
<ul>
<li>  start：将网格项对齐到其单元格的左侧起始边缘（左侧对齐）</li>
<li>  end：将网格项对齐到其单元格的右侧结束边缘（右侧对齐）</li>
<li>  center：将网格项对齐到其单元格的水平中间位置（水平居中对齐）</li>
<li>  stretch：填满单元格的宽度（默认值）</li>
</ul>
<p>.container {<br>  justify-items: start  end  center  stretch;<br>}</p>
<p>示例：</p>
<p>.container {<br>  justify-items: start;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-items-start.svg"></p>
<p>.container{<br>  justify-items: end;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-items-end.svg"></p>
<p>.container{<br>  justify-items: center;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-items-center.svg"></p>
<p>.container{<br>  justify-items: stretch;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-items-stretch.svg"> 这些行为也可以通过每个单独网格项(grid items) 的 justify-self 属性设置。 </p>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>沿着 block（列）轴线对齐网格项(grid items)（相反的属性是 justify-items 沿着 inline（行）轴线对齐）。此值适用于容器内的所有网格项。 值：</p>
<ul>
<li>  start：将网格项对齐到其单元格的顶部起始边缘（顶部对齐）</li>
<li>  end：将网格项对齐到其单元格的底部结束边缘（底部对齐）</li>
<li>  center：将网格项对齐到其单元格的垂直中间位置（垂直居中对齐）</li>
<li>  stretch：填满单元格的高度（默认值）</li>
</ul>
<p>.container {<br>  align-items: start  end  center  stretch;<br>}</p>
<p>示例：</p>
<p>.container {<br>  align-items: start;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-items-start.svg"></p>
<p>.container {<br>  align-items: end;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-items-end.svg"></p>
<p>.container {<br>  align-items: center;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-items-center.svg"></p>
<p>.container {<br>  align-items: stretch;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-items-stretch.svg"> 这些行为也可以通过每个单独网格项(grid items) 的 align-self 属性设置。 </p>
<h3 id="place-items"><a href="#place-items" class="headerlink" title="place-items"></a>place-items</h3><p>place-items 是设置 align-items 和 justify-items 的简写形式。 值：</p>
<ul>
<li>  <align-items> <justify-items>：第一个值设置 align-items 属性，第二个值设置 justify-items 属性。如果省略第二个值，则将第一个值同时分配给这两个属性。</li>
</ul>
<p>除 Edge 之外的所有主要浏览器都支持 place-items 简写属性。 有关更多详细信息，请参阅<a href="#prop-align-items">align-items</a> 和 <a href="#prop-justify-items">justify-items</a>。  </p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>有时，你的网格合计大小可能小于其 网格容器(grid container) 大小。 如果你的所有 网格项(grid items) 都使用像 px 这样的非灵活单位设置大小，就可能出现这种情况。在这种情况下，您可以设置网格容器内的网格的对齐方式。 此属性沿着 inline（行）轴线对齐网格（相反的属性是 align-content ，沿着 block（列）轴线对齐网格）。 值：</p>
<ul>
<li>  start：将网格对齐到 网格容器(grid container) 的左侧起始边缘（左侧对齐）</li>
<li>  end：将网格对齐到 网格容器 的右侧结束边缘（右侧对齐）</li>
<li>  center：将网格对齐到 网格容器 的水平中间位置（水平居中对齐）</li>
<li>  stretch：调整 网格项(grid items) 的宽度，允许该网格填充满整个 网格容器 的宽度</li>
<li>  space-around：在每个网格项之间放置一个均匀的空间，左右两端放置一半的空间</li>
<li>  space-between：在每个网格项之间放置一个均匀的空间，左右两端没有空间</li>
<li>  space-evenly：在每个网格项目之间放置一个均匀的空间，左右两端放置一个均匀的空间</li>
</ul>
<p>.container {<br>  justify-content: start  end  center  stretch  space-around  space-between  space-evenly;<br>}</p>
<p>示例：</p>
<p>.container {<br>  justify-content: start;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-content-start.svg"></p>
<p>.container {<br>  justify-content: end;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-content-end.svg"></p>
<p>.container {<br>  justify-content: center;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-content-center.svg"></p>
<p>.container {<br>  justify-content: stretch;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-content-stretch.svg"></p>
<p>.container {<br>  justify-content: space-around;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-content-space-around.svg"></p>
<p>.container {<br>  justify-content: space-between;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-content-space-between.svg"></p>
<p>.container {<br>  justify-content: space-evenly;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-content-space-evenly.svg"> </p>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>有时，你的网格合计大小可能小于其 网格容器(grid container) 大小。 如果你的所有 网格项(grid items) 都使用像 px 这样的非灵活单位设置大小，就可能出现这种情况。在这种情况下，您可以设置网格容器内的网格的对齐方式。 此属性沿着 block（列）轴线对齐网格（相反的属性是 justify-content ，沿着 inline（行）轴线对齐网格）。 值：</p>
<ul>
<li>  start：将网格对齐到 网格容器(grid container) 的顶部起始边缘（顶部对齐）</li>
<li>  end：将网格对齐到 网格容器 的底部结束边缘（底部对齐）</li>
<li>  center：将网格对齐到 网格容器 的垂直中间位置（垂直居中对齐）</li>
<li>  stretch：调整 网格项(grid items) 的高度，允许该网格填充满整个 网格容器 的高度</li>
<li>  space-around：在每个网格项之间放置一个均匀的空间，上下两端放置一半的空间</li>
<li>  space-between：在每个网格项之间放置一个均匀的空间，上下两端没有空间</li>
<li>  space-evenly：在每个网格项目之间放置一个均匀的空间，上下两端放置一个均匀的空间</li>
</ul>
<p>.container {<br>  align-content: start  end  center  stretch  space-around  space-between  space-evenly;<br>}</p>
<p>示例：</p>
<p>.container {<br>  align-content: start;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-content-start.svg"></p>
<p>.container {<br>  align-content: end;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-content-end.svg"></p>
<p>.container {<br>  align-content: center;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-content-center.svg"></p>
<p>.container {<br>  align-content: stretch;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-content-stretch.svg"></p>
<p>.container {<br>  align-content: space-around;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-content-space-around.svg"></p>
<p>.container {<br>  align-content: space-between;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-content-space-between.svg"></p>
<p>.container {<br>align-content: space-evenly;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-content-space-evenly.svg"> </p>
<h2 id="place-content"><a href="#place-content" class="headerlink" title="place-content"></a>place-content</h2><p>place-content 是设置 align-content 和 justify-content 的简写形式。 值：</p>
<ul>
<li>  <align-content> <justify-content>：第一个值设置 align-content 属性，第二个值设置 justify-content 属性。如果省略第二个值，则将第一个值同时分配给这两个属性。</li>
</ul>
<p>除 Edge 之外的所有主要浏览器都支持 place-content 简写属性。 有关更多详细信息，请参阅align-content 和 justify-content。</p>
<h3 id="grid-auto-columns-grid-auto-rows"><a href="#grid-auto-columns-grid-auto-rows" class="headerlink" title="grid-auto-columns / grid-auto-rows"></a>grid-auto-columns / grid-auto-rows</h3><p>指定任何自动生成的网格轨道(grid tracks)（又名隐式网格轨道）的大小。当网格中的网格项多于单元格时，或者当网格项位于显式网格之外时，就会创建隐式轨道。（<a target="_blank" rel="noopener" href="http://www.w3cbest.com/504.html">参见显式网格和隐式网格之间的区别</a>） 值：</p>
<ul>
<li>  <track-size>：可以是长度值，百分比，或者等份网格容器中可用空间的分数（使用 fr 单位）</li>
</ul>
<p>.container {<br>  grid-auto-columns: <track-size> …;<br>  grid-auto-rows: <track-size> …;<br>}</p>
<p>为了说明如何创建隐式网格轨道，请考虑一下以下的代码：</p>
<p>.container {<br>  grid-template-columns: 60px 60px;<br>  grid-template-rows: 90px 90px<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/grid-auto-columns-rows-01.svg"> 这将生成了一个 2×2 的网格。 但现在想象一下，你使用 grid-column 和 grid-row 来定位你的网格项，像这样：</p>
<p>.item-a {<br>  grid-column: 1 / 2;<br>  grid-row: 2 / 3;<br>}<br>.item-b {<br>  grid-column: 5 / 6;<br>  grid-row: 2 / 3;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/grid-auto-columns-rows-02.svg"> 我们告诉 .item-b 从第 5 条列网格线开始到第 6 条列网格线结束，但我们从来没有定义过 第5 或 第6 列网格线。 因为我们引用的网格线不存在，所以创建宽度为 0 的隐式网格轨道以填补空缺。我们可以使用 grid-auto-columns 和 grid-auto-rows 来指定这些隐式轨道的大小：</p>
<p>.container {<br>  grid-auto-columns: 60px;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/grid-auto-columns-rows-03.svg">  </p>
<h3 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h3><p>如果你有一些没有明确放置在网格上的网格项(grid items)，自动放置算法 会自动放置这些网格项。该属性控制自动布局算法如何工作。 值：</p>
<ul>
<li>  row：告诉自动布局算法依次填充每行，根据需要添加新行 （默认）</li>
<li>  column：告诉自动布局算法依次填入每列，根据需要添加新列</li>
<li>  dense：告诉自动布局算法在稍后出现较小的网格项时，尝试填充网格中较早的空缺</li>
</ul>
<p>.container {<br>  grid-auto-flow: row  column  row dense  column dense<br>}</p>
<p>请注意，dense 只会更改网格项的可视顺序，并可能导致它们出现乱序，这对可访问性不利。 示例： 考虑以下 HTML :</p>
<section class="container">
  <div class="item-a">item-a</div>
  <div class="item-b">item-b</div>
  <div class="item-c">item-c</div>
  <div class="item-d">item-d</div>
  <div class="item-e">item-e</div>
</section>

<p>你定义一个有 5 列和 2 行的网格，并将 grid-auto-flow 设置为 row（也就是默认值）：</p>
<p>.container {<br>  display: grid;<br>  grid-template-columns: 60px 60px 60px 60px 60px;<br>  grid-template-rows: 30px 30px;<br>  grid-auto-flow: row;<br>}</p>
<p>将网格项放在网格上时，只能为其中的两个指定位置：</p>
<p>.item-a {<br>  grid-column: 1;<br>  grid-row: 1 / 3;<br>}<br>.item-e {<br>  grid-column: 5;<br>  grid-row: 1 / 3;<br>}</p>
<p>因为我们把 grid-auto-flow 设成了 row ，所以我们的网格看起来会是这样。注意 我们没有进行定位的网格项（item-b，item-c，item-d）会这样排列在可用的行中： <img data-src="http://file.w3cbest.com/file/images/grid-auto-flow-01.svg"> 相反地，如果我们把 grid-auto-flow 设成了 column ，那么 item-b，item-c，item-d 会沿着列向下排列：</p>
<p>.container {<br>  display: grid;<br>  grid-template-columns: 60px 60px 60px 60px 60px;<br>  grid-template-rows: 30px 30px;<br>  grid-auto-flow: column;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/grid-auto-flow-02.svg"> </p>
<h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><p>在一个声明中设置所有以下属性的简写： grid-template-rows, grid-template-columns, grid-template-areas, grid-auto-rows, grid-auto-columns, 和 grid-auto-flow 。（注意：您只能在单个网格声明中指定显式或隐式网格属性）。 值：</p>
<ul>
<li>  none：将所有子属性设置为其初始值。</li>
<li>  <grid-template>：与grid-template 简写的工作方式相同。</li>
<li>  <grid-template-rows> / [ auto-flow &amp;&amp; dense? ] <grid-auto-columns>? ：将grid-template-rows 设置为指定的值。 如果 auto-flow 关键字位于斜杠的右侧，则会将 grid-auto-flow 设置为 column。 如果另外指定了 dense 关键字，则自动放置算法使用 “dense” 算法。 如果省略 grid-auto-columns ，则将其设置为 auto。</li>
<li>  [ auto-flow &amp;&amp; dense? ] <grid-auto-rows>? / <grid-template-columns>：将 grid-template-columns 设置为指定值。 如果 auto-flow 关键字位于斜杠的左侧，则会将grid-auto-flow 设置为 row 。 如果另外指定了 dense 关键字，则自动放置算法使用 “dense” 打包算法。 如果省略 grid-auto-rows ，则将其设置为 auto。</li>
</ul>
<p>例子： 以下两个代码块是等效的：</p>
<p>.container {<br>  grid: 100px 300px / 3fr 1fr;<br>}</p>
<p>.container {<br>  grid-template-rows: 100px 300px;<br>  grid-template-columns: 3fr 1fr;<br>}</p>
<p>以下两个代码块是等效的：</p>
<p>.container {<br>  grid: auto-flow / 200px 1fr;<br>}</p>
<p>.container {<br>  grid-auto-flow: row;<br>  grid-template-columns: 200px 1fr;<br>}</p>
<p>以下两个代码块是等效的：</p>
<p>.container {<br>  grid: auto-flow dense 100px / 1fr 2fr;<br>}</p>
<p>.container {<br>  grid-auto-flow: row dense;<br>  grid-auto-rows: 100px;<br>  grid-template-columns: 1fr 2fr;<br>}</p>
<p>以下两个代码块是等效的：</p>
<p>.container {<br>  grid: 100px 300px / auto-flow 200px;<br>}</p>
<p>.container {<br>  grid-template-rows: 100px 300px;<br>  grid-auto-flow: column;<br>  grid-auto-columns: 200px;<br>}</p>
<p>它也接受一个更复杂但相当方便的语法来一次设置所有内容。您可以指定 grid-template-areas，grid-template-rows和grid-template-columns，并所有其他的子属性都被设置为它们的初始值。这么做可以在它们网格区域内相应地指定网格线名字和网格轨道的大小。用最简单的例子来描述：</p>
<p>.container {<br>  grid: [row1-start] “header header header” 1fr [row1-end]<br>        [row2-start] “footer footer footer” 25px [row2-end]<br>        / auto 50px auto;<br>}</p>
<p>等价于：</p>
<p>.container {<br>  grid-template-areas:<br>    “header header header”<br>    “footer footer footer”;<br>  grid-template-rows: [row1-start] 1fr [row1-end row2-start] 25px [row2-end];<br>  grid-template-columns: auto 50px auto;<br>}</p>
<h3 id="子元素-网格项-Grid-Items-属性"><a href="#子元素-网格项-Grid-Items-属性" class="headerlink" title="子元素 网格项(Grid Items) 属性"></a>子元素 网格项(Grid Items) 属性</h3><p>注意：float，display: inline-block，display: table-cell，vertical-align 和 column-* 属性对网格项无效。</p>
<h3 id="grid-column-start-grid-column-end-grid-row-start-grid-row-end"><a href="#grid-column-start-grid-column-end-grid-row-start-grid-row-end" class="headerlink" title="grid-column-start / grid-column-end / grid-row-start / grid-row-end"></a>grid-column-start / grid-column-end / grid-row-start / grid-row-end</h3><p>通过引用特定网格线(grid lines) 来确定 网格项(grid item) 在网格内的位置。 grid-column-start / grid-row-start 是网格项开始的网格线，grid-column-end / grid-row-end 是网格项结束的网格线。 值：</p>
<ul>
<li>  <line> ：可以是一个数字引用一个编号的网格线，或者一个名字来引用一个命名的网格线</li>
<li>  span <number> ：该网格项将跨越所提供的网格轨道数量</li>
<li>  span <name> ：该网格项将跨越到它与提供的名称位置</li>
<li>  auto：表示自动放置，自动跨度，默认会扩展一个网格轨道的宽度或者高度</li>
</ul>
<p>.item {<br>  grid-column-start: <number>  <name>  span <number>  span <name>  auto<br>  grid-column-end: <number>  <name>  span <number>  span <name>  auto<br>  grid-row-start: <number>  <name>  span <number>  span <name>  auto<br>  grid-row-end: <number>  <name>  span <number>  span <name>  auto<br>}</p>
<p>示例：</p>
<p>.item-a {<br>  grid-column-start: 2;<br>  grid-column-end: five;<br>  grid-row-start: row1-start<br>  grid-row-end: 3;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/grid-column-row-start-end-01.svg"></p>
<p>.item-b {<br>  grid-column-start: 1;<br>  grid-column-end: span col4-start;<br>  grid-row-start: 2<br>  grid-row-end: span 2<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/grid-column-row-start-end-02.svg"> 如果没有声明指定 grid-column-end / grid-row-end，默认情况下，该网格项将占据 1 个轨道。 项目可以相互重叠。您可以使用 z-index 来控制它们的重叠顺序。  </p>
<h3 id="grid-column-grid-row"><a href="#grid-column-grid-row" class="headerlink" title="grid-column / grid-row"></a>grid-column / grid-row</h3><p>分别为 grid-column-start + grid-column-end 和 grid-row-start + grid-row-end 的简写形式。 值：</p>
<ul>
<li>  <start-line> / <end-line>：每个网格项都接受所有相同的值，作为普通书写的版本，包括跨度</li>
</ul>
<p>.item {<br>  grid-column: <start-line> / <end-line>  <start-line> / span <value>;<br>  grid-row: <start-line> / <end-line>  <start-line> / span <value>;<br>}</p>
<p>示例：</p>
<p>.item-c {<br>  grid-column: 3 / span 2;<br>  grid-row: third-line / 4;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/grid-column-row.svg"> 如果没有声明分隔线结束位置，则该网格项默认占据 1 个网格轨道。 </p>
<h3 id="grid-area"><a href="#grid-area" class="headerlink" title="grid-area"></a>grid-area</h3><p>为网格项提供一个名称，以便可以 被使用网格容器 grid-template-areas 属性创建的模板进行引用。 另外，这个属性可以用作grid-row-start + grid-column-start + grid-row-end + grid-column-end 的简写。 值：</p>
<ul>
<li>  <name>：你所选的名称</li>
<li>  <row-start> / <column-start> / <row-end> / <column-end>：数字或分隔线名称</li>
</ul>
<p>.item {<br>  grid-area: <name>  <row-start> / <column-start> / <row-end> / <column-end>;<br>}</p>
<p>示例： 作为为网格项分配名称的一种方法：</p>
<p>.item-d {<br>  grid-area: header<br>}</p>
<p>作为grid-row-start + grid-column-start + grid-row-end + grid-column-end 属性的简写形式</p>
<p>.item-d {<br>    grid-area: 1 / col4-start / last-line / 6<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/grid-area.svg"> </p>
<h3 id="justify-self"><a href="#justify-self" class="headerlink" title="justify-self"></a>justify-self</h3><p>沿着 inline（行）轴线对齐网格项（ 相反的属性是 align-self ，沿着 block（列）轴线对齐）。此值适用于单个网格项内的内容。 值：</p>
<ul>
<li>  start：将网格项对齐到其单元格的左侧起始边缘（左侧对齐）</li>
<li>  end：将网格项对齐到其单元格的右侧结束边缘（右侧对齐）</li>
<li>  center：将网格项对齐到其单元格的水平中间位置（水平居中对齐）</li>
<li>  stretch：填满单元格的宽度（默认值）</li>
</ul>
<p>.item {<br>  justify-self: start  end  center  stretch;<br>}</p>
<p>示例：</p>
<p>.item-a {<br>  justify-self: start;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-self-start.svg"></p>
<p>.item-a {<br>  justify-self: end;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-self-end.svg"></p>
<p>.item-a {<br>  justify-self: center;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-self-center.svg"></p>
<p>.item-a {<br>  justify-self: stretch;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/justify-self-stretch.svg"> 要为网格中的所有网格项设置 行轴线(row axis) 线上对齐方式，也可以在 网格容器 上设置 <a href="#prop-justify-items">justify-items</a> 属性。 </p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>沿着 block（列）轴线对齐网格项(grid items)（ 相反的属性是 justify-self ，沿着 inline（行）轴线对齐）。此值适用于单个网格项内的内容。 值：</p>
<ul>
<li>  start：将网格项对齐到其单元格的顶部起始边缘（顶部对齐）</li>
<li>  end：将网格项对齐到其单元格的底部结束边缘（底部对齐）</li>
<li>  center：将网格项对齐到其单元格的垂直中间位置（垂直居中对齐）</li>
<li>  stretch：填满单元格的高度（默认值）</li>
</ul>
<p>.item{<br>  align-self: start  end  center  stretch;<br>}</p>
<p>示例：</p>
<p>.item-a {<br>  align-self: start;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-self-start.svg"></p>
<p>.item-a {<br>  align-self: end;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-self-end.svg"></p>
<p>.item-a {<br>  align-self: center;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-self-center.svg"></p>
<p>.item-a {<br>  align-self: stretch;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/align-self-stretch.svg"> 要为网格中的所有网格项设置 列轴线(column axis) 上的对齐方式，也可以在 网格容器 上设置<a href="#prop-align-items">align-items</a>属性。  </p>
<h3 id="place-self"><a href="#place-self" class="headerlink" title="place-self"></a>place-self</h3><p>place-self 是设置 align-self 和 justify-self 的简写形式。 值：</p>
<ul>
<li>  auto – 布局模式的 “默认” 对齐方式。</li>
<li>  <align-self> <justify-self>：第一个值设置 align-self 属性，第二个值设置 justify-self 属性。如果省略第二个值，则将第一个值同时分配给这两个属性。</li>
</ul>
<p>示例：</p>
<p>.item-a {<br>  place-self: center;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/place-self-center.svg"></p>
<p>.item-a {<br>  place-self: center stretch;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/place-self-center-stretch.svg"> 除 Edge 之外的所有主要浏览器都支持 place-self 简写属性。</p>
<h2 id="动画（Animation）"><a href="#动画（Animation）" class="headerlink" title="动画（Animation）"></a>动画（Animation）</h2><p>根据 CSS Grid 布局模块 Level 1 规范，有 5 个可应用动画的网格属性：</p>
<ul>
<li>  grid-gap， grid-row-gap，grid-column-gap 作为长度，百分比或 calc。</li>
<li>  grid-template-columns，grid-template-rows 作为长度，百分比或 calc 的简单列表，只要列表中长度、百分比或calc组件的值不同即可。</li>
</ul>
<h3 id="浏览器支持CSS网格属性"><a href="#浏览器支持CSS网格属性" class="headerlink" title="浏览器支持CSS网格属性"></a>浏览器支持CSS网格属性</h3><p>截至今天（2018年5月7日），在测试的几个浏览器中仅实现 (grid-)gap，(grid-)row-gap，(grid-)column-gap 的动画。 浏览器支持可设置动画的网格属性：</p>
<p>Browser</p>
<p><code>(grid-)gap</code>, <code>(grid-)row-gap</code>, <code>(grid-)column-gap</code></p>
<p><code>grid-template-columns</code></p>
<p><code>grid-template-rows</code></p>
<p>Firefox</p>
<p>supported ✅ 53+</p>
<p>supported ✅ 66+</p>
<p>supported ✅ 66+</p>
<p>Safari 12.0</p>
<p>not supported ❌</p>
<p>not supported ❌</p>
<p>not supported ❌</p>
<p>Chrome</p>
<p>supported ✅ 66+</p>
<p>not supported ❌</p>
<p>not supported ❌</p>
<p>Chrome for Android 66+, Opera Mini 33+</p>
<p>supported ✅</p>
<p>not supported ❌</p>
<p>not supported ❌</p>
<p>Edge</p>
<p>supported ✅ 16+</p>
<p>not supported ❌</p>
<p>not supported ❌</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/matuzo/pen/rmQvMG/">CSS Grid Layout: Animation</a> by Manuel Matuzovic (<a target="_blank" rel="noopener" href="https://codepen.io/matuzo">@matuzo</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>文章来源：<a target="_blank" rel="noopener" href="https://css-tricks.com/snippets/css/complete-guide-grid/#prop-align-items">https://css-tricks.com/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Tom</p>
  <div class="site-description" itemprop="description">w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">338</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">W3Cbest前端开发</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
