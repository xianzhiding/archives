<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xianzhiding.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
<meta property="og:type" content="website">
<meta property="og:title" content="前端开发 大前端 W3Cbest">
<meta property="og:url" content="https://xianzhiding.github.io/page/11/index.html">
<meta property="og:site_name" content="前端开发 大前端 W3Cbest">
<meta property="og:description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tom">
<meta property="article:tag" content="前端开发,es5,es6,es10,css,javascript,html,flexbox,grid,echarts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xianzhiding.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>前端开发 大前端 W3Cbest</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">前端开发 大前端 W3Cbest</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个专注 WEB 开发的技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/19/css%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/19/css%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%EF%BC%89/" class="post-title-link" itemprop="url">CSS变量使用指南（自定义属性）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-19 22:47:24" itemprop="dateCreated datePublished" datetime="2018-09-19T22:47:24+08:00">2018-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CSS预处理器，如Sass和Less，使得CSS代码易于组织和维护。通过提供变量、混合、循环等特性，使得CSS具有动态编写的能力，从而减少重复性工作，提高开发速度。 最近，CSS开始添加一些动态特性。<a target="_blank" rel="noopener" href="https://www.w3.org/TR/css-variables/">CSS变量</a> （自定义属性）已经加入规范，并且获得了大多数浏览器的支持。但是<a target="_blank" rel="noopener" href="https://tabatkins.github.io/specs/css-apply-rule/">CSS混合特性还在进行中</a>。 在这篇文章中，我们将会向你展示怎么把CSS变量应用到开发中，从而使得样式表更加可维护和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a> (Don’t Repeat Yourself)。 让我们现在开始！</p>
<h2 id="CSS变量是什么？"><a href="#CSS变量是什么？" class="headerlink" title="CSS变量是什么？"></a>CSS变量是什么？</h2><p>如果你使用过任何编程语言，你肯定熟悉变量这个概念。变量让你存储和更新程序运行需要的值。 例如，考虑下面的JavaScript片段：</p>
<p>let number1 = 2;<br>let number2 = 3;<br>let total = number1 + number2;<br>console.log(total); // 5<br>number1 = 4;<br>total = number1 + number2;<br>console.log(total); // 7</p>
<p>number1和number2是两个变量，分别存储数字2和3。 total也是一个变量，存储<code>number1</code>和<code>number2</code>变量的和，在这个例子中是5。你可以动态更新这些变量的值，并且在程序的任何地方使用更新后的值。在上面的代码片段中，我把<code>number1</code>的值更新为<code>4</code>，当我使用相同的变量再次执行加法操作时，存储在<code>total</code>中的值就变成7，而不是5了。 变量的好处在于你可以把值存储在一个地方，然后在你需要的地方修改它。这样你就不用在程序的不同地方为不同的值添加不同的变量：所有变量更新使用同一个存储地址，比如你的变量。 CSS主要是一门声明式语言，缺乏动态性。你可能会说给CSS添加变量会与CSS本身相矛盾。如果前端开发仅仅关注语义，那么给CSS添加变量确实会与CSS本身矛盾。幸运的是，网络语言更像动态语言，它会随着周围环境和开发者的需求不断变化。CSS也不例外。 总而言之，变量已经成为CSS中令人激动的实现，你很快也会发现，学习和使用它非常直观。</p>
<h2 id="使用CSS变量有什么好处？"><a href="#使用CSS变量有什么好处？" class="headerlink" title="使用CSS变量有什么好处？"></a>使用CSS变量有什么好处？</h2><p>在CSS中使用变量的好处和在编程语言中没有特别大的不同。 下面是规范对上述问题的回答：</p>
<blockquote>
<p>[使用CSS变量]使大文件更易于阅读，因为看起来很随意的值有了一个提示信息的名字，并且编辑这些文件更加简单，更不易于出错。因为你只需要在自定义属性处修改一次，然后这个修改就会自动应用到使用该变量的任何地方。 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/css-variables/#intro">W3C规范</a>。</p>
</blockquote>
<p>换句话说： 通过与项目相关的方式命名变量，管理和维护代码会变得更加容易。例如，如果项目的主色调保存在<code>--primary-color</code>中，修改项目的主色调就会变得很容易，仅仅改变该变量的值就可以，而不用去修改遍布在代码各处、不同CSS属性中的颜色值。</p>
<h2 id="CSS变量和预处理器变量的不同之处？"><a href="#CSS变量和预处理器变量的不同之处？" class="headerlink" title="CSS变量和预处理器变量的不同之处？"></a>CSS变量和预处理器变量的不同之处？</h2><p>在给网站添加样式时，你可能已经通过预处理器，如<a target="_blank" rel="noopener" href="http://sass-lang.com/">Sass</a>和<a target="_blank" rel="noopener" href="http://lesscss.org/">Less</a>，体验过变量的灵活性带来的好处。 预处理器可以让你设置变量，并且在函数、循环和数学操作等中使用。这是不是意味着CSS变量就没有什么用处了？ 不完全是，主要是因为CSS变量和预处理器变量并不一样。 不同之处在于CSS变量是运行在浏览器中的动态CSS属性，而预处理器变量会被编译成普通的CSS代码。因此，浏览器并不知道预处理器变量的存在。 这就意味着你可以更改样式表、行内样式属性和SVG展示型属性中的CSS变量，或者使用JavaScript操作它们。这是预处理器变量做不到的。CSS变量提供了更多可能性！ 但这并不是说你需要在二者之间选择其一：你可以同时使用CSS变量和预处理器变量的强大功能。</p>
<h2 id="CSS变量的语法"><a href="#CSS变量的语法" class="headerlink" title="CSS变量的语法"></a>CSS变量的语法</h2><p>为了简单起见，在这篇文章中我使用了CSS变量这个术语，但是官方文档给出的是级联变量的CSS自定义属性。CSS自定义属性形式如下：</p>
<p>--my-cool-background: #73a4f4;</p>
<p>在自定义属性前面添加两个短横线，然后像普通的CSS属性一样给它赋值。在上面的代码片段中，给<code>--my-cool-background</code>自定义属性赋了一个颜色值。 级联变量部分包括使用<code>var()</code>函数应用自定义属性，形式如下：</p>
<p>var(–my-cool-background)</p>
<p>自定义属性的使用范围是CSS选择器的内部，<code>var()</code>像一个真正的CSS属性值被使用。</p>
<p>:root {<br>  –my-cool-background: #73a4f4;<br>}<br>/* CSS文件的其他部分 */<br>#foo {<br>  background-color: var(–my-cool-background);<br>}</p>
<p>上面的代码片段把<code>--my-cool-background</code>自定义属性定义在<code>:root</code>伪元素内，这使得自定义属性的值全局可用（:root匹配元素内的任何元素）。然后使用var()函数把值应用到ID是foo的容器的background-color属性上，然后这个容器就会得到一个淡蓝色背景。 除此之外，还可以把淡蓝色应用到多个HTML元素的其他颜色属性上，如<code>color</code>，<code>border-color</code>等。你需要做得仅仅是通过<code>var(--my-cool-background)</code>获取自定义属性的值，然后应用到相应的属性上。当然，你需要好好考虑CSS变量的命名规范，使你的变量名能更好地反映变量的内容。</p>
<p>p {<br>    color: var(–my-cool-background);<br>}</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/SitePoint/pen/gRMaJw/">Basic Workings of CSS Variables</a> by SitePoint (<a target="_blank" rel="noopener" href="https://codepen.io/SitePoint">@SitePoint</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>你也可以在CSS变量中使用另一个CSS变量，举例如下：</p>
<p>--top-color: orange;<br>–bottom-color: yellow;<br>–my-gradient: linear-gradient(var(–top-color), var(–bottom-color));</p>
<p>上面的代码片段创建了<code>--my-gradient</code>变量，它的值是使用<code>--top-color</code>和<code>--bottom-color</code>变量创建的一个渐变。现在，你可以在任何地方通过仅仅改变变量的值来修改渐变，而不必到处在样式表中创建渐变实例。 下面是一个在线CodePen演示。</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/SitePoint/pen/RgRrba/">Setting Value of CSS Variable with Another CSS Variable</a> by SitePoint (<a target="_blank" rel="noopener" href="https://codepen.io/SitePoint">@SitePoint</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>最后，在使用CSS变量的时候，还可以添加一个或多个后备值，举例如下：</p>
<p>var(–main-color, #333);</p>
<p>在上面的代码片段中，<code>#333</code>是一个后备值。如果没有提供后备值，当自定义属性无效或者没有赋值的时候，会使用继承值。</p>
<h2 id="CSS变量是大小写敏感的"><a href="#CSS变量是大小写敏感的" class="headerlink" title="CSS变量是大小写敏感的"></a>CSS变量是大小写敏感的</h2><p>和一般的CSS属性不一样，CSS变量是大小写敏感的。 例如，<code>var(--foo)</code>和<code>var(--Foo)</code>使用的是两个不同的自定义属性，分别是<code>--foo</code>和<code>--Foo</code>。</p>
<h2 id="CSS变量是级联的"><a href="#CSS变量是级联的" class="headerlink" title="CSS变量是级联的"></a>CSS变量是级联的</h2><p>类似一般的CSS属性，CSS变量也会继承。例如，我们定义一个值是blue的自定义属性：</p>
<p>:root {<br>    –main-color: blue;<br>}</p>
<p><code>&lt;html&gt;</code>根元素内的所有元素如果应用<code>--main-color</code>就会继承值<code>blue</code>。 如果你在另一个元素里面给自定义属性赋了一个不同的值，这个元素的所有子元素就会继承这个新值，举例如下：</p>
<p>:root {<br>    –main-color: blue;<br>}</p>
<p>.alert {<br>    –main-color: red;<br>}</p>
<p>p {<br>    color: var(–main-color);<br>}</p>
<p>&lt;–! HTML –&gt;</p>
<html>
  <head>
    <!-- head code here -->
  </head>
  <body>
    <div>
      <p>blue paragraph.</p>
      <div class="alert">
        <p>red paragraph.</p>
      </div>
    </div>
  </body>
</html>

<p>上面的标记语言中的第一个段落会继承全局<code>--main-color</code>的值，所以字体颜色是蓝色。 具有<code>.alert</code>类的div元素内部的段落元素的字体颜色是红色的，因为它继承了局部范围内的<code>--main-color</code>变量，这个变量的值是red。</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/SitePoint/pen/vZKLOG/">Simple Example of CSS Variables Inheritance</a> by SitePoint (<a target="_blank" rel="noopener" href="https://codepen.io/SitePoint">@SitePoint</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>现在了解了规则，让我们开始实践吧！</p>
<h2 id="在SVG中使用CSS变量"><a href="#在SVG中使用CSS变量" class="headerlink" title="在SVG中使用CSS变量"></a>在SVG中使用CSS变量</h2><p>CSS变量和SVG可以很好的一起工作！你可以使用CSS变量来修改内联SVG中的样式和展示型属性。 比如，你想通过SVG图标元素的父元素来给它一个不同的颜色。你可以在父元素内设置一个局部的CSS变量，然后把它赋值成你想要的颜色，然后，父元素内的图标就能从父元素继承到合适的颜色。 下面是相关代码：</p>
<p>/* 图标的内联SVG symbol */<br><svg><br>  <symbol id="close-icon" viewbox="0 0 200 200"><br>    <circle cx="96" cy="96" r="88" fill="none" stroke="var(--icon-color)" stroke-width="15" /><br>    <text x="100" y="160" fill="var(--icon-color)" text-anchor="middle" style="font-size:250px;">x</text><br>  </symbol><br></svg></p>
<p>/* 图标的第一个实例  */<br><svg><br>  <use xlink:href="#close-icon" /><br></svg></p>
<p>上面的标记语言使用了标签，使用它可以创建不可见的SVG图形。然后使用标签实例化了一个上述图形的可见版本。使用这种方式通过简单地引用元素的ID(<code>#close-icon</code>)就能创建大量的图标，然后再根据你的喜好对图标进行自定义。这比重复的写同一段代码要简便的多。如果你想复习这个技术，Massimo Cassandro在他的创造你<a target="_blank" rel="noopener" href="https://www.sitepoint.com/build-svg-icons/">自己的SVG图标</a>中提供了一个快速教程。 注意SVG中的圆形元素的stroke属性值和文本元素的fill属性值：它们都使用了一个CSS变量，<code>--icon-color</code>，这个变量定义在CSS文档的<code>:root</code>选择器上，如下所示：</p>
<p>:root {<br>  –icon-color: black;<br>}</p>
<p>图标现在的样子如下： <img data-src="http://file.w3cbest.com/file/images/1497293805default-svg-icon.png"> 如果你现在把SVG图标放到不同的容器中，然后在每个父元素的选择器中给这个变量赋不同的颜色值，你就能在不添加任何样式规则的情况下创建不同颜色的图标。真酷！ 举个例子，把上面图标的一个实例放在一个有类<code>.success</code>的div中。</p>
<div class="success">
  <svg>
    <use xlink:href="#close-icon" />
  </svg> 
</div>

<p>现在，在.success选择器内给–icon-color变量赋值green，然后看下效果。</p>
<p>.success {<br>    –icon-color: green;<br>}</p>
<p>现在，图标的颜色变成了绿色： <img data-src="http://file.w3cbest.com/file/images/1497293895success-icon.png"> 查看下面完整的演示示例：</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/SitePoint/pen/JJKGbj/">Basic Use of SVG Icon and CSS Variables</a> by SitePoint (<a target="_blank" rel="noopener" href="https://codepen.io/SitePoint">@SitePoint</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<h2 id="在-keyframes动画中使用CSS变量"><a href="#在-keyframes动画中使用CSS变量" class="headerlink" title="在@keyframes动画中使用CSS变量"></a>在@keyframes动画中使用CSS变量</h2><p>CSS变量可以和CSS动画一起使用，不论是在一般的HTML元素还是内联SVG元素上。只需要记住在想添加动画的元素的选择器上定义自定义属性，然后使用<code>var()</code>函数在<code>@keyframes</code>中引用。 比如，给SVG的一个有类<code>.bubble</code>的元素添加动画，CSS代码如下：</p>
<p>.bubble {<br>  –direction-y: 30px;<br>  –transparency: 0;<br>  animation: bubbling 3s forwards infinite;<br>}</p>
<p>@keyframes bubbling {<br>  0% {<br>    transform: translatey(var(–direction-y));<br>    opacity: var(–transparency);<br>  }<br>  40% {<br>    opacity: calc(var(–transparency) + 0.2);<br>  }<br>  70% {<br>    opacity: calc(var(–transparency) + 0.1);<br>  }<br>  100% {<br>    opacity: var(–transparency);<br>  }<br>}</p>
<p>你可能已经注意到我们可以使用CSS的<code>calc()</code>通过<code>var()</code>函数对变量进行计算，这使代码更加灵活。 这个例子中使用CSS变量的灵活之处是通过简单的改变相应选择器内部的变量值，就可以改变动画效果，而不必查找<code>@keyframes</code>指令中的每个属性。 下面是完整的CodePen演示：</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/SitePoint/pen/zzBrNV/">Simple Animation with CSS Variables and SVG</a> by SitePoint (<a target="_blank" rel="noopener" href="https://codepen.io/SitePoint">@SitePoint</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<h2 id="使用JavaScript操作CSS变量"><a href="#使用JavaScript操作CSS变量" class="headerlink" title="使用JavaScript操作CSS变量"></a>使用JavaScript操作CSS变量</h2><p>一件更酷的事情是你可以直接通过JavaScript代码访问CSS变量。 假设有一个叫<code>--left-pos</code>的CSS变量，它的值的<code>100px</code>，定义在CSS文档的<code>.sidebar</code>类中：</p>
<p>.sidebar {<br>  –left-pos: 100px;<br>}</p>
<p>使用类似下面的JavaScript代码获取<code>--left-pos</code>的值：</p>
<p>// 获取你想添加动画的元素<br>const sidebarElement = document.querySelector(‘.sidebar’);</p>
<p>// 把侧边栏元素的样式存储在cssStyles变量中<br>const cssStyles = getComputedStyle(sidebarElement);</p>
<p>// 获取CSS变量–left-pos的值<br>const cssVal = String(cssStyles.getPropertyValue(‘–left-pos’)).trim();</p>
<p>// 在控制台打印CSS变量的值<br>// 控制台会输出变量的值为100px<br>console.log(cssVal);</p>
<p>使用类似下面的JavaScript代码给CSS变量赋值：</p>
<p>sidebarElement.style.setProperty(‘–left-pos’, ‘200px’);</p>
<p>上面的代码片段把侧边栏元素的<code>--left-pos</code>变量设置成<code>200px</code>。 相对于改变大量的类或者重写全部的CSS规则，使用CSS变量给网站添加交互更直接，也更易于维护。 查看下面的CodePen演示，你可以通过侧边栏来改变<a target="_blank" rel="noopener" href="https://www.sitepoint.com/close-up-css-mix-blend-mode-property/">混合模式</a>属性和背景颜色，而这仅仅需要CSS变量和JavaScript:</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/SitePoint/pen/NgrxvM/">Blend Modes, CSS Variables and JavaScript</a> by SitePoint (<a target="_blank" rel="noopener" href="https://codepen.io/SitePoint">@SitePoint</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<h2 id="浏览器对CSS变量的支持情况"><a href="#浏览器对CSS变量的支持情况" class="headerlink" title="浏览器对CSS变量的支持情况"></a>浏览器对CSS变量的支持情况</h2><p>除了IE11（不支持）和Microsoft Edge（buggy支持），在本文编写的时候，所有主流浏览器都完全<a target="_blank" rel="noopener" href="http://caniuse.com/#feat=css-variables">支持CSS变量</a>。 适配有问题的浏览器的方式之一是使用@supports进行条件查询：</p>
<p>section {<br>  color: gray;<br>}</p>
<p>@supports(–css: variables) {<br>  section {<br>    –my-color: blue;<br>    color: var(–my-color, ‘blue’);<br>}<br>}</p>
<p>因为IE/Edge支持<code>@supports</code>，所以上面的代码会生效。如果在<code>var()</code>函数中添加一个后备值，你的代码将会更加健壮，在支持的更加不好的浏览器中也能优雅降级。 所以，在Chrome和其他支持CSS变量的浏览器中， 元素内部的文本是蓝色的： <img data-src="http://file.w3cbest.com/file/images/1497294865browser-with-css-variables-support.png"> IE11不支持CSS变量，文本会被渲染成灰色： <img data-src="http://file.w3cbest.com/file/images/1497294899browser-without-css-variables-support.png"> 查看在线演示：</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/SitePoint/pen/zzBrWY/">@supports with CSS Variables</a> by SitePoint (<a target="_blank" rel="noopener" href="https://codepen.io/SitePoint">@SitePoint</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p>这种方式的缺点是如果你在项目中使用了大量的CSS变量，但是该项目主要通过不支持CSS变量的浏览器打开，那么代码不仅会变得有点儿复杂，维护也将会是噩梦。 在这种情况下，你可以选择使用支持cssnext的<a target="_blank" rel="noopener" href="http://cssnext.io/">PostCSS</a>，然后你就可以编写尖端的CSS代码了，兼容不支持的浏览器交给PostCSS去做就可以了，这有点儿像JavaScript的编译器。如果你想了解PostCSS，SitePoint Premium为其所有成员提供了有关此主题的精彩<a target="_blank" rel="noopener" href="https://www.sitepoint.com/premium/courses/kick-starting-postcss-2948">视频课程</a>。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>想了解更多CSS变量的细节，包括浏览器兼容问题的解决方案和有趣的例子，查看下面的资源：</p>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://www.w3.org/TR/css-variables/">用于级联变量的CSS自定义属性模块级别1</a> - W3C规范</li>
<li>  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">使用CSS变量</a> - MDN</li>
<li>  <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=kZOJCVvyF-4">Lea Verou为CSSConf Asia 2016谈论CSS变量</a>（视频）</li>
<li>  <a target="_blank" rel="noopener" href="https://css-tricks.com/difference-between-types-of-css-variables/">CSS变量和预处理器变量之间有什么区别？</a> - Chris Coyier（CSS-Tricks）</li>
<li>  <a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2017/04/start-using-css-custom-properties/">现在是时候开始使用CSS自定义属性</a> - Serg Hospodarets（Smashing Magazine）</li>
<li>  <a target="_blank" rel="noopener" href="https://una.im/local-css-vars/">本地范围的CSS变量：什么，如何以及为什么</a> - Una Kravets</li>
<li>  <a target="_blank" rel="noopener" href="https://csswizardry.com/2016/10/pragmatic-practical-progressive-theming-with-custom-properties/">自定义属性的实用，实用和渐进式主题</a> - Harry Roberts（CSS Wizardry）</li>
<li>  <a target="_blank" rel="noopener" href="https://codepen.io/AmeliaBR/post/customizable-svg-icons-css-variables">带CSS变量的可定制SVG图标</a> - Amelia Bellamy-Royds（CodePen）。</li>
</ul>
<h2 id="有趣的例子"><a href="#有趣的例子" class="headerlink" title="有趣的例子"></a>有趣的例子</h2><ul>
<li>  <a target="_blank" rel="noopener" href="https://codepen.io/wesbos/pen/gPZBZQ?editors=0010">CSS变量的动画</a>- Wes Bos</li>
<li>  <a target="_blank" rel="noopener" href="https://codepen.io/wesbos/pen/adQjoY?editors=0110">使用JS更新CSS变量</a>- Wes Bos</li>
<li>  <a target="_blank" rel="noopener" href="https://codepen.io/chriscoyier/pen/ORdLvq?editors=0110">简单的响应网格与CSS变量</a>- 克里斯科伊尔</li>
<li>  <a target="_blank" rel="noopener" href="https://codepen.io/ramenhog/pen/yXYNzz?editors=1010">Slack主题与CSS自定义属性</a>- 斯蒂芬妮</li>
<li>  <a target="_blank" rel="noopener" href="https://codepen.io/search/pens/?q=css+variables&limit=thebabydino">Ana Tudor在CodePen上的CSS变量演示</a>。</li>
</ul>
<p>你还在等什么？尝试使用CSS变量并通过评论让我知道你的想法！ 文章来源：<a target="_blank" rel="noopener" href="https://www.sitepoint.com/practical-guide-css-variables-custom-properties/">https://www.sitepoint.com/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/18/%E5%85%B3%E4%BA%8Ecss%E5%8F%98%E9%87%8F%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/18/%E5%85%B3%E4%BA%8Ecss%E5%8F%98%E9%87%8F%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87/" class="post-title-link" itemprop="url">关于CSS变量你需要知道的一切</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-18 22:34:30" itemprop="dateCreated datePublished" datetime="2018-09-18T22:34:30+08:00">2018-09-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>多数编程语言都支持变量。但是CSS从最初就一直缺少对原生变量的功能支持。 你写CSS吧？那你就没办法用变量。不过，你还可以用Sass这样的预编译器。 Sass这样的预编译器就把变量作为一个巨大的卖点，一个尝试新东西的原因。你知道吗？我们还真的很吃这一套。 不过互联网还在飞速前行。所以我也很开心的宣布CSS现在终于支持变量了。 预编译器支持更多的特性，其中CSS变量就是一个不错的卖点。这些工作让互联网更加接近未来。 在这篇指南里，我会展示如何使用CSS原生变量，以及如何在日常工作里使用它们，让生活变的更美好。</p>
<h2 id="你会学到这些"><a href="#你会学到这些" class="headerlink" title="你会学到这些"></a>你会学到这些</h2><p>首先，我会介绍一些CSS变量的基础知识。我相信理解CSS变量应该从这里开始。 学习基础知识是非常酷的一件事。更酷的把这些基础知识应用到现实应用当中去。 所以我会用三个例子来展示如何方便的使用CSS变量。下面我们简单过一下这三个例子。</p>
<h3 id="例1：使用CSS变量创建可变组件"><a href="#例1：使用CSS变量创建可变组件" class="headerlink" title="例1：使用CSS变量创建可变组件"></a>例1：使用CSS变量创建可变组件</h3><p>今天你可能已经在构建自己可变组件了。无论你是在使用React，Angular，或者Vue，CSS变量都能使这个过程简洁许多。 <img data-src="http://file.w3cbest.com/file/images/1_qElS3I43_SdpdRA8-m2iew.gif"> 参见 <a target="_blank" rel="noopener" href="https://codepen.io/ohansemmanuel/full/PQYzvv/">Codepen的这个例子</a>;</p>
<h3 id="例2-带有CSS变量的主题样式"><a href="#例2-带有CSS变量的主题样式" class="headerlink" title="例2: 带有CSS变量的主题样式"></a>例2: 带有CSS变量的主题样式</h3><p>你可能已经在别处看到过这样的用法。我接下来要展示的是CSS变量如何使得创建站点级别的主题样式更加简便。 <img data-src="http://file.w3cbest.com/file/images/1_r2TrlsC-gWRD5Hu6Tp2gjQ.gif"> 参见 <a target="_blank" rel="noopener" href="https://codepen.io/ohansemmanuel/full/xYKgwE/">Codepen的这个例子</a></p>
<h3 id="例3-创建CSS变量盒"><a href="#例3-创建CSS变量盒" class="headerlink" title="例3: 创建CSS变量盒"></a>例3: 创建CSS变量盒</h3><p>恩，这是最后一个例子。请忽略这个名字，我想不到更好的了… <img data-src="http://file.w3cbest.com/file/images/1_E6H-wT6a0BDR9OJK7Z0dTA.gif"> 注意这些盒子的颜色是动态更新的，盒子容器也是可以3D旋转的。 <img data-src="http://file.w3cbest.com/file/images/1_iy_MjZVlp-H0KUQa7H7fUg.gif"> 这个例子让我们看到如何使用JavaScript更新CSS变量，并展示出一个很好的交互效果。</p>
<h2 id="接下来的更有趣！"><a href="#接下来的更有趣！" class="headerlink" title="接下来的更有趣！"></a>接下来的更有趣！</h2><p>花点时间尝试一下 <a target="_blank" rel="noopener" href="https://codepen.io/ohansemmanuel/full/EoBLgd/">Codepen上的这个例子</a>。 请注意：本文假设你已经熟练掌握了CSS。如果你还不了解CSS，或者想学习创造让人瞠目结舌的UI，我建议你上一下我的这堂高级<a target="_blank" rel="noopener" href="https://bit.ly/learn_css">CSS课程</a>（付费课程，包括85节课）。本文是其中一课的摘录（不害臊脸）。</p>
<h2 id="为何变量如此重要"><a href="#为何变量如此重要" class="headerlink" title="为何变量如此重要"></a>为何变量如此重要</h2><p>如果你刚开始学预编译器的变量，或者熟悉原生CSS，下面便是一些你要了解变量的原因：</p>
<h3 id="原因1-提高代码可读性"><a href="#原因1-提高代码可读性" class="headerlink" title="原因1:提高代码可读性"></a>原因1:提高代码可读性</h3><p>无需赘言，变量让代码可读性更强，可维护性更好。</p>
<h3 id="原因2-使大型文档中的代码改动更容易"><a href="#原因2-使大型文档中的代码改动更容易" class="headerlink" title="原因2: 使大型文档中的代码改动更容易"></a>原因2: 使大型文档中的代码改动更容易</h3><p>如果你所有的常量都存在一个单独的文件里，你就不需要在几千行代码里一一修改变量了。这就很容易了。 只要改一行，就结了！</p>
<h3 id="原因3-更快的发现拼写错误"><a href="#原因3-更快的发现拼写错误" class="headerlink" title="原因3: 更快的发现拼写错误"></a>原因3: 更快的发现拼写错误</h3><p>在多行代码里找错，是很痛苦的一件事。更烦人的是，这个错误可能只是简单的拼写错误。很难查找。合理使用变量，就能消除一些烦心事。 因此，可读性和可维护性可以双赢。 感谢CSS变量，现在我们终于可以在原生CSS中使用它们了。</p>
<h2 id="定义CSS变量"><a href="#定义CSS变量" class="headerlink" title="定义CSS变量"></a>定义CSS变量</h2><p>让我们从你熟悉的开始吧：JavaScript中的变量。 一个JavaScript中的变量可能是这样定义的：</p>
<p>var amAwesome;</p>
<p>然后这样赋值：</p>
<p>amAwesome = “awesome string”</p>
<p>CSS中，一个CSS变量是任意一个以两个破折号开头的”属性“值，</p>
<p>/*能找到这里定义变量么? */<br>.block {<br>color: #8cacea;<br>–color: blue<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/0_2Pl5qBF8DCTGL_np.png"></p>
<h2 id="CSS变量作用域"><a href="#CSS变量作用域" class="headerlink" title="CSS变量作用域"></a>CSS变量作用域</h2><p>还有一点你需要注意。 在JavaScript里，变量都有一个作用域。它们或是一个全局变量，或是一个局部变量。 CSS变量也一样。请看下面的例子：</p>
<p>:root {<br>–main-color: red<br>}</p>
<p><code>:root</code>选择器能让我们选择DOM树里的最顶级的元素，也就是文档树。所以，这样定义的变量，也就相当于全局变量了。理解了么？ <img data-src="http://file.w3cbest.com/file/images/0_GLjARI5CCGA3xJAx.png"></p>
<h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p>假设你想设置一个存储网站主题样式的CSS变量，你会怎么做？</p>
<h4 id="1，你需要使用范围选择器。用-root来定义一个全局变量。"><a href="#1，你需要使用范围选择器。用-root来定义一个全局变量。" class="headerlink" title="1，你需要使用范围选择器。用:root来定义一个全局变量。"></a>1，你需要使用范围选择器。用<code>:root</code>来定义一个全局变量。</h4><p>:root {}</p>
<h4 id="2，定义变量"><a href="#2，定义变量" class="headerlink" title="2，定义变量"></a>2，定义变量</h4><p>:root {<br>–primary-color: red<br>}</p>
<p>请记住，CSS变量是任意一个以两个破折号开始的“属性”。就这么简单。</p>
<h2 id="使用CSS变量"><a href="#使用CSS变量" class="headerlink" title="使用CSS变量"></a>使用CSS变量</h2><p>变量定义且被赋值后，你就可以使用它了。不过要上手还是有一些麻烦的地方。 如果你习惯了预编译器，那么肯定知道如何使用变量了。例如：</p>
<p>$font-size: 20px<br>.test {<br>font-size: $font-size<br>}</p>
<p>CSS变量和这稍有不同。 你需要使用<code>var()</code>这个函数引用变量。 上面的例子中，CSS变量是这样引用的：</p>
<p>:root {<br>–font-size: 20px<br>}<br>.test {<br>font-size: var(–font-size)<br>}</p>
<p>非常不同。 <img data-src="http://file.w3cbest.com/file/images/0_Gv8Nci9VTrJBxpBe.png"> 一旦你习惯了这样的方式，你就会爱上CSS变量的，非常爱！ 另一个重要的提示是，不像Sass或者其他预编译器中的变量，你可以在很多地方使用变量。CSS的变量需要小心谨慎，如果需要你还能做数学运算。多数情况下你应该把它们当作属性值来使用。</p>
<p>/*下面这样是不对的*/<br>.margin {<br>–side: margin-top;<br> var(–side): 20px;<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/0_vtIhP9EGm_vTxeio.png"> 你也无法直接使用数学运算功能。运算功能需要使用<code>calc()</code>函数。后面遇到时我会加以讨论。</p>
<p>/*下面这样也不对 */<br>.margin {<br>–space: 20px * 2;<br>font-size:  var(–space);  //这不是 40px<br>}</p>
<p>如果你一定需要用数学计算，那么请使用 calc()函数，如下：</p>
<p>.margin {<br>–space: calc(20px * 2);<br>font-size:  var(–space);  /*equals 40px*/<br>}</p>
<h2 id="值得一提的属性"><a href="#值得一提的属性" class="headerlink" title="值得一提的属性"></a>值得一提的属性</h2><p>有一些行为是值得提醒注意的。</p>
<h3 id="1-自定义属性是普通属性值，因此它们可以定义在任意元素上。"><a href="#1-自定义属性是普通属性值，因此它们可以定义在任意元素上。" class="headerlink" title="1. 自定义属性是普通属性值，因此它们可以定义在任意元素上。"></a>1. 自定义属性是普通属性值，因此它们可以定义在任意元素上。</h3><p>在段落p元素，section，aside元素或者root根元素，甚至是伪元素上使用变量，都是可以的。 <img data-src="http://file.w3cbest.com/file/images/0_plpQVof3v3JrzC1P.png"></p>
<h3 id="2-CSS变量和普通CSS继承和叠加的规则相同"><a href="#2-CSS变量和普通CSS继承和叠加的规则相同" class="headerlink" title="2. CSS变量和普通CSS继承和叠加的规则相同"></a>2. CSS变量和普通CSS继承和叠加的规则相同</h3><p>看这个例子：</p>
<p>div {<br>–color: red;<br>}<br>div.test {<br>color: var(–color)<br>}<br>div.ew {<br>color: var(–color)<br>}</p>
<p>和普通变量相同，<code>--color</code>的值也会从其他的div元素继承下来。 <img data-src="http://file.w3cbest.com/file/images/0_GNSU5IDdk7dx3B8t.png"></p>
<h3 id="3-CSS变量也可以和-media或其他条件选择的规则同时使用"><a href="#3-CSS变量也可以和-media或其他条件选择的规则同时使用" class="headerlink" title="3. CSS变量也可以和@media或其他条件选择的规则同时使用"></a>3. CSS变量也可以和<code>@media</code>或其他条件选择的规则同时使用</h3><p>和其他属性一样，你也可以使用<code>@media</code>或其他的条件规则里使用变量， 例如，下面的代码改变了变量的值，在不同的设备上使用不同值。</p>
<p>:root {<br>–gutter: 10px<br>}<br>@media screen and (min-width: 768px) {<br>    –gutter: 30px<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/0_qmsVGjnWjLCKfyvt.png"></p>
<h3 id="4-CSS变量可以在HTML的style属性中使用"><a href="#4-CSS变量可以在HTML的style属性中使用" class="headerlink" title="4. CSS变量可以在HTML的style属性中使用"></a>4. CSS变量可以在HTML的style属性中使用</h3><p>你也可以在内联样式里使用变量，它们也正常工作。</p>
<html style="--color: red">
body {
color: var(--color)
}

<p><img data-src="http://file.w3cbest.com/file/images/0_EQiFgdDyNBQ1AfDk.png"> CSS变量大小写敏感。请注意这一点。我为了省事全部都用小写。你的情况可能不一样。</p>
<p>/*这是两个不同的变量*/<br>:root {<br>   –color: blue;<br>–COLOR: red;<br>}</p>
<h2 id="解决多重定义"><a href="#解决多重定义" class="headerlink" title="解决多重定义"></a>解决多重定义</h2><p>和其他属性是一样的，重定义变量也遵循标准级联规则。 下面来看个例子：</p>
<p>/*变量定义*/<br>:root { –color: blue; }<br>div { –color: green; }<br>#alert { –color: red; }</p>
<p>/*使用变量 */<br>* { color: var(–color); }</p>
<p>有了上面的定义，不同元素的值是什么样的呢？</p>
<p>我的颜色是?</p>
<div>我的呢?</div>
<div>
我的颜色是?
<p>颜色?</p>
</div>

<p>你能猜出来么？ 第一个p元素是 blue，没有任何–color 变量定义是在 p元素的，因此它会继承自根元素 :root。</p>
<p>:root { –color: blue; }</p>
<p>第一个div是绿色green。毋庸赘述。在div`上有一个颜色变量定义。</p>
<p>div { –color: green; }</p>
<p>使用ID值为alert 定义的 div，不是绿色，而是红色red。</p>
<p>#alert { –color: red; }</p>
<p>The ID has a direct variable scoping. As such, the value within the definition will override the others. The selector #alert is more specific. 这个ID有一个更直接的变量范围。因此，这个范围内定义的变量值会覆盖其他的变量值。#alert ID选择器更具体。 最后， 在ID<code>#alert</code>中的这个p 是红色red。 在第一个p 元素上，并没有变量声明。可以推测，这个元素是在根元素 <code>:root</code>以内的，因此它的颜色是蓝色。</p>
<p>:root { –color: blue; }</p>
<p>和其他属性一样，CSS变量也是可继承的。这个值也会从其父节点上获得。</p>
<p>#alert { –color: red; }</p>
<p><img data-src="http://file.w3cbest.com/file/images/1_lGioVJqkKo0N91R9eMvywQ.png"></p>
<h2 id="解决循环依赖"><a href="#解决循环依赖" class="headerlink" title="解决循环依赖"></a>解决循环依赖</h2><p>循环依赖通常会在下面几种情况下发生： 变量需要依赖其自身值。也就是说，定义时就使用了var()引用其值。</p>
<p>:root {<br>    –m: var(–m)<br>}<br>body {<br>    margin: var(–m)<br>}</p>
<p>多个变量相互引用时。</p>
<p>:root {<br>    –one: calc(var(–two) + 10px);<br>    –two: calc(var(–one) - 10px);<br>}</p>
<p>请注意，不要在代码中创建这样的循环引用。</p>
<h2 id="使用无效变量会怎样？"><a href="#使用无效变量会怎样？" class="headerlink" title="使用无效变量会怎样？"></a>使用无效变量会怎样？</h2><p>语法错误会被忽略，但是无效的使用<code>var()</code>会导致错误的初始值或者是继承到有问题的值。 看下面的代码：</p>
<p>:root {–color: 20px;}<br>p {background-color: red;}<br>p {background-color: var(–color);}</p>
<p><img data-src="http://file.w3cbest.com/file/images/0_fa59XRLGKo5Rsqm4.png"> <code>--color</code>会被代入<code>var()</code>，但是这条属性值，<code>background-color: 20px</code> 在变量代入后是无效的（译者注：错误的颜色值）。因为<code>backgroud-color</code>不是继承属性，那么它的值就会是这个属性的初始值 <code>transparent</code>。 <img data-src="http://file.w3cbest.com/file/images/0_uVic7R1o96n-T1l5.png"> 请注意，如果你直接写<code>backgroud-color: 20px</code>，那么这个属性声明就是无效的。这一行之前的定义就正常工作了。 <img data-src="http://file.w3cbest.com/file/images/0_9HzCVQdyvqeo5dZq.png"></p>
<h2 id="创建单一标记时，请注意"><a href="#创建单一标记时，请注意" class="headerlink" title="创建单一标记时，请注意"></a>创建单一标记时，请注意</h2><p>当你设置一个类似下面的属性的变量时，20px就被编译成一个单一标记。</p>
<p>font-size: 20px</p>
<p>简单理解就是，20px 就是一个单独的整体。 使用CSS变量构建独立单一标记需要十分小心。 例如，看下面的代码：</p>
<p>:root {<br>–size: 20<br>}</p>
<p>div {<br>font-size: var(–size)px **/*错了*/**<br>}</p>
<p>你也许会认为，font-size的值是20px，但你错了。浏览器会解析成 20 px， 注意20和px之间的空格。 因此，如果你一定需要创建独立标记，那么就一定要用变量表示这个整体。例如： <code>--size: 20px</code>,或者是用 <code>calc()</code> 这个函数，例如， <code>calc(var(--size) * 1px)</code>，然后其中的<code>--size</code> 值就是20。 不要着急。如果你还不太能理解这一点，后面的例子中我会解释的更具体。</p>
<h2 id="一起来动手吧！"><a href="#一起来动手吧！" class="headerlink" title="一起来动手吧！"></a>一起来动手吧！</h2><p>下面就是本文里我们最期待的一部分。 我会带着大家做一些有用的例子，把实际应用中的概念都过一遍。我们开始吧。</p>
<h3 id="例1-使用CSS变量创建可变组件"><a href="#例1-使用CSS变量创建可变组件" class="headerlink" title="例1: 使用CSS变量创建可变组件"></a>例1: 使用CSS变量创建可变组件</h3><p>假设你需要创建两个不同的按钮。基本样式相同，只有一点小小的区别。 <img data-src="http://file.w3cbest.com/file/images/1_qElS3I43_SdpdRA8-m2iew.gif"> 在这个例子里，不同的属性只有 <code>background-color</code>和<code>border-color</code> 。 那怎样处理这种情况呢？下面是一种典型的解决方案： 创建一个基类，比如 .btn，然后加上其他的不同类，例如：</p>
<p><button class="btn">Hello</button><br><button class="btn red">Hello</button></p>
<p>.btn 包含了按钮的基本样式，例如：</p>
<p>.btn {<br>padding: 2rem 4rem;<br>border: 2px solid black;<br>background: transparent;<br>font-size: 0.6em;<br>border-radius: 2px;<br>}</p>
<p>/*on hover */<br>.btn:hover {<br>cursor: pointer;<br>background: black;<br>color: white;<br>}</p>
<p>那按钮样式如何变化呢?像这样：</p>
<p>/* variations */<br>.btn.red {<br>border-color: red<br>}</p>
<p>.btn.red:hover {<br>background: red<br>}</p>
<p>你看，这里就有重复的代码了吧？这样也好，但使用CSS变量可以更简洁。</p>
<h2 id="第一步是什么呢？"><a href="#第一步是什么呢？" class="headerlink" title="第一步是什么呢？"></a>第一步是什么呢？</h2><p>把变化的颜色值用CSS变量定义出来，不要忘记加默认值！</p>
<p>.btn {<br>padding: 2rem 4rem;<br>border: 2px solid var(–color, black);<br>background: transparent;<br>font-size: 0.6em;<br>border-radius: 2px;<br> }</p>
<p> /*on hover*/<br>.btn:hover {<br>cursor: pointer;<br>background: var(–color, black);<br>color: white;<br>}</p>
<p>你这样设置<code>background: **var(--color, black)**</code>时，也就是说把背景设置为变量–color的值。如果这个变量不存在，那就用默认值黑色**black**替代 。 这就是设置默认值的方法，和JavaScript或者其他语言一样。 下面是有趣的部分了。 有了变量，你就可以像下面这样设置新的变量值了：</p>
<p>.btn.red {<br>–color: red<br>}</p>
<p>这就可以了。如果元素class中使用了<code>.red</code>，那么浏览器就能注意到不同的<code>--color</code>值，这样就使得不同的按钮有不同的颜色了。 这样你就可以省下来很多时间，创建可复用的组件了。 下图是简单的对比： <img data-src="http://file.w3cbest.com/file/images/1_bdT9ITBx1wpXjLOYoWBI7w.png"> 哦，对了，如果你有更多的变量，那还能省下很多打字的时间： <img data-src="http://file.w3cbest.com/file/images/1_erZb3Z5FtTIR8EV9fl0QOA.png"></p>
<h3 id="例2：使用CSS变量制作网站主题"><a href="#例2：使用CSS变量制作网站主题" class="headerlink" title="例2：使用CSS变量制作网站主题"></a>例2：使用CSS变量制作网站主题</h3><p>我想你肯定遇到过这样的情况。有主题的网站可以让用户有自己定制的感觉，就像是由他们来控制一样。 下面这个例子就是我们要做的。   <img data-src="http://file.w3cbest.com/file/images/1_r2TrlsC-gWRD5Hu6Tp2gjQ.gif"> 那么CSS变量是如何让这件事变得简单一点的呢？ 让我们一起来看。 在这之前，我想提醒你，这个例子非常重要。在这个例子里，我会介绍如何使用JavaScript更新CSS变量。超有趣！你肯定会喜欢的。</p>
<h2 id="我们实际要做的"><a href="#我们实际要做的" class="headerlink" title="我们实际要做的"></a>我们实际要做的</h2><p>CSS变量的美妙是它们的互动性。一旦它们的值发生了变化，对应CSS的属性也会相应的进行更新。 下图从概念上解释了在本例中这个过程是如何发生的 。 <img data-src="http://file.w3cbest.com/file/images/1_ZONC-xXCXnGc8nr_QMv8rg.png"> 所以，我们需要增加一些JavaScript来监听点击事件。 在这个例子里，背景颜色和文字颜色是基于CSS变量的。 当你点击上面任何一个按钮时，它们就将对应的CSS变量设置成另一种颜色。于是，页面的背景颜色也更新了。 你看，这就是所有的内容了。 哦，还有一件事。 当我说把CSS变量设置成另一个值的时候，这又是怎样做到的呢？ <img data-src="http://file.w3cbest.com/file/images/1_FeTfEPsJuDQNGDuZQQBIew.png"> 即便是设置在inline style中，CSS变量也会生效。和JavaScript一起，我们就可以控制整个root文档，这样也就能设置CSS变量的值了。 理解了么？ 不过前面都是说的，下面我们来看代码。</p>
<h2 id="初始代码"><a href="#初始代码" class="headerlink" title="初始代码"></a>初始代码</h2><p>最初代码像这样： <div class="theme"> <button value="dark">dark</button> <button value="calm">calm</button> <button value="light">light</button> </div> <article> . . . </article> 这段代码由三个button和一个 class是<code>.theme</code> 父元素组成。为了简洁一点我去掉了中间的内容部分，只用article元素替代。article元素内就是页面内容。</p>
<h2 id="页面样式"><a href="#页面样式" class="headerlink" title="页面样式"></a>页面样式</h2><p>这个小项目的成功点就是页面的样式。技巧其实很简单。 没必要为每种风格设置<code>background-color</code>和 <code>color</code>，我们只需要使用变量来设置即可。 就像下面这样：</p>
<p>body {<br>    background-color: **var(–bg, white)**;<br>    color: **var(–bg-text, black)**<br>}</p>
<p>这样做目的很明显。点击每个button时，这个页面的背景和文字颜色就可以随之变化。 基于这个改变，整体的页面就很容易改变了。小菜一碟。 <img data-src="http://file.w3cbest.com/file/images/1_HmDLDbOPHpEE2F8x4aSDYA.png"> 接下来我们就来增加处理更新值的JavaScript脚本部分。</p>
<h2 id="涉及JavaScript的部分"><a href="#涉及JavaScript的部分" class="headerlink" title="涉及JavaScript的部分"></a>涉及JavaScript的部分</h2><p>接下来我会把项目需要的JavaScript逐步分析。</p>
<p>const root = document.documentElement<br>const themeBtns = document.querySelectorAll(‘.theme &gt; button’)<br>themeBtns.forEach((btn) =&gt; {<br>  btn.addEventListener(‘click’, handleThemeUpdate)<br>})</p>
<p>function handleThemeUpdate(e) {<br>  switch(e.target.value) {<br>    case ‘dark’:<br>      root.style.setProperty(‘–bg’, ‘black’)<br>      root.style.setProperty(‘–bg-text’, ‘white’)<br>      break<br>    case ‘calm’:<br>       root.style.setProperty(‘–bg’, ‘#B3E5FC’)<br>       root.style.setProperty(‘–bg-text’, ‘#37474F’)<br>      break<br>    case ‘light’:<br>      root.style.setProperty(‘–bg’, ‘white’)<br>      root.style.setProperty(‘–bg-text’, ‘black’)<br>      break<br>  }<br>}</p>
<p>别被吓到了。代码其实比你想的简单的多。 首先，创建一个对root元素的引用， <code>const root = document.documentElement</code>。 这里的root元素就是 HTML。一会你就明白为什么这一点很重要了。如果你很好奇，就先理解这是为了设置CSS变量使用的。 然后，对不同button也保存对应的引用， <code>const themeBtns = document.querySelectorAll(&#39;.theme &gt; button&#39;)</code>。 <code>querySelectorAll</code>会返回一个可以遍历的数组结构。这样我们就可以遍历每个按钮给它们增加对应的点击事件。 就像这样：</p>
<p>themeBtns.forEach((btn) =&gt; {<br>    btn.addEventListener(‘click’, handleThemeUpdate)<br>})</p>
<p><code>handleThemeUpdate</code> 在哪呢？接下来就是。 点击按钮时，对应的<code>handleThemeUpdate</code>就会触发。因此要记下哪个按钮点击了，应该执行对应什么样的操作。 因此，这里用了一个<code>switch</code>的<code>operator</code>，不同的按钮的点击事件在这里有了区别。 现在你再回去看一下前面的JavaScript的代码。你应该能更好的理解它了。</p>
<h3 id="例3-创建CSS变量盒-1"><a href="#例3-创建CSS变量盒-1" class="headerlink" title="例3: 创建CSS变量盒"></a>例3: 创建CSS变量盒</h3><p>假如你忘了，那再提一下，我们要做的例子是这样的: <img data-src="http://file.w3cbest.com/file/images/1_E6H-wT6a0BDR9OJK7Z0dTA.gif"> 请记住，盒子的颜色是动态变化的，盒子可以根据用户的输入进行3D的旋转。 <img data-src="http://file.w3cbest.com/file/images/1_iy_MjZVlp-H0KUQa7H7fUg.gif"> 你可以在<a target="_blank" rel="noopener" href="https://codepen.io/ohansemmanuel/full/EoBLgd/">Codepen</a>上玩一下。 这是使用CSS变量和JavaScript共同创造出的一个即有交互性又很美妙的例子。 我们一起看看怎么做的。</p>
<h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><p>我们需要下面一些元素：</p>
<ol>
<li> 一个范围输入</li>
<li> 一个容器来显示说明部分</li>
<li> 一个部分用来列出不同的盒子和每一种输入</li>
</ol>
<p><img data-src="http://file.w3cbest.com/file/images/1_39k9sbEsldtRtJ1-Woq0rQ.png"> 代码部分很简单，下面就是:</p>
<main class="booth">
    <aside class="slider">
        <label>Move this ? </label>
        <input class="booth-slider" type="range" min="-50" max="50" value="-50" step="5"/>
    </aside>

<pre><code>&lt;section class=&quot;color-boxes&quot;&gt;
  &lt;div class=&quot;color-box&quot; id=&quot;1&quot;&gt;&lt;input value=&quot;red&quot;/&gt;&lt;/div&gt;
  &lt;div class=&quot;color-box&quot; id=&quot;2&quot;&gt;&lt;input/&gt;&lt;/div&gt;
  &lt;div class=&quot;color-box&quot; id=&quot;3&quot;&gt;&lt;input/&gt;&lt;/div&gt;
  &lt;div class=&quot;color-box&quot; id=&quot;4&quot;&gt;&lt;input/&gt;&lt;/div&gt;
  &lt;div class=&quot;color-box&quot; id=&quot;5&quot;&gt;&lt;input/&gt;&lt;/div&gt;
  &lt;div class=&quot;color-box&quot; id=&quot;6&quot;&gt;&lt;input/&gt;&lt;/div&gt;
&lt;/section&gt;

&lt;footer class=&quot;instructions&quot;&gt;
    Move the slider&lt;br/&gt;
    Write any color in the red boxes 
&lt;/footer&gt;
</code></pre>
</main>

<p>需要注意以下几点：</p>
<ol>
<li> 输入的范围是从<code>-50</code>到<code>50</code>，步长是<code>5</code>。而且，最小值是<code>-50</code>。</li>
<li> 如果你不太清楚这个范围输入是什么原理，可以在 w3schools找到相关说明。</li>
<li> 注意外层带有<code>.color-boxes</code>类的容器，它包含了<code>.color-box</code>的容器，再其中就是各种输入了。</li>
<li> 或许应该提一下，第一个输入框的默认值是红色。</li>
</ol>
<p>理解了页面的结构，接下来我们看一下页面样式： <img data-src="http://file.w3cbest.com/file/images/1_LbgNgLeTjACXCfDBExkqgg.png"></p>
<ol>
<li> 首先把<code>.slider</code>和<code>.instructions</code>的元素移出文档流，进行绝对定位。</li>
<li> 然后给body元素添加日出的背景颜色，再用一朵花的背景图做装饰，放在页面的左下角。</li>
<li> 然后把<code>color-boxes</code>居中对齐。</li>
<li> 接下来给<code>color-boxes</code>增加样式。</li>
</ol>
<p>我们一起来深入一下细节。下面的代码完成的是第一个任务。</p>
<p>/* Slider */<br>.slider,<br>.instructions {<br>    position: absolute;<br>    background: rgba(0,0,0,0.4);<br>    padding: 1rem 2rem;<br>    border-radius: 5px<br>}<br>.slider {<br>    right: 10px;<br>    top: 10px;<br>}<br>.slider &gt; * {<br>    display: block;<br>}</p>
<p>/* Instructions */<br>.instructions {<br>    text-align: center;<br>    bottom: 0;<br>    background: initial;<br>    color: black;<br>}</p>
<p>这段代码非常简单。我想你肯定能读懂，如果不懂就发评论或者发推。 给 body元素加上样式就复杂一些了。希望你能很好的理解这部分CSS。 因为我们需要设置元素的背景颜色和背景图像，那么我们最好使用简化的background属性来增加多种不同的背景。代码如下：</p>
<p>body {<br>    margin: 0;<br>    color: rgba(255,255,255,0.9);<br>    background: url(‘<a target="_blank" rel="noopener" href="http://bit.ly/2FiPrRA&#39;">http://bit.ly/2FiPrRA&#39;</a>) 0 100%/340px no-repeat, var(–primary-color);<br>    font-family: ‘Shadows Into Light Two’, cursive;<br>}</p>
<p>url部分设置向日葵图片的链接。 接下来<code>0``100%</code>代表图像在背景中的位置。 这里有对于CSS中background属性定位的具体阐释：</p>
<p><img data-src="http://file.w3cbest.com/file/images/1_uFlBKNdQ-FOcZ-XaACi4uA.png"> 来源：<a target="_blank" rel="noopener" href="http://bit.ly/learn_css">the advanced guide to CSS</a></p>
<p><img data-src="http://file.w3cbest.com/file/images/1_NOPEnEV_H2RB8XYFxEcFpA.png"> 来源：<a target="_blank" rel="noopener" href="http://bit.ly/learn_css">the advanced guide to CSS</a></p>
<p>在斜线后的另一部分是代表<code>background-size</code>，这个值是340px。如果这个值小一些，那图片也会更小一点。 你也许会想no-repeat是什么意思，它意味着背景不允许重复。 最后，逗号之后的部分就是第二种背景声明。这次我们把<code>background-color</code>设置成<code>var(primary-color)</code>。 哦，它是一个变量。 这就意味着你需要定义这个变量，就像这样：</p>
<p>:root {<br>    –primary-color: rgba(241,196,15 ,1)<br>}</p>
<p>现在的颜色是日出的黄色。不是什么大问题。接下来我们会设置更多的变量。 然后，把<code>color-boxes</code>居中对齐。</p>
<p>main.booth {<br>    min-height: 100vh;<br>    display: flex;<br>    justify-content: center;<br>    align-items: center;<br>}</p>
<p>主要容器是布局设置成flex，然后直接将子元素放在页面中间， 也就是接下来<code>color-box</code>的部分。 下面我们把容器和子元素美化一下。 首先是子元素：</p>
<p>.color-box {<br>    padding: 1rem 3.5rem;<br>    margin-bottom: 0.5rem;<br>    border: 1px solid rgba(255,255,255,0.2);<br>    border-radius: 0.3rem;<br>    box-shadow: 10px 10px 30px rgba(0,0,0,0.4);<br>}</p>
<p>这样就够了。还加了一个漂亮的阴影。这样就有了酷炫的效果了。 不过这还不够。还有<code>container-boxes</code>容器的样式：</p>
<p>/* Color Boxes */<br>.color-boxes {<br>    background: var(–secondary-color);<br>    box-shadow: 10px 10px 30px rgba(0,0,0,0.4);<br>    border-radius: 0.3rem;<br>    transform: perspective(500px) rotateY( calc(var(–slider) * 1deg));<br>    transition: transform 0.3s<br>}</p>
<p>棒！ 这样就好多了。 让我们细化一下。 下面是简单的部分：</p>
<p>.color-boxes {<br>    background: **var(–secondary-color)**;<br>    box-shadow: 10px 10px 30px rgba(0,0,0,0.4);<br>    border-radius: 0.3rem;<br>}</p>
<p>你知道意思，对吧？ 这里用了一个新的变量。因此我们需要在root选择器里加上定义。</p>
<p>:root {<br>    –primary-color: rgba(241,196,15 ,1);<br>    –secondary-color: red;<br>}</p>
<p>这里的<code>secondary-color</code>是红色。这样就使得容器有一个红色的背景。 但你可能对下面的部分感到疑惑，</p>
<p>/* Color Boxes */<br>.color-boxes {<br>    transform: perspective(500px) rotateY( calc(var(–slider) * 1deg));<br>    transition: transform 0.3s<br>}</p>
<p>我们可以暂时简化上面代码里<code>transfrom</code>的属性。 <img data-src="http://file.w3cbest.com/file/images/1_oNaNYDRDRZPSEga9Oo4bPw.png"> 例如：</p>
<p>transform: perspective(500px) rotateY( 30deg);</p>
<p><code>transform</code>合并了两个不同的函数。一个是透视，一个是以Y轴为标准的旋转。 不过，<code>perspective</code>和<code>rotateY</code>又起了什么样的作用呢？ <code>perspective()</code>函数可以使元素在3D的空间内变形。它会激活一个三维空间，使元素增加一个z轴。 你可以在 codrops看到更多关于<code>perspective</code>函数的介绍。 那么rotateY函数又有什么用呢？ 激活了三维空间后，元素就有了x，y，z三个轴。 rotateY函数就意味着把元素以 Y 轴为中心进行旋转。 codrops的这幅图可以帮我们直观的理解这一点。 <img data-src="http://file.w3cbest.com/file/images/1_kFdzSl4wwyPJt_Crmbtuow.png"></p>
<p><a target="_blank" rel="noopener" href="https://tympanus.net/codrops/css_reference/transform/#section_rotate3d">Codrops</a></p>
<p>希望这能帮你拨开云雾见天日。 回到前面的主题。 <img data-src="http://file.w3cbest.com/file/images/1_oNaNYDRDRZPSEga9Oo4bPw.png"> 移动滑块的时候，你知道是哪个函数影响了<code>.container-box</code>的旋转效果么？ 是的，就是这个 rotateY函数被调用了。因此这个盒元素就沿着Y轴进行旋转。 因为这个值可以通过JavaScript传给函数，所以这个值就用一个变量来表示。 <img data-src="http://file.w3cbest.com/file/images/1_oL_Ik1Xg_ByTc28g2B1ESg.png"> 那为什么要用这个变量乘以1deg呢？ 按通常的经验来说，也为了自由定义变量，我们建议在创建变量时，不带单位。 这样你就可以在任何需要使用单位的时候通过calc函数达成目标。 <img data-src="http://file.w3cbest.com/file/images/1_jsB27oUUYY48n3s9wAmd_Q.png"> 这就使得你可以在需要时任意使用了。它即可以转化成deg， 也可以转化成一个相对于用户视窗单位vw的比例 ，你可以想怎么做就怎么做。 在这个例子中，我们把一个数字通过乘以一个1deg的值，得到了一个有单位的数值。 <img data-src="http://file.w3cbest.com/file/images/1_5j1qhUmE2pB99qw17Zp4iA.png"> 因为CSS并不理解数学计算，因此你需要把这个算术放在calc函数里才能得到CSS属性需要的对应数值。 这些都完成，我们就可以开始下一步了。现在我们要用JavaScript来更新这个变量值。 不过还剩下一点CSS的代码。这就是了：</p>
<p>/* Handle colors for each color box */<br>.color-box:nth-child(1) {<br>    background: var(–bg-1)<br>}<br>.color-box:nth-child(2) {<br>    background: var(–bg-2)<br>}<br>.color-box:nth-child(3) {<br>    background: var(–bg-3)<br>}<br>.color-box:nth-child(4) {<br>    background: var(–bg-4)<br>}<br>.color-box:nth-child(5) {<br>    background: var(–bg-5)<br>}<br>.color-box:nth-child(6) {<br>    background: var(–bg-6)<br>}</p>
<p>这又是什么鬼? 首先，<code>nth-child</code>选择器用来选择不同的子元素。 <img data-src="http://file.w3cbest.com/file/images/1_T5oqa3Kh5ChIcgi5ldqXKg.png"> 这里我们需要看深入一点。我们已经了解需要更新每个盒子的颜色，也知道每盒子的颜色需要用一个变量以便使用JavaScript更新，对把？ 因此，我们就这样设置：</p>
<p>.color-box:nth-child(1) {<br>    background: var(–bg-1)<br>}</p>
<p>简单吧？ 不过还有一个问题，如果这个变量不存在，那会怎么样呢？ 我们需要默认值。 这样就没问题了：</p>
<p>.color-box:nth-child(1) {<br>    background: var(–bg-1, red)<br>}</p>
<p>不过在这个实际的例子里，我选择不提供任何默认值。 如果这个变量的属性值不合法，那么这个属性值就会用其初始值。 也就是说，如果 <code>--bg-1</code>不合法或者无效，那么背景就是它的初始值，也就是透明色。 没有明确指定时，初始值就是这个属性的默认值。例如，如果你不设置元素的<code>background-color</code>，那它就是默认就是透明的。 初始值也是一种默认值。 开始写JavaScript 需要写的JavaScript的部分非常少。 首先让我们处理滑块。 五行就够了！</p>
<p>const root = document.documentElement<br>const range = document.querySelector(‘.booth-slider’)</p>
<p>//as slider range’s value changes, do something<br>range.addEventListener(‘input’, handleSlider)</p>
<p>function handleSlider (e) {<br>    let value = e.target.value<br>    root.style.setProperty(‘–slider’, value)<br>}</p>
<p>很简单吧？ 不过我还是要解释一下，以防我把你搞糊涂了。 首先，保存一个对slider元素的引用，<code>const range = document.querySelector(&#39;.booth-slider&#39;)</code>。 <img data-src="http://file.w3cbest.com/file/images/1_bQwZp0psRdiNn2harZW-HQ.png"> 然后给它增加一个事件，用来处理滑块值变化，<code>range.addEventListener(&#39;input&#39;, handleSlider)</code>。 接下来就是这个回调事件handleSlider：</p>
<p>function handleSlider (e) {<br>    let value = e.target.value<br>    root.style.setProperty(‘–slider’, value)<br>}</p>
<p><code>root.style.setProperty(&#39;--slider&#39;, value)</code> 是指把root元素的style属性设置成对应值。 处理颜色变化 这和处理滑块值的变化一样简单。下面就是：</p>
<p>const inputs = document.querySelectorAll(‘.color-box &gt; input’)<br>//as the value in the input changes, do something.<br>inputs.forEach(input =&gt; {<br>    input.addEventListener(‘input’, handleInputChange)<br>})</p>
<p>function handleInputChange (e) {<br>    let value = e.target.value<br>    let inputId = e.target.parentNode.id<br>    let inputBg = `–bg-${inputId}`<br>    root.style.setProperty(inputBg, value)<br>}</p>
<p>保存一个对所有输入框的引用， const inputs = document.querySelectorAll(‘.color-box &gt; input’)。 为每一个输入框增加一个事件处理：</p>
<p>inputs.forEach(input =&gt; {<br>    input.addEventListener(‘input’, handleInputChange)<br>})</p>
<p>接下来是 handleInputChange 函数：</p>
<p>function handleInputChange (e) {<br>    let value = e.target.value<br>    let inputId = e.target.parentNode.id<br>    let inputBg = `–bg-${inputId}`<br>    root.style.setProperty(inputBg, value)<br>}</p>
<p><img data-src="http://file.w3cbest.com/file/images/1_A3e4duLT1V1-8_NqVF1DGg.png"> 嗯… 这就没了！ 样例做完了！ 我怎么能忘记这些呢？ 我写完这篇文章还改了初稿之后，才想起来我还没提到浏览器的兼容性。所以，让我补上这一部分。 CSS变量的浏览器支持并不差。可以说相当好了，几乎所有的现代浏览器都能支持（我写这篇文章的时候超过87%）。 <img data-src="http://file.w3cbest.com/file/images/20190118223123.jpg"></p>
<p><a target="_blank" rel="noopener" href="https://caniuse.com/#search=css%20var">caniuse</a></p>
<p>所以，你可以在生产环境中使用么？我当然说是啦！不过你还是要检查一下适用的比例。 往好的方向面看，你也可以使用 Myth类似的预编译器。它可以把你现在使用的CSS变成未来可期的CSS，超酷的，对吧？ 如果你有用过postCSS的经验，那这也是一个现在使用未来CSS的不错的方法。这里有一些使用postCSS的例子。 好啦，我都讲完了。 原文翻译：<a target="_blank" rel="noopener" href="https://medium.freecodecamp.org/everything-you-need-to-know-about-css-variables-c74d922ea855">https://medium.freecodecamp.org</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/17/art-template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E6%95%B0%E7%BB%84%E6%B8%B2%E6%9F%93%E7%9A%84%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/17/art-template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E6%95%B0%E7%BB%84%E6%B8%B2%E6%9F%93%E7%9A%84%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">art-template模板引擎数组渲染的方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-17 14:47:11" itemprop="dateCreated datePublished" datetime="2018-09-17T14:47:11+08:00">2018-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%B5%84%E6%BA%90/" itemprop="url" rel="index"><span itemprop="name">资源</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JavaScript 模板引擎作为数据与界面分离工作中最重要一环，越来越受开发者关注，模板引擎种类也是五花八门，我就说几个安全性高、错误处理调试优，执行速度快的有artTemplate(腾讯 14k)、juicer(国外 12k)这俩个，doT除了错误处理调试差以外其他的都和这两个一样,他有一个优点是小(4k)，扯远啦。 art-template 是一个简约、超快的模板引擎。 它采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行性能，并且同时支持 NodeJS 和浏览器。<a target="_blank" rel="noopener" href="https://aui.github.io/art-template/rendering-test/">在线速度测试</a>。 我们就讲一下讲简洁语法的渲染方式，template(filename, content)根据模板名渲染模板。前提是你已经对artTemplate有所了解， 今天我们就讲一下数组渲染的方法 数组渲染有数组对象和纯数组两种形式，我们先说数组对象，如后端返回我们接口，收到的就是一个数组。比如：</p>
<pre class="language-none"><code class="language-none">const res &#x3D; [
  &#123;&quot;name&quot;:&quot;小明&quot;, &quot;age&quot;:16, &quot;marry&quot;:&quot;单身&quot;&#125;,
  &#123;&quot;name&quot;:&quot;小花&quot;,&quot;age&quot;:15, &quot;marry&quot;:&quot;有男朋友&quot;&#125;,
  &#123;&quot;name&quot;:&quot;小胖&quot;,&quot;age&quot;:15, &quot;marry&quot;:&quot;有女朋友&quot;&#125;,
  &#123;&quot;name&quot;:&quot;小丽&quot;,&quot;age&quot;:15, &quot;marry&quot;:&quot;单身&quot;&#125;
];</code></pre>

<p>用artTemplate有个好处就是除了你的数据需要重组，其他的完全可以拿来直接用。如下 html</p>
<pre class="language-none"><code class="language-none">&lt;div id&#x3D;&quot;person&quot;&gt;&lt;&#x2F;div&gt;</code></pre>

<p>js</p>
<pre class="language-none"><code class="language-none">&lt;script&gt;
  const res &#x3D; [
    &#123;&quot;name&quot;:&quot;小明&quot;, &quot;age&quot;:16, &quot;marry&quot;:&quot;单身&quot;&#125;,
    &#123;&quot;name&quot;:&quot;小花&quot;,&quot;age&quot;:15, &quot;marry&quot;:&quot;有男朋友&quot;&#125;,
    &#123;&quot;name&quot;:&quot;小胖&quot;,&quot;age&quot;:15, &quot;marry&quot;:&quot;有女朋友&quot;&#125;,
    &#123;&quot;name&quot;:&quot;小丽&quot;,&quot;age&quot;:15, &quot;marry&quot;:&quot;单身&quot;&#125;
  ];
  document.getElementById(&#39;person&#39;).innerHTML &#x3D; template(&#39;tpl&#39;, &#123;data:res&#125;); 
  &#x2F;&#x2F; 其实这里是把数组转为对象的形式传进的
&lt;&#x2F;scrtip&gt;</code></pre>

<p>template</p>
<pre class="language-none"><code class="language-none">&lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;tpl&quot;&gt;
  &#x2F;&#x2F;写法一
  &#123;&#123;each data&#125;&#125;
  &lt;li&gt;&#123;&#123;$index&#125;&#125;索引 我叫&#123;&#123;$value.name&#125;&#125;，今年&#123;&#123;$value.age&#125;&#125;岁，&#123;&#123;$value.marry&#125;&#125;&lt;&#x2F;li&gt;
  &#123;&#123;&#x2F;each&#125;&#125;

  &#x2F;&#x2F;写法二
  &#123;&#123;each data item index&#125;&#125;
  &lt;li&gt;&#123;&#123;index&#125;&#125;索引 我叫&#123;&#123;item.name&#125;&#125;，今年&#123;&#123;item.age&#125;&#125;岁，&#123;&#123;item.marry&#125;&#125;&lt;&#x2F;li&gt;
  &#123;&#123;&#x2F;each&#125;&#125;
&lt;&#x2F;script&gt;</code></pre>

<p>下面在看数组渲染，这是一个数组</p>
<pre class="language-none"><code class="language-none">const res &#x3D; [&#39;文艺&#39;, &#39;博客&#39;, &#39;摄影&#39;, &#39;电影&#39;, &#39;民谣&#39;, &#39;旅行&#39;, &#39;吉他&#39;];</code></pre>

<p>html</p>
<pre class="language-none"><code class="language-none">&lt;div id&#x3D;&quot;interest&quot;&gt;&lt;&#x2F;div&gt;</code></pre>

<p>js</p>
<pre class="language-none"><code class="language-none">&lt;script&gt;
  const res &#x3D; [&#39;文艺&#39;, &#39;博客&#39;, &#39;摄影&#39;, &#39;电影&#39;, &#39;民谣&#39;, &#39;旅行&#39;, &#39;吉他&#39;];
  document.getElementById(&#39;interest&#39;).innerHTML &#x3D; template(&#39;tpl&#39;, &#123;data:res&#125;);
  &#x2F;&#x2F; 其实这里是把数组转为对象的形式传进的
&lt;&#x2F;scrtip&gt;</code></pre>

<p>template</p>
<pre class="language-none"><code class="language-none">&lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;tpl&quot;&gt;
  &#x2F;&#x2F;写法一
  &#123;&#123;each data&#125;&#125;
  &lt;li&gt;&#123;&#123;$index&#125;&#125;索引 我喜欢&#123;&#123;$value.name&#125;&#125;&lt;&#x2F;li&gt;
  &#123;&#123;&#x2F;each&#125;&#125;

  &#x2F;&#x2F;写法二
  &#123;&#123;each data item index&#125;&#125;
  &lt;li&gt;&#123;&#123;index&#125;&#125;索引 我喜欢&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;
  &#123;&#123;&#x2F;each&#125;&#125;
&lt;&#x2F;script&gt;</code></pre>

<p>就说这么多吧，其实这种模板用着挺简单的很顺手。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/14/%E5%88%A9%E7%94%A8jquery%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/14/%E5%88%A9%E7%94%A8jquery%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/" class="post-title-link" itemprop="url">利用jQuery实现简单的数据双向绑定</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-14 16:23:43" itemprop="dateCreated datePublished" datetime="2018-09-14T16:23:43+08:00">2018-09-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在软件开发中，MVC或者MVVM是经常被用到的设计模式。在web前端开发中，之前我们需要自己写许多代码来完成这项功能。而现在有许多优秀的类库可以帮我们实现这个功能。 许多优秀的前端框架都提供了强大的数据双向绑定的功能。比如 Vue.js， Angular.js， KnockoutJS。 如果我们在一些小型的项目中，只是希望某个功能区域有数据双向绑定的功能，是不是就非得使用这么重的框架呢？事实上，我们可以用jQuery来实现一个简单的数据双向绑定的功能。 从头开始做一个数据双向绑定并不是那么复杂。简单来说，需要实现下面三点： 我们需要指定View中的UI元素和数据中的属性对应关系。 我们需要监听View中的UI元素内容以及数据的变化。 最后就是我们需要把变化通知到所有与之绑定的数据或者UI元素。 Javascript Code</p>
<pre class="language-none"><code class="language-none">function DataBinder (objectId) &#123;
  &#x2F;&#x2F; 使用jQuery空对象作为监听对象
  var pubSub &#x3D; jQuery(&#123;&#125;);
  &#x2F;&#x2F;
  var dataAttr &#x3D; &#39;bind-&#39; + objectId;
  var message &#x3D; objectId + &#39;:change&#39;;
  &#x2F;&#x2F; 监听dom中所有元素的 data-binding 属性变化。并由pubSub来处理。
  $(document).on(&#39;input change&#39;, &#39;[data-&#39; + dataAttr + &#39;]&#39;, function (event) &#123;
    var $ele &#x3D; $(this);
    console.log(&#39;$ele&#39;, $ele);
    pubSub.trigger(message, [$ele.data(dataAttr), $ele.val()]);
  &#125;);
  &#x2F;&#x2F; pubSub把数据变化推送给所有与之绑定的页面元素
  pubSub.on(message, function (event, proName, newValue) &#123;
    $(&#39;[data-&#39; + dataAttr + &#39;&#x3D;&#39; + proName + &#39;]&#39;).each(function () &#123;
      var $ele &#x3D; $(this);
      if($ele.is(&#39;input, textarea, select&#39;)) &#123;
        $ele.val(newValue);
      &#125; else &#123;
        $ele.html(newValue);
      &#125;
    &#125;)
  &#125;);
  return pubSub;
&#125;
function User(uid) &#123;
    var binder &#x3D; new DataBinder(uid);
    var user &#x3D; &#123;
      attributes: &#123;&#125;,
      set: function (attrName, val) &#123;
        this.attributes[attrName] &#x3D; val;
        binder.trigger(uid + &#39;:change&#39;, [attrName, val, this]);
      &#125;,
      get: function (attrName) &#123;
        return this.attributes[attrName];
      &#125;,
      _binder: binder
    &#125;
  return user;
&#125;</code></pre>

<p>调用的时候，用uid与之关联。 Javascript Code</p>
<pre class="language-none"><code class="language-none">var user &#x3D; new User(&#39;user&#39;);
$(&#39;#btnSet&#39;).bind(&#39;click&#39;, function (event) &#123;
  user.set(&#39;name&#39;, &#39;Liuyuan211&#39;);
&#125;);</code></pre>

<p>Html</p>
<pre class="language-none"><code class="language-none">&lt;div class&#x3D;&quot;item&quot;&gt;
&lt;label&gt;用户名：&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;text&quot; data-bind-user&#x3D;&quot;name&quot; &#x2F;&gt;&lt;span data-bind-user&#x3D;&quot;name&quot;&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;
&lt;div class&#x3D;&quot;item&quot;&gt;
&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btnSet&quot; value&#x3D;&quot;Set&quot; &#x2F;&gt;
&lt;&#x2F;div&gt;</code></pre>

<p>该例子中，uid就是 data-bind-user=”name” 中的 user ，绑定的页面元素会自动与user对应的属性关联。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/14/jquery%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/14/jquery%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">jquery脚本的动态加载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-14 14:29:10" itemprop="dateCreated datePublished" datetime="2018-09-14T14:29:10+08:00">2018-09-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="我们平时如何挂载脚本"><a href="#我们平时如何挂载脚本" class="headerlink" title="我们平时如何挂载脚本?"></a>我们平时如何挂载脚本?</h4><p>众所周知，在web应用中，我们时常需要使用js脚本对应用做这样或者那样的操作。而仙贝们为了解放大家的双手，降低大家的开发成本，创造了很多具有各种用途，或者针对对应问题的解决方案。这些解决方案，被称作框架和库。 而作为这些脚本的使用者，我们只需要简单而又传统的将脚本使用script标签插入我们的应用中就行了。</p>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>test</title>
</head>
<body>
<script src="myscript.js"></script>
</body>
</html>

<p>如上文所说，这是简单而又传统的使用方法。事实上在技术快速迭代的今天，传统方式有时候并不能满足我们的需求。当一个webapp含有过多的功能的时候，我们的脚本可能越来越大。而用户的体验则是：这网站打开真慢啊～～～ 然而事实上我们功能做得相当的多，效果做得相当的好，大部分用户其实只是使用了其中的某几个基础功能而已。但只是为了所有功能能够使用而增加了加载量，似乎有些得不偿失。</p>
<h4 id="然后，我们有了动态加载脚本的想法"><a href="#然后，我们有了动态加载脚本的想法" class="headerlink" title="然后，我们有了动态加载脚本的想法"></a>然后，我们有了动态加载脚本的想法</h4><p>从_Netscape Navigator 4.0_为起点，浏览器厂商们都开始支持起了不同形态的动态html。通过dom api，程序猿们可以轻松的对节点进行各种操作。于是对我们来说，又有了新的方法去加载脚本。</p>
<p>var script = document.createElement(‘script’);<br>script.async = true;<br>script.src = ‘myScript.js’;<br>document.getElementsByTagName(‘head’)[0].appendChild(script);</p>
<p>当然了，这样的写法是最基础的增加方法。在这样的写法下，我们无法得知脚本到底有没有加载完，如果依赖脚本没有加载并解释完毕，那么我们加载它就没有任何意义，还会因此阻断所有相关操作。 谢天谢地，天无绝人之路，浏览器老板们还是给我们提供了方法对脚本加载情况进行探知。我们所知的onreadystatechange事件和onload事件可以帮我们判断脚本是否加载完毕～</p>
<p>script.onreadystatechange = script.onload = function (evt) {<br>var evt = evt ? evt : window.event;<br>if (!evt.readyState  evt.readyState === ‘loaded’  evt.readyState === ‘complete’) {<br>cb &amp;&amp; cb();<br>script.onreadystatechange = script.onload ＝ null;<br>script.parent.removeChild(script);<br>script = null;<br>}<br>}</p>
<h4 id="作为一个正常人，我们想不想加载更多东西呢？"><a href="#作为一个正常人，我们想不想加载更多东西呢？" class="headerlink" title="作为一个正常人，我们想不想加载更多东西呢？"></a>作为一个正常人，我们想不想加载更多东西呢？</h4><p>想！当然想。作为一个正常人，我们极其希望也load别的东西过来，那现在我们还有什么东西可以通过动态加载呢？css／picture／function都可以成为我们的加载对象。这时候，我们就该有一个简单的加载器了，聚合我们想要的功能，让我们解放双手！</p>
<p>var handler = {<br>js: jsHandler,<br>css: cssHandler,<br>fn: fnHandler<br>};</p>
<p>var Loader = function (src, type) {</p>
<p>if (src === undefined) {<br>throw new Error(‘木有参数’);<br>}<br>// 修正参数<br>if (!type) {<br>if (typeof src === ‘string’) {<br>if (/\.css$\.css\?/i.test(src)) {<br>type = ‘css’;<br>}<br>if (/\.js$\.js\?/i.test(src)) {<br>type = ‘js’;<br>}<br>}<br>if (typeof src === ‘function’) {<br>type = ‘fn’<br>}<br>}<br>type = type  ‘js’;</p>
<p>handler[type](src);<br>};</p>
<p>function jsHandler(src) {}</p>
<p>function cssHandler(href) {}</p>
<p>function fnHandler(fn) {}</p>
<h4 id="如何填充我们的函数"><a href="#如何填充我们的函数" class="headerlink" title="如何填充我们的函数"></a>如何填充我们的函数</h4><p><img data-src="http://www.w3cbest.com/wp-content/uploads/2018/09/lhtfg.jpg"> 我们有了处理不同类型加载项的逻辑，但首先，我们还是要完善jsHandler函数</p>
<h4 id="获取head元素"><a href="#获取head元素" class="headerlink" title="获取head元素"></a>获取head元素</h4><p>var doc = document;<br>var head = doc.head  doc.getElementsByTagName(“head”)[0]  doc.documentElement;</p>
<p>将document和head缓存起来，以便多次使用，这可以提高一点点的性能… 为jsHandler完善加载部分</p>
<p>function jsHandler(src, callback) {<br>var script = doc.createElement(‘script’);<br>script.async = true;<br>script.src = src;</p>
<p>// 对支持onload事件的浏览器做处理<br>var hasOnload = ‘onload’ in script;<br>if (hasOnload) {<br>script.onload = jsOnload;<br>script.onerror = function () {<br>jsOnload(true);<br>}<br>}</p>
<p>// 对支持onreadystatechange的浏览器做处理<br>else {<br>script.onreadystatechange = function() {<br>if (/loadedcomplete/.test(script.readyState)) {<br>jsOnload();<br>}<br>}<br>}</p>
<p>head.appendChild(script);</p>
<p>// 当事件<br>function jsOnload(error) {<br>isTimeout = false;<br>script.onload = script.onerror = script.onreadystatechange = null;<br>head.removeChild(script);<br>script = null;<br>callback(error);<br>}<br>}</p>
<p>在上面这段代码中，我们为加载js做了一系列处理，由于浏览器厂商的实现问题，我们要对脚本是否加载成功或失败作出判断，这是个很麻烦的事情，尤其是对需要向下兼容的同学来说。 从<a target="_blank" rel="noopener" href="http://qianduanblog.com/post/headjs.html">headjs</a>这篇文章的注释来看，脚本是否加载完毕依赖于onload事件，而ie9及以下依赖于对状态标志进行load或者complete字符的检测。</p>
<p>// IE 7/8 (2 events on 1st load)<br>// 1) event.type = readystatechange, s.readyState = loading<br>// 2) event.type = readystatechange, s.readyState = loaded</p>
<p>// IE 7/8 (1 event on reload)<br>// 1) event.type = readystatechange, s.readyState = complete</p>
<p>// event.type === ‘readystatechange’ &amp;&amp; /loaded¦complete/.test(s.readyState)</p>
<p>// IE 9 (3 events on 1st load)<br>// 1) event.type = readystatechange, s.readyState = loading<br>// 2) event.type = readystatechange, s.readyState = loaded<br>// 3) event.type = load , s.readyState = loaded</p>
<p>// IE 9 (2 events on reload)<br>// 1) event.type = readystatechange, s.readyState = complete<br>// 2) event.type = load , s.readyState = complete</p>
<p>// event.type === ‘load’ &amp;&amp; /loaded¦complete/.test(s.readyState)<br>// event.type === ‘readystatechange’ &amp;&amp; /loaded¦complete/.test(s.readyState)</p>
<p>// IE 10 (3 events on 1st load)<br>// 1) event.type = readystatechange, s.readyState = loading<br>// 2) event.type = load , s.readyState = complete<br>// 3) event.type = readystatechange, s.readyState = loaded</p>
<p>// IE 10 (3 events on reload)<br>// 1) event.type = readystatechange, s.readyState = loaded<br>// 2) event.type = load , s.readyState = complete<br>// 3) event.type = readystatechange, s.readyState = complete</p>
<p>// event.type === ‘load’ &amp;&amp; /loaded¦complete/.test(s.readyState)<br>// event.type === ‘readystatechange’ &amp;&amp; /complete/.test(s.readyState)</p>
<p>// Other Browsers (1 event on 1st load)<br>// 1) event.type = load, s.readyState = undefined</p>
<p>// Other Browsers (1 event on reload)<br>// 1) event.type = load, s.readyState = undefined</p>
<p>// event.type == ‘load’ &amp;&amp; s.readyState = undefined</p>
<p>当然，如果遇到了既不支持onload又不支持onreadystatechange的浏览器的时候，我们只能另寻他法了。 如果要加载的脚本是你写的，那你自己可以处理～如果加载的脚本不是你写的～哦喽，不在本文讨论范围之内～</p>
<h4 id="当你需要jsHandler检测加载是否超时的时候"><a href="#当你需要jsHandler检测加载是否超时的时候" class="headerlink" title="当你需要jsHandler检测加载是否超时的时候"></a>当你需要jsHandler检测加载是否超时的时候</h4><p>我们为jsHandler增加一个参数timeout，并在函数中实现如下逻辑</p>
<p>function jsHandler(src, callback, timeout) {<br>…<br>// 检测是否超时的标志<br>var isTimeout = true;<br>…</p>
<p>if (timeout) {<br>setTimeout(timeoutHandler, timeout);<br>}</p>
<p>head.appendChild(script);</p>
<p>function jsOnload(error) {<br>// 当在时间内完成操作时，不管是否成功，将超时标志设为false<br>isTimeout = false;<br>script.onload = script.onerror = script.onreadystatechange = null;<br>head.removeChild(script);<br>script = null;<br>callback(error);<br>}</p>
<p>function timeoutHandler() {<br>// 如果标志未改变，认为其超时<br>if (isTimeout) {<br>jsOnload(true);<br>}<br>}<br>}</p>
<h4 id="当我们同步执行代码的时候"><a href="#当我们同步执行代码的时候" class="headerlink" title="当我们同步执行代码的时候"></a>当我们同步执行代码的时候</h4><p>当我们需要加载一个或者多个脚本的时候，我们会发现，“奥我次奥，怎么请求了那么多次呢？这不科学。” 这是因为我们的loader在多处被调用或同步调用了，于是我们想啊，搞个map纪录缓存算了。于是乎： － 我们需要一些变量</p>
<p>// 用作存储脚本信息<br>var cache = {};<br>// 用作生成不重复的客户端id<br>var _cid = 0;<br>// 用作存储其他loader实例需要运行的脚本任务<br>var processCache = {};</p>
<p>// 加载状态标识<br>var DONE = ‘done’;<br>var REJECTED = ‘rejected’;<br>var PENDING = ‘pending’;<br>我们需要产生不同的存储id<br>/**<br>* 产生客户端id<br>* @return {Number} [description]<br>*/<br>function cid() {<br>return _cid++;<br>}</p>
<p>我们需要创建一个Script类，new一个实例用于存储任务的基本信息</p>
<p>/**<br>* Script对象，储存需要加载的任务的基本信息<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>*/<br>function Script(uri, type) {<br>this.uri = uri;<br>this.type = type;<br>this.cid = cid();<br>this.status = PENDING;<br>}</p>
<p>－ 当我们寻找缓存中的任务对象的时候，因该返回正确的对象。怎么寻找缓存呢，当然是通过地址来索引啦</p>
<p>/**<br>* 从缓存中获取需要的Script对象<br>* 如果没有，新建一个<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>* @return {Object} 需要的Script对象<br>*/<br>function get(uri, type) {<br>// 如果不存在于缓存中，创建一个新的Script对象<br>return cache[uri]  (cache[uri] = new Script(uri, type));<br>}</p>
<h4 id="如果我们的脚本或函数有别名怎么办！"><a href="#如果我们的脚本或函数有别名怎么办！" class="headerlink" title="如果我们的脚本或函数有别名怎么办！"></a>如果我们的脚本或函数有别名怎么办！</h4><p>var alias = {};<br>/**<br>* 获取有别名的Script对象<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>* @return {Object} Script Object<br>*/<br>function getCache(uri, type) {<br>var src = getAlias(uri);<br>return src ? get(src) : get(uri, type);<br>}</p>
<p>/**<br>* 获取真实地址<br>* @param {String} name [description]<br>* @return {[type]} return uri<br>*/<br>function getAlias(name) {<br>return alias[name];<br>}</p>
<p>别名的用途在于我们不用多次输入同样长度的uri,或者说是函数。</p>
<h4 id="现在，该填充我们的Loader类了。"><a href="#现在，该填充我们的Loader类了。" class="headerlink" title="现在，该填充我们的Loader类了。"></a>现在，该填充我们的Loader类了。</h4><p>我们要很清楚的知道，Loader需要做什么。 一个简单的Loader应该可以多次添加需要加载的内容，then或者add方法可以让用户添加任务。那它应该有一个内置的list，可以存储这些待添加的任务。 它也应该可以在全部脚本加载完的时候执行我们的callback，那么我们应该实现一个方法接受一个回调，在任务执行完时调用。 我们也要可以对某些地址进行别名命名，也需要设置超时时间 实现Loader类</p>
<p>/**<br>* Loader类<br>*/<br>var Loader = function () {<br>this.list = [];<br>this.timeout = 0;<br>this.callback = null;<br>};</p>
<p>实现then方法，使用then的时候应该可以连续使用</p>
<p>/**<br>* 实现的then方法<br>* @param {String} src 地址<br>* @param {String} type 类型<br>* @return {Object} Loader对象<br>*/<br>Loader.prototype.then = function(src, type) {<br>if (src === undefined) {<br>throw new Error(‘木有参数’);<br>}</p>
<p>// 修正参数<br>if (!type) {<br>if (typeof src === ‘string’) {<br>if (/\.css$\.css\?/i.test(src)) {<br>type = ‘css’;<br>}<br>if (/\.js$\.js\?/i.test(src)) {<br>type = ‘js’;<br>}<br>}<br>if (typeof src === ‘function’) {<br>type = ‘fn’<br>}<br>}</p>
<p>type = type  ‘js’;<br>this.list.push(getCache(src, type));<br>return this;<br>};</p>
<p>实现done方法</p>
<p>/**<br>* done方法，接受一个callback，在所有任务完成时调用<br>* @param {Function} cb 完成后的回调<br>* @return {Object} 第一次调用done后返回一个新的对象<br>*/<br>Loader.prototype.done = function(cb) {<br>if (this.callback === null) {<br>this.callback = cb;<br>}<br>if (!this.list.length) {<br>this.callback &amp;&amp; this.callback();<br>return;<br>}<br>var script = this.list.shift();<br>handler[script.type](this, script);<br>if (!this.called) {<br>this.called = true;<br>return new Loader();<br>}<br>};</p>
<p>实现config配置</p>
<p>Loader.prototype.config = function (opts) {<br>this.timeout = opts.timeout  0;<br>if (opts.alias &amp;&amp; !opts.alias.length) {<br>for (var i = opts.alias.length - 1; i &gt;= 0; i–) {<br>alias[i] = opts.alias[i];<br>}<br>}<br>}</p>
<h4 id="如何让错误集中显示"><a href="#如何让错误集中显示" class="headerlink" title="如何让错误集中显示"></a>如何让错误集中显示</h4><p>我们需要接入一个resolve方法，Loader类也应该有一个errors的列表来储存每次错误的信息，最后放到callback中集中显示。</p>
<p>function resolve(loader, s) {<br>if (s.error) {<br>loader.errors.push(s);<br>}<br>loader.done();<br>var cache = processCache[s.cid];<br>if (cache &amp;&amp; !cache.length) {<br>for (var i = 0, len = cache.length; i &lt; len; i++) {<br>cache.shift().loader.done();<br>}<br>}<br>}</p>
<p>var Loader = function () {<br>this.list = [];<br>this.timeout = 0;<br>this.errors = [];<br>this.callback = null;<br>};</p>
<p>最终，我们将所有的思路组装起来</p>
<p>(function (root, factory) {<br>if (typeof define === ‘function’ &amp;&amp; define.amd) {<br>// AMD. Register as an anonymous module.<br>define(factory);<br>} else {<br>// Browser globals<br>root.Loader = factory();<br>}<br>}(this, function () {</p>
<p>// 用作存储脚本信息<br>var cache = {};<br>// 用作生成不重复的客户端id<br>var _cid = 0;<br>// 用作存储其他loader实例需要运行的脚本任务<br>var processCache = {};<br>// 用作储存别名<br>window.alias = {};</p>
<p>// 加载状态标识<br>var DONE = ‘done’;<br>var REJECTED = ‘rejected’;<br>var PENDING = ‘pending’;</p>
<p>// 获取document,head<br>var doc = document;<br>var head = doc.head  doc.getElementsByTagName(“head”)[0]  doc.documentElement;</p>
<p>/**<br>* 产生客户端id<br>* @return {Number} [description]<br>*/<br>function cid() {<br>return _cid++;<br>}</p>
<p>/**<br>* Script对象，储存需要加载的任务的基本信息<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>*/<br>function Script(uri, type) {<br>this.uri = uri;<br>this.type = type;<br>this.cid = cid();<br>this.status = PENDING;<br>}</p>
<p>/**<br>* 从缓存中获取需要的Script对象<br>* 如果没有，新建一个<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>* @return {Object} 需要的Script对象<br>*/<br>function get(uri, type) {<br>// 如果不存在于缓存中，创建一个新的Script对象<br>return cache[uri]  (cache[uri] = new Script(uri, type));<br>}</p>
<p>/**<br>* 获取真实地址<br>* @param {String} name [description]<br>* @return {[type]} return uri<br>*/<br>function getAlias(name) {<br>return alias[name];<br>}</p>
<p>function getCache(uri, type) {<br>var opts = getAlias(uri);<br>return opts ? get(opts.uri, opts.type) : get(uri, type);<br>}</p>
<p>// 处理<br>var handler = {<br>js: jsHandler,<br>css: cssHandler,<br>fn: fnHandler<br>};</p>
<p>// 对函数的处理<br>function fnHandler(context, s) {<br>// 函数不需要判断是否为正在加载状态<br>try {<br>s.uri();<br>resolve(context, s);<br>}<br>catch (e) {<br>s.error = e.message;<br>resolve(context, s);<br>}<br>}</p>
<p>// 对css请求的处理<br>function cssHandler(context, s) {<br>// 当其他Loader实体中的任务已经完成时<br>if (s.status !== PENDING) {<br>resolve(context, s);<br>return;<br>}<br>var link = document.createElement(‘link’);<br>link.type = ‘text/css’;<br>link.rel = ‘stylesheet’<br>link.href = s.uri;<br>head.appendChild(link);<br>resolve(context, s);<br>};</p>
<p>// 对js动态加载的处理<br>function jsHandler(context, s) {</p>
<p>// 处理已完成任务<br>if (s.status !== PENDING) {<br>resolve(context, s);<br>return;<br>}</p>
<p>// 如果非第一个加载，将剩余的任务和任务关联的上下文塞进正在进行的进程中<br>if (s.changeState) {<br>processCache[s.cid] = processCache[s.cid]  [];<br>processCache[s.cid].push({ loader: context, s: s });<br>return;<br>}</p>
<p>s.changeState = true;</p>
<p>// 设置超时标志<br>var isTimeout = true;<br>var script = document.createElement(‘script’);<br>script.async = true;<br>script.src = s.uri;</p>
<p>// 如果支持onload事件<br>var hasOnload = ‘onload’ in script;</p>
<p>if (hasOnload) {<br>script.onload = jsOnload;<br>script.onerror = function () {<br>jsOnload(‘ScriptError’);<br>}<br>}<br>else {<br>script.onreadystatechange = function() {<br>if (/loadedcomplete/.test(script.readyState)) {<br>jsOnload();<br>}<br>}<br>}</p>
<p>// 如果设置了超时，启动一个计时器<br>if (context.timeout) {<br>setTimeout(timeoutHandler, context.timeout);<br>}</p>
<p>head.appendChild(script);</p>
<p>function jsOnload(error) {<br>isTimeout = false;<br>script.onload = script.onerror = script.onreadystatechange = null;<br>head.removeChild(script);<br>script = null;<br>if (error &amp;&amp; typeof error === ‘string’) {<br>s.error = error;<br>}<br>resolve(context, s);<br>}</p>
<p>function timeoutHandler() {<br>if (isTimeout) {<br>console.log(‘timeout’);<br>jsOnload(‘RequestTimeout’);<br>}<br>}<br>}</p>
<p>function resolve(loader, s) {<br>if (s.error) {<br>loader.errors.push(s);<br>}<br>loader.done();<br>var cache = processCache[s.cid];<br>if (cache &amp;&amp; !cache.length) {<br>for (var i = 0, len = cache.length; i &lt; len; i++) {<br>cache.shift().loader.done();<br>}<br>}<br>}</p>
<p>var Loader = function () {<br>this.list = [];<br>this.errors = [];<br>this.timeout = [];<br>this.callback = null;<br>};</p>
<p>Loader.prototype.then = function(src, type) {<br>if (src === undefined) {<br>throw new Error(‘木有参数’);<br>}</p>
<p>// 修正参数<br>if (!type) {<br>if (typeof src === ‘string’) {<br>if (/\.css$\.css\?/i.test(src)) {<br>type = ‘css’;<br>}<br>if (/\.js$\.js\?/i.test(src)) {<br>type = ‘js’;<br>}<br>}<br>if (typeof src === ‘function’) {<br>type = ‘fn’<br>}<br>}</p>
<p>type = type  ‘js’;<br>this.list.push(getCache(src, type));<br>return this;<br>};</p>
<p>Loader.prototype.done = function(cb) {<br>if (this.callback === null) {<br>this.callback = cb;<br>}<br>if (!this.list.length) {<br>this.callback &amp;&amp; this.callback(this.errors);<br>return;<br>}<br>var script = this.list.shift();<br>handler[script.type](this, script);<br>if (!this.called) {<br>this.called = true;<br>return new Loader();<br>}<br>};</p>
<p>Loader.prototype.config = function (opts) {<br>this.timeout = opts.timeout  0;<br>if (opts.alias &amp;&amp; !opts.alias.length) {<br>for (var i in alias) {</p>
<p>}<br>for (var i = opts.alias.length - 1; i &gt;= 0; i–) {<br>alias[i] = opts.alias[i]<br>}<br>}<br>return this;<br>};</p>
<p>return Loader;<br>}));</p>
<p>除了此类常规的写法，我们其实还可以使用其他更多的方法来实现脚本动态加载，比如自定义事件，比如模块化加载的实现，比如promise实现等等 这篇文章的意义在于开阔思维，回顾基础。 下面的observer对象实现了一个简单的事件注册，监听，销毁的功能，对模式有过研究或者码力深厚的同学肯定不陌生。</p>
<p>var observer = (function () {</p>
<p>var list = {};</p>
<p>var on = function (evt, cb) {<br>if (!list[evt]) {<br>list[evt] = [];<br>}<br>list[evt].push(cb);<br>};</p>
<p>var trigger = function () {<br>var evtName = Array.prototype.shift.call(arguments);<br>callbacks = list[evtName];<br>if (!callbacks  callbacks.length === 0) {<br>return;<br>}<br>for (var i = 0, len = callbacks.length; i &lt; len; i++) {<br>callbacks[i].apply(this, arguments);<br>}<br>};</p>
<p>var off = function (evt, fn) {<br>var callbacks = list[evt];<br>if (!callbacks) {<br>return;<br>}<br>if (!fn) {<br>callbacks &amp;&amp; callbacks.length = 0;<br>return;<br>}<br>for (var i = 0, len = callbacks.length i &lt; len; i++) {<br>if (fn === callbacks[i]) {<br>callbacks.splice(i, 1);<br>}<br>}<br>};</p>
<p>// 暴露对外接口<br>return {<br>trigger: trigger,<br>on: on,<br>off: off<br>}<br>})();</p>
<p>转载：<a target="_blank" rel="noopener" href="http://eux.baidu.com/blog">http://eux.baidu.com/blog</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/13/%E4%BD%BF%E7%94%A8javascript%E6%9B%B4%E6%96%B0css%E5%8F%98%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/13/%E4%BD%BF%E7%94%A8javascript%E6%9B%B4%E6%96%B0css%E5%8F%98%E9%87%8F/" class="post-title-link" itemprop="url">使用JavaScript更新CSS变量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-13 15:57:30" itemprop="dateCreated datePublished" datetime="2018-09-13T15:57:30+08:00">2018-09-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一个CSS变量（正式称为“ CSS自定义属性 ”） html</p>
<div class="mover"></div>

<p>css</p>
<p>:root {<br>    –mouse-x: 0px;<br>    –mouse-y: 0px;<br>}</p>
<p>你可以用它们来设定一个位置： css</p>
<p>.mover {<br>    left: var(–mouse-x);<br>    top: var(–mouse-y);<br>}</p>
<p>如果要从JavaScript更新这些值，您需要： js</p>
<p>let root = document.documentElement;<br>root.addEventListener(“mousemove”, e =&gt; {<br>    root.style.setProperty(‘–mouse-x’, e.clientX + “px”);<br>    root.style.setProperty(‘–mouse-y’, e.clientY + “px”);<br>});</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/13/%E5%90%91%E8%A1%A8%E5%8D%95%E6%B7%BB%E5%8A%A0%E9%AA%8C%E8%AF%81%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/13/%E5%90%91%E8%A1%A8%E5%8D%95%E6%B7%BB%E5%8A%A0%E9%AA%8C%E8%AF%81%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">表单验证的最简单方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-13 15:35:19" itemprop="dateCreated datePublished" datetime="2018-09-13T15:35:19+08:00">2018-09-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>向HTML表单添加验证将确保用户以正确的格式准确地输入数据。在过去，验证表单输入需要使用JavaScript插件，但是现在大多数浏览器都有可以处理大部分验证的内置解决方案。 在本教程中，我们将向您展示如何仅使用本地HTML输入属性向表单添加验证规则。 项目概览 为了演示创建验证规则的过程，我们准备了一个简单的HTML注册表单Bootstrap 4。你可以点击下面的图片来打开一个现场演示。 布局 HTML 我们的设计包括一个带有两个输入字段和一个提交按钮的引导表单。在本例中，我们使用了3种不同类型的输入字段-文本输入、密码输入和电子邮件输入。</p>
<div class="registration-form">
<form>
<h3 class="text-center">Create your account</h3>
<div class="form-group">
<input class="form-control item" type="text" name="username" maxlength="15" minlength="4" pattern="^\[a-zA-Z0-9\_.-\]\*$" id="username" placeholder="Username" required>
</div>
<div class="form-group">
<input class="form-control item" type="password" name="password" minlength="6" id="password" placeholder="Password" required>
</div>
<div class="form-group">
<input class="form-control item" type="email" name="email" id="email" placeholder="Email" required>
</div>
<div class="form-group">
<button class="btn btn-primary btn-block create-account" type="submit">Create Account</button>
</div>
</form>
</div>

<p>CSS 我们还添加了一些基本的CSS样式，以使表单更加简单。</p>
<p>html {<br>background-color:#214c84;<br>background-blend-mode:overlay;<br>display:flex;<br>align-items:center;<br>justify-content:center;<br>height:100%;<br>}</p>
<p>body {<br>background-color:transparent;<br>}</p>
<p>.registration-form {<br>padding:50px 0;<br>}</p>
<p>.registration-form form {<br>max-width:800px;<br>padding:50px 70px;<br>border-radius:10px;<br>box-shadow:4px 4px 15px rgba(0, 0, 0, 0.2);<br>background-color:#fff;<br>}</p>
<p>.registration-form form h3 {<br>font-weight:bold;<br>margin-bottom:30px;<br>}</p>
<p>.registration-form .item {<br>border-radius:10px;<br>margin-bottom:25px;<br>padding:10px 20px;<br>}</p>
<p>.registration-form .create-account {<br>border-radius:30px;<br>padding:10px 20px;<br>font-size:18px;<br>font-weight:bold;<br>background-color:#3f93ff;<br>border:none;<br>color:white;<br>margin-top:20px;<br>}</p>
<p>@media (max-width: 576px) {<br>.registration-form form {<br>padding:50px 20px;<br>}<br>}</p>
<p>验证类型 HTML 5提供了一种使用输入属性进行内联验证的好方法。有大量的属性可用，我们将只看一些最常见的。要获得完整的列表，您可以访问这个优秀的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input">MDN指南</a>. required 此属性指定输入字段不能为空。它要求用户在提交表单之前输入一些内容。</p>
<input class="form-control item" type="email" name="email" id="email" placeholder="Email" required>

<p>maxlength 和 minlength 指定用户可以在输入字段中输入的最大/最小符号数。这在密码字段中尤其有用，因为更长的密码意味着更安全的密码。</p>
<input class="form-control item" type="password" name="password" minlength="6" id="password" placeholder="Password" required>

<p>pattern 指定必须匹配以传递输入数据的正则表达式。它可以与以下输入类型一起使用：文本、搜索、url、电子邮件和密码。</p>
<input class="form-control item" type="text" name="username" maxlength="15" minlength="4" pattern="^\[a-zA-Z0-9\_.-\]\*$" id="username" placeholder="Username" required>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/13/%E7%94%A8css3%E5%92%8Cjquery%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E6%96%9C%E8%A7%92%E7%9A%84%E9%80%89%E9%A1%B9%E5%8D%A1%E9%9D%A2%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/13/%E7%94%A8css3%E5%92%8Cjquery%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E6%96%9C%E8%A7%92%E7%9A%84%E9%80%89%E9%A1%B9%E5%8D%A1%E9%9D%A2%E6%9D%BF/" class="post-title-link" itemprop="url">用css3和jquery制作一个带有斜角的选项卡面板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-13 15:24:07" itemprop="dateCreated datePublished" datetime="2018-09-13T15:24:07+08:00">2018-09-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天我们将使用CSS 3 gradients技术创建一个好看的带有斜角的选项卡面板。 <img data-src="http://www.w3cbest.com/wp-content/uploads/2018/09/tabs1.jpg"> 下面就直接上代码</p>
<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><ul id="tabs">
<li><a href="#" title="tab1">tab1</a></li>
<li><a href="#" title="tab2">tab2</a></li>
<li><a href="#" title="tab3">tab3</a></li>
<li><a href="#" title="tab4">tab4</a></li>
</ul>

<div id="content">
<div id="tab1">tab1 - content</div>
<div id="tab2">tab2 - content</div>
<div id="tab3">tab3 - content</div>
<div id="tab4">tab4 - content</div>
</div>

<h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p>#tabs {<br>overflow: auto;<br>width: 100%;<br>list-style: none;<br>margin: 0;<br>padding: 0;<br>}</p>
<p>#tabs li {<br>margin: 0;<br>padding: 0;<br>float: left;<br>}</p>
<p>#tabs a {<br>box-shadow: -4px 0 0 rgba(0, 0, 0, .2);<br>background: #ad1c1c;<br>background: linear-gradient(225deg, transparent 10px, #ad1c1c 10px);<br>text-shadow: 0 1px 0 rgba(0,0,0,.5);<br>color: #fff;<br>float: left;<br>font: bold 12px/35px ‘Lucida sans’, Arial, Helvetica;<br>height: 35px;<br>padding: 0 30px;<br>text-decoration: none;<br>}</p>
<p>#tabs a:hover {<br>background: #c93434;<br>background: linear-gradient(225deg, transparent 10px, #c93434 10px);<br>}</p>
<p>#tabs a:focus {<br>outline: 0;<br>}</p>
<p>#tabs #current a {<br>background: #fff;<br>background: linear-gradient(225deg, transparent 10px, #fff 10px);<br>text-shadow: none;<br>color: #333;<br>}</p>
<p>#content {<br>background-color: #fff;<br>background-image: linear-gradient(top, #fff, #ddd);<br>border-radius: 0 2px 2px 2px;<br>box-shadow: 0 2px 2px #000, 0 -1px 0 #fff inset;<br>padding: 30px;<br>}</p>
<p>/* 这里的高度可随意*/<br>#content div {<br>height: 220px;<br>}</p>
<h4 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h4><p>下面的代码可能不是最好的，但我认为它相当不错</p>
<p>$(document).ready(function() {<br>$(“#content div”).hide(); // 最初隐藏所有内容<br>$(“#tabs li:first”).attr(“id”,”current”); // 激活第一个选项卡<br>$(“#content div:first”).fadeIn(); // 显示第一个标签内容</p>
<p>$(‘#tabs a’).click(function(e) {<br>e.preventDefault();<br>$(“#content div”).hide(); // 隐藏所有内容<br>$(“#tabs li”).attr(“id”,””); // 重置Id<br>$(this).parent().attr(“id”,”current”); // 这里点击后激活<br>$(‘#’ + $(this).attr(‘title’)).fadeIn(); // 显示当前选项卡的内容<br>});<br>})();</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/10/art-template-js%E5%85%B3%E4%BA%8Echeckbox%E3%80%81radio%E9%80%89%E4%B8%AD%E5%90%8E%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/10/art-template-js%E5%85%B3%E4%BA%8Echeckbox%E3%80%81radio%E9%80%89%E4%B8%AD%E5%90%8E%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93/" class="post-title-link" itemprop="url">art-template.js关于checkbox、radio选中后返回数据如何渲染</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-10 15:44:58" itemprop="dateCreated datePublished" datetime="2018-09-10T15:44:58+08:00">2018-09-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>假如我们有一个多选和单选列表, 图片 我们从后端拿到数据后想在初始化的时候按照数据的值进行渲染，是选中的就显示选中状态，没有选中的就显示默认状态, 假如这是我们拿到的数据（理想中的数据应该是这样的）,如下：</p>
<pre class="language-none"><code class="language-none">[
    &#123; &quot;code&quot;: &quot;1&quot;, &quot;name&quot;: &quot;语文&quot;, &quot;content&quot;: &quot;1&quot;, &quot;checked&quot;: false &#125;,
    &#123; &quot;code&quot;: &quot;2&quot;, &quot;name&quot;: &quot;数学&quot;, &quot;content&quot;: &quot;2&quot;, &quot;checked&quot;: true &#125;,
    &#123; &quot;code&quot;: &quot;3&quot;, &quot;name&quot;: &quot;英语&quot;, &quot;content&quot;: &quot;3&quot;, &quot;checked&quot;: true &#125;,
    &#123; &quot;code&quot;: &quot;4&quot;, &quot;name&quot;: &quot;物理&quot;, &quot;content&quot;: &quot;4&quot;, &quot;checked&quot;: false &#125;
]</code></pre>

<p>那么就很简单的了，就可以直接进行数据渲染，如下： html</p>
<pre class="language-none"><code class="language-none">&lt;div class&#x3D;&quot;form-check&quot; id&#x3D;&quot;formCheckBox&quot;&gt;&lt;&#x2F;div&gt;</code></pre>

<p>js</p>
<pre class="language-none"><code class="language-none">res &#x3D; [
    &#123; &quot;code&quot;: &quot;1&quot;, &quot;name&quot;: &quot;语文&quot;, &quot;content&quot;: &quot;1&quot;, &quot;checked&quot;: false &#125;,
    &#123; &quot;code&quot;: &quot;2&quot;, &quot;name&quot;: &quot;数学&quot;, &quot;content&quot;: &quot;2&quot;, &quot;checked&quot;: true &#125;,
    &#123; &quot;code&quot;: &quot;3&quot;, &quot;name&quot;: &quot;英语&quot;, &quot;content&quot;: &quot;3&quot;, &quot;checked&quot;: true &#125;,
    &#123; &quot;code&quot;: &quot;4&quot;, &quot;name&quot;: &quot;物理&quot;, &quot;content&quot;: &quot;4&quot;, &quot;checked&quot;: false &#125;
]
document.getElementById(&#39;formCheckBox&#39;).innerHTML &#x3D; template(&#39;checkboxTemp&#39;, &#123; data: res &#125;);</code></pre>

<p>template</p>
<pre class="language-none"><code class="language-none">&lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;checkboxTemp&quot;&gt;
&#123;&#123;each data item&#125;&#125;
&lt;label for&#x3D;&quot;checkbox&#123;&#123;item.code&#125;&#125;&quot;&gt;
    &lt;input class&#x3D;&quot;form-check-input&quot; type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;checkbox&#123;&#123;item.code&#125;&#125;&quot; value&#x3D;&quot;&#123;&#123;item.content&#125;&#125;&quot; &#123;&#123;if item.checked &#x3D;&#x3D; true&#125;&#125;checked&#123;&#123;&#x2F;if&#125;&#125;&gt; &#123;&#123;item.name&#125;&#125;
&lt;&#x2F;label&gt;
&#123;&#123;&#x2F;each&#125;&#125;
&lt;&#x2F;script&gt;</code></pre>

<p>如果拿到的数据是乱七八糟的后端给出来的怎么办，那我就需要处理一下数据，如下：</p>
<pre class="language-none"><code class="language-none">&#123;&quot;data&quot;: [
    &#123; &quot;code&quot;: &quot;1&quot;, &quot;name&quot;: &quot;语文&quot;, &quot;content&quot;: &quot;1&quot; &#125;,
    &#123; &quot;code&quot;: &quot;2&quot;, &quot;name&quot;: &quot;数学&quot;, &quot;content&quot;: &quot;2&quot; &#125;,
    &#123; &quot;code&quot;: &quot;3&quot;, &quot;name&quot;: &quot;英语&quot;, &quot;content&quot;: &quot;3&quot; &#125;,
    &#123; &quot;code&quot;: &quot;4&quot;, &quot;name&quot;: &quot;物理&quot;, &quot;content&quot;: &quot;4&quot; &#125;
    ],
&quot;select&quot;: [1, 4]
&#125;</code></pre>
<p>如果是这种的话我们就先渲染，然后再用JQ的each循环改变选中状态，如下： html</p>
<pre class="language-none"><code class="language-none">&lt;div class&#x3D;&quot;form-check&quot; id&#x3D;&quot;formCheckBox&quot;&gt;&lt;&#x2F;div&gt;</code></pre>

<p>js</p>
<pre class="language-none"><code class="language-none">res &#x3D; &#123;
    &quot;data&quot;: [
        &#123; &quot;code&quot;: &quot;1&quot;, &quot;name&quot;: &quot;语文&quot;, &quot;content&quot;: &quot;1&quot; &#125;,
        &#123; &quot;code&quot;: &quot;2&quot;, &quot;name&quot;: &quot;数学&quot;, &quot;content&quot;: &quot;2&quot; &#125;,
        &#123; &quot;code&quot;: &quot;3&quot;, &quot;name&quot;: &quot;英语&quot;, &quot;content&quot;: &quot;3&quot; &#125;,
        &#123; &quot;code&quot;: &quot;4&quot;, &quot;name&quot;: &quot;物理&quot;, &quot;content&quot;: &quot;4&quot; &#125;
    ],
    &quot;select&quot;: [1, 4]
&#125;;
document.getElementById(&#39;formCheckBox&#39;).innerHTML &#x3D; template(&#39;tpl&#39;, &#123; data: res.data &#125;);
$(&#39;#formCheckBox label&#39;).each(function() &#123;
    var cont &#x3D; $(this).find(&#39;input&#39;).val();
    for (var i &#x3D; 0; i &lt; check.value.length; i++) &#123;
        if (check.select[i] &#x3D;&#x3D; val) &#123;
            $(this).find(&#39;input&#39;).prop(&#39;checked&#39;, true)
        &#125;
    &#125;
&#125;)</code></pre>

<p>template</p>
<pre class="language-none"><code class="language-none">&lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;tpl&quot;&gt;
    &#123;&#123;each data&#125;&#125;
    &lt;label for&#x3D;&quot;checkbox&#123;&#123;$value.code&#125;&#125;&quot;&gt;
    &lt;input class&#x3D;&quot;form-check-input&quot; type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;checkbox&#123;&#123;$value.code&#125;&#125;&quot; value&#x3D;&quot;&#123;&#123;$value.content&#125;&#125;&quot;&gt; &#123;&#123;$value.name&#125;&#125;&lt;&#x2F;label&gt;
    &#123;&#123;&#x2F;each&#125;&#125;
&lt;&#x2F;script&gt;</code></pre>

<p>后记：其实拿到的数据基本上如果可以直接用的话就不必处理，但是有的数据是需要重新处理重新组合成我们用的那种结果，比如上面最后一个例子提到的，他有两个checkbox被选中，但是我们渲染的时候会用data数据渲染，那么你可以把select的两标记组合到data里面，如:</p>
<pre class="language-none"><code class="language-none">res &#x3D; &#123; 
    &quot;data&quot;: [
        &#123; 
            &quot;code&quot;: &quot;1&quot;, 
            &quot;name&quot;: &quot;语文&quot;, 
            &quot;content&quot;: &quot;1&quot;, 
            &quot;select&quot;: true&#x2F;&#x2F; 这个就是标记被选中
        &#125;,
        ....
    ]
&#125;</code></pre>

<p>这样就可以直接渲染数据了，方法有很多种，就看你怎么理解，想怎么用</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2018/09/06/%E7%94%A8display-flex%E6%96%B0%E5%B1%9E%E6%80%A7%E5%81%9A%E4%B8%AA%E5%AF%BC%E8%88%AA%E6%8E%92%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/06/%E7%94%A8display-flex%E6%96%B0%E5%B1%9E%E6%80%A7%E5%81%9A%E4%B8%AA%E5%AF%BC%E8%88%AA%E6%8E%92%E5%88%97/" class="post-title-link" itemprop="url">用display:flex新属性做个导航排列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-06 13:30:29" itemprop="dateCreated datePublished" datetime="2018-09-06T13:30:29+08:00">2018-09-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>现在你得导航还在用float来设置水平排列吗？ 随着css的强大新的属性的增加，浏览器的内核升级，让我们的代码越写越简单，以前我们在写代码设置某一块水平排列用的最多的应该是float了吧，80后的程序员最有感受，深受低版本浏览器的残害(IE6)，乃至现在还会随手敲一个float出来(包括我)。不过现在好了，随着浏览器的内核升级，很多企业也已抛弃低版本浏览器，css的很多新属性就可以用到了，我们今天就用这个新属性flex做个导航水平排列,如下：</p>
<ul>
<li>  首页</li>
<li>  关于我们</li>
<li>  产品展示</li>
<li>  客户支持</li>
<li>  联系我们</li>
</ul>
<p>html</p>
<ul class="navbar">
  <li><a href="/">首页</a></li>
  <li><a href="/">关于我们</a></li>
  <li><a href="/">产品展示</a></li>
  <li><a href="/">客户支持</a></li>
  <li><a href="/">联系我们</a></li>
</ul>

<p>css</p>
<p>.navbar{<br>  display: flex;<br>  flex-direction: row;<br>  flex-wrap: nowrap;<br>  justify-content: flex-start;<br>  align-items: stretch;<br>  align-content: stretch;<br>}</p>
<p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 我们来测试一下他的兼容性</p>
<p>复制代码</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Tom</p>
  <div class="site-description" itemprop="description">w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">338</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">W3Cbest前端开发</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
