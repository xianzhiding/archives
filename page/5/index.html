<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xianzhiding.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
<meta property="og:type" content="website">
<meta property="og:title" content="前端开发 大前端 W3Cbest">
<meta property="og:url" content="https://xianzhiding.github.io/page/5/index.html">
<meta property="og:site_name" content="前端开发 大前端 W3Cbest">
<meta property="og:description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tom">
<meta property="article:tag" content="前端开发,es5,es6,es10,css,javascript,html,flexbox,grid,echarts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xianzhiding.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>前端开发 大前端 W3Cbest</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">前端开发 大前端 W3Cbest</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个专注 WEB 开发的技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/04/20/notyf-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84-javascript-%E9%80%9A%E7%9F%A5%E6%8F%92%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/20/notyf-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84-javascript-%E9%80%9A%E7%9F%A5%E6%8F%92%E4%BB%B6/" class="post-title-link" itemprop="url">Notyf – 响应式的 JavaScript 通知插件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-20 13:31:01" itemprop="dateCreated datePublished" datetime="2019-04-20T13:31:01+08:00">2019-04-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%B5%84%E6%BA%90/" itemprop="url" rel="index"><span itemprop="name">资源</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简要教程"><a href="#简要教程" class="headerlink" title="简要教程"></a>简要教程</h2><p>notyf.js是一款超级简单的响应式纯js消息通知插件。它使用纯javascript来制作，没有任何外部依赖，通过简单的设置，即可生成漂亮的消息通知效果。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以通过npm来安装notyf.js消息通知插件。</p>
<pre class="language-none"><code class="language-none">npm i notyf</code></pre>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在页面中引入notyf.min.css和notyf.min.js文件。</p>
<pre class="language-none"><code class="language-none">&lt;html&gt;
&lt;head&gt;
    ...
    &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;&#x2F;path&#x2F;to&#x2F;notyf.min.css&quot;&gt;
&lt;&#x2F;head&gt;
&lt;body&gt;
    ...
    &lt;script src&#x3D;&quot;&#x2F;path&#x2F;to&#x2F;notyf.min.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>

<h2 id="初始化插件"><a href="#初始化插件" class="headerlink" title="初始化插件"></a>初始化插件</h2><p>notyf.js消息通知插件的使用方法如下：</p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F;创建一个Notyf实例对象
var notyf &#x3D; new Notyf();
&#x2F;&#x2F;显示一条警告消息
notyf.error(&#39;You must fill out the form before moving forward&#39;);
&#x2F;&#x2F;显示一条成功消息
notyf.success(&#39;Your changes have been successfully saved!&#39;);</code></pre>

<h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p>notyf.js消息通知插件的可用配置参数如下：</p>
<hr>
<h2 id="参数-类型-默认值-描述"><a href="#参数-类型-默认值-描述" class="headerlink" title="|参数       |类型    |默认值   |描述                           |"></a>|参数       |类型    |默认值   |描述                           |</h2><h2 id="delay-Number-2000-消息通知显示的延迟时间，单位毫秒"><a href="#delay-Number-2000-消息通知显示的延迟时间，单位毫秒" class="headerlink" title="|delay      |Number |2000     |消息通知显示的延迟时间，单位毫秒 |"></a>|delay      |Number |2000     |消息通知显示的延迟时间，单位毫秒 |</h2><h2 id="alertIcon-String-预定义图标-警告消息显示的图标的class类"><a href="#alertIcon-String-预定义图标-警告消息显示的图标的class类" class="headerlink" title="|alertIcon  |String |预定义图标|警告消息显示的图标的class类     |"></a>|alertIcon  |String |预定义图标|警告消息显示的图标的class类     |</h2><h2 id="confirmIcon-String-预定义图标-成功消息显示的图标的class类"><a href="#confirmIcon-String-预定义图标-成功消息显示的图标的class类" class="headerlink" title="|confirmIcon|String    |预定义图标|成功消息显示的图标的class类     |"></a>|confirmIcon|String    |预定义图标|成功消息显示的图标的class类     |</h2><p>下面的例子是消息在用户点击按钮后1秒钟显示，并使用FontAwesome字体图标作为警告框和成功消息框的图标。</p>
<pre class="language-none"><code class="language-none">var notyf &#x3D; new Notyf(&#123;
    delay: 1000,
    alertIcon: &#39;icon icon-exclamation-circle&#39;,
    confirmIcon: &#39;icon icon-check-circle&#39;
&#125;)</code></pre>

<p>演示地址：<a target="_blank" rel="noopener" href="https://carlosroso.com/notyf/">https://carlosroso.com/notyf/</a><br>github地址：<a target="_blank" rel="noopener" href="https://github.com/caroso1222/notyf">https://github.com/caroso1222/notyf</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/04/16/%E5%A4%A7%E9%83%A8%E5%88%86%E6%95%99%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%91%8A%E8%AF%89%E4%BD%A0%E7%9A%8412%E4%B8%AAJS%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/16/%E5%A4%A7%E9%83%A8%E5%88%86%E6%95%99%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%91%8A%E8%AF%89%E4%BD%A0%E7%9A%8412%E4%B8%AAJS%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">大部分教程不会告诉你的12个JS技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-16 09:25:30" itemprop="dateCreated datePublished" datetime="2019-04-16T09:25:30+08:00">2019-04-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-过滤唯一值"><a href="#1-过滤唯一值" class="headerlink" title="1. 过滤唯一值"></a>1. 过滤唯一值</h2><p>ES6 引入了 Set 对象和延展（spread）语法…，我们可以用它们来创建一个只包含唯一值的数组。</p>
<p>const array = [1, 1, 2, 3, 5, 5, 1]<br>const uniqueArray = […new Set(array)];<br>console.log(uniqueArray); // Result: [1, 2, 3, 5]</p>
<p>在 ES6 之前，获得同样的数组需要更多的代码！ 这个技巧可以支持包含原始类型的数组：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>string</code> 和 number</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/04/16/%E5%A4%A7%E9%83%A8%E5%88%86%E6%95%99%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%91%8A%E8%AF%89%E4%BD%A0%E7%9A%8412%E4%B8%AAJS%E6%8A%80%E5%B7%A7/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/04/10/10%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84javascript%E5%92%8Ccss%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/10/10%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84javascript%E5%92%8Ccss%E5%BA%93/" class="post-title-link" itemprop="url">10个有趣的JavaScript和CSS库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-10 17:39:42" itemprop="dateCreated datePublished" datetime="2019-04-10T17:39:42+08:00">2019-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%B5%84%E6%BA%90/" itemprop="url" rel="index"><span itemprop="name">资源</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://cube.dev/"><img data-src="https://file.w3cbest.com/file/images/cubejs.png"></a> <a target="_blank" rel="noopener" href="https://cube.dev/">Cube.js</a> 强大的开源框架，用于开发复杂的，定制的分析系统。由前端SDK和API后端组成，适用于大多数数据库，包括MySQL，Postreges和MongoDB。 <a target="_blank" rel="noopener" href="https://github.com/kognise/water.css"><img data-src="https://file.w3cbest.com/file/images/watercss.png"></a> <a target="_blank" rel="noopener" href="https://github.com/kognise/water.css">Water.css</a> 一个just-add-css框架，它可以应用样式而无需定义元素类。只需通过CDN将其包含在您的项目中，您的所有页面都会自动显示得更好。包括明暗主题，可通过SCSS定制。 <a target="_blank" rel="noopener" href="https://codex.so/editor"><img data-src="https://file.w3cbest.com/file/images/editorjs.png"></a> <a target="_blank" rel="noopener" href="https://codex.so/editor">Editor.js</a> 富文本和媒体编辑器，以JSON格式输出数据。它是完全模块化的，由“块”组成，这意味着每个结构单元都是它自己的块（例如Paragraph，Heading，Image都是块），用户可以轻松编写自己的插件来进一步扩展编辑器。 <a target="_blank" rel="noopener" href="https://github.com/alikinvv/stepper"><img data-src="https://file.w3cbest.com/file/images/stepper.png"></a> <a target="_blank" rel="noopener" href="https://github.com/alikinvv/stepper">Stepper</a> 漂亮的数字Stepper组件，非常适合upvote / downvote控件或其他计数器元素。非常精美的动画，点击箭头时有一个黄油般的CSS效果。 <a target="_blank" rel="noopener" href="https://github.com/leeoniya/dropcss"><img data-src="https://file.w3cbest.com/file/images/dropcsss.png"></a> <a target="_blank" rel="noopener" href="https://github.com/leeoniya/dropcss">DropCSS</a> 彻底的CSS清理器，它可以获取HTML和CSS并仅返回实际使用的样式。它删除所有未使用的样式块，重复选择器，@ keyframes等。高度优化，速度极快。 <a target="_blank" rel="noopener" href="https://github.com/twitter/twemoji"><img data-src="https://file.w3cbest.com/file/images/twemoji.png"></a> <a target="_blank" rel="noopener" href="https://github.com/twitter/twemoji">Twemoji</a> Twitter团队提供的优秀图书馆，可在所有平台上提供标准的Unicode表情符号支持。拥有超过3000个emojis和一个可靠的API，当您想要将emojis添加到您的应用程序时，它可以是完美的解决方案。 <a target="_blank" rel="noopener" href="https://foreseaz.github.io/react-loadcon/"><img data-src="https://file.w3cbest.com/file/images/react-loadcon.png"></a> <a target="_blank" rel="noopener" href="https://foreseaz.github.io/react-loadcon/">React LoadCon</a> React组件，允许您使用一系列动态生成的图像为网站的图标设置动画。此效果可以用作进度或加载指示器，或者只是作为一个很酷的小动画来使您的页面脱颖而出。 <a target="_blank" rel="noopener" href="https://github.com/matvp91/indigo-player"><img data-src="https://file.w3cbest.com/file/images/indigoplayer.png"></a> <a target="_blank" rel="noopener" href="https://github.com/matvp91/indigo-player">Indigo Player</a> 基于React的视频播放器，具有开箱即用的功能，如字幕，缩略图，质量选择等。高度可扩展，现代化，并支持大多数流行的视频格式和编解码器。 <a target="_blank" rel="noopener" href="https://github.com/niklasvh/html2canvas"><img data-src="https://file.w3cbest.com/file/images/html2canvas.png"></a> <a target="_blank" rel="noopener" href="https://github.com/niklasvh/html2canvas">html2canvas</a> 这个很酷的脚本获取页面中的元素和样式，并通过呈现DOM的副本来捕获“屏幕截图”。由于屏幕截图基于DOM，因此它们可能不是100％准确，但该库仍然是调试和自动化测试的绝佳工具。 <a target="_blank" rel="noopener" href="https://github.com/jshjohnson/Choices"><img data-src="https://file.w3cbest.com/file/images/choices.png"></a> <a target="_blank" rel="noopener" href="https://github.com/jshjohnson/Choices">Choices</a> 轻量级库，用于制作高度可自定义的选择框，文本区域和其他表单输入。类似于<a target="_blank" rel="noopener" href="https://select2.org/">Select2</a>和<a target="_blank" rel="noopener" href="https://selectize.github.io/selectize.js/">Selectize</a>但没有jQuery依赖。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/04/09/%E7%90%86%E8%A7%A3-css-%E5%B8%83%E5%B1%80%E5%92%8C-bfc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/%E7%90%86%E8%A7%A3-css-%E5%B8%83%E5%B1%80%E5%92%8C-bfc/" class="post-title-link" itemprop="url">理解 CSS 布局和 BFC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 14:35:24" itemprop="dateCreated datePublished" datetime="2019-04-09T14:35:24+08:00">2019-04-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CSS布局中有一些概念，一旦你理解了它们，就能真正提高你的 CSS 布局能力。本文是关于块格式化上下文(BFC)的。你可能从未听说过这个术语，但是如果你曾经用CSS做过布局，你可能知道它是什么，理解什么是 BFC，怎么工作以及如何创建 BFC 非常有用，这些可以帮助你理解CSS中的布局是如何工作的。 在本文中，通过熟悉的示例来解释什么是 BFC。然后说明 display 的一个新值，只有当你理解了什么是 BFC 以及为什么需要它时，它才有意义。</p>
<h2 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC"></a>什么是 BFC</h2><p>在一个Web页面的CSS渲染中，块级格式化上下文 (Block Fromatting Context)是按照块级盒子布局的。W3C对BFC的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个 BFC 中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 块格式化上下文(BFC)的行为通过一个简单的float示例很容易理解。在下面的示例中，我有一个框，其中包含向左浮动的图像和一些文本。如果我们有足够多的文本，它会环绕浮动的图像和边框，然后环绕整个区域。</p>
<div class="outer">
<div class="float">I am a floated element.</div>
I am text inside the outer box.
</div>

<p>.outer {<br>    border: 5 px dotted rgb(214, 129, 137);<br>    border - radius: 5 px;<br>    width: 450 px;<br>    padding: 10 px;<br>    margin - bottom: 40 px;<br>}<br>.float {<br>    padding: 10 px;<br>    border: 5 px solid rgba(214, 129, 137, .4);<br>    border - radius: 5 px;<br>    background - color: rgba(233, 78, 119, .4);<br>    color: #fff;<br>    float: left;<br>    width: 200 px;<br>    margin: 0 20 px 0 0;<br>}</p>
<p><img data-src="https://file.w3cbest.com/file/images/floats1-800w-opt.png"> 如果我删除了一些文本，那么就没有足够的内容来包围图像，而且由于浮动被从文档流中脱离，所以边框会上升，并在图像下方，直到文本的高度。 <img data-src="https://file.w3cbest.com/file/images/floats2-800w-opt.png"> 这是因为当我们浮动一个元素时，文本所在的框的宽度保持不变，为给浮动元素腾出空间而缩短的是文本的行框。这就是为什么背景和边框会出现在浮动后面的原因。 我们通常有两种方法来解决这个布局问题。一种方法是使用 <a target="_blank" rel="noopener" href="https://css-tricks.com/snippets/css/clear-fix/">clearfix hack</a>，它的作用是在文本和图像下面插入一个元素，并将其设置为 clear:both。另一种方法是使用 overflow 属性，其值不是缺省值 visible。</p>
<p>.outer {<br>    overflow: auto;<br>}</p>
<p><img data-src="https://file.w3cbest.com/file/images/floats3-800w-opt.png"> overflow 以这种方式工作的原因是，使用 visible 的初值以外的任何值都会创建一个块格式化上下文，而 BFC 的一个特性是它包含浮动。</p>
<h2 id="BFC-是布局中的一个迷你布局"><a href="#BFC-是布局中的一个迷你布局" class="headerlink" title="BFC 是布局中的一个迷你布局"></a>BFC 是布局中的一个迷你布局</h2><p>你可以将 BFC 看作是页面内的一个迷你布局。一旦一个元素创建了一个 BFC，它就包含了所有的内容。正如我们所看到的，这包括浮动的元素，它们不再从盒子底部伸出来。BFC 还会导致一些其他有用的行为。 <strong>BFC 可以防止 margin 折叠</strong> 了解边距合并是另一个被低估的 CSS 技能。在下一个示例中，假设有一个背景颜色为灰色的 div。 这个 div 包含两个标签 p。外部 <code>div</code> 元素的 <code>margin-bottom</code> 为 40 像素，标签 p 的顶部和底部 margin 都是 20 像素。</p>
<p>// html</p>
<div class="outer">
    <p>I am paragraph one and I have a margin top and bottom of 20px;</p>
    <p>I am paragraph one and I have a margin top and bottom of 20px;</p>
</div>

<p>// css<br>.outer {<br>    background-color: #ccc;<br>    margin: 0 0 40px 0;<br>}<br>p {<br>    padding: 0;<br>    margin: 20px 0 20px 0;<br>    background-color: rgb(233, 78, 119);<br>    color: #fff;<br>}</p>
<p><img data-src="https://file.w3cbest.com/file/images/margins1-800w-opt.png"> 因为 p 元素的 <code>margin</code> 和外部 div 上的 <code>margin</code> 之间没有任何东西，所以两个会折叠，因此 p 最终与 div 的顶部和底部齐平。 我们在 p 的上方和下方看不到任何灰色。 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。折叠的结果按照如下规则计算： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 <strong>产生折叠的必备条件：margin必须是邻接的!</strong> 如果我们把盒子设为 BFC，它现在包含了标签 p 和它们的边距，这样它们就不会折叠，我们可以看到边距后面容器的灰色背景。</p>
<p>.outer {<br>    background-color: #ccc;<br>    margin: 0 0 40px 0;<br>    overflow: auto;<br>}</p>
<p>再一次，BFC 的工作是把东西装在盒子里，防止它们从盒子里跑出来。 <strong>BFC 可以阻止元素被浮动元素覆盖</strong> 你将熟悉 BFC 的这种行为，因为使用浮动的任何列类型布局都是这样工作的。如果一个项目创建了一个 BFC，那么该项目将不会包裹任何浮动元素。在下面的例子中，有如下 html 结构：</p>
<div class="outer">
    <div class="float">I am a floated element.</div>
    <div class="text">I am text</div>
</div>

<p><img data-src="https://file.w3cbest.com/file/images/margins2-800w-opt.png"> 带有 <code>float</code> 类的项被向左浮动，因此 <code>div</code> 中的文本在它环绕 <code>float</code> 之后。 我可以通过将包裹文本的 div 设置为 BFC 来防止这种包裹行为。</p>
<p>.text {<br>    overflow: auto;<br>}</p>
<p><img data-src="https://file.w3cbest.com/file/images/wrap2-800w-opt.png"> 这实际上是我们创建具有多个列的浮动布局的方法。浮动项还为该项创建了一个 BFC，因此，如果右边的列比左边的列高，那么我们的列就不会相互环绕。</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/rachelandrew/pen/qVKEpJ/">A BFC preventing wrapping of floats.</a> by rachelandrew (<a target="_blank" rel="noopener" href="https://codepen.io/rachelandrew">@rachelandrew</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<h2 id="还有什么能创建-BFC"><a href="#还有什么能创建-BFC" class="headerlink" title="还有什么能创建 BFC?"></a>还有什么能创建 BFC?</h2><p>除了使用 <code>overflow</code> 创建 BFC 外，其他一些 CSS 属性还创建 <code>BFC</code>。正如我们所看到的，浮动元素创建了 BFC。你的浮动项将包含它里面的任何东西。 使用以下方式都能创建 BFC</p>
<ul>
<li>  float 的值不是 none。</li>
<li>  position 的值不是 static 或者 relative。</li>
<li>  display 的值是 inline-block、table-cell、flex、table-caption 或者inline-flex</li>
<li>  overflow 的值不是 visible</li>
</ul>
<h2 id="创建-BFC-的新方式"><a href="#创建-BFC-的新方式" class="headerlink" title="创建 BFC 的新方式"></a>创建 BFC 的新方式</h2><p>使用<code>overflow</code>或其他的方法创建BFC时会有两个问题。首先，这些方法本身是有自身的设计目的，所以在使用它们创建BFC时可能会产生副作用。例如，使用<code>overflow</code>创建BFC后在某些情况下可能会看到出现一个滚动条或者元素内容被裁切。 这是由于<code>overflow</code>属性的设计是用来让你告诉浏览器如何定义元素的溢出状态的。浏览器执行了它最基本的定义。 即使在没有任何不想要的副作用的情况下，使用 <code>overflow</code> 也可能会让其他开发人员感到困惑。为什么 overflow 设置为 auto 或 scroll?最初的开发者的意图是什么?他们想要这个组件上的滚动条吗? 最安全的做法应该是创建一个 BFC 时并不会带来任何副作用，它内部的元素都安全的呆在这个迷你布局中，这种方法不会引起任何意想不到的问题，也可以理解开发者的意图。CSS 工作组也十分认同这种想法，所以他们定制了一个新的属性值：display:flow-root。</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/rachelandrew/pen/WXyvpd/">Using display: flow-root for common tasks</a> by rachelandrew (<a target="_blank" rel="noopener" href="https://codepen.io/rachelandrew">@rachelandrew</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>
<p><strong>flow-root 浏览器支持情况</strong> 你可以使用<code>display:flow-root</code>安全的创建BFC，来解决上文中提到的各种问题：包裹浮动元素、阻止外边距叠加和阻止围绕浮动元素。</p>
<p><a target="_blank" rel="noopener" href="http://caniuse.com/#feat=flow-root">Can I Use flow-root?</a> Data on support for the flow-root feature across the major browsers from caniuse.com.</p>
<p>浏览器对该属性的支持目前还是有限的，如果你觉得这个属性值很方便，请投票去让Edge也支持它。不过无论如何，你现在应该已经理解了什么是 BFC，以及如何使用 <code>overflow</code> 或其他方法来包裹浮动，以及知道了 BFC 可以阻止元素去环绕浮动元素，如果你想使用弹性或网格布局可以在一些不支持他们的浏览器中使用 BFC 的这些特性做降级处理。 理解浏览器如何布置网页是非常基础的。 虽然有时看起来无关紧要，但是这些小知识可以加快创建和调试 CSS 布局所需的时间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/04/08/12%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8F%90%E5%8D%87javascript%E6%8A%80%E8%83%BD%E7%9A%84%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/08/12%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8F%90%E5%8D%87javascript%E6%8A%80%E8%83%BD%E7%9A%84%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">12个可以提升JavaScript技能的概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-08 17:47:32" itemprop="dateCreated datePublished" datetime="2019-04-08T17:47:32+08:00">2019-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>javascript 是一门复杂的语言。如果你是一名 javascript 开发者，理解它的一些基础概念是很重要的。本文选取了 12 个 JS 开发者应该掌握的概念，但不代表 JS 开发者需要了解的全部内容。 <strong>注意：</strong>我会在 github 仓库<a href="https://link.juejin.im/?target=https://github.com/nas5w/javascript-tips-and-tidbits">JS Tips &amp; Tidbits</a>上持续更新这个列表，如果有兴趣欢迎 star。</p>
<h2 id="1-值-VS-引用"><a href="#1-值-VS-引用" class="headerlink" title="1. 值 VS 引用"></a>1. 值 VS 引用</h2><p>理解 javascript 中如何分配变量的值是写好代码的基础。如果你还不了解这些，你可能很容易写出无意中修改值的代码。 javascript 总是按值分配变量。但是请特别注意：当分配的值是 javascript 的 5 种原始类型（boolean null undefined string number）时，是分配的真正的值。而如果分配的值是 Array Function Object时，只会分配该对象在内存中的一个引用。 举个例子。在下面的代码中，var2 被赋值为 var1。因为 var1 是原始类型（string），var2 的值就是 var1 的 值，并且与 var1 是完全独立的两个值，只是它们都是同样的字符串。或者说，重新给 var2 赋值对 var1 没有影响。</p>
<p>let var1 = ‘My string’;<br>let var2 = var1;<br>var2 = ‘My new string’;<br>console.log(var1);<br>// ‘My string’<br>console.log(var2);<br>// ‘My new string’</p>
<p>和赋值对象进行比较：</p>
<p>let var1 = { name: ‘Jim’ };<br>let var2 = var1;<br>var2.name = ‘John’;<br>console.log(var1);<br>// { name: ‘John’ }<br>console.log(var2);<br>// { name: ‘John’ }</p>
<p>如果你期望像分配原始类型那样的结果，这里就会出现问题，修改 var2 同样会影响到 var1。如果你创建了一个无意中修改对象的函数，就可能有难以预料的错误。</p>
<h2 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2. 闭包"></a>2. 闭包</h2><p>闭包是 javascript 中很重要的特性，可以实现变量的私有访问。在下面的例子中，createGreeter 返回了一个匿名函数，函数可以访问外层函数的 greeting 参数。</p>
<p>function createGreeter(greeting) {<br>    return function(name) {<br>        console.log(greeting + ‘, ‘ + name);<br>    };<br>}<br>const sayHello = createGreeter(‘Hello’);<br>sayHello(‘Joe’);<br>// Hello, Joe</p>
<p>在实际编码中，你可能希望有一个初始化函数 apiConnect(apiKey) 能够返回某些方法会用到的 apiKey。这种情况下，apiKey 只需要提供一次即可。</p>
<p>function apiConnect(apiKey) {<br>    function get(route) {<br>        return fetch(`${route}?key=${apiKey}`);<br>    }<br>    function post(route, params) {<br>        return fetch(route, {<br>            method: ‘POST’,<br>            body: JSON.stringify(params),<br>            headers: {<br>                Authorization: `Bearer ${apiKey}`,<br>            },<br>        });<br>    }<br>    return { get, post };<br>}<br>const api = apiConnect(‘my-secret-key’);<br>// No need to include the apiKey anymore<br>api.get(‘<a target="_blank" rel="noopener" href="http://www.example.com/get-endpoint&#39;">http://www.example.com/get-endpoint&#39;</a>);<br>api.post(‘<a target="_blank" rel="noopener" href="http://www.example.com/post-endpoint&#39;">http://www.example.com/post-endpoint&#39;</a>, { name: ‘Joe’ });</p>
<h2 id="3-解构"><a href="#3-解构" class="headerlink" title="3. 解构"></a>3. 解构</h2><p>不要忽略 javascript 的参数解构！这是从对象中干净地提取属性的常用方法。</p>
<p>const obj = {<br>    name: ‘Joe’,<br>    food: ‘cake’,<br>};<br>const { name, food } = obj;<br>console.log(name, food);<br>// ‘Joe’ ‘cake’</p>
<p>如果你想将属性解构成不同的名称，参考下面的语法：</p>
<p>const obj = {<br>    name: ‘Joe’,<br>    food: ‘cake’,<br>};<br>const { name: myName, food: myFood } = obj;<br>console.log(myName, myFood);<br>// ‘Joe’ ‘cake’</p>
<p>下面的例子中，解构用来干净地将 person 对象传递给 introduce 函数。或者说，解构可以（经常）用来提取传递给函数的参数的属性。如果你熟悉 React，你可能见过下面的代码。</p>
<p>const person = {<br>    name: ‘Eddie’,<br>    age: 24,<br>};<br>function introduce({ name, age }) {<br>    console.log(`I’m ${name} and I’m ${age} years old!`);<br>}<br>console.log(introduce(person));<br>// “I’m Eddie and I’m 24 years old!”</p>
<h2 id="4-展开运算符"><a href="#4-展开运算符" class="headerlink" title="4. 展开运算符"></a>4. 展开运算符</h2><p>一个相对简单的 javascript 概念。下面的例子中，Math.max 不能接收一个数组，而是接收单个值作为参数。展开运算符…就是用来把数组里的元素一个一个拉出来。</p>
<p>const arr = [4, 6, -1, 3, 10, 4];<br>const max = Math.max(…arr);<br>console.log(max);<br>// 10</p>
<h2 id="5-剩余运算符"><a href="#5-剩余运算符" class="headerlink" title="5. 剩余运算符"></a>5. 剩余运算符</h2><p>说一下 javascript 的剩余运算符。你可以用它将任意数量的参数放入一个数组再传递给函数。</p>
<p>function myFunc(…args) {<br>    console.log(args[0] + args[1]);<br>}<br>myFunc(1, 2, 3, 4);<br>// 3</p>
<h2 id="6-数组方法"><a href="#6-数组方法" class="headerlink" title="6. 数组方法"></a>6. 数组方法</h2><p>javascript 的数组方法经常能让你很优雅、便捷地转换你想要的数据。我经常看到有关如何以某种方式操纵对象数组的问题。这正是数组方法的可用之处。 我将在这里介绍一些不同的数组方法，以类似的可能会混淆的方法来分类。这个列表并不全面，我鼓励你们在 MDN 上反复复习并练习这些方法。</p>
<h3 id="map-filter-reduce"><a href="#map-filter-reduce" class="headerlink" title="map, filter, reduce"></a>map, filter, reduce</h3><p>有人可能对这 3 个方法有些混乱。但这些都是转换数组或返回聚合值的有用方法。 <strong>map：</strong>返回一个新的数组，其中每个元素按指定函数进行转换。</p>
<p>const arr = [1, 2, 3, 4, 5, 6];<br>const mapped = arr.map(el =&gt; el + 20);<br>console.log(mapped);<br>// [21, 22, 23, 24, 25, 26]</p>
<p><strong>filter：</strong>返回一个新的数组，其中只包括回调函数返回 true 的元素。</p>
<p>const arr = [1, 2, 3, 4, 5, 6];<br>const filtered = arr.filter(el =&gt; el === 2  el === 4);<br>console.log(filtered);<br>// [2, 4]</p>
<p><strong>reduce：</strong>累加函数中指定的值。</p>
<p>const arr = [1, 2, 3, 4, 5, 6];<br>const reduced = arr.reduce((total, current) =&gt; total + current);<br>console.log(reduced);<br>// 21</p>
<h3 id="find-findIndex-indexOf"><a href="#find-findIndex-indexOf" class="headerlink" title="find, findIndex, indexOf"></a>find, findIndex, indexOf</h3><p>这三个方法通常会被混为一谈，下面是使用方法： <strong>find：</strong>返回与指定条件匹配的第一个元素。不会再寻找其他匹配的元素。</p>
<p>const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];<br>const found = arr.find(el =&gt; el &gt; 5);<br>console.log(found);<br>// 6</p>
<p>注意，虽然 5 之后的元素都满足条件，但只会返回第一个匹配元素。 <strong>findIndex：</strong>和 find 的机制基本一样，只是会返回第一个匹配元素的索引值而不是返回该元素。来看下面的例子：</p>
<p>const arr = [‘Nick’, ‘Frank’, ‘Joe’, ‘Frank’];<br>const foundIndex = arr.findIndex(el =&gt; el === ‘Frank’);<br>console.log(foundIndex);<br>// 1</p>
<p>indexOf：和 findIndex 的机制基本一样，但它接收一个值而不是一个函数作为参数。你可以在只需要简单的逻辑，不需要使用函数来判断匹配元素时使用它。</p>
<p>const arr = [‘Nick’, ‘Frank’, ‘Joe’, ‘Frank’];<br>const foundIndex = arr.indexOf(‘Frank’);<br>console.log(foundIndex);<br>// 1</p>
<h3 id="push-pop-shift-unshift"><a href="#push-pop-shift-unshift" class="headerlink" title="push, pop, shift, unshift"></a>push, pop, shift, unshift</h3><p>这是一组很棒的数组方法，可以让你有针对性地添加或删除数组中的元素。 <strong>push：</strong>在数组尾部添加一个元素。会修改原数组，返回添加到数组的元素。</p>
<p>let arr = [1, 2, 3, 4];<br>const pushed = arr.push(5);<br>console.log(arr);<br>// [1, 2, 3, 4, 5]<br>console.log(pushed);<br>// 5</p>
<p><strong>pop：</strong>删除数组的最后一个元素。会修改原数组，返回被删除的元素。</p>
<p>let arr = [1, 2, 3, 4];<br>const popped = arr.pop();<br>console.log(arr);<br>// [1, 2, 3]<br>console.log(popped);<br>// 4</p>
<p><strong>shift：</strong>删除数组的第一个元素。会修改原数组，返回被删除的元素。</p>
<p>let arr = [1, 2, 3, 4];<br>const shifted = arr.shift();<br>console.log(arr);<br>// [2, 3, 4]<br>console.log(shifted);<br>// 1</p>
<p><strong>unshift：</strong>在数组头部添加一个元素。会修改原数组，不同于其他几个方法，这个方法返回数组的新的长度。</p>
<p>let arr = [1, 2, 3, 4];<br>const unshifted = arr.unshift(5, 6, 7);<br>console.log(arr);<br>// [5, 6, 7, 1, 2, 3, 4]<br>console.log(unshifted);<br>// 7</p>
<h3 id="splice-slice"><a href="#splice-slice" class="headerlink" title="splice, slice"></a>splice, slice</h3><p>这 2 个方法会修改数组或返回一个子数组。 splice：通过删除或替换已存在的元素或插入新的元素来修改原数组的内容。会修改原数组。 下面的例子可以理解为：在索引为 1 的位置移除 0 个元素并插入了元素 b。</p>
<p>let arr = [‘a’, ‘c’, ‘d’, ‘e’];<br>arr.splice(1, 0, ‘b’);</p>
<p><strong>slice</strong>：从指定的开始和结束位置返回数组的浅复制副本。如果没有指定结束位置，返回数组的剩余部分。重要的是，此方法不修改原数组而是返回所需要的子数组。</p>
<p>let arr = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’];<br>const sliced = arr.slice(2, 4);<br>console.log(sliced);<br>// [‘c’, ‘d’]<br>console.log(arr);<br>// [‘a’, ‘b’, ‘c’, ‘d’, ‘e’]</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p><strong>sort：</strong>基于提供的函数对数组进行排序，该函数接收 2 个参数，代表需要排序的 2 个数组元素。会修改原数组。如果函数返回负值或 0，元素顺序保持不变，返回正值，对调元素位置。</p>
<p>let arr = [1, 7, 3, -1, 5, 7, 2];<br>const sorter = (firstEl, secondEl) =&gt; firstEl - secondEl;<br>arr.sort(sorter);<br>console.log(arr);<br>// [-1, 1, 2, 3, 5, 7, 7]</p>
<p>你是否已经全部理解了呢？我还没有。事实上，我在写这篇文章的时候也经常参考 MDN 文档——没关系！只要知道有什么样的方法就可以了。</p>
<h2 id="7-Generators"><a href="#7-Generators" class="headerlink" title="7. Generators"></a>7. Generators</h2><p>不要害怕*。生成器函数指定了下次调用next()时会迭代什么值。可以进行有限次数的迭代，也可以在循环中进行无限次数的迭代。</p>
<p>function* greeter() {<br>    yield ‘Hi’;<br>    yield ‘How are you?’;<br>    yield ‘Bye’;<br>}<br>const greet = greeter();<br>console.log(greet.next().value);<br>// ‘Hi’<br>console.log(greet.next().value);<br>// ‘How are you?’<br>console.log(greet.next().value);<br>// ‘Bye’<br>console.log(greet.next().value);<br>// undefined</p>
<p>无限迭代：</p>
<p>function* idCreator() {<br>    let i = 0;<br>    while (true) yield i++;<br>}<br>const ids = idCreator();<br>console.log(ids.next().value);<br>// 0<br>console.log(ids.next().value);<br>// 1<br>console.log(ids.next().value);<br>// 2<br>// etc…</p>
<h2 id="8-VS"><a href="#8-VS" class="headerlink" title="8. === VS =="></a>8. === VS ==</h2><p>确信你已经了解了===与==的差异。在进行比较时，==会进行类型转换，===则不会。</p>
<p>console.log(0 == ‘0’);<br>// true<br>console.log(0 === ‘0’);<br>// false</p>
<h2 id="9-比较对象"><a href="#9-比较对象" class="headerlink" title="9. 比较对象"></a>9. 比较对象</h2><p>一个 javascript 新手常犯的错误就是直接比较对象。变量指向对象在内存中的引用，而不是对象本身。比较变量的一个方法是将它们转换为 JSON 字符串。当然这样会有缺点：不能保证对象属性的顺序。更安全的方式是使用第三方库中专用的比较方法来比较（lodash.isEqual）。 下面的对象看着是一样的，但其实它们指向不同的引用。</p>
<p>const joe1 = { name: ‘Joe’ };<br>const joe2 = { name: ‘Joe’ };<br>console.log(joe1 === joe2);<br>// false</p>
<p>反过来说，下面的比较结果为 true，因为变量被直接赋值为相同的值，都指向同一个引用（在内存中只有一个对象）。</p>
<p>const joe1 = { name: ‘Joe’ };<br>const joe2 = joe1;<br>console.log(joe1 === joe2);<br>// true</p>
<p>复习下之前的值 VS 引用章节，保证能完全理解将一个引用变量赋值给其他变量时，其实是赋值了内存中同一对象的相同引用给其他变量。</p>
<h2 id="10-回调函数"><a href="#10-回调函数" class="headerlink" title="10. 回调函数"></a>10. 回调函数</h2><p>许多人都会被 javascript 的回调函数吓到！其他它们很简单，来看例子。console.log作为回调函数传递给了myFunc。当计时器就绪时执行。</p>
<p>function myFunc(text, callback) {<br>    setTimeout(function() {<br>        callback(text);<br>    }, 2000);<br>}<br>myFunc(‘Hello world!’, console.log);<br>// ‘Hello world!’</p>
<h2 id="11-Promises"><a href="#11-Promises" class="headerlink" title="11. Promises"></a>11. Promises</h2><p>一旦你理解的回调函数，你就会陷入回调地狱。然后 Promises 解决了问题。在 Promise 中包裹你的异步逻辑，成功时调用 resolve，失败时调用 reject。使用 then 来处理成功状态，使用 catch 来处理异常状态。</p>
<p>const myPromise = new Promise(function(res, rej) {<br>    setTimeout(function() {<br>        if (Math.random() &lt; 0.9) {<br>            return res(‘Hooray!’);<br>        }<br>        return rej(‘Oh no!’);<br>    }, 1000);<br>});</p>
<p>myPromise<br>    .then(function(data) {<br>        console.log(‘Success: ‘ + data);<br>    })<br>    .catch(function(err) {<br>        console.log(‘Error: ‘ + err);<br>    });</p>
<p>// If Math.random() returns less than 0.9 the following is logged:<br>// “Success: Hooray!”<br>// If Math.random() returns 0.9 or greater the following is logged:<br>// “Error: On no!”</p>
<h2 id="12-Async-Await"><a href="#12-Async-Await" class="headerlink" title="12. Async Await"></a>12. Async Await</h2><p>一旦你掌握了 Promises，你就会喜欢async/await，它是基于 promises 的语法糖。下面的例子中我们使用了 async 函数，在函数里使用了 await 来处理greeter。</p>
<p>const greeter = new Promise((res, rej) =&gt; {<br>    setTimeout(() =&gt; res(‘Hello world!’), 2000);<br>});<br>async function myFunc() {<br>    const greeting = await greeter;<br>    console.log(greeting);<br>}<br>myFunc();<br>// ‘Hello world!’</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果你还不了解这 12 个概念，你可能已经至少增长了一些 javascript 的知识。如果你已经了解了这些，希望这是你练习和加强知识的机会。 文章来源：<a target="_blank" rel="noopener" href="https://hackernoon.com/12-javascript-concepts-that-will-level-up-your-development-skills-b37d16ad7104">12 Concepts That Will Level Up Your JavaScript Skills</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/04/04/echarts%E8%AE%BE%E7%BD%AE%E5%9D%90%E6%A0%87%E8%BD%B4%E5%8C%BA%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%88%86%E9%9A%94%E7%BA%BF%E9%A2%9C%E8%89%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/04/echarts%E8%AE%BE%E7%BD%AE%E5%9D%90%E6%A0%87%E8%BD%B4%E5%8C%BA%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%88%86%E9%9A%94%E7%BA%BF%E9%A2%9C%E8%89%B2/" class="post-title-link" itemprop="url">echarts设置坐标轴区域中的分隔线颜色</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-04 15:41:42" itemprop="dateCreated datePublished" datetime="2019-04-04T15:41:42+08:00">2019-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ECharts/" itemprop="url" rel="index"><span itemprop="name">ECharts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>想要设置区域分割线颜色首先要知道他的属性是什么，<code>splitLine</code> 顾名思义”分割线”。知道了分割线是什么属性后我来看看他都包含哪些特性。 从API中可以看出他是坐标轴<code>xAxis</code>和<code>yAxis</code>中的一个<code>splitLine:&#123;&#125;</code> 对象，证明他的内部有多个属性和值。我们以X轴为例</p>
<p>splitLine: {<br>show: true,<br>interval: ‘auto’,<br>lineStyle: {<br>color: [‘#ccc’],<br>width: 1,<br>type: ‘solid’,<br>shadowBlur: …,<br>shadowColor: …,<br>shadowOffsetX: 0,<br>shadowOffsetY: 0,<br>opacity: …,<br>}<br>}</p>
<p><strong><code>xAxis.splitLine.show</code></strong>      boolean 值 [ default: true ] 是否显示分隔线。默认数值轴显示，类目轴不显示。 <strong><code>xAxis.splitLine.interval</code></strong>   number, Function [ default: ‘auto’ ] 坐标轴分隔线的显示间隔，在类目轴中有效。默认同 axisLabel.interval 一样。 默认会采用标签不重叠的策略间隔显示标签。 可以设置成 0 强制显示所有标签。 如果设置为 1，表示『隔一个标签显示一个标签』，如果值为 2，表示隔两个标签显示一个标签，以此类推。 可以用数值表示间隔的数据，也可以通过回调函数控制。回调函数格式如下： (index:number, value: string) =&gt; boolean 第一个参数是类目的 index，第二个值是类目名称，如果跳过则返回 false。 <strong><code>xAxis.splitLine.lineStyle</code></strong>      Object</p>
<blockquote>
<p><code>xAxis.splitLine.lineStyle.**color**</code>      Array, string</p>
</blockquote>
<p>[ default: [‘#ccc’] ] 分隔线颜色，可以设置成单个颜色。 也可以设置成颜色数组，分隔线会按数组中颜色的顺序依次循环设置颜色。 示例</p>
<p>splitLine: {<br>    lineStyle: {<br>        // 使用深浅的间隔色<br>        color: [‘#aaa’, ‘#ddd’]<br>    }<br>}</p>
<blockquote>
<p><code>xAxis.splitLine.lineStyle.**width**</code>      number</p>
</blockquote>
<p>[ default: 1 ] 分隔线线宽。</p>
<blockquote>
<p><code>xAxis.splitLine.lineStyle.**type**</code>      string</p>
</blockquote>
<p>[ default: ‘solid’ ] 分隔线线的类型。 可选：</p>
<ul>
<li>  <code>&#39;solid&#39;</code></li>
<li>  <code>&#39;dashed&#39;</code></li>
<li>  <code>&#39;dotted&#39;</code></li>
</ul>
<blockquote>
<p><code>xAxis.splitLine.lineStyle.**shadowBlur**</code>      number</p>
</blockquote>
<p>图形阴影的模糊大小。该属性配合 <code>shadowColor</code>,<code>shadowOffsetX</code>, <code>shadowOffsetY</code>一起设置图形的阴影效果。 示例：</p>
<p>{<br>    shadowColor: ‘rgba(0, 0, 0, 0.5)’,<br>    shadowBlur: 10<br>}</p>
<blockquote>
<p><code>xAxis.splitLine.lineStyle.**shadowColor**</code>      Color</p>
</blockquote>
<p>阴影颜色。支持的格式同color。</p>
<blockquote>
<p><code>xAxis.splitLine.lineStyle.**shadowOffsetX**</code>      number</p>
</blockquote>
<p>[ default: 0 ] 阴影水平方向上的偏移距离。</p>
<blockquote>
<p><code>xAxis.splitLine.lineStyle.**shadowOffsetY**</code>      number</p>
</blockquote>
<p>[ default: 0 ] 阴影垂直方向上的偏移距离。</p>
<blockquote>
<p><code>xAxis.splitLine.lineStyle.**opacity**</code>      number</p>
</blockquote>
<p>图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。 通过上面的解释我们可以了解到坐标轴区域的分割线可以设置 分割线颜色、分割线大小、分割线类型、分割线阴影以及分割线的透明度</p>
<p>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/w3cbest/pen/BEjxKJ/">Echarts设置坐标轴区域中的分隔线颜色</a> by w3cbest.com (<a target="_blank" rel="noopener" href="https://codepen.io/w3cbest">@w3cbest</a>) on <a target="_blank" rel="noopener" href="https://codepen.io/">CodePen</a>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/04/03/css-%E5%87%BD%E6%95%B0calc-%E4%B8%8E-css-%E5%8F%98%E9%87%8Fvar%E7%9A%84%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/03/css-%E5%87%BD%E6%95%B0calc-%E4%B8%8E-css-%E5%8F%98%E9%87%8Fvar%E7%9A%84%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">CSS 函数calc() 与 CSS 变量var()的混合使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-03 12:19:03" itemprop="dateCreated datePublished" datetime="2019-04-03T12:19:03+08:00">2019-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CSS-变量混合使用加法减法"><a href="#CSS-变量混合使用加法减法" class="headerlink" title="CSS 变量混合使用加法减法"></a><a target="_blank" rel="noopener" href="http://www.w3cbest.com/592.html">CSS 变量</a>混合使用加法减法</h2><p>当设置一个变量为200px时后期不满足需求需要增加10px或20px时而需要扩展； 例如我们需要给一个div的宽度设置为210px，但我们的变量是200px，这时我们就可以用变量的值加上10px就行了，如下 （本篇所使用的宽度属性是<a target="_blank" rel="noopener" href="http://www.w3cbest.com/469.html">CSS逻辑属性</a>）</p>
<p>:root{<br>    –base-size-200: 200px;<br>}</p>
<p>div{<br>    inline-size: calc(var(–base-size-200) + 10px);<br>}</p>
<p>或者我们的变量里面已经有10px这个变量了，那么可以这样做</p>
<p>:root{<br>    –base-size-200: 200px;<br>    –base-size-10: 10px;<br>}</p>
<p>div{<br>    inline-size: calc(var(–base-size-200) + var(–base-size-10));<br>}</p>
<p>如果的话减法同上面一样，就是把加号换做减号就行了</p>
<p>div{<br>    inline-size: calc(var(–base-size-200) - var(–base-size-10));<br>}</p>
<h2 id="CSS-变量混合使用乘法除法"><a href="#CSS-变量混合使用乘法除法" class="headerlink" title="CSS 变量混合使用乘法除法"></a>CSS 变量混合使用乘法除法</h2><p>乘法就是把你现在大小乘以你想要的值就是你的尺寸，我们还以上面的为例，将200px设为2倍或3倍来运算</p>
<p>:root{<br>    –base-size-200: 200px;<br>}</p>
<p>div{<br>    inline-size: calc(var(–base-size-200) * 2);<br>}</p>
<p>除法同上面一样将乘号换为除号</p>
<p>div{<br>    inline-size: calc(var(–base-size-200) / 2);<br>}</p>
<h2 id="CSS-变量加法与乘法混合使用"><a href="#CSS-变量加法与乘法混合使用" class="headerlink" title="CSS 变量加法与乘法混合使用"></a>CSS 变量加法与乘法混合使用</h2><p>其实这个也很简但，就是将上面的两种方法加起来运算就可以了</p>
<p>:root{<br>    –base-size-200: 200px;<br>    –base-size-10: 10px;<br>}<br>div{<br>    inline-size: calc(var(–base-size-200) * 2 + var(–base-size-10));<br>}</p>
<p>好了全是废话，篇幅较小不喜勿喷</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/04/02/ckeditor-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/02/ckeditor-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/" class="post-title-link" itemprop="url">ckeditor 从入门到放弃</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-02 18:42:01" itemprop="dateCreated datePublished" datetime="2019-04-02T18:42:01+08:00">2019-04-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CKEDITOR网页编辑器还是挺复杂的，有一个 CKEDITOR 的全局空间，有一个 CKEDITOR.instances的全局实例引用，有 Classic 编辑和 Inline 编辑两种模式，有 Plugin 也有 Widget，有自成一体的编译打包工具，与 AMD\CMD\UMD社区不兼容。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><script src="http://example.com/js/ckeditor/ckeditor.js"></script>

<h2 id="生成编辑器"><a href="#生成编辑器" class="headerlink" title="生成编辑器"></a>生成编辑器</h2><h3 id="经典编辑（Classic-Editing）"><a href="#经典编辑（Classic-Editing）" class="headerlink" title="经典编辑（Classic Editing）"></a>经典编辑（Classic Editing）</h3><p><textarea id="editor"></textarea></p>
<script>
CKEDITOR.replace('editor')
</script>

<h3 id="内嵌编辑（Inline-Editing）"><a href="#内嵌编辑（Inline-Editing）" class="headerlink" title="内嵌编辑（Inline Editing）"></a>内嵌编辑（Inline Editing）</h3><div id="editor" contenteditable="true"></div>

<script>
CKEDITOR.disableAutoInline = true; // 关闭自动内嵌编辑
CKEDITOR.inline('editor'); // 手动对 #editor 元素开启内嵌编辑
</script>

<h2 id="按钮面板定制（Toolbar）"><a href="#按钮面板定制（Toolbar）" class="headerlink" title="按钮面板定制（Toolbar）"></a>按钮面板定制（Toolbar）</h2><h3 id="一组一组定义"><a href="#一组一组定义" class="headerlink" title="一组一组定义"></a>一组一组定义</h3><p>config.toolbarGroups = [<br>    { name: ‘clipboard’,   groups: [ ‘clipboard’, ‘undo’ ] },<br>    { name: ‘editing’,     groups: [ ‘find’, ‘selection’, ‘spellchecker’ ] },<br>    { name: ‘links’ },<br>    { name: ‘insert’ },<br>    { name: ‘forms’ },<br>    { name: ‘tools’ },<br>    { name: ‘document’,    groups: [ ‘mode’, ‘document’, ‘doctools’ ] },<br>    { name: ‘others’ },<br>    ‘/‘,<br>    { name: ‘basicstyles’, groups: [ ‘basicstyles’, ‘cleanup’ ] },<br>    { name: ‘paragraph’,   groups: [ ‘list’, ‘indent’, ‘blocks’, ‘align’, ‘bidi’ ] },<br>    { name: ‘styles’ },<br>    { name: ‘colors’ },<br>    { name: ‘about’ }<br>];</p>
<h3 id="一个一个定义"><a href="#一个一个定义" class="headerlink" title="一个一个定义"></a>一个一个定义</h3><p>config.toolbar = [<br>    { name: ‘document’, items: [ ‘Source’, ‘-‘, ‘NewPage’, ‘Preview’, ‘-‘, ‘Templates’ ] },<br>    { name: ‘clipboard’, items: [ ‘Cut’, ‘Copy’, ‘Paste’, ‘PasteText’, ‘PasteFromWord’, ‘-‘, ‘Undo’, ‘Redo’ ] },<br>    ‘/‘,<br>    { name: ‘basicstyles’, items: [ ‘Bold’, ‘Italic’ ] }<br>];</p>
<h2 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h2><p>假如我们开发一个插入当前时间戳的插件</p>
<h3 id="插件目录结构"><a href="#插件目录结构" class="headerlink" title="插件目录结构"></a>插件目录结构</h3><ul>
<li>ckeditor root/<ul>
<li>plugins/<ul>
<li>timestamp/<ul>
<li>icons/<ul>
<li>  timestamp.png</li>
</ul>
</li>
<li>  plugin.js</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="插件代码"><a href="#插件代码" class="headerlink" title="插件代码"></a>插件代码</h3><p>CKEDITOR.plugins.add(‘timestamp’, {<br>    icons: ‘timestamp’,<br>    init: function(editor) {<br>        editor.addCommand(‘insertTimestamp’, {<br>            exec: function(editor) {<br>                var now = new Date();<br>                editor.insertHtml(‘The current date and time is: <em>‘ + now.toString() + ‘</em>‘);<br>            }<br>        });<br>        editor.ui.addButton(‘Timestamp’, {<br>            label: ‘Insert Timestamp’,<br>            command: ‘insertTimestamp’,<br>            toolbar: ‘insert’<br>        });<br>    }<br>});</p>
<p>通过 <code>CKEDITOR.plugins.add</code>方法添加插件，第一个参数为插件名，后面为参数列表。 通过<code>editor.addCommand</code>方法添加一个 insertTimestamp 的命令 通过<code>editor.ui.addButton</code>方法添加一个按钮控件，并绑定其执行的 command 通过 <code>editor.insertHtml</code>方法往编辑内容区域追加内容</p>
<h3 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h3><p>通过配置文件来开启插件</p>
<p>config.extraPlugins = ‘timestamp’;</p>
<p>如果这是一个会出现在 Toolbar 的插件，且 Toolbar 被定制过，则需要显性配置 toolbar让其显示</p>
<p>config.toolbar = {<br>  {name: ‘insert’, [‘Timestamp’]}<br>}</p>
<h2 id="挂件（Widget）"><a href="#挂件（Widget）" class="headerlink" title="挂件（Widget）"></a>挂件（Widget）</h2><p>挂件是由一组 html 元素组成的特殊富文本单元，类似于模板机制 <strong>与插件的区别</strong> 挂件有 template 字段，插件没有 <strong>挂件目录结构</strong> 与插件一致</p>
<h3 id="挂件代码"><a href="#挂件代码" class="headerlink" title="挂件代码"></a>挂件代码</h3><p>CKEDITOR.plugins.add( ‘simplebox’, {</p>
<p>  // 表明这是一个 widget<br>  requires: ‘widget’,</p>
<pre><code>icons: &#39;simplebox&#39;,

init: function( editor ) &#123;
    CKEDITOR.dialog.add( &#39;simplebox&#39;, this.path + &#39;dialogs/simplebox.js&#39; );

    editor.widgets.add( &#39;simplebox&#39;, &#123;

   // 鼠标 hover 在 toolbar 上出现的提示
        button: &#39;Create a simple box&#39;,

        // 挂件模板
        template:
            &#39;&lt;div class=&quot;simplebox&quot;&gt;&#39; +
                &#39;&lt;h2 class=&quot;simplebox-title&quot;&gt;Title&lt;/h2&gt;&#39; +
                &#39;&lt;div class=&quot;simplebox-content&quot;&gt;&lt;p&gt;Content...&lt;/p&gt;&lt;/div&gt;&#39; +
            &#39;&lt;/div&gt;&#39;,

        // 定义挂件中可编辑的部分
        editables: &#123;
            title: &#123;
                selector: &#39;.simplebox-title&#39;,
                allowedContent: &#39;br strong em&#39;
            &#125;,
            content: &#123;
                selector: &#39;.simplebox-content&#39;,
                allowedContent: &#39;p br ul ol li strong em&#39;
            &#125;
        &#125;,

        // 挂件内允许出现的组合
        allowedContent:
            &#39;div(!simplebox,align-left,align-right,align-center)&#123;width&#125;;&#39; +
            &#39;div(!simplebox-content); h2(!simplebox-title)&#39;,

        // 挂件最小组合，如果这个 div 被删除，则自动清除该挂件
        requiredContent: &#39;div(simplebox)&#39;,

        dialog: &#39;simplebox&#39;,

        upcast: function( element ) &#123;
            return element.name \== &#39;div&#39; &amp;&amp; element.hasClass( &#39;simplebox&#39; );
        &#125;,

        init: function() &#123;
            var width \= this.element.getStyle( &#39;width&#39; );
            if ( width )
                this.setData( &#39;width&#39;, width );
            if ( this.element.hasClass( &#39;align-left&#39; ) )
                this.setData( &#39;align&#39;, &#39;left&#39; );
            if ( this.element.hasClass( &#39;align-right&#39; ) )
                this.setData( &#39;align&#39;, &#39;right&#39; );
            if ( this.element.hasClass( &#39;align-center&#39; ) )
                this.setData( &#39;align&#39;, &#39;center&#39; );
        &#125;,

        data: function() &#123;

            if ( this.data.width \== &#39;&#39; )
                this.element.removeStyle( &#39;width&#39; );
            else
                this.element.setStyle( &#39;width&#39;, this.data.width );

            this.element.removeClass( &#39;align-left&#39; );
            this.element.removeClass( &#39;align-right&#39; );
            this.element.removeClass( &#39;align-center&#39; );
            if ( this.data.align )
                this.element.addClass( &#39;align-&#39; + this.data.align );
        &#125;
    &#125; );
&#125;
</code></pre>
<p>} );</p>
<h2 id="ACF"><a href="#ACF" class="headerlink" title="ACF"></a>ACF</h2><p>CKEditor 的高级内容过滤器，当用户在源码输入模式、<code>editor.setData</code>输入、直接粘贴 html 代码等输入时候，将不希望出现的内容给过滤掉。</p>
<h3 id="自动模式（Automatic-Mode）"><a href="#自动模式（Automatic-Mode）" class="headerlink" title="自动模式（Automatic Mode）"></a>自动模式（Automatic Mode）</h3><p>当 <code>config.allowedContent</code> 没有设置的时候，ACF 就会进入自动模式。 自动模式通过<code>config.removePlugins</code> 、<code>config.removeButtons</code> 和 <code>config.format_tag</code> 来做过滤微调</p>
<p>config.removePlugins = ‘image,table,tabletools,horizontalrule’;<br>config.removeButtons = ‘Anchor,Underline,Strike,Subscript,Superscript’;<br>config.format_tags = ‘p;h1;h2;pre’;</p>
<h3 id="自定义模式（Custom-Mode）"><a href="#自定义模式（Custom-Mode）" class="headerlink" title="自定义模式（Custom Mode）"></a>自定义模式（Custom Mode）</h3><p>通过 <code>config.allowedContent</code> 来进入自定义模式</p>
<p>config.allowedContent =<br>    ‘h1 h2 h3 p blockquote strong em;’ +<br>    ‘a[!href];’ +<br>    ‘img(left,right)[!src,alt,width,height];’;</p>
<h3 id="ACF语法"><a href="#ACF语法" class="headerlink" title="ACF语法"></a>ACF语法</h3><blockquote>
<p><em>elements [attributes]{styles}(classes)</em></p>
</blockquote>
<p>例如我们需要保留<span class=”mod\_fillblank”>这样的富文本内容，规则为span(mod_fillblank)，其 attributes 对 class 无效。</p>
<h2 id="实战建议"><a href="#实战建议" class="headerlink" title="实战建议"></a>实战建议</h2><ul>
<li>  能用 CKEditor 社区插件解决的问题，用插件解决</li>
<li>  插件解决不了的问题，业务自己写plugin 或者 widget 解决</li>
<li>  业务自己写的部分，尽量不要用 CKEditor 自带的 <code>CKEDITOR.dialog</code> ，他们的实现是用 JS 去码DOM 结构，太复杂了。随便一个 Dialog 控件都能用得很舒服</li>
<li>  不要用CKEditor 的 jQuery Adapter，他家的 Adapter 对于同一个 DOM 的进行实例化、销毁等操作有 bug，时不时给你冒一个错误。自己包裹一个 Adapter 则肯定没有 bug</li>
<li>  工程化的时候，构建工具做依赖分析的时候，记得排除掉 CKEditor 目录，否则他家一堆的插件，会严重拖慢依赖分析那步</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/03/25/%E5%85%B3%E4%BA%8Ejs-%E6%95%B0%E7%BB%84%E9%AA%9A%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/25/%E5%85%B3%E4%BA%8Ejs-%E6%95%B0%E7%BB%84%E9%AA%9A%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">关于JS 数组的一些骚操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-25 14:54:12" itemprop="dateCreated datePublished" datetime="2019-03-25T14:54:12+08:00">2019-03-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要从应用来讲数组api的一些骚操作; 如一行代码扁平化n维数组、数组去重、求数组最大值、数组求和、排序、对象和数组的转化等； 上面这些应用场景你可以用一行代码实现？</p>
<h2 id="1-扁平化n维数组"><a href="#1-扁平化n维数组" class="headerlink" title="1.扁平化n维数组"></a>1.扁平化n维数组</h2><h3 id="1-终极篇"><a href="#1-终极篇" class="headerlink" title="1.终极篇"></a>1.终极篇</h3><p>[1,[2,3]].flat(2) //[1,2,3]<br>[1,[2,3,[4,5]].flat(3) //[1,2,3,4,5]<br>[1,[2,3,[4,5]]].toString() //‘1,2,3,4,5’<br>[1[2,3,[4,5[…]].flat(Infinity) //[1,2,3,4…n]</p>
<p><code>Array.flat(n)</code>是ES10扁平数组的api,n表示维度,n值为Infinity时维度为无限大</p>
<h3 id="2-开始篇"><a href="#2-开始篇" class="headerlink" title="2.开始篇"></a>2.开始篇</h3><p>function flatten(arr) {<br>    while (arr.some(item =&gt; Array.isArray(item))) {<br>        arr = [].concat(…arr);<br>    }<br>    return arr;<br>}<br>flatten([1, [2, 3]]) //[1,2,3]<br>flatten([1, [2, 3, [4, 5]]) //[1,2,3,4,5]</p>
<p>实质是利用递归和数组合并方法concat实现扁平</p>
<h2 id="2-去重"><a href="#2-去重" class="headerlink" title="2.去重"></a>2.去重</h2><h3 id="1-终极篇-1"><a href="#1-终极篇-1" class="headerlink" title="1.终极篇"></a>1.终极篇</h3><p>Array.from(new Set([1,2,3,3,4,4])) //[1,2,3,4]<br>[…new Set([1,2,3,3,4,4])] //[1,2,3,4]</p>
<p><code>set</code>是ES6新出来的一种一种定义不重复数组的数据类型 <code>Array.from</code>是将类数组转化为数组 <code>...</code>是扩展运算符,将set里面的值转化为字符串</p>
<h3 id="2-开始篇-1"><a href="#2-开始篇-1" class="headerlink" title="2.开始篇"></a>2.开始篇</h3><p>Array.prototype.distinct = function() {<br>    var arr = this,<br>        result = [],<br>        i,<br>        j,<br>        len = arr.length;<br>    for (i = 0; i &lt; len; i++) {<br>        for (j = i + 1; j &lt; len; j++) {<br>            if (arr[i] === arr[j]) {<br>                j = ++i;<br>            }<br>        }<br>        result.push(arr[i]);<br>    }<br>    return result;<br>}<br>[1, 2, 3, 3, 4, 4].distinct(); //[1,2,3,4]</p>
<p>取新数组存值,循环两个数组值相比较</p>
<h2 id="3-排序"><a href="#3-排序" class="headerlink" title="3.排序"></a>3.排序</h2><h3 id="1-终极篇-2"><a href="#1-终极篇-2" class="headerlink" title="1.终极篇"></a>1.终极篇</h3><p>[1,2,3,4].sort((a, b) =&gt; a - b); // [1, 2,3,4],默认是升序<br>[1,2,3,4].sort((a, b) =&gt; b - a); // [4,3,2,1] 降序</p>
<p><code>sort</code>是js内置的排序方法,参数为一个函数</p>
<h3 id="2-开始篇-2"><a href="#2-开始篇-2" class="headerlink" title="2.开始篇"></a>2.开始篇</h3><p>冒泡排序:</p>
<p>Array.prototype.bubleSort = function() {<br>    let arr = this,<br>        len = arr.length;<br>    for (let outer = len; outer &gt;= 2; outer–) {<br>        for (let inner = 0; inner &lt;= outer - 1; inner++) {<br>            if (arr[inner] &gt; arr[inner + 1]) {<br>                //升序<br>                [arr[inner], arr[inner + 1]] = [arr[inner + 1], arr[inner]];<br>                console.log([arr[inner], arr[inner + 1]]);<br>            }<br>        }<br>    }<br>    return arr;<br>}<br>[1, 2, 3, 4].bubleSort() //[1,2,3,4]</p>
<p>选择排序</p>
<p>Array.prototype.selectSort = function() {<br>    let arr = this,<br>        len = arr.length;<br>    for (let i = 0, len = arr.length; i &lt; len; i++) {<br>        for (let j = i, len = arr.length; j &lt; len; j++) {<br>            if (arr[i] &gt; arr[j]) {<br>                [arr[i], arr[j]] = [arr[j], arr[i]];<br>            }<br>        }<br>    }<br>    return arr;<br>}<br>[1, 2, 3, 4].selectSort() //[1,2,3,4]</p>
<h2 id="4-最大值"><a href="#4-最大值" class="headerlink" title="4.最大值"></a>4.最大值</h2><h3 id="1-终极篇-3"><a href="#1-终极篇-3" class="headerlink" title="1.终极篇"></a>1.终极篇</h3><p>Math.max(…[1, 2, 3, 4]) //4<br>Math.max.apply(this, [1, 2, 3, 4]) //4<br>[1, 2, 3, 4].reduce((prev, cur, curIndex, arr) =&gt; {<br>    return Math.max(prev, cur);<br>}, 0) //4</p>
<p><code>Math.max()</code>是Math对象内置的方法,参数是字符串; <code>reduce</code>是ES5的数组api,参数有函数和默认初始值; 函数有四个参数</p>
<ul>
<li>  <code>pre</code>(上一次的返回值)</li>
<li>  <code>cur</code>(当前值)</li>
<li>  <code>curIndex</code>(当前值索引)</li>
<li>  <code>arr</code>(当前数组)</li>
</ul>
<h3 id="2-开始篇-3"><a href="#2-开始篇-3" class="headerlink" title="2.开始篇"></a>2.开始篇</h3><p>先排序再取值</p>
<h2 id="5-求和"><a href="#5-求和" class="headerlink" title="5.求和"></a>5.求和</h2><h3 id="1-终极篇-4"><a href="#1-终极篇-4" class="headerlink" title="1.终极篇"></a>1.终极篇</h3><p>[1, 2, 3, 4].arr.reduce(function(prev, cur){<br>    return prev + cur;<br>}, 0) //10</p>
<h3 id="2-开始篇-4"><a href="#2-开始篇-4" class="headerlink" title="2.开始篇"></a>2.开始篇</h3><p>function sum(arr) {<br>    var len = arr.length;<br>    if (len == 0) {<br>        return 0;<br>    } else if (len == 1) {<br>        return arr[0];<br>    } else {<br>        return arr[0] + sum(arr.slice(1));<br>    }<br>}<br>sum([1,2,3,4]) //10</p>
<p>利用slice截取改变数组,再利用递归求和</p>
<h2 id="6-合并"><a href="#6-合并" class="headerlink" title="6.合并"></a>6.合并</h2><h3 id="1-终极篇-5"><a href="#1-终极篇-5" class="headerlink" title="1.终极篇"></a>1.终极篇</h3><p>[1,2,3,4].concat([5,6]) //[1,2,3,4,5,6]<br>[…[1,2,3,4],…[4,5]] //[1,2,3,4,5,6]<br>[1,2,3,4].push.apply([1,2,3,4],[5,6]) //[1,2,3,4,5,6]</p>
<h3 id="2-开始篇-5"><a href="#2-开始篇-5" class="headerlink" title="2.开始篇"></a>2.开始篇</h3><p>let arr = [1, 2, 3, 4];<br>[5, 6].map(item =&gt; {<br>    arr.push(item)<br>})<br>//arr值为[1,2,3,4,5,6],注意不能直接return出来,return后只会返回[5,6]</p>
<h2 id="7-判断是否包含值"><a href="#7-判断是否包含值" class="headerlink" title="7.判断是否包含值"></a>7.判断是否包含值</h2><h3 id="1-终极篇-6"><a href="#1-终极篇-6" class="headerlink" title="1.终极篇"></a>1.终极篇</h3><p>[1,2,3].includes(4) //false<br>[1,2,3].indexOf(4) //-1 如果存在换回索引<br>[1, 2, 3].find((item)=&gt;item===3)) //3 如果数组中无值返回undefined<br>[1, 2, 3].findIndex((item)=&gt;item===3)) //2 如果数组中无值返回-1</p>
<p><code>includes()</code>,<code>find()</code>,<code>findIndex()</code>是ES6的api</p>
<h3 id="2-开始篇-6"><a href="#2-开始篇-6" class="headerlink" title="2.开始篇"></a>2.开始篇</h3><p>[1, 2, 3].some(item =&gt;{<br>    return item === 3<br>}) //true 如果不包含返回false</p>
<h2 id="8-类数组转化"><a href="#8-类数组转化" class="headerlink" title="8.类数组转化"></a>8.类数组转化</h2><h3 id="1-终极篇-7"><a href="#1-终极篇-7" class="headerlink" title="1.终极篇"></a>1.终极篇</h3><p>Array.prototype.slice.call(arguments) //arguments是类数组(伪数组)<br>Array.prototype.slice.apply(arguments)<br>Array.from(arguments)<br>[…arguments]</p>
<p>类数组:表示有length属性,但是不具备数组的方法 <code>call</code>,<code>apply</code>:是改变<code>slice</code>里面的<code>this</code>指向<code>arguments</code>,所以<code>arguments</code>也可调用数组的方法 <code>Array.from</code>是将类似数组或可迭代对象创建为数组 <code>...</code>是将类数组扩展为字符串,再定义为数组</p>
<h3 id="2-开始篇-7"><a href="#2-开始篇-7" class="headerlink" title="2.开始篇"></a>2.开始篇</h3><p>Array.prototype.slice = function(start, end) {<br>    var result = new Array();<br>    start = start  0;<br>    end = end  this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键<br>    for (var i = start; i &lt; end; i++) {<br>        result.push(this[i]);<br>    }<br>    return result;<br>}</p>
<h2 id="9-每一项设置值"><a href="#9-每一项设置值" class="headerlink" title="9.每一项设置值"></a>9.每一项设置值</h2><h3 id="1-终极篇-8"><a href="#1-终极篇-8" class="headerlink" title="1.终极篇"></a>1.终极篇</h3><p>[1,2,3].fill(false) //[false,false,false]</p>
<p><code>fill</code>是ES6的方法</p>
<h3 id="2-开始篇-8"><a href="#2-开始篇-8" class="headerlink" title="2.开始篇"></a>2.开始篇</h3><p>[1,2,3].map(() =&gt; 0)</p>
<h2 id="10-每一项是否满足"><a href="#10-每一项是否满足" class="headerlink" title="10.每一项是否满足"></a>10.每一项是否满足</h2><p>[1,2,3].every(item=&gt;{return item&gt;2}) //false</p>
<p><code>every</code>是ES5的api,每一项满足返回 true</p>
<h2 id="11-有一项满足"><a href="#11-有一项满足" class="headerlink" title="11.有一项满足"></a>11.有一项满足</h2><p>[1,2,3].some(item=&gt;{return item&gt;2}) //true</p>
<p><code>some</code>是ES5的api,有一项满足返回 true</p>
<h2 id="12-过滤数组"><a href="#12-过滤数组" class="headerlink" title="12.过滤数组"></a>12.过滤数组</h2><p>[1,2,3].filter(item=&gt;{return item&gt;2}) //[3]</p>
<p><code>filter</code>是ES5的api,返回满足添加的项的数组</p>
<h2 id="13-对象和数组转化"><a href="#13-对象和数组转化" class="headerlink" title="13.对象和数组转化"></a>13.对象和数组转化</h2><p>Object.keys({name:’张三’,age:14}) //[‘name’,’age’]<br>Object.values({name:’张三’,age:14}) //[‘张三’,14]<br>Object.entries({name:’张三’,age:14}) //[[name,’张三’],[age,14]]<br>Object.fromEntries([name,’张三’],[age,14]) //ES10的api,Chrome不支持 , firebox输出{name:’张三’,age:14}</p>
<p>文章来源：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018549643">https://segmentfault.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/02/26/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-javascript-%E8%A7%A3%E6%9E%90-url/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/26/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-javascript-%E8%A7%A3%E6%9E%90-url/" class="post-title-link" itemprop="url">如何使用 JavaScript 解析 URL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-26 12:44:55" itemprop="dateCreated datePublished" datetime="2019-02-26T12:44:55+08:00">2019-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 Web 开发中，有许多情况需要解析 URL,这篇主要学习如何使用 URL 对象实现这一点。 入门 创建一个以下内容的 HTML 文件，并在浏览器中打开。</p>
<html>
    <head>
        <title>JavaScript URL parsing</title>
    </head>
    <body>
        <script>
            // Exciting code coming soon!
        </script>
    </body>
</html>

<p>如果你想尝试本文中的任何内容，可以将其放在 <script> 标记中，保存，重新加载页面，看看会发生什么！ 在本教程中，将使用 console.log 来打印所需要的内容，你可以打开开发都工具，来查看内容。</p>
<h2 id="什么是-URL"><a href="#什么是-URL" class="headerlink" title="什么是 URL"></a>什么是 URL</h2><p>这应该是相当简单的，但让我们说清楚。 URL 是网页的地址，可以在浏览器中输入以获取该网页的唯一内容。 可以在地址栏中看到它： <img data-src="https://file.w3cbest.com/file/images/url-annotated.png"> URL 是统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 此外，如果你不熟悉基本 URL 路径的工作方式，可以查看<a target="_blank" rel="noopener" href="https://codetheweb.blog/2017/10/14/links-images-about-file-paths/">此文</a>学习。 <strong>URL 不都长的一样的</strong></p>
<blockquote>
<p>这是一个快速提醒 - 有时 URL 可能非常奇怪，如下： <a target="_blank" rel="noopener" href="https://example.com:1234/page/?a=b">https://example.com:1234/page/?a=b</a> <a target="_blank" rel="noopener" href="http://localhost/page.html">http://localhost/page.html</a> <a target="_blank" rel="noopener" href="https://154.23.54.156/page?x=">https://154.23.54.156/page?x=</a>… file:///Users/username/folder/file.png</p>
</blockquote>
<h2 id="获取当前URL"><a href="#获取当前URL" class="headerlink" title="获取当前URL"></a>获取当前URL</h2><p>获取当前页面的 URL 非常简单 - 我们可以使用 <code>window.location</code>。 试着把这个添加到我们形如写的的脚本中:</p>
<p>console.log(window.location);</p>
<p>查看浏览器的控制台： <img data-src="https://file.w3cbest.com/file/images/console-log-window-location.png"> 不是你想要的?这是因为它不返回你在浏览器中看到的实际 URL 地址——它返回的是一个 URL 对象。使用这个 URL 对象，我们可以解析 URL 的不同部分，接下来就会讲到。</p>
<h2 id="创建-URL-对象"><a href="#创建-URL-对象" class="headerlink" title="创建 URL 对象"></a>创建 URL 对象</h2><p>很快就会看到，可以使用 URL 对象来了解 URL 的不同部分。如果你想对任何 URL 执行此操作，而不仅仅是当前页面的 URL，该怎么办？ 我们可以通过创建一个新的 URL 对象来实现。 以下是如何创建一个：</p>
<p>var myURL = new URL(‘<a target="_blank" rel="noopener" href="https://example.com&/#39;">https://example.com&#39;</a>);</p>
<p>就这么简单！ 可以打印 <code>myURL</code> 来查看 <code>myURL</code> 的内容：</p>
<p>console.log(myURL);</p>
<p><img data-src="https://file.w3cbest.com/file/images/console-log-myurl.png"> 出于本文的目的，将 myURL 设置为这个值：</p>
<p>var myURL = new URL(‘<a target="_blank" rel="noopener" href="https://example.com:4000/folder/page.html?x=y&amp;a=b#section-2&#39;">https://example.com:4000/folder/page.html?x=y&amp;a=b#section-2&#39;</a>)</p>
<p>将其复制并粘贴到 <code>&lt;script&gt;</code> 元素中，以便你可以继续操作！ 这个 <code>URL</code> 的某些部分可能不熟悉，因为它们并不总是被使用 - 但你将在下面了解它们，所以不要担心！</p>
<h2 id="URL-对象的结构"><a href="#URL-对象的结构" class="headerlink" title="URL 对象的结构"></a>URL 对象的结构</h2><p>使用 URL 对象，可以非常轻松地获取 URL 的不同部分。 以下是你可以从 URL 对象获得的所有内容。 对于这些示例，我们将使用上面设置的 <code>myURL</code>。</p>
<h4 id="href"><a href="#href" class="headerlink" title="href"></a><strong>href</strong></h4><p>URL 的 <code>href</code> 基本上是作为字符串(文本)的整个 URL。如果你想把页面的 URL 作为字符串而不是 URL 对象，你可以写 <code>window.location.href</code>。</p>
<p>console.log(myURL.href);<br>// Output: “<a target="_blank" rel="noopener" href="https://example.com:4000/folder/page.html?x=y&amp;a=b#section-2&quot;">https://example.com:4000/folder/page.html?x=y&amp;a=b#section-2&quot;</a></p>
<h4 id="协议-protocol"><a href="#协议-protocol" class="headerlink" title="协议 (protocol)"></a><strong>协议 (protocol)</strong></h4><p>URL的协议是一开始的部分。这告诉浏览器如何访问该页面，例如通过 HTTP 或 HTTPS。 但是还有很多其他协议，比如 <strong>ftp</strong>（文件传输协议）和 <strong>ws</strong>（WebSocket）。通常，网站将使用 HTTP 或 HTTPS。 虽然如果你的计算机上打开了文件，你可能正在使用文件协议！ URL对象的协议部分包括<code>：</code>，但不包括 <code>//</code>。 让我们看看 <code>myURL</code> 吧！</p>
<p>console.log(myURL.protocol);<br>// Output: “https:”</p>
<h4 id="主机名（hostname）"><a href="#主机名（hostname）" class="headerlink" title="主机名（hostname）"></a><strong>主机名（hostname）</strong></h4><p>主机名是站点的域名。 如果你不熟悉域名，则它是在浏览器中看到的URL的主要部分 - 例如 <code>google.com</code> 或<code>codetheweb.blog</code>。</p>
<p>console.log(myURL.hostname);<br>// Output: “example.com”</p>
<h4 id="端口（port）"><a href="#端口（port）" class="headerlink" title="端口（port）"></a><strong>端口（port）</strong></h4><p>URL 的端口号位于域名后面，用冒号分隔（例如 <code>example.com:1234</code>）。 大多数网址都没有端口号，这种情况非常罕见。 端口号是服务器上用于获取数据的特定“通道” - 因此，如果我拥有 <code>example.com</code>，我可以在多个不同的端口上发送不同的数据。 但通常域名默认为一个特定端口，因此不需要端口号。 来看看 <code>myURL</code> 的端口号：</p>
<p>console.log(myURL.port);<br>// Output: “4000”</p>
<h4 id="主机（host）"><a href="#主机（host）" class="headerlink" title="主机（host）"></a><strong>主机（host）</strong></h4><p>主机只是<code>主机名</code>和<code>端口</code>放在一起，尝试获取 <code>myURL</code> 的主机：</p>
<p>console.log(myURL.host);<br>// Output: “example.com:4000”</p>
<h4 id="来源（origin）"><a href="#来源（origin）" class="headerlink" title="来源（origin）"></a><strong>来源（origin）</strong></h4><p>origin 由 URL 的协议，主机名和端口组成。 它基本上是整个 URL，直到端口号结束，如果没有端口号，到主机名结束。</p>
<p>console.log(myURL.origin);<br>// Output: “<a href="https://example.com:4000&quot;">https://example.com:4000&quot;</a></p>
<h4 id="pathname（文件名）"><a href="#pathname（文件名）" class="headerlink" title="pathname（文件名）"></a><strong>pathname（文件名）</strong></h4><p><code>pathname</code> 从域名的最后一个 “/” 开始到 “?” 为止,是文件名部分,如果没有 “?” ,则是从域名最后的一个 “/” 开始到 “#” 为止 , 是文件部分, 如果没有 “?” 和 “#” , 那么从域名后的最后一个 “/” 开始到结束 , 都是文件名部分。</p>
<p>console.log(myURL.pathname);<br>// Output: “/folder/page.html”</p>
<h4 id="锚点（hash）"><a href="#锚点（hash）" class="headerlink" title="锚点（hash）"></a>锚点（hash）</h4><p>从 <strong>“#”</strong> 开始到最后，都是锚部分。可以将哈希值添加到 URL 以直接滚动到具有 ID 为该值的哈希值 的元素。 例如，如果你有一个 <code>id</code> 为 <code>hello</code> 的元素，则可以在 URL 中添加 <code>#hello</code> 就可以直接滚动到这个元素的位置上。通过以下方式可以在 URL 获取 <strong>“#”</strong> 后面的值:</p>
<p>console.log(myURL.hash);<br>// Output: “#section-2”</p>
<h4 id="查询参数-search"><a href="#查询参数-search" class="headerlink" title="查询参数 (search)"></a><strong>查询参数 (search)</strong></h4><p>你还可以向 URL 添加查询参数。它们是键值对，意味着将特定的<strong>“变量”</strong>设置为特定值。 查询参数的形式为 <code>key=value</code>。 以下是一些 URL 查询参数的示例：</p>
<p>?key1=value1&amp;key2=value2&amp;key3=value3</p>
<p>请注意，如果 URL 也有 <strong>锚点（hash</strong>），则查询参数位于 锚点（hash）(也就是 <strong>‘#’</strong>)之前，如我们的示例 URL 中所示：</p>
<p><a target="_blank" rel="noopener" href="https://example.com:4000/folder/page.html?x=y&amp;a=b#section-2">https://example.com:4000/folder/page.html?x=y&amp;a=b#section-2</a></p>
<p>要将查询参数作为字符串，我们只需使用myURL.search：</p>
<p>console.log(myURL.search);<br>// Output: “?x=y&amp;a=b”</p>
<p>但是，如果我们想要拆分它们并获取它们的值，那就有点复杂了。</p>
<h2 id="使用-URLSearchParams-解析查询参数"><a href="#使用-URLSearchParams-解析查询参数" class="headerlink" title="使用 URLSearchParams 解析查询参数"></a>使用 URLSearchParams 解析查询参数</h2><p>要解析查询参数，我们需要创建一个 <strong>URLSearchParams</strong> 对象，如下所示：</p>
<p>var searchParams = new URLSearchParams(myURL.search);</p>
<p>然后可以通过调用 <code>searchParams.get（&#39;key&#39;）</code>来获取特定键的值。 使用我们的示例网址 - 这是原始搜索参数：</p>
<p>?x=y&amp;a=b</p>
<p>因此，如果我们调用 <code>searchParams.get（&#39;x&#39;</code>），那么它应该返回 <code>y</code>，而 <code>searchParams.get（&#39;a&#39;）</code>应该返回 <code>b</code>，我们来试试吧！</p>
<p>console.log(searchParams.get(‘x’));<br>// Output: “y”<br>console.log(searchParams.get(‘a’));<br>// Output: “b”</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Tom</p>
  <div class="site-description" itemprop="description">w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">339</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">W3Cbest前端开发</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
