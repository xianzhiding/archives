<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xianzhiding.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
<meta property="og:type" content="website">
<meta property="og:title" content="前端开发 大前端 W3Cbest">
<meta property="og:url" content="https://xianzhiding.github.io/page/2/index.html">
<meta property="og:site_name" content="前端开发 大前端 W3Cbest">
<meta property="og:description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tom">
<meta property="article:tag" content="前端开发,es5,es6,es10,css,javascript,html,flexbox,grid,echarts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xianzhiding.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>前端开发 大前端 W3Cbest</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">前端开发 大前端 W3Cbest</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个专注 WEB 开发的技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/11/18/%E4%BD%BF%E7%94%A8css-grid%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/18/%E4%BD%BF%E7%94%A8css-grid%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">使用CSS Grid轻松搞定响应式布局</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-18 10:13:51" itemprop="dateCreated datePublished" datetime="2019-11-18T10:13:51+08:00">2019-11-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在这篇文章中，我将教你如何使用 CSS Grid 来创建一个超酷的图像网格图，它将根据屏幕的宽度来改变列的数量。最精彩的地方在于：所有的响应特性被添加到了一行 css 代码中。这意味着我们不必将 HTML 与丑陋的类名(如col-sm-4, col-md-8)混杂在一起，也不必为每个屏幕创建媒体查询。ok，让我们发车吧。</p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>在本文中，我将继续使用我在第一篇 <a target="_blank" rel="noopener" href="https://www.freecodecamp.org/news/learn-css-grid-in-5-minutes-f582e87b1228/">CSS Grid 布局教程文章</a>中的网格布局。然后，我们将在文章末尾添加图片。下面是我们初始化网格的外观： <img data-src="http://file.w3cbest.com/file/images/1_fJNIdDiScjhI9CZjdxv3Eg.png"> HTML 代码：</p>
<pre class="language-none"><code class="language-none">&lt;div class&#x3D;&quot;container&quot;&gt;
  &lt;div&gt;1&lt;&#x2F;div&gt;
  &lt;div&gt;2&lt;&#x2F;div&gt;
  &lt;div&gt;3&lt;&#x2F;div&gt;
  &lt;div&gt;4&lt;&#x2F;div&gt;
  &lt;div&gt;5&lt;&#x2F;div&gt;
  &lt;div&gt;6&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;</code></pre>

<p>CSS 代码：</p>
<pre class="language-none"><code class="language-none">.container &#123;
display: grid;
grid-template-columns: 100px 100px 100px;
grid-template-rows: 50px 50px;
&#125;</code></pre>

<p>注意: 示例中有一些基础的样式，但我在这里没有写出来，因为这对 CSS 网格布局没有任何影响 如果这段代码让你感到困惑，我建议你去好好读下我的这篇文章<a target="_blank" rel="noopener" href="https://www.freecodecamp.org/news/learn-css-grid-in-5-minutes-f582e87b1228/">Learn CSS Grid in 5 minutes</a>，其中就详细的解释了布局的基础知识。 让我们让列开始具有自适应特性吧。 基础响应单位: fraction CSS 栅格布局带来了一个全新的值:fraction单位，fraction单位通常简写为fr，它允许你根据需要将容器拆分为多个块。 让我们将每一列更改为一个 fraction 单位宽:</p>
<pre class="language-none"><code class="language-none">.container &#123;
display: grid;
grid-template-columns: 1fr 1fr 1fr;
grid-template-rows: 50px 50px;
&#125;</code></pre>

<p>结果是栅格布局将会把整个宽度分成三个 fraction，每列占据一个 fraction 单位，效果如下： <img data-src="http://file.w3cbest.com/file/images/1_JgGPqT2AfFNDD8DhG2wPdQ.gif"> 如果我们将grid-template-columns的值更改为1fr 2fr 1fr，第二列的宽度将会是其它两列的两倍。总宽现在是四个 fraction 单位，第二列占据两个 fraction 单位，其它列各占一个 fraction。效果如下： <img data-src="http://file.w3cbest.com/file/images/1_cpfokc1HBgCwOTNhRU9SHg.gif"> 总的来说，fraction 单位值将使你可以很容易的更改列的宽度。 高级响应 然而，上面列子并没有给出我们想要的响应性，因为网格总是三列宽。我们希望网格能根据容器的宽度改变列的数量。要做到这一点，你必须学习如下三个概念：</p>
<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p>首先我们学习repeat()函数。这是一个强大的指定列和行的方法。让我们使用repeat()函数来更改网格:</p>
<pre class="language-none"><code class="language-none">.container &#123;
  display: grid;
  grid-template-columns: repeat(3, 100px);
  grid-template-rows: repeat(2, 50px);
  &#125;</code></pre>

<p>在上面代码中，repeat(3, 100px)等于100px 100px 100px。第一个参数指定行与列的数量，第二个参数指定它们的宽度，因此它将为我们提供与开始时完全相同的布局： <img data-src="http://file.w3cbest.com/file/images/1_fJNIdDiScjhI9CZjdxv3Eg.png"></p>
<h2 id="auto-fit"><a href="#auto-fit" class="headerlink" title="auto-fit"></a>auto-fit</h2><p>然后是auto-fit。让我们跳过固定数量的列，将3替换为自适应数量：</p>
<pre class="language-none"><code class="language-none">.container &#123;
display: grid;
grid-gap: 5px;
grid-template-columns: repeat(auto-fit, 100px);
grid-template-rows: repeat(2, 100px);
&#125;</code></pre>

<p>效果如下: <img data-src="http://file.w3cbest.com/file/images/v2-e9df20fc5a27960605959ba296042ffa_b.webp"> 现在，栅格将会根据容器的宽度调整其数量。它会尝试在容器中容纳尽可能多的 100px 宽的列。但如果我们将所有列硬写为 100px，我们将永远没法获得所需的弹性，因为它们很难填充整个宽度。正如你在上图看到的，网格通常在右侧留有空白。</p>
<h2 id="minmax"><a href="#minmax" class="headerlink" title="minmax()"></a>minmax()</h2><p>为了解决上述问题，我们需要minmax()。我们将 100px 替换为 minmax(100px, 1fr)，代码如下：</p>
<pre class="language-none"><code class="language-none">.container &#123;
display: grid;
grid-gap: 5px;
grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
grid-template-rows: repeat(2, 100px);
&#125;</code></pre>

<p>请注意，所有响应都发生在一行 css 代码中 效果如下： <img data-src="http://file.w3cbest.com/file/images/v2-4c968663383dbf14b08e22c45c1ddbd8_b.webp"> 正如你所见，效果完美。minmax()函数定义的范围大于或等于 min， 小于或等于 max。 因此，现在每列将至少为 100px。但如果有更多的可用空间，栅格布局将简单地将其均分给每列，因为这些列变成了 fraction 单位，而不是 100px。</p>
<h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><p>最后一步是添加图片。这与 <a target="_blank" rel="noopener" href="http://www.w3cbest.com/494.html">CSS Grid</a> 布局无关，但让我们看下代码。 我们在每个网格中添加一个图片标签：</p>
<pre class="language-none"><code class="language-none">&lt;div&gt;&lt;img src&#x3D;&quot;img&#x2F;forest.jpg&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</code></pre>

<p>为了使图片适应于每个条目，我们将其宽、高设置为与条目本身一样，我们使用object-fit:cover。这将使图片覆盖它的整个容器，根据需要，浏览器将会对其进行裁剪。</p>
<pre class="language-none"><code class="language-none">.container &gt; div &gt; img &#123;
width: 100%;
height: 100%;
object-fit: cover;
&#125;</code></pre>
<p>效果如下： <img data-src="http://file.w3cbest.com/file/images/v2-5589cdec01ac4734366b7d38ebac182a_b.webp"> ok！现在你已经了解了 <a target="_blank" rel="noopener" href="http://www.w3cbest.com/494.html">CSS Grid</a> 布局中最复杂的概念之一了，请给自己一个赞吧。</p>
<h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><p>在结束本文前，我提下浏览器支持情况，在撰写本文时，全球77%的网站将支持 CSS Grid，而且比例还在逐步攀升。 2018将是 CSS 网格布局的元年。它将获得突破，并成为前端开发者的必备技能，就像过去几年 <a target="_blank" rel="noopener" href="http://www.w3cbest.com/490.html">CSS Flexbox</a> 布局发生的情况一样。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/09/17/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84-js-%E5%86%99%E5%BE%97%E6%9B%B4%E6%BC%82%E4%BA%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/17/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84-js-%E5%86%99%E5%BE%97%E6%9B%B4%E6%BC%82%E4%BA%AE/" class="post-title-link" itemprop="url">如何让你的 JS 写得更漂亮</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-17 09:02:48" itemprop="dateCreated datePublished" datetime="2019-09-17T09:02:48+08:00">2019-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-按强类型风格写代码"><a href="#1-按强类型风格写代码" class="headerlink" title="1. 按强类型风格写代码"></a>1. 按强类型风格写代码</h2><p>JS是弱类型的，但是写代码的时候不能太随意，写得太随意也体现了编码风格不好。下面分点说明：</p>
<h3 id="（1）定义变量的时候要指明类型，告诉JS解释器这个变量是什么数据类型的，而不要让解释器去猜，例如不好的写法："><a href="#（1）定义变量的时候要指明类型，告诉JS解释器这个变量是什么数据类型的，而不要让解释器去猜，例如不好的写法：" class="headerlink" title="（1）定义变量的时候要指明类型，告诉JS解释器这个变量是什么数据类型的，而不要让解释器去猜，例如不好的写法："></a>（1）定义变量的时候要指明类型，告诉JS解释器这个变量是什么数据类型的，而不要让解释器去猜，例如不好的写法：</h3><pre class="language-none"><code class="language-none">var num,
    str,
    obj;</code></pre>

<p>声明了三个变量，但其实没什么用，因为解释器不知道它们是什么类型的，好的写法应该是这样的：</p>
<pre class="language-none"><code class="language-none">var num &#x3D; 0,
    str &#x3D; &#39;&#39;,
    obj &#x3D; null;</code></pre>

<p>定义变量的时候就给他一个默认值，这样不仅方便了解释器，也方便了阅读代码的人，他会在心里有数——知道这些变量可能会当作什么用。</p>
<h3 id="（2）不要随意地改变变量的类型，例如下面代码："><a href="#（2）不要随意地改变变量的类型，例如下面代码：" class="headerlink" title="（2）不要随意地改变变量的类型，例如下面代码："></a>（2）不要随意地改变变量的类型，例如下面代码：</h3><pre class="language-none"><code class="language-none">var num &#x3D; 5; 
    num &#x3D; &quot;-&quot; + num;</code></pre>
<p>第1行它是一个整型，第2行它变成了一个字符串。因为JS最终都会被解释成汇编的语言，汇编语言变量的类型肯定是要确定的，你把一个整型的改成了字符串，那解释器就得做一些额外的处理。并且这种编码风格是不提倡的，有一个变量第1行是一个整型，第10行变成了一个字符串，第20行又变成了一个object，这样就让阅读代码的人比较困惑，上面明明是一个整数，怎么突然又变成一个字符串了。好的写法应该是再定义一个字符串的变量：</p>
<pre class="language-none"><code class="language-none">var num &#x3D; 5;
var sign &#x3D; &quot;-&quot; + num;</code></pre>

<h3 id="（3）函数的返回类型应该是要确定的，例如下面不确定的写法："><a href="#（3）函数的返回类型应该是要确定的，例如下面不确定的写法：" class="headerlink" title="（3）函数的返回类型应该是要确定的，例如下面不确定的写法："></a>（3）函数的返回类型应该是要确定的，例如下面不确定的写法：</h3><pre class="language-none"><code class="language-none">function getPrice(count)&#123;
    if(count &lt; 0) return &quot;&quot;;
    else return count \* 100;
&#125;</code></pre>

<p>getPrice这个函数有可能返回一个整数，也有可能返回一个空的字符串。这样写也不太好，虽然它是符合JS语法的，但这种编码风格是不好的。使用你这个函数的人会有点无所适从，不敢直接进行加减乘除，因为如果返回字符串进行运算的话值就是NaN了。函数的返回类型应该是要确定的，如下面是返回整型：</p>
<pre class="language-none"><code class="language-none">function getPrice(count)&#123;
    if(count &lt; 0) return -1;
    else return count \* 100;
&#125;</code></pre>

<p>然后告诉使用者，如果返回-1就表示不合法。如果类型确定，解释器也不用去做一些额外的工作，可以加快运行速度。</p>
<h2 id="2-减少作用域查找"><a href="#2-减少作用域查找" class="headerlink" title="2. 减少作用域查找"></a>2. 减少作用域查找</h2><h3 id="（1）不要让代码暴露在全局作用域下"><a href="#（1）不要让代码暴露在全局作用域下" class="headerlink" title="（1）不要让代码暴露在全局作用域下"></a>（1）不要让代码暴露在全局作用域下</h3><p>例如以下运行在全局作用域的代码：</p>
<pre class="language-none"><code class="language-none">&lt;script&gt;
    var map &#x3D; document.querySelector(&quot;#my-map&quot;);
    map.style.height &#x3D; &quot;600px&quot;;
&lt;&#x2F;script&gt;</code></pre>

<p>有时候你需要在页面直接写一个script，要注意在一个script标签里面，代码的上下文都是全局作用域的，由于全局作用域比较复杂，查找比较慢。例如上面的map变量，第二行在使用的时候，需要在全局作用域查找一下这个变量，假设map是在一个循环里面使用，那可能就会有效率问题了。所以应该要把它搞成一个局部的作用域：</p>
<pre class="language-none"><code class="language-none">&lt;script&gt;
!function()&#123;
    var map &#x3D; document.querySelector(&quot;#my-map&quot;);
    map.style.height &#x3D; &quot;600px&quot;;
&#125;()
&lt;&#x2F;script&gt;</code></pre>

<p>上面用了一个function制造一个局部作用域，也可以用ES6的块级作用域。由于map这个变量直接在当前的局部作用域命中了，所以就不用再往上一级的作用域（这里是全局作用域）查找了，而局部作用域的查找是很快的。同时直接在全局作用域定义变量，会污染window对象。</p>
<h3 id="（2）不要滥用闭包"><a href="#（2）不要滥用闭包" class="headerlink" title="（2）不要滥用闭包"></a>（2）不要滥用闭包</h3><p>闭包的作用在于可以让子级作用域使用它父级作用域的变量，同时这些变量在不同的闭包是不可见的。这样就导致了在查找某个变量的时候，如果当前作用域找不到，就得往它的父级作用域查找，一级一级地往上直到找到了，或者到了全局作用域还没找到。因此如果闭包嵌套得越深，那么变量查找的时间就越长。如下：</p>
<pre class="language-none"><code class="language-none">function getResult(count)&#123;
    count++;
    function process()&#123;
        var factor &#x3D; 2;
        return count \* factor - 5;
    &#125;
    return process();
&#125;</code></pre>

<p>上面的代码定义了一个process函数，在这个函数里面count变量的查找时间要高于局部的factor变量。其实这里不太适合用闭包，可以直接把count传给process：</p>
<pre class="language-none"><code class="language-none">function getResult(count)&#123;
    count++;
    function process(count)&#123;
        var factor &#x3D; 2;
        return count \* factor - 5;
    &#125;
    return process(count);
&#125;</code></pre>

<p>这样count的查找时间就和factor一样，都是在当前作用域直接命中。这个就启示我们如果某个全局变量需要频繁地被使用的时候，可以用一个局部变量缓存一下，如下：</p>
<pre class="language-none"><code class="language-none">var url &#x3D; &quot;&quot;;
if(window.location.protocal &#x3D;&#x3D;&#x3D; &quot;https:&quot;)&#123;
    url &#x3D; &quot;wss:&#x2F;&#x2F;xxx.com&quot; + window.location.pathname + window.location.search;
&#125;</code></pre>

<p>频繁地使用了window.location对象，所以可以先把它缓存一下：</p>
<pre class="language-none"><code class="language-none">var url &#x3D; &quot;&quot;;
var location &#x3D; window.location;
if(location.protocal &#x3D;&#x3D;&#x3D; &quot;https:&quot;)&#123;
    url &#x3D; &quot;wss:&#x2F;&#x2F;xxx.com&quot; + location.pathname + location.search;
&#125;</code></pre>


<p>搞成了一个局变变量，这样查找就会明显快于全局的查找，代码也可以写少一点。</p>
<h2 id="3-避免-的使用"><a href="#3-避免-的使用" class="headerlink" title="3. 避免==的使用"></a>3. 避免==的使用</h2><p>这里你可能会有疑问了，有些人喜欢用==，有些人喜欢用===，大家的风格不一样，你为什么要强制别人用===呢？习惯用==的人，不能仅仅是因为==比===少敲了一次键盘。为什么不提倡用==呢？</p>
<h3 id="（1）如果你确定了变量的类型，那么就没必要使用-了，如下："><a href="#（1）如果你确定了变量的类型，那么就没必要使用-了，如下：" class="headerlink" title="（1）如果你确定了变量的类型，那么就没必要使用==了，如下："></a>（1）如果你确定了变量的类型，那么就没必要使用==了，如下：</h3><pre class="language-none"><code class="language-none">if(typeof num !&#x3D; &quot;undefined&quot;)&#123; &#125; 
var num &#x3D; parseInt(value);
if(num &#x3D;&#x3D; 10)&#123; &#125;</code></pre>


<p>上面的两个例子都是确定类型的，一个是字符串，一个是整数。就没必要使用==了，直接用===就可以了。</p>
<h3 id="（2）如果类型不确定，那么应该手动做一下类型转换，而不是让别人或者以后的你去猜这里面有类型转换，如下："><a href="#（2）如果类型不确定，那么应该手动做一下类型转换，而不是让别人或者以后的你去猜这里面有类型转换，如下：" class="headerlink" title="（2）如果类型不确定，那么应该手动做一下类型转换，而不是让别人或者以后的你去猜这里面有类型转换，如下："></a>（2）如果类型不确定，那么应该手动做一下类型转换，而不是让别人或者以后的你去猜这里面有类型转换，如下：</h3><pre class="language-none"><code class="language-none">var totalPage &#x3D; &quot;5&quot;;
if(parseInt(totalPage) &#x3D;&#x3D;&#x3D; 1)&#123; &#125;</code></pre>

<h3 id="（3）使用-在JSLint检查的时候是不通过的："><a href="#（3）使用-在JSLint检查的时候是不通过的：" class="headerlink" title="（3）使用==在JSLint检查的时候是不通过的："></a>（3）使用==在JSLint检查的时候是不通过的：</h3><pre class="language-none"><code class="language-none">if(a &#x3D;&#x3D; b)&#123; &#125;</code></pre>

<p>如下JSLint的输出：</p>
<pre class="language-none"><code class="language-none">Expected ‘&#x3D;&#x3D;&#x3D;’ and instead saw ‘&#x3D;&#x3D;’. 
if(a &#x3D;&#x3D; b)&#123; &#125;</code></pre>


<h3 id="（4）并且使用-可能会出现一些奇怪的现象，这些奇怪的现象可能会给代码埋入隐患："><a href="#（4）并且使用-可能会出现一些奇怪的现象，这些奇怪的现象可能会给代码埋入隐患：" class="headerlink" title="（4）并且使用==可能会出现一些奇怪的现象，这些奇怪的现象可能会给代码埋入隐患："></a>（4）并且使用==可能会出现一些奇怪的现象，这些奇怪的现象可能会给代码埋入隐患：</h3><pre class="language-none"><code class="language-none">null &#x3D;&#x3D; undefined        &#x2F;&#x2F;true
&#39;&#39; &#x3D;&#x3D; &#39;0&#39;&#x2F;&#x2F;false
0  &#x3D;&#x3D; &#39;&#39;&#x2F;&#x2F;true
0  &#x3D;&#x3D; &#39;0&#39;&#x2F;&#x2F;true
&#39;&#39; &#x3D;&#x3D; 0&#x2F;&#x2F;true
new String(&quot;abc&quot;) &#x3D;&#x3D; &quot;abc&quot;                      &#x2F;&#x2F;true
new Boolean(true) &#x3D;&#x3D; true                       &#x2F;&#x2F;true
true &#x3D;&#x3D; 1&#x2F;&#x2F;true</code></pre>

<p>上面的比较在用===的时候都是false，这样才是比较合理的。例如第一点null居然会等于undefined，就特别地奇怪，因为null和undefined是两个毫无关系的值，null应该是作为初始化空值使用，而undefined是用于检验某个变量是否未定义。 这和第1点介绍强类型的思想是相通的。</p>
<h2 id="4-合并表达式"><a href="#4-合并表达式" class="headerlink" title="4. 合并表达式"></a>4. 合并表达式</h2><p>如果用1句代码就可以实现5句代码的功能，那往往1句代码的执行效率会比较高，并且可读性可能会更好</p>
<h3 id="（1）用三目运算符取代简单的if-else"><a href="#（1）用三目运算符取代简单的if-else" class="headerlink" title="（1）用三目运算符取代简单的if-else"></a>（1）用三目运算符取代简单的if-else</h3><p>如上面的getPrice函数：</p>
<pre class="language-none"><code class="language-none">function getPrice(count)&#123;
    if(count &lt; 0) return -1;
    else return count \* 100;
&#125;</code></pre>

<p>可以改成：</p>
<pre class="language-none"><code class="language-none">function getPrice(count)&#123;
    return count &lt; 0 ? return -1 : count \* 100;
&#125;</code></pre>

<p>这个比写一个if-else看起来清爽多了。当然，如果你写了if-else，压缩工具也会帮你把它改三目运算符的形式：</p>
<pre class="language-none"><code class="language-none">function getPrice(e)&#123;return 0&gt;e?-1:100\*e&#125;</code></pre>

<h3 id="（2）连等"><a href="#（2）连等" class="headerlink" title="（2）连等"></a>（2）连等</h3><p>连等是利用赋值运算表达式会返回所赋的值，并且执行顺序是从右到左的，如下：</p>
<pre class="language-none"><code class="language-none">overtime &#x3D; favhouse &#x3D; listingDetail &#x3D; &#123;...&#125;</code></pre>

<p>有时候你会看到有人这样写：</p>
<pre class="language-none"><code class="language-none">var age &#x3D; 0;
if((age &#x3D; +form.age.value) &gt;&#x3D; 18)&#123;
    console.log(&quot;你是成年人&quot;);
&#125; else &#123;
    consoe.log(&quot;小朋友，你还有&quot; + (18 - age) + &quot;就成年了&quot;);
&#125;</code></pre>

<p>也是利用了赋值表达式会返回一个值，在if里面赋值的同时用它的返回值做判断，然后else里面就已经有值了。上面的+号把字符串转成了整数。</p>
<h3 id="（3）自增"><a href="#（3）自增" class="headerlink" title="（3）自增"></a>（3）自增</h3><p>利用自增也可以简化代码。如下，每发出一条消息，localMsgId就自增1：</p>
<pre class="language-none"><code class="language-none">chatService.sendMessage(localMsgId++, msgContent);</code></pre>

<h2 id="5-减少魔数"><a href="#5-减少魔数" class="headerlink" title="5. 减少魔数"></a>5. 减少魔数</h2><p>例如，在某个文件的第800行，冒出来了一句：</p>
<pre class="language-none"><code class="language-none">dialogHandler.showQuestionNaire（&quot;seller&quot;, &quot;sell&quot;, 5, true);</code></pre>

<p>就会让人很困惑了，上面的四个常量分别代表什么呢，如果我不去查一个那个函数的变量说明就不能够很快地意会到这些常量分别有什么用。这些意义不明的常量就叫“魔数”。 所以最好还是给这些常量取一个名字，特别是在一些比较关键的地方。例如上面的代码可改成：</p>
<pre class="language-none"><code class="language-none">var naireType &#x3D; &quot;seller&quot;,
dialogType &#x3D; &quot;sell&quot;,
questionsCount &#x3D; 5,
reloadWindow &#x3D; true;

naireHandler.showNaire(naireType, dialogType, questionsCount, reloadWindow);</code></pre>

<p>这样意义就很明显了。</p>
<h2 id="6-使用ES6简化代码"><a href="#6-使用ES6简化代码" class="headerlink" title="6. 使用ES6简化代码"></a>6. 使用ES6简化代码</h2><p>ES6已经发展很多年了，兼容性也已经很好了。恰当地使用，可以让代码更加地简洁优雅。</p>
<h3 id="（1）使用箭头函数取代小函数"><a href="#（1）使用箭头函数取代小函数" class="headerlink" title="（1）使用箭头函数取代小函数"></a>（1）使用箭头函数取代小函数</h3><p>有很多使用小函数的场景，如果写个function，代码起码得写3行，但是用箭头函数一行就搞定了，例如实现数组从大到小排序：</p>
<pre class="language-none"><code class="language-none">var nums &#x3D; [4, 8, 1, 9, 0];
nums.sort(function(a, b)&#123;
    return b - a;
&#125;);
&#x2F;&#x2F;输出[9, 8, 4, 1, 0]</code></pre>

<p>如果用箭头函数，排序只要一行就搞定了：</p>
<pre class="language-none"><code class="language-none">var nums &#x3D; [4, 8, 1, 9, 0];

nums.sort(a, b &#x3D;&gt; b - a);</code></pre>

<p>代码看起来简洁多了，还有setTimeout里面经常会遇到只要执行一行代码就好了，写个function总感觉有点麻烦，用字符串的方式又不太好，所以这种情况用箭头函数也很方便：</p>
<pre class="language-none"><code class="language-none">setTimeout(() &#x3D;&gt; console.log(&quot;hi&quot;), 3000)</code></pre>

<p>箭头函数在C++/Java等其它语言里面叫做Lambda表达式，Ruby比较早就有这种语法形式了，后来C++/Java也实现了这种语法。 当然箭头函数或者Lambda表达式不仅适用于这种一行的，多行代码也可以，不过在一行的时候它的优点才比较明显。</p>
<h3 id="（2）使用ES6的class"><a href="#（2）使用ES6的class" class="headerlink" title="（2）使用ES6的class"></a>（2）使用ES6的class</h3><p>虽然ES6的class和使用function的prototype本质上是一样的，都是用的原型。但是用class可以减少代码量，同时让代码看起来更加地高大上，使用function要写这么多：</p>
<pre class="language-none"><code class="language-none">function Person(name, age)&#123;
    this.name &#x3D; name;
    this.age &#x3D; age;
&#125;

Person.prototype.addAge &#x3D; function()&#123;
    this.age++;
&#125;;


Person.prototype.setName &#x3D; function(name)&#123;
    this.name &#x3D; name;
&#125;;</code></pre>

<p>使用class代码看加地简洁易懂：</p>
<pre class="language-none"><code class="language-none">class Person&#123;
    constructor(name, age)&#123;
        this.name &#x3D; name;
        this.age &#x3D; age;
    &#125;
    addAge()&#123;
        this.age++;
    &#125;
    setName(name)&#123;
        this.name &#x3D; name;
    &#125;
&#125;</code></pre>

<p>并且class还可以很方便地实现继承、静态的成员函数，就不需要自己再去通过一些技巧去实现了。</p>
<h3 id="（3）字符串拼接"><a href="#（3）字符串拼接" class="headerlink" title="（3）字符串拼接"></a>（3）字符串拼接</h3><p>以前要用+号拼接：</p>
<pre class="language-none"><code class="language-none">var tpl &#x3D; 
    &#39;&lt;div&gt;&#39; + 
    &#39;    &lt;span&gt;1&lt;&#x2F;span&gt;&#39; +
    &#39;&lt;&#x2F;div&gt;&#39;;</code></pre>

<p>现在只要用两个反引号“`”就可以了：</p>
<pre class="language-none"><code class="language-none">var tpl &#x3D; 
    &#96;&lt;div&gt;
        &lt;span&gt;1&lt;&#x2F;span&gt;
    &lt;&#x2F;div&gt;
    &#96;;</code></pre>

<p>另外反引号还支持占位替换，原本你需要：</p>
<pre class="language-none"><code class="language-none">var page &#x3D; 5,
type &#x3D; encodeURIComponet(&quot;#js&quot;);
var url &#x3D; &quot;&#x2F;list?page&#x3D;&quot; + page + &quot;&amp;type&#x3D;&quot; + type;</code></pre>

<p>现在只需要： <code>var url = `/list?page=$&#123;page&#125;&amp;type=$&#123;type&#125;`;</code> 就不用使用+号把字符串拆散了。</p>
<h3 id="（4）块级作用域变量"><a href="#（4）块级作用域变量" class="headerlink" title="（4）块级作用域变量"></a>（4）块级作用域变量</h3><p>块级作用域变量也是ES6的一个特色，下面的代码是一个任务队列的模型抽象：</p>
<pre class="language-none"><code class="language-none">var tasks &#x3D; [];
for(var i &#x3D; 0; i &lt; 4; i++)&#123;
    tasks.push(function()&#123;
        console.log(&quot;i is &quot; + i);
    &#125;);
&#125;
for(var j &#x3D; 0; j &lt; tasks.length; j++)&#123;
    tasks[j]();
&#125;</code></pre>

<p>但是上面代码的执行输出是4，4，4，4，并且不是想要输出：0，1，2，3，所以每个task就不能取到它的index了，这是因为闭包都是用的同一个i变量，i已经变成4了，所以执行闭包的时候就都是4了。那怎么办呢？可以这样解决：</p>
<pre class="language-none"><code class="language-none">var tasks &#x3D; [];
for(var i &#x3D; 0; i &lt; 4; i++)&#123;
    !function(k)&#123;
        tasks.push(function()&#123;
            console.log(&quot;i is &quot; + k);
        &#125;);
    &#125;(i);
&#125;
for(var j &#x3D; 0; j &lt; tasks.length; j++)&#123;
    tasks[j]();
&#125;</code></pre>

<p>把i赋值给了k，由于k它是一个function的一个参数，每次执行函数的时候，肯定会实例化新的k，所以每次的k都是不同的变量，这样就输出就正常了。 但是代码看起来有点别扭，如果用ES6，只要把var改成let就可以了：</p>
<pre class="language-none"><code class="language-none">var tasks &#x3D; [];
for(let i &#x3D; 0; i &lt;&#x3D; 4; i++)&#123;
    tasks.push(function()&#123;
        console.log(&quot;i is &quot; + i);
    &#125;);
&#125;
for(var j &#x3D; 0; j &lt; tasks.length; j++)&#123;
    tasks[j]();
&#125;</code></pre>

<p>只改动了3个字符就达到了目的。因为for循环里面有个大括号，大括号就是一个独立的作用域，let定义的变量在独立的作用域里面它的值也是独立的。当然即使没写大括号for循环执行也是独立的。 除了以上几点，ES6还有其它一些比较好用的功能，如Object的assign，Promise等，也是可以帮助写出简洁高效的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/09/04/js%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9Fnull-%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/04/js%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9Fnull-%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">JS中原始类型有哪几种？null 是对象吗？原始数据类型和复杂数据类型有什么区别？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-04 07:35:02" itemprop="dateCreated datePublished" datetime="2019-09-04T07:35:02+08:00">2019-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目前，JS原始类型有六种，分别为:</p>
<ul>
<li>  Boolean</li>
<li>  String</li>
<li>  Number</li>
<li>  Undefined</li>
<li>  Null</li>
<li>  Symbol(ES6新增)</li>
<li>  ES10新增了一种基本数据类型：BigInt</li>
</ul>
<h2 id="复杂数据类型只有一种-Object"><a href="#复杂数据类型只有一种-Object" class="headerlink" title="复杂数据类型只有一种: Object"></a>复杂数据类型只有一种: Object</h2><p>null 不是一个对象，尽管 typeof null 输出的是 object，这是一个历史遗留问题，JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，null 表示为全零，所以将它错误的判断为 object 。 基本数据类型和复杂数据类型的区别为: 1、内存的分配不同</p>
<ul>
<li>  基本数据类型存储在栈中。</li>
<li>  复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址。</li>
</ul>
<p>2、访问机制不同</p>
<ul>
<li>  基本数据类型是按值访问</li>
<li>  复杂数据类型按引用访问，JS不允许直接访问保存在堆内存中的对象，在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值。</li>
</ul>
<p>3、复制变量时不同(a=b)</p>
<ul>
<li>  基本数据类型：a=b;是将b中保存的原始值的副本赋值给新变量a，a和b完全独立，互不影响</li>
<li>  复杂数据类型：a=b;将b保存的对象内存的引用地址赋值给了新变量a;a和b指向了同一个堆内存地址，其中一个值发生了改变，另一个也会改变。</li>
</ul>
<pre class="language-none"><code class="language-none">let b &#x3D; &#123;
age: 10
&#125;

let a &#x3D; b;
a.age &#x3D; 20;
console.log(a); &#x2F;&#x2F;&#123; age: 20 &#125;</code></pre>

<h2 id="参数传递的不同-实参-形参"><a href="#参数传递的不同-实参-形参" class="headerlink" title="参数传递的不同(实参/形参)"></a>参数传递的不同(实参/形参)</h2><p>函数传参都是按值传递(栈中的存储的内容)：基本数据类型，拷贝的是值；复杂数据类型，拷贝的是引用地址</p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F;基本数据类型
let b &#x3D; 10

function change(info) &#123;
info&#x3D;20;
&#125;
&#x2F;&#x2F;info&#x3D;b;基本数据类型，拷贝的是值得副本，二者互不干扰
change(b);
console.log(b);&#x2F;&#x2F;10
&#x2F;&#x2F;复杂数据类型
let b &#x3D; &#123;
age: 10
&#125;

function change(info) &#123;
info.age &#x3D; 20;
&#125;
&#x2F;&#x2F;info&#x3D;b;根据第三条差异，可以看出，拷贝的是地址的引用，修改互相影响。
change(b);
console.log(b);&#x2F;&#x2F;&#123; age: 20 &#125;</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/09/03/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%88%A4%E6%96%ADthis%E7%9A%84%E6%8C%87%E5%90%91%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/03/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%88%A4%E6%96%ADthis%E7%9A%84%E6%8C%87%E5%90%91%EF%BC%9F/" class="post-title-link" itemprop="url">如何正确判断this的指向？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-03 16:32:06" itemprop="dateCreated datePublished" datetime="2019-09-03T16:32:06+08:00">2019-09-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。 但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己： this 的指向可以按照以下顺序判断:</p>
<h2 id="1-全局环境中的-this"><a href="#1-全局环境中的-this" class="headerlink" title="1. 全局环境中的 this"></a>1. 全局环境中的 this</h2><p>浏览器环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 window; node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 {};</p>
<h2 id="2-是否是-new-绑定"><a href="#2-是否是-new-绑定" class="headerlink" title="2. 是否是 new 绑定"></a>2. 是否是 new 绑定</h2><p>如果是 new 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下: 构造函数返回值不是 function 或 object。</p>
<pre class="language-none"><code class="language-none">
function Super(age) &#123;
    this.age &#x3D; age;
&#125;
let instance &#x3D; new Super(&#39;26&#39;);
console.log(instance.age); &#x2F;&#x2F;26
</code></pre>

<p>构造函数返回值是 function 或 object，这种情况下 this 指向的是返回的对象。</p>
<pre class="language-none"><code class="language-none">
function Super(age) &#123;
    this.age &#x3D; age;
    let obj &#x3D; &#123;a: &#39;2&#39;&#125;;
    return obj;
&#125;
let instance &#x3D; new Super(&#39;hello&#39;);
console.log(instance.age); &#x2F;&#x2F;undefined
</code></pre>

<p>你可以想知道为什么会这样？我们来看一下 new 的实现原理:</p>
<ol>
<li> 创建一个新对象。</li>
<li> 这个新对象会被执行 <code>[原型]</code> 连接。</li>
<li> 属性和方法被加入到 this 引用的对象中。并执行了构造函数中的方法.</li>
<li> 如果函数没有返回其他对象，那么 this 指向这个新对象，否则 this 指向构造函数中返回的对象。</li>
</ol>
<pre class="language-none"><code class="language-none">
function new(func) &#123;
    let target &#x3D; &#123;&#125;;
    target.__proto__ &#x3D; func.prototype;
    let res &#x3D; func.call(target);
    &#x2F;&#x2F;排除 null 的情况
    if (res &amp;&amp; typeof(res) &#x3D;&#x3D; &quot;object&quot;  typeof(res) &#x3D;&#x3D; &quot;function&quot;) &#123;
    return res;
    &#125;
    return target;
&#125;
</code></pre>

<h2 id="3-函数是否通过-call-apply-调用，或者使用了-bind-绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。"><a href="#3-函数是否通过-call-apply-调用，或者使用了-bind-绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。" class="headerlink" title="3. 函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。"></a>3. 函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。</h2><pre class="language-none"><code class="language-none">
function info()&#123;
    console.log(this.age);
&#125;
var person &#x3D; &#123;
    age: 20,
    info
&#125;
var age &#x3D; 28;
var info &#x3D; person.info;
info.call(person);   &#x2F;&#x2F;20
info.apply(person);  &#x2F;&#x2F;20
info.bind(person)(); &#x2F;&#x2F;20
</code></pre>

<p>这里同样需要注意一种特殊情况，如果 call,apply 或者 bind 传入的第一个参数值是 undefined 或者 null，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window)</p>
<pre class="language-none"><code class="language-none">
function info()&#123;
    &#x2F;&#x2F;node环境中:非严格模式 global，严格模式为null
    &#x2F;&#x2F;浏览器环境中:非严格模式 window，严格模式为null
    console.log(this);
    console.log(this.age);
&#125;
var person &#x3D; &#123;
    age: 20,
    info
&#125;
var age &#x3D; 28;
var info &#x3D; person.info;
&#x2F;&#x2F;严格模式抛出错误；
&#x2F;&#x2F;非严格模式，node下输出undefined（因为全局的age不会挂在 global 上）
&#x2F;&#x2F;非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）
info.call(null);
</code></pre>

<h2 id="4-隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为-xxx-fn"><a href="#4-隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为-xxx-fn" class="headerlink" title="4. 隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn()"></a>4. 隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn()</h2><pre class="language-none"><code class="language-none">
function info()&#123;
    console.log(this.age);
&#125;
var person &#x3D; &#123;
    age: 20,
    info
&#125;
var age &#x3D; 28;
person.info(); &#x2F;&#x2F;20;执行的是隐式绑定
</code></pre>

<h2 id="5-默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。"><a href="#5-默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。" class="headerlink" title="5. 默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。"></a>5. 默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。</h2><pre class="language-none"><code class="language-none">
非严格模式： node环境，执行全局对象 global，浏览器环境，执行全局对象 window。 严格模式：执行 undefined

function info()&#123;
    console.log(this.age);
&#125;
var age &#x3D; 28;
&#x2F;&#x2F;严格模式；抛错
&#x2F;&#x2F;非严格模式，node下输出 undefined（因为全局的age不会挂在 global 上）
&#x2F;&#x2F;非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）
&#x2F;&#x2F;严格模式抛出，因为 this 此时是 undefined
info();
</code></pre>

<h2 id="6-箭头函数的情况："><a href="#6-箭头函数的情况：" class="headerlink" title="6. 箭头函数的情况："></a>6. 箭头函数的情况：</h2><p>箭头函数没有自己的this，继承外层上下文绑定的this。</p>
<pre class="language-none"><code class="language-none">
let obj &#x3D; &#123;
    age: 20,
    info: function() &#123;
        return () &#x3D;&gt; &#123;
            console.log(this.age); &#x2F;&#x2F;this继承的是外层上下文绑定的this
        &#125;
    &#125;
&#125;

let person &#x3D; &#123;age: 28&#125;;
let info &#x3D; obj.info();
info(); &#x2F;&#x2F;20

let info2 &#x3D; obj.info.call(person);
info2(); &#x2F;&#x2F;28
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/09/03/array-from-%E4%BA%94%E4%B8%AA%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84%E7%94%A8%E9%80%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/03/array-from-%E4%BA%94%E4%B8%AA%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84%E7%94%A8%E9%80%94/" class="post-title-link" itemprop="url">Array.from() 五个超好用的用途</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-03 15:55:40" itemprop="dateCreated datePublished" datetime="2019-09-03T15:55:40+08:00">2019-09-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>任何一种编程语言都具有超出基本用法的功能，它得益于成功的设计和试图去解决广泛问题。 JavaScript 中有一个这样的函数: Array.from：允许在 JavaScript 集合(如: 数组、类数组对象、或者是字符串、map 、set 等可迭代对象) 上进行有用的转换。 在本文中，我将描述5个有用且有趣的 Array.from() 用例。</p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>在开始之前，我们先回想一下 Array.from() 的作用。语法:</p>
<blockquote>
<p>Array.from(arrayLike[, mapFunction[, thisArg]])</p>
</blockquote>
<p>arrayLike：必传参数，想要转换成数组的伪数组对象或可迭代对象。 mapFunction：可选参数，mapFunction(item，index){…} 是在集合中的每个项目上调用的函数。返回的值将插入到新集合中。 thisArg：可选参数，执行回调函数 mapFunction 时 this 对象。这个参数很少使用。 例如，让我们将类数组的每一项乘以2：</p>
<pre class="language-none"><code class="language-none">const someNumbers &#x3D; &#123; &#39;0&#39;: 10, &#39;1&#39;: 15, length: 2 &#125;;

Array.from(someNumbers, value &#x3D;&gt; value * 2); &#x2F;&#x2F; &#x3D;&gt; [20, 30]</code></pre>


<h2 id="2-将类数组转换成数组"><a href="#2-将类数组转换成数组" class="headerlink" title="2.将类数组转换成数组"></a>2.将类数组转换成数组</h2><p>Array.from() 第一个用途：将类数组对象转换成数组。 通常，你会碰到的类数组对象有：函数中的 arguments 关键字，或者是一个 DOM 集合。 在下面的示例中，让我们对函数的参数求和：</p>
<pre class="language-none"><code class="language-none">function sumArguments() &#123;
return Array.from(arguments).reduce((sum, num) &#x3D;&gt; sum + num);
&#125;

sumArguments(1, 2, 3); &#x2F;&#x2F; &#x3D;&gt; 6</code></pre>


<p>Array.from(arguments) 将类数组对象 arguments 转换成一个数组，然后使用数组的 reduce 方法求和。 此外，Array.from() 的第一个参数可以是任意一个可迭代对象，我们继续看一些例子:</p>
<pre class="language-none"><code class="language-none">Array.from(&#39;Hey&#39;); &#x2F;&#x2F; &#x3D;&gt; [&#39;H&#39;, &#39;e&#39;, &#39;y&#39;]
Array.from(new Set([&#39;one&#39;, &#39;two&#39;])); &#x2F;&#x2F; &#x3D;&gt; [&#39;one&#39;, &#39;two&#39;]

const map &#x3D; new Map();
map.set(&#39;one&#39;, 1)
map.set(&#39;two&#39;, 2);
Array.from(map); &#x2F;&#x2F; &#x3D;&gt; [[&#39;one&#39;, 1], [&#39;two&#39;, 2]]</code></pre>


<h2 id="3-克隆一个数组"><a href="#3-克隆一个数组" class="headerlink" title="3.克隆一个数组"></a>3.克隆一个数组</h2><p>在 JavaScript 中有很多克隆数组的方法。正如你所想，Array.from() 可以很容易的实现数组的浅拷贝。</p>
<pre class="language-none"><code class="language-none">const numbers &#x3D; [3, 6, 9];
const numbersCopy &#x3D; Array.from(numbers);

numbers &#x3D;&#x3D;&#x3D; numbersCopy; &#x2F;&#x2F; &#x3D;&gt; false</code></pre>


<p>Array.from(numbers) 创建了对 numbers 数组的浅拷贝，numbers === numbersCopy 的结果是 false，意味着虽然 numbers 和 numbersCopy有着相同的项，但是它们是不同的数组对象。 是否可以使用 Array.from() 创建数组的克隆，包括所有嵌套的？挑战一下！</p>
<pre class="language-none"><code class="language-none">function recursiveClone(val) &#123;
return Array.isArray(val) ? Array.from(val, recursiveClone) : val;
&#125;
const numbers &#x3D; [[0, 1, 2], [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]];
const numbersClone &#x3D; recursiveClone(numbers);
numbersClone; &#x2F;&#x2F; &#x3D;&gt; [[0, 1, 2], [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]]
numbers[0] &#x3D;&#x3D;&#x3D; numbersClone[0] &#x2F;&#x2F; &#x3D;&gt; false</code></pre>


<p>recursiveClone() 能够对数组的深拷贝，通过判断 数组的 item 是否是一个数组，如果是数组，就继续调用 recursiveClone() 来实现了对数组的深拷贝。 你能编写一个比使用 Array.from() 递归拷贝更简短的数组深拷贝吗？如果可以的话，请写在下面的评论区。</p>
<h2 id="4-使用值填充数组"><a href="#4-使用值填充数组" class="headerlink" title="4. 使用值填充数组"></a>4. 使用值填充数组</h2><p>如果你需要使用相同的值来初始化数组，那么 Array.from() 将是不错的选择。 我们来定义一个函数，创建一个填充相同默认值的数组：</p>
<pre class="language-none"><code class="language-none">const length &#x3D; 3;
const init &#x3D; 0;
const result &#x3D; Array.from(&#123; length &#125;, () &#x3D;&gt; init);
result; &#x2F;&#x2F; &#x3D;&gt; [0, 0, 0]</code></pre>


<p>result 是一个新的数组，它的长度为3，数组的每一项都是0。调用 Array.from() 方法，传入一个类数组对象 { length } 和 返回初始化值的 mapFunction 函数。 但是，有一个替代方法 array.fill() 可以实现同样的功能。</p>
<pre class="language-none"><code class="language-none">const length &#x3D; 3;
const init &#x3D; 0;
const result &#x3D; Array(length).fill(init);
fillArray2(0, 3); &#x2F;&#x2F; &#x3D;&gt; [0, 0, 0]</code></pre>


<p>fill() 使用初始值正确填充数组。</p>
<h3 id="4-1-使用对象填充数组"><a href="#4-1-使用对象填充数组" class="headerlink" title="4.1 使用对象填充数组"></a>4.1 使用对象填充数组</h3><p>当初始化数组的每个项都应该是一个新对象时，Array.from() 是一个更好的解决方案：</p>
<pre class="language-none"><code class="language-none">const length &#x3D; 3;
const resultA &#x3D; Array.from(&#123; length &#125;, () &#x3D;&gt; (&#123;&#125;));
const resultB &#x3D; Array(length).fill(&#123;&#125;);

resultA; &#x2F;&#x2F; &#x3D;&gt; [&#123;&#125;, &#123;&#125;, &#123;&#125;]
resultB; &#x2F;&#x2F; &#x3D;&gt; [&#123;&#125;, &#123;&#125;, &#123;&#125;]

resultA[0] &#x3D;&#x3D;&#x3D; resultA[1]; &#x2F;&#x2F; &#x3D;&gt; false
resultB[0] &#x3D;&#x3D;&#x3D; resultB[1]; &#x2F;&#x2F; &#x3D;&gt; true</code></pre>


<p>由 Array.from 返回的 resultA 使用不同空对象实例进行初始化。之所以发生这种情况是因为每次调用时，mapFunction，即此处的 () =&gt; ({}) 都会返回一个新的对象。 然后，fill() 方法创建的 resultB 使用相同的空对象实例进行初始化。不会跳过空项。</p>
<h3 id="4-2-使用-array-map-怎么样？"><a href="#4-2-使用-array-map-怎么样？" class="headerlink" title="4.2 使用 array.map 怎么样？"></a>4.2 使用 array.map 怎么样？</h3><p>是不是可以使用 array.map() 方法来实现？我们来试一下:</p>
<pre class="language-none"><code class="language-none">const length &#x3D; 3;
const init &#x3D; 0;
const result &#x3D; Array(length).map(() &#x3D;&gt; init);

result; &#x2F;&#x2F; &#x3D;&gt; [undefined, undefined, undefined]</code></pre>


<p>map() 方法似乎不正常，创建出来的数组不是预期的 [0, 0, 0]，而是一个有3个空项的数组。 这是因为 Array(length) 创建了一个有3个空项的数组(也称为稀疏数组)，但是 map() 方法会跳过空项。</p>
<h2 id="5-生成数字范围"><a href="#5-生成数字范围" class="headerlink" title="5. 生成数字范围"></a>5. 生成数字范围</h2><p>你可以使用 Array.from() 生成值范围。例如，下面的 range 函数生成一个数组，从0开始到 end - 1。</p>
<pre class="language-none"><code class="language-none">function range(end) &#123;
return Array.from(&#123; length: end &#125;, (_, index) &#x3D;&gt; index);
&#125;
range(4); &#x2F;&#x2F; &#x3D;&gt; [0, 1, 2, 3]</code></pre>


<p>在 range() 函数中，Array.from() 提供了类似数组的 {length：end} ，以及一个简单地返回当前索引的 map 函数 。这样你就可以生成值范围。</p>
<h2 id="6-数组去重"><a href="#6-数组去重" class="headerlink" title="6.数组去重"></a>6.数组去重</h2><p>由于 Array.from() 的入参是可迭代对象，因而我们可以利用其与 Set 结合来实现快速从数组中删除重复项。</p>
<pre class="language-none"><code class="language-none">function unique(array) &#123;
return Array.from(new Set(array));
&#125;

unique([1, 1, 2, 3, 3]); &#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]</code></pre>


<p>首先，new Set(array) 创建了一个包含数组的集合，Set 集合会删除重复项。 因为 Set 集合是可迭代的，所以可以使用 Array.from() 将其转换为一个新的数组。 这样，我们就实现了数组去重。</p>
<h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7.结论"></a>7.结论</h2><p>Array.from() 方法接受类数组对象以及可迭代对象，它可以接受一个 map 函数，并且，这个 map 函数不会跳过值为 undefined 的数值项。这些特性给 Array.from() 提供了很多可能。 如上所述，你可以轻松的将类数组对象转换为数组，克隆一个数组，使用初始化填充数组，生成一个范围，实现数组去重。 实际上，Array.from() 是非常好的设计，灵活的配置，允许很多集合转换。 你知道 Array.from() 的其他有趣用例吗？可以写在评论区。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/08/07/%E7%BB%8F%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%88%AA%E5%8F%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/07/%E7%BB%8F%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%88%AA%E5%8F%96/" class="post-title-link" itemprop="url">经常用到的几个字符串的截取</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-07 14:51:42" itemprop="dateCreated datePublished" datetime="2019-08-07T14:51:42+08:00">2019-08-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre class="language-none"><code class="language-none">var str&#x3D;&quot;123abc456&quot;;
var i&#x3D;3;</code></pre>


<p>1 取字符串的前i个字符：（不操作原字符）</p>
<pre class="language-none"><code class="language-none">str&#x3D;str.substring(0,i);</code></pre>


<p>2 从右边开始取i个字符：（不操作原字符）</p>
<pre class="language-none"><code class="language-none">str&#x3D;str.substring(str.Length-i);</code></pre>


<p>3 从右边开始去掉i个字符：（不操作原字符）</p>
<pre class="language-none"><code class="language-none">str&#x3D;str.substring(0,str.Length-i);</code></pre>


<p>4 如果字符串中有”abc”则替换成”ABC”：（操作原字符）</p>
<pre class="language-none"><code class="language-none">str&#x3D;str.replace(&quot;abc&quot;,&quot;ABC&quot;);</code></pre>


<p>5 如果想从某一个字符的下标开始：（不操作原字符）</p>
<pre class="language-none"><code class="language-none">str&#x3D;str.substr(str.indexOf(&#39;a&#39;),3);&#x2F;&#x2F; 从‘a’下标开始(包括‘a’)截取3个元素，不操作原字符</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/07/20/css3%E6%96%87%E6%9C%AC%E6%B8%90%E5%8F%98%EF%BC%88Gradient%20Text%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/20/css3%E6%96%87%E6%9C%AC%E6%B8%90%E5%8F%98%EF%BC%88Gradient%20Text%EF%BC%89/" class="post-title-link" itemprop="url">CSS3 文本渐变（Gradient Text）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-20 14:56:36" itemprop="dateCreated datePublished" datetime="2019-07-20T14:56:36+08:00">2019-07-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果你现在刚刚熟悉渐变是什么，我们会在你深入研究更强硬的东西之前为你画画。渐变是具有起点和终点的颜色的渐变 - 因此，线性渐变以一种颜色（如红色）开始，并逐渐沿直线过渡到另一种颜色（如蓝色）。就像我们在线性渐变文章中所说的那样，将日落视为线性渐变的最佳示例，以及每种颜色如何精美无缝地进入下一个。</p>
<style>h2 {text-align: center;font-size: 48px !important;font-weight: 800;background: -webkit-linear-gradient(45deg, #09009f, #00ff95 80%);-webkit-background-clip: text;-webkit-text-fill-color: transparent;margin: 0;}</style>

<h2 id="文字渐变"><a href="#文字渐变" class="headerlink" title="文字渐变"></a>文字渐变</h2><pre class="language-none"><code class="language-none">h1 &#123;
  font-size：72px;
  background：-webkit-linear-gradient（#eee，＃333）;
  -webkit-background-clip：text;
  -webkit-text-fill-color：transparent;
&#125;</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/07/19/css3%E5%BE%84%E5%90%91%E6%B8%90%E5%8F%98%EF%BC%88radial-gradients%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/19/css3%E5%BE%84%E5%90%91%E6%B8%90%E5%8F%98%EF%BC%88radial-gradients%EF%BC%89/" class="post-title-link" itemprop="url">CSS3 径向渐变（Radial Gradients）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-19 14:50:35" itemprop="dateCreated datePublished" datetime="2019-07-19T14:50:35+08:00">2019-07-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>径向渐变由它的中心定义。 为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。 <strong>语法</strong></p>
<pre class="language-none"><code class="language-none">background: radial-gradient(center, shape size, start-color, ..., last-color);</code></pre>


<p>径向渐变 - 颜色结点均匀分布</p>
<pre class="language-none"><code class="language-none">background: radial-gradient(red, green, blue); &#x2F;* 标准的语法 *&#x2F;</code></pre>


<p>径向渐变 - 颜色结点不均匀分布</p>
<pre class="language-none"><code class="language-none">background: radial-gradient(red 5%, green 15%, blue 60%); &#x2F;* 标准的语法 *&#x2F;</code></pre>


<h2 id="设置形状"><a href="#设置形状" class="headerlink" title="设置形状"></a>设置形状</h2><p>shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。</p>
<pre class="language-none"><code class="language-none">background: radial-gradient(circle, red, yellow, green); &#x2F;* 标准的语法 *&#x2F;</code></pre>


<h3 id="不同尺寸大小关键字的使用"><a href="#不同尺寸大小关键字的使用" class="headerlink" title="不同尺寸大小关键字的使用"></a>不同尺寸大小关键字的使用</h3><p>size 参数定义了渐变的大小。它可以是以下四个值：</p>
<ul>
<li>  closest-side</li>
<li>  farthest-side</li>
<li>  closest-corner</li>
<li>  farthest-corner</li>
</ul>
<p>带有不同尺寸大小关键字的径向渐变</p>
<pre class="language-none"><code class="language-none">background: radial-gradient(60% 55%, closest-side,blue,green,yellow,black);

background: radial-gradient(60% 55%, farthest-side,blue,green,yellow,black);</code></pre>


<h2 id="重复的径向渐变"><a href="#重复的径向渐变" class="headerlink" title="重复的径向渐变"></a>重复的径向渐变</h2><p>repeating-radial-gradient() 函数用于重复径向渐变</p>
<pre class="language-none"><code class="language-none">background: repeating-radial-gradient(red, yellow 10%, green 15%);</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/07/18/css3%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98%EF%BC%88linear-gradients%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/18/css3%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98%EF%BC%88linear-gradients%EF%BC%89/" class="post-title-link" itemprop="url">CSS3线性渐变（Linear Gradients）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-18 14:42:27" itemprop="dateCreated datePublished" datetime="2019-07-18T14:42:27+08:00">2019-07-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML-CSS/" itemprop="url" rel="index"><span itemprop="name">HTML/CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。 以前，你必须使用图像来实现这些效果。但是，通过使用 CSS3 渐变（gradients），你可以减少下载的时间和宽带的使用。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。 CSS3 定义了两种类型的渐变（gradients）：</p>
<ul>
<li>  线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向</li>
<li>  径向渐变（Radial Gradients）- 由它们的中心定义</li>
</ul>
<h2 id="CSS3-线性渐变"><a href="#CSS3-线性渐变" class="headerlink" title="CSS3 线性渐变"></a>CSS3 线性渐变</h2><p>为了创建一个线性渐变，你必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。 <strong>语法</strong></p>
<pre class="language-none"><code class="language-none">background: linear-gradient(direction, color-stop1, color-stop2, ...);</code></pre>


<p><strong>线性渐变 - 从上到下（默认情况下）</strong></p>
<pre class="language-none"><code class="language-none">background: linear-gradient(red, blue); &#x2F;* 标准的语法 *&#x2F;</code></pre>


<p><strong>线性渐变 - 从左到右</strong></p>
<pre class="language-none"><code class="language-none">background: linear-gradient(to right, red , blue); &#x2F;* 标准的语法 *&#x2F;</code></pre>


<p><strong>线性渐变 - 对角</strong></p>
<pre class="language-none"><code class="language-none">background: linear-gradient(to bottom right, red , blue); &#x2F;* 标准的语法 *&#x2F;</code></pre>


<h3 id="使用角度"><a href="#使用角度" class="headerlink" title="使用角度"></a>使用角度</h3><p>如果你想要在渐变的方向上做更多的控制，你可以定义一个角度，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）。 <strong>语法</strong></p>
<pre class="language-none"><code class="language-none">background: linear-gradient(angle, color-stop1, color-stop2);</code></pre>


<p>角度是指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。 <a target="_blank" rel="noopener" href="http://www.w3cbest.com/wp-content/uploads/2019/07/7B0CC41A-86DC-4E1B-8A69-A410E6764B91.jpg">http://www.w3cbest.com/wp-content/uploads/2019/07/7B0CC41A-86DC-4E1B-8A69-A410E6764B91.jpg</a> 但是，请注意很多浏览器(Chrome,Safari,fiefox等)的使用了旧的标准，即 0deg 将创建一个从左到右的渐变，90deg 将创建一个从下到上的渐变。换算公式 90 - x = y 其中 x 为标准角度，y为非标准角度。 <strong>带有指定的角度的线性渐变</strong></p>
<pre class="language-none"><code class="language-none">background: linear-gradient(180deg, red, blue); &#x2F;* 标准的语法 *&#x2F;</code></pre>


<p><strong>使用多个颜色结点</strong> 带有多个颜色结点的从上到下的线性渐变</p>
<pre class="language-none"><code class="language-none">background: linear-gradient(red, green, blue); &#x2F;* 标准的语法 *&#x2F;</code></pre>


<p>带有多个颜色结点的从左到右的线性渐变</p>
<pre class="language-none"><code class="language-none">background: linear-gradient(to right, red,orange,yellow,green,blue,indigo,violet);</code></pre>


<h2 id="使用透明度（transparent）"><a href="#使用透明度（transparent）" class="headerlink" title="使用透明度（transparent）"></a>使用透明度（transparent）</h2><p>CSS3 渐变也支持透明度（transparent），可用于创建减弱变淡的效果。 为了添加透明度，我们使用 rgba() 函数来定义颜色结点。rgba() 函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。</p>
<pre class="language-none"><code class="language-none">background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); &#x2F;* 标准的语法 *&#x2F;</code></pre>


<h2 id="重复的线性渐变"><a href="#重复的线性渐变" class="headerlink" title="重复的线性渐变"></a>重复的线性渐变</h2><p>repeating-linear-gradient() 函数用于重复线性渐变：</p>
<pre class="language-none"><code class="language-none">background: repeating-linear-gradient(red, yellow 10%, green 20%);</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xianzhiding.github.io/2019/07/04/echarts-%E4%B8%BA%E9%9B%B7%E8%BE%BE%E5%9B%BE%E8%AE%BE%E7%BD%AE%E6%9E%81%E5%9D%90%E6%A0%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端开发 大前端 W3Cbest">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/04/echarts-%E4%B8%BA%E9%9B%B7%E8%BE%BE%E5%9B%BE%E8%AE%BE%E7%BD%AE%E6%9E%81%E5%9D%90%E6%A0%87/" class="post-title-link" itemprop="url">echarts 为雷达图设置极坐标</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-04 16:45:33" itemprop="dateCreated datePublished" datetime="2019-07-04T16:45:33+08:00">2019-07-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ECharts/" itemprop="url" rel="index"><span itemprop="name">ECharts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ECharts 雷达图可以使用 <code>series[i]-radar</code>设置 ，雷达图主要用于表现多变量的数据，例如玩”和平精英”战况的各个属性分析，雷达图依赖<code>radar</code>组件。 关于雷达图其他的一些属性自行去查看官网，我们在这里讲的是在雷达图上设置极坐标。 首先要了解极坐标系，因为实现极坐标需要一个系列三个属性完成，分别是<code>polar:&#123;&#125;</code>极坐标系、<code>radiusAxis:&#123;&#125;</code>极坐标系的径向轴、<code>angleAxis:&#123;&#125;</code>极坐标系的角度轴完成，<a target="_blank" rel="noopener" href="https://www.echartsjs.com/gallery/editor.html?c=doc-example/polar-start-angle">查看示例</a> 如何把极坐标系和雷达图合并呢，下面我们就来说说如何设置，还是需要用到<code>radar</code>组件，<code>radar</code>组件下面有一个<code>indicator</code>属性， 它是雷达图的指示器，用来指定雷达图中的多个变量（维度）。 然后我们它的最大值<code>radar.indicator[i].max</code>和最小值<code>radar.indicator[i].min</code>设为统一的值，要注意它的这里的最大值要大于或等于你的数据的最大值，最小值要小于或等于你的数据的最小值。 下面是用雷达图表现的示例。</p>
<p class="codepen" data-height="460" data-theme-id="0" data-default-tab="result" data-user="w3cbest" data-slug-hash="zVLxKV" style="height: 456px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="echarts 雷达图设置极坐标">
  <span>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/w3cbest/pen/zVLxKV/">
  echarts 雷达图设置极坐标</a> by w3cbest.com (<a target="_blank" rel="noopener" href="https://codepen.io/w3cbest">@w3cbest</a>)
  on <a target="_blank" rel="noopener" href="https://codepen.io">CodePen</a>.</span>
</p>

<pre class="language-none"><code class="language-none">var max &#x3D; 4, min &#x3D; -4;
option &#x3D; &#123;
    ...
    radar: &#123;
        ...
        indicator: [&#123;
                name: &#39;销售&#39;,
                max: max,
                min: min
            &#125;,
            &#123;
                name: &#39;管理&#39;,
                max: max,
                min: min
            &#125;,
            &#123;
                name: &#39;技术&#39;,
                max: max,
                min: min
            &#125;
        ],
        splitArea: &#123;
            show: false
        &#125;,
        splitLine: &#123;
            show: false
        &#125;
    &#125;,
    polar: &#123;&#125;,
    angleAxis: &#123;
        min: 0,
        max: 360,
        interval: 5,
        clockwise: false,
        axisTick: &#123;
            show: false
        &#125;,
        axisLabel: &#123;
            show: false
        &#125;,
        axisLine: &#123;
            show: false
        &#125;,
        splitLine: &#123;
            show: false
        &#125;
    &#125;,
    radiusAxis: &#123;
        min: min,
        max: max,
        interval: 2,
        splitArea: &#123;
            show: true
        &#125;
    &#125;,
    series: [&#123;
        ...
        data: [&#123;
            value: [4, -4, 1]
        &#125;]
    &#125;]
&#125;;</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Tom</p>
  <div class="site-description" itemprop="description">w3cbest是一个专注前端开发、用户体验设计,提供大量最新前端前沿技术文章及资源。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">338</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">W3Cbest前端开发</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
