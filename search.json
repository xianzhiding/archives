[{"title":"10个有趣的JavaScript和CSS库","url":"/2019/04/10/10%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84javascript%E5%92%8Ccss%E5%BA%93/","content":"<p><a href=\"https://cube.dev/\"><img src=\"http://file.w3cbest.com/file/images/cubejs.png\"></a> <a href=\"https://cube.dev/\">Cube.js</a> 强大的开源框架，用于开发复杂的，定制的分析系统。由前端SDK和API后端组成，适用于大多数数据库，包括MySQL，Postreges和MongoDB。 <a href=\"https://github.com/kognise/water.css\"><img src=\"http://file.w3cbest.com/file/images/watercss.png\"></a> <a href=\"https://github.com/kognise/water.css\">Water.css</a> 一个just-add-css框架，它可以应用样式而无需定义元素类。只需通过CDN将其包含在您的项目中，您的所有页面都会自动显示得更好。包括明暗主题，可通过SCSS定制。 <a href=\"https://codex.so/editor\"><img src=\"http://file.w3cbest.com/file/images/editorjs.png\"></a> <a href=\"https://codex.so/editor\">Editor.js</a> 富文本和媒体编辑器，以JSON格式输出数据。它是完全模块化的，由“块”组成，这意味着每个结构单元都是它自己的块（例如Paragraph，Heading，Image都是块），用户可以轻松编写自己的插件来进一步扩展编辑器。 <a href=\"https://github.com/alikinvv/stepper\"><img src=\"http://file.w3cbest.com/file/images/stepper.png\"></a> <a href=\"https://github.com/alikinvv/stepper\">Stepper</a> 漂亮的数字Stepper组件，非常适合upvote / downvote控件或其他计数器元素。非常精美的动画，点击箭头时有一个黄油般的CSS效果。 <a href=\"https://github.com/leeoniya/dropcss\"><img src=\"http://file.w3cbest.com/file/images/dropcsss.png\"></a> <a href=\"https://github.com/leeoniya/dropcss\">DropCSS</a> 彻底的CSS清理器，它可以获取HTML和CSS并仅返回实际使用的样式。它删除所有未使用的样式块，重复选择器，@ keyframes等。高度优化，速度极快。 <a href=\"https://github.com/twitter/twemoji\"><img src=\"http://file.w3cbest.com/file/images/twemoji.png\"></a> <a href=\"https://github.com/twitter/twemoji\">Twemoji</a> Twitter团队提供的优秀图书馆，可在所有平台上提供标准的Unicode表情符号支持。拥有超过3000个emojis和一个可靠的API，当您想要将emojis添加到您的应用程序时，它可以是完美的解决方案。 <a href=\"https://foreseaz.github.io/react-loadcon/\"><img src=\"http://file.w3cbest.com/file/images/react-loadcon.png\"></a> <a href=\"https://foreseaz.github.io/react-loadcon/\">React LoadCon</a> React组件，允许您使用一系列动态生成的图像为网站的图标设置动画。此效果可以用作进度或加载指示器，或者只是作为一个很酷的小动画来使您的页面脱颖而出。 <a href=\"https://github.com/matvp91/indigo-player\"><img src=\"http://file.w3cbest.com/file/images/indigoplayer.png\"></a> <a href=\"https://github.com/matvp91/indigo-player\">Indigo Player</a> 基于React的视频播放器，具有开箱即用的功能，如字幕，缩略图，质量选择等。高度可扩展，现代化，并支持大多数流行的视频格式和编解码器。 <a href=\"https://github.com/niklasvh/html2canvas\"><img src=\"http://file.w3cbest.com/file/images/html2canvas.png\"></a> <a href=\"https://github.com/niklasvh/html2canvas\">html2canvas</a> 这个很酷的脚本获取页面中的元素和样式，并通过呈现DOM的副本来捕获“屏幕截图”。由于屏幕截图基于DOM，因此它们可能不是100％准确，但该库仍然是调试和自动化测试的绝佳工具。 <a href=\"https://github.com/jshjohnson/Choices\"><img src=\"http://file.w3cbest.com/file/images/choices.png\"></a> <a href=\"https://github.com/jshjohnson/Choices\">Choices</a> 轻量级库，用于制作高度可自定义的选择框，文本区域和其他表单输入。类似于<a href=\"https://select2.org/\">Select2</a>和<a href=\"https://selectize.github.io/selectize.js/\">Selectize</a>但没有jQuery依赖。</p>\n","categories":["HTML/CSS","资源","JavaScript"],"tags":["CSS库","css插件","JavaScript库","JavaScript插件"]},{"title":"12个令人难以置信的纯CSS实验","url":"/2019/01/29/12%E4%B8%AA%E4%BB%A4%E4%BA%BA%E9%9A%BE%E4%BB%A5%E7%BD%AE%E4%BF%A1%E7%9A%84%E7%BA%AFcss%E5%AE%9E%E9%AA%8C/","content":"<p>你可能认为 CSS 只是一种简单地为网页设计样式的语言，但它的功能比你想象的要多得多。 从逼真的图像到甚至是视频游戏，你会惊讶地看到一个优秀的开发者可以用 CSS 做些什么。 这里有各种滤镜和特效，它们都是开源的，可以用在你自己的 web 项目中。 这些模块有的机遇 JavaScript，更多的是HTML。 这意味着它们比你期望的更轻盈。 看看这些惊人的纯CSS实验，也许你自己也可以尝试一下。</p>\n<h2 id=\"太阳系\"><a href=\"#太阳系\" class=\"headerlink\" title=\"太阳系\"></a>太阳系</h2><p>See the Pen <a href=\"https://codepen.io/kowlor/pen/ZYYQoy/\">Solar System animation - Pure CSS</a> by Malik Dellidj (<a href=\"https://codepen.io/kowlor\">@kowlor</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>哇！ 如果你喜欢太空，一定会被这个用 CSS 实现的的太阳系动画效果所震撼。 这不仅仅是一个漂亮的动画; 相对于真实的地球年，每个行星都能准确地围绕太阳旋转。</p>\n<h2 id=\"渐变背景动画\"><a href=\"#渐变背景动画\" class=\"headerlink\" title=\"渐变背景动画\"></a>渐变背景动画</h2><p>See the Pen <a href=\"https://codepen.io/P1N2O/pen/pyBNzX/\">Pure CSS3 Gradient Background Animation</a> by Manuel Pinto (<a href=\"https://codepen.io/P1N2O\">@P1N2O</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>动画对于网站来说是一个臭名昭着的问题。如果优化不佳，可能会导致速度大服务放缓。这个美丽的动画渐变效果非常轻巧，更不用说它能让你很容易的就能编辑和添加自己的颜色。</p>\n<h2 id=\"堆叠游戏\"><a href=\"#堆叠游戏\" class=\"headerlink\" title=\"堆叠游戏\"></a>堆叠游戏</h2><p>See the Pen <a href=\"https://codepen.io/finnhvman/pen/xJRMJp/\">Pure CSS Stack</a> by Ben Szabo (<a href=\"https://codepen.io/finnhvman\">@finnhvman</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>你不需要JavaScript来制作游戏。它可能很简单，但纯CSS堆栈游戏很有趣，而且图形也很漂亮。这可不容易，但它只是展示了一点CSS的能力。</p>\n<h2 id=\"3D进度条\"><a href=\"#3D进度条\" class=\"headerlink\" title=\"3D进度条\"></a>3D进度条</h2><p>See the Pen <a href=\"https://codepen.io/rgg/pen/QbRyOq/\">Pure CSS Progress</a> by Rafael González (<a href=\"https://codepen.io/rgg\">@rgg</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>漂亮轻便的进度条。易于定制，很容易适应你的项目。 这些条纹使用 3D 技术制作，具有独特的液体外观。 你甚至可以将它们变成迷你 3D 图表！</p>\n<h2 id=\"Glitched-Text\"><a href=\"#Glitched-Text\" class=\"headerlink\" title=\"Glitched Text\"></a>Glitched Text</h2><p>See the Pen <a href=\"https://codepen.io/lbebber/pen/ypgql/\">CSS Glitched Text</a> by Lucas Bebber (<a href=\"https://codepen.io/lbebber\">@lbebber</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>Glitched文本看起来总是很酷。这个案例没有使用 GIF，仅用 JavaScript 或 HTML 就实现了生动的特效。 如果你想为你的网站添加小故障效果，请参考它。</p>\n<h2 id=\"Francine\"><a href=\"#Francine\" class=\"headerlink\" title=\"Francine\"></a>Francine</h2><p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/NorZmX/\">francine</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>你可以用 HTML 和 CSS 制作艺术品！ Francine 是一副18世纪风格的画作，纯粹用代码制作和展示。 然而它看起来与其他传统创作的艺术品没有任何区别。</p>\n<h2 id=\"Mobile-Phone\"><a href=\"#Mobile-Phone\" class=\"headerlink\" title=\"Mobile Phone\"></a>Mobile Phone</h2><p>See the Pen <a href=\"https://codepen.io/Wujek_Greg/pen/LmrweG/\">Photorealistic pure CSS mobile phone</a> by Grzegorz Witczak (<a href=\"https://codepen.io/Wujek_Greg\">@Wujek_Greg</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>与 Francine 类似，这款手机也是只用 CSS 和 HTML 创造的，但是看上去简直和真的一样！ 如果你有兴趣，可以使用代码并查看如何实现。</p>\n<h2 id=\"我的世界\"><a href=\"#我的世界\" class=\"headerlink\" title=\"我的世界\"></a>我的世界</h2><p>See the Pen <a href=\"https://codepen.io/onediv/pen/NrNebj/\">Full CSS Map creator</a> by Vincent Durand (<a href=\"https://codepen.io/onediv\">@onediv</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>你以为要用 JavaScript 来编写这东西？ 再好好想想！ 这个可爱的 3D 地图创作器除了 CSS（还有一点点HTML）之外什么都没有。 难道这不足以令人兴奋吗？</p>\n<h2 id=\"Instagram-css\"><a href=\"#Instagram-css\" class=\"headerlink\" title=\"Instagram.css\"></a>Instagram.css</h2><p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/ZwOgQP/\">Instagram</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>你的网站需要一些仿 Instagram 风格的过滤器？ 这组缩小文件也附带安装教程。 现在，你可以轻松地将 Instagram 过滤器添加到任何图像中。</p>\n<h2 id=\"动画渐变重影按钮\"><a href=\"#动画渐变重影按钮\" class=\"headerlink\" title=\"动画渐变重影按钮\"></a>动画渐变重影按钮</h2><p>See the Pen <a href=\"https://codepen.io/ARS/pen/vEwEPP/\">Animated Gradient Ghost Button Concept</a> by Arsen Zbidniakov (<a href=\"https://codepen.io/ARS\">@ARS</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>令人惊讶的是它是只用 CSS 编写的。 凭借其漂亮的动画和渐变效果，把这个按钮用在任何网站上，看起来都会很棒。</p>\n<h2 id=\"Devices-css\"><a href=\"#Devices-css\" class=\"headerlink\" title=\"Devices.css\"></a><a href=\"https://picturepan2.github.io/devices.css/\">Devices.css</a></h2><p><a href=\"https://picturepan2.github.io/devices.css/\"><img src=\"http://file.w3cbest.com/file/images/css-experiments-devices.jpg\"></a> 如果你曾经想在自己的网站上展示手机或电脑，并在屏幕上显示你所选择的图片，请参考此项目。 这些都是以现代设备为蓝本设计的！</p>\n<h2 id=\"动态图像着色\"><a href=\"#动态图像着色\" class=\"headerlink\" title=\"动态图像着色\"></a>动态图像着色</h2><p>See the Pen <a href=\"https://codepen.io/noahblon/pen/ZbjmbK/\">Dynamic Image Colorizing with &lt;input type=&quot;color&quot;&rt;</a> by Noah Blon (<a href=\"https://codepen.io/noahblon\">@noahblon</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>这是一个非常酷的项目：用 CSS 和颜色选择工具更改图片中的颜色。</p>\n<h2 id=\"小巧、灵敏和美丽\"><a href=\"#小巧、灵敏和美丽\" class=\"headerlink\" title=\"小巧、灵敏和美丽\"></a>小巧、灵敏和美丽</h2><p>你在网站上看到的许多惊人的特效都可以说是 JavaScript 的功劳，遗憾的是 JS 并不总是最轻量级的解决方案。 不过你可能会对CSS的功能感到惊讶。 如果做得正确，大多数情况下它对性能的影响要小得多。 无论是哪种方式，可以看到 CSS开发者提出的这些创意都很有趣。这些实验项目是由一些真正的创新开发者做出的，所以请去给他们一些支持，并告诉我你觉得哪个是最酷的！ 文章来源：<a href=\"https://1stwebdesigner.com/12-incredible-pure-css-experiments/\">https://1stwebdesigner.com</a></p>\n","categories":["资源"],"tags":["css","html","javascript","前端","前端资源"]},{"title":"12个可以提升JavaScript技能的概念","url":"/2019/04/08/12%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8F%90%E5%8D%87javascript%E6%8A%80%E8%83%BD%E7%9A%84%E6%A6%82%E5%BF%B5/","content":"<p>javascript 是一门复杂的语言。如果你是一名 javascript 开发者，理解它的一些基础概念是很重要的。本文选取了 12 个 JS 开发者应该掌握的概念，但不代表 JS 开发者需要了解的全部内容。 <strong>注意：</strong>我会在 github 仓库<a href=\"https://link.juejin.im/?target=https://github.com/nas5w/javascript-tips-and-tidbits\">JS Tips &amp; Tidbits</a>上持续更新这个列表，如果有兴趣欢迎 star。</p>\n<h2 id=\"1-值-VS-引用\"><a href=\"#1-值-VS-引用\" class=\"headerlink\" title=\"1. 值 VS 引用\"></a>1. 值 VS 引用</h2><p>理解 javascript 中如何分配变量的值是写好代码的基础。如果你还不了解这些，你可能很容易写出无意中修改值的代码。 javascript 总是按值分配变量。但是请特别注意：当分配的值是 javascript 的 5 种原始类型（boolean null undefined string number）时，是分配的真正的值。而如果分配的值是 Array Function Object时，只会分配该对象在内存中的一个引用。 举个例子。在下面的代码中，var2 被赋值为 var1。因为 var1 是原始类型（string），var2 的值就是 var1 的 值，并且与 var1 是完全独立的两个值，只是它们都是同样的字符串。或者说，重新给 var2 赋值对 var1 没有影响。</p>\n<p>let var1 = ‘My string’;<br>let var2 = var1;<br>var2 = ‘My new string’;<br>console.log(var1);<br>// ‘My string’<br>console.log(var2);<br>// ‘My new string’</p>\n<p>和赋值对象进行比较：</p>\n<p>let var1 = { name: ‘Jim’ };<br>let var2 = var1;<br>var2.name = ‘John’;<br>console.log(var1);<br>// { name: ‘John’ }<br>console.log(var2);<br>// { name: ‘John’ }</p>\n<p>如果你期望像分配原始类型那样的结果，这里就会出现问题，修改 var2 同样会影响到 var1。如果你创建了一个无意中修改对象的函数，就可能有难以预料的错误。</p>\n<h2 id=\"2-闭包\"><a href=\"#2-闭包\" class=\"headerlink\" title=\"2. 闭包\"></a>2. 闭包</h2><p>闭包是 javascript 中很重要的特性，可以实现变量的私有访问。在下面的例子中，createGreeter 返回了一个匿名函数，函数可以访问外层函数的 greeting 参数。</p>\n<p>function createGreeter(greeting) {<br>    return function(name) {<br>        console.log(greeting + ‘, ‘ + name);<br>    };<br>}<br>const sayHello = createGreeter(‘Hello’);<br>sayHello(‘Joe’);<br>// Hello, Joe</p>\n<p>在实际编码中，你可能希望有一个初始化函数 apiConnect(apiKey) 能够返回某些方法会用到的 apiKey。这种情况下，apiKey 只需要提供一次即可。</p>\n<p>function apiConnect(apiKey) {<br>    function get(route) {<br>        return fetch(`${route}?key=${apiKey}`);<br>    }<br>    function post(route, params) {<br>        return fetch(route, {<br>            method: ‘POST’,<br>            body: JSON.stringify(params),<br>            headers: {<br>                Authorization: `Bearer ${apiKey}`,<br>            },<br>        });<br>    }<br>    return { get, post };<br>}<br>const api = apiConnect(‘my-secret-key’);<br>// No need to include the apiKey anymore<br>api.get(‘<a href=\"http://www.example.com/get-endpoint&#39;\">http://www.example.com/get-endpoint&#39;</a>);<br>api.post(‘<a href=\"http://www.example.com/post-endpoint&#39;\">http://www.example.com/post-endpoint&#39;</a>, { name: ‘Joe’ });</p>\n<h2 id=\"3-解构\"><a href=\"#3-解构\" class=\"headerlink\" title=\"3. 解构\"></a>3. 解构</h2><p>不要忽略 javascript 的参数解构！这是从对象中干净地提取属性的常用方法。</p>\n<p>const obj = {<br>    name: ‘Joe’,<br>    food: ‘cake’,<br>};<br>const { name, food } = obj;<br>console.log(name, food);<br>// ‘Joe’ ‘cake’</p>\n<p>如果你想将属性解构成不同的名称，参考下面的语法：</p>\n<p>const obj = {<br>    name: ‘Joe’,<br>    food: ‘cake’,<br>};<br>const { name: myName, food: myFood } = obj;<br>console.log(myName, myFood);<br>// ‘Joe’ ‘cake’</p>\n<p>下面的例子中，解构用来干净地将 person 对象传递给 introduce 函数。或者说，解构可以（经常）用来提取传递给函数的参数的属性。如果你熟悉 React，你可能见过下面的代码。</p>\n<p>const person = {<br>    name: ‘Eddie’,<br>    age: 24,<br>};<br>function introduce({ name, age }) {<br>    console.log(`I’m ${name} and I’m ${age} years old!`);<br>}<br>console.log(introduce(person));<br>// “I’m Eddie and I’m 24 years old!”</p>\n<h2 id=\"4-展开运算符\"><a href=\"#4-展开运算符\" class=\"headerlink\" title=\"4. 展开运算符\"></a>4. 展开运算符</h2><p>一个相对简单的 javascript 概念。下面的例子中，Math.max 不能接收一个数组，而是接收单个值作为参数。展开运算符…就是用来把数组里的元素一个一个拉出来。</p>\n<p>const arr = [4, 6, -1, 3, 10, 4];<br>const max = Math.max(…arr);<br>console.log(max);<br>// 10</p>\n<h2 id=\"5-剩余运算符\"><a href=\"#5-剩余运算符\" class=\"headerlink\" title=\"5. 剩余运算符\"></a>5. 剩余运算符</h2><p>说一下 javascript 的剩余运算符。你可以用它将任意数量的参数放入一个数组再传递给函数。</p>\n<p>function myFunc(…args) {<br>    console.log(args[0] + args[1]);<br>}<br>myFunc(1, 2, 3, 4);<br>// 3</p>\n<h2 id=\"6-数组方法\"><a href=\"#6-数组方法\" class=\"headerlink\" title=\"6. 数组方法\"></a>6. 数组方法</h2><p>javascript 的数组方法经常能让你很优雅、便捷地转换你想要的数据。我经常看到有关如何以某种方式操纵对象数组的问题。这正是数组方法的可用之处。 我将在这里介绍一些不同的数组方法，以类似的可能会混淆的方法来分类。这个列表并不全面，我鼓励你们在 MDN 上反复复习并练习这些方法。</p>\n<h3 id=\"map-filter-reduce\"><a href=\"#map-filter-reduce\" class=\"headerlink\" title=\"map, filter, reduce\"></a>map, filter, reduce</h3><p>有人可能对这 3 个方法有些混乱。但这些都是转换数组或返回聚合值的有用方法。 <strong>map：</strong>返回一个新的数组，其中每个元素按指定函数进行转换。</p>\n<p>const arr = [1, 2, 3, 4, 5, 6];<br>const mapped = arr.map(el =&gt; el + 20);<br>console.log(mapped);<br>// [21, 22, 23, 24, 25, 26]</p>\n<p><strong>filter：</strong>返回一个新的数组，其中只包括回调函数返回 true 的元素。</p>\n<p>const arr = [1, 2, 3, 4, 5, 6];<br>const filtered = arr.filter(el =&gt; el === 2  el === 4);<br>console.log(filtered);<br>// [2, 4]</p>\n<p><strong>reduce：</strong>累加函数中指定的值。</p>\n<p>const arr = [1, 2, 3, 4, 5, 6];<br>const reduced = arr.reduce((total, current) =&gt; total + current);<br>console.log(reduced);<br>// 21</p>\n<h3 id=\"find-findIndex-indexOf\"><a href=\"#find-findIndex-indexOf\" class=\"headerlink\" title=\"find, findIndex, indexOf\"></a>find, findIndex, indexOf</h3><p>这三个方法通常会被混为一谈，下面是使用方法： <strong>find：</strong>返回与指定条件匹配的第一个元素。不会再寻找其他匹配的元素。</p>\n<p>const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];<br>const found = arr.find(el =&gt; el &gt; 5);<br>console.log(found);<br>// 6</p>\n<p>注意，虽然 5 之后的元素都满足条件，但只会返回第一个匹配元素。 <strong>findIndex：</strong>和 find 的机制基本一样，只是会返回第一个匹配元素的索引值而不是返回该元素。来看下面的例子：</p>\n<p>const arr = [‘Nick’, ‘Frank’, ‘Joe’, ‘Frank’];<br>const foundIndex = arr.findIndex(el =&gt; el === ‘Frank’);<br>console.log(foundIndex);<br>// 1</p>\n<p>indexOf：和 findIndex 的机制基本一样，但它接收一个值而不是一个函数作为参数。你可以在只需要简单的逻辑，不需要使用函数来判断匹配元素时使用它。</p>\n<p>const arr = [‘Nick’, ‘Frank’, ‘Joe’, ‘Frank’];<br>const foundIndex = arr.indexOf(‘Frank’);<br>console.log(foundIndex);<br>// 1</p>\n<h3 id=\"push-pop-shift-unshift\"><a href=\"#push-pop-shift-unshift\" class=\"headerlink\" title=\"push, pop, shift, unshift\"></a>push, pop, shift, unshift</h3><p>这是一组很棒的数组方法，可以让你有针对性地添加或删除数组中的元素。 <strong>push：</strong>在数组尾部添加一个元素。会修改原数组，返回添加到数组的元素。</p>\n<p>let arr = [1, 2, 3, 4];<br>const pushed = arr.push(5);<br>console.log(arr);<br>// [1, 2, 3, 4, 5]<br>console.log(pushed);<br>// 5</p>\n<p><strong>pop：</strong>删除数组的最后一个元素。会修改原数组，返回被删除的元素。</p>\n<p>let arr = [1, 2, 3, 4];<br>const popped = arr.pop();<br>console.log(arr);<br>// [1, 2, 3]<br>console.log(popped);<br>// 4</p>\n<p><strong>shift：</strong>删除数组的第一个元素。会修改原数组，返回被删除的元素。</p>\n<p>let arr = [1, 2, 3, 4];<br>const shifted = arr.shift();<br>console.log(arr);<br>// [2, 3, 4]<br>console.log(shifted);<br>// 1</p>\n<p><strong>unshift：</strong>在数组头部添加一个元素。会修改原数组，不同于其他几个方法，这个方法返回数组的新的长度。</p>\n<p>let arr = [1, 2, 3, 4];<br>const unshifted = arr.unshift(5, 6, 7);<br>console.log(arr);<br>// [5, 6, 7, 1, 2, 3, 4]<br>console.log(unshifted);<br>// 7</p>\n<h3 id=\"splice-slice\"><a href=\"#splice-slice\" class=\"headerlink\" title=\"splice, slice\"></a>splice, slice</h3><p>这 2 个方法会修改数组或返回一个子数组。 splice：通过删除或替换已存在的元素或插入新的元素来修改原数组的内容。会修改原数组。 下面的例子可以理解为：在索引为 1 的位置移除 0 个元素并插入了元素 b。</p>\n<p>let arr = [‘a’, ‘c’, ‘d’, ‘e’];<br>arr.splice(1, 0, ‘b’);</p>\n<p><strong>slice</strong>：从指定的开始和结束位置返回数组的浅复制副本。如果没有指定结束位置，返回数组的剩余部分。重要的是，此方法不修改原数组而是返回所需要的子数组。</p>\n<p>let arr = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’];<br>const sliced = arr.slice(2, 4);<br>console.log(sliced);<br>// [‘c’, ‘d’]<br>console.log(arr);<br>// [‘a’, ‘b’, ‘c’, ‘d’, ‘e’]</p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h3><p><strong>sort：</strong>基于提供的函数对数组进行排序，该函数接收 2 个参数，代表需要排序的 2 个数组元素。会修改原数组。如果函数返回负值或 0，元素顺序保持不变，返回正值，对调元素位置。</p>\n<p>let arr = [1, 7, 3, -1, 5, 7, 2];<br>const sorter = (firstEl, secondEl) =&gt; firstEl - secondEl;<br>arr.sort(sorter);<br>console.log(arr);<br>// [-1, 1, 2, 3, 5, 7, 7]</p>\n<p>你是否已经全部理解了呢？我还没有。事实上，我在写这篇文章的时候也经常参考 MDN 文档——没关系！只要知道有什么样的方法就可以了。</p>\n<h2 id=\"7-Generators\"><a href=\"#7-Generators\" class=\"headerlink\" title=\"7. Generators\"></a>7. Generators</h2><p>不要害怕*。生成器函数指定了下次调用next()时会迭代什么值。可以进行有限次数的迭代，也可以在循环中进行无限次数的迭代。</p>\n<p>function* greeter() {<br>    yield ‘Hi’;<br>    yield ‘How are you?’;<br>    yield ‘Bye’;<br>}<br>const greet = greeter();<br>console.log(greet.next().value);<br>// ‘Hi’<br>console.log(greet.next().value);<br>// ‘How are you?’<br>console.log(greet.next().value);<br>// ‘Bye’<br>console.log(greet.next().value);<br>// undefined</p>\n<p>无限迭代：</p>\n<p>function* idCreator() {<br>    let i = 0;<br>    while (true) yield i++;<br>}<br>const ids = idCreator();<br>console.log(ids.next().value);<br>// 0<br>console.log(ids.next().value);<br>// 1<br>console.log(ids.next().value);<br>// 2<br>// etc…</p>\n<h2 id=\"8-VS\"><a href=\"#8-VS\" class=\"headerlink\" title=\"8. === VS ==\"></a>8. === VS ==</h2><p>确信你已经了解了===与==的差异。在进行比较时，==会进行类型转换，===则不会。</p>\n<p>console.log(0 == ‘0’);<br>// true<br>console.log(0 === ‘0’);<br>// false</p>\n<h2 id=\"9-比较对象\"><a href=\"#9-比较对象\" class=\"headerlink\" title=\"9. 比较对象\"></a>9. 比较对象</h2><p>一个 javascript 新手常犯的错误就是直接比较对象。变量指向对象在内存中的引用，而不是对象本身。比较变量的一个方法是将它们转换为 JSON 字符串。当然这样会有缺点：不能保证对象属性的顺序。更安全的方式是使用第三方库中专用的比较方法来比较（lodash.isEqual）。 下面的对象看着是一样的，但其实它们指向不同的引用。</p>\n<p>const joe1 = { name: ‘Joe’ };<br>const joe2 = { name: ‘Joe’ };<br>console.log(joe1 === joe2);<br>// false</p>\n<p>反过来说，下面的比较结果为 true，因为变量被直接赋值为相同的值，都指向同一个引用（在内存中只有一个对象）。</p>\n<p>const joe1 = { name: ‘Joe’ };<br>const joe2 = joe1;<br>console.log(joe1 === joe2);<br>// true</p>\n<p>复习下之前的值 VS 引用章节，保证能完全理解将一个引用变量赋值给其他变量时，其实是赋值了内存中同一对象的相同引用给其他变量。</p>\n<h2 id=\"10-回调函数\"><a href=\"#10-回调函数\" class=\"headerlink\" title=\"10. 回调函数\"></a>10. 回调函数</h2><p>许多人都会被 javascript 的回调函数吓到！其他它们很简单，来看例子。console.log作为回调函数传递给了myFunc。当计时器就绪时执行。</p>\n<p>function myFunc(text, callback) {<br>    setTimeout(function() {<br>        callback(text);<br>    }, 2000);<br>}<br>myFunc(‘Hello world!’, console.log);<br>// ‘Hello world!’</p>\n<h2 id=\"11-Promises\"><a href=\"#11-Promises\" class=\"headerlink\" title=\"11. Promises\"></a>11. Promises</h2><p>一旦你理解的回调函数，你就会陷入回调地狱。然后 Promises 解决了问题。在 Promise 中包裹你的异步逻辑，成功时调用 resolve，失败时调用 reject。使用 then 来处理成功状态，使用 catch 来处理异常状态。</p>\n<p>const myPromise = new Promise(function(res, rej) {<br>    setTimeout(function() {<br>        if (Math.random() &lt; 0.9) {<br>            return res(‘Hooray!’);<br>        }<br>        return rej(‘Oh no!’);<br>    }, 1000);<br>});</p>\n<p>myPromise<br>    .then(function(data) {<br>        console.log(‘Success: ‘ + data);<br>    })<br>    .catch(function(err) {<br>        console.log(‘Error: ‘ + err);<br>    });</p>\n<p>// If Math.random() returns less than 0.9 the following is logged:<br>// “Success: Hooray!”<br>// If Math.random() returns 0.9 or greater the following is logged:<br>// “Error: On no!”</p>\n<h2 id=\"12-Async-Await\"><a href=\"#12-Async-Await\" class=\"headerlink\" title=\"12. Async Await\"></a>12. Async Await</h2><p>一旦你掌握了 Promises，你就会喜欢async/await，它是基于 promises 的语法糖。下面的例子中我们使用了 async 函数，在函数里使用了 await 来处理greeter。</p>\n<p>const greeter = new Promise((res, rej) =&gt; {<br>    setTimeout(() =&gt; res(‘Hello world!’), 2000);<br>});<br>async function myFunc() {<br>    const greeting = await greeter;<br>    console.log(greeting);<br>}<br>myFunc();<br>// ‘Hello world!’</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>如果你还不了解这 12 个概念，你可能已经至少增长了一些 javascript 的知识。如果你已经了解了这些，希望这是你练习和加强知识的机会。 文章来源：<a href=\"https://hackernoon.com/12-javascript-concepts-that-will-level-up-your-development-skills-b37d16ad7104\">12 Concepts That Will Level Up Your JavaScript Skills</a></p>\n","categories":["JavaScript"],"tags":["Array.filter","Array.find","Array.includes","Array.indexOf","Array.map","array()","Promise","slice()","splice()"]},{"title":"15个必须知道的JavaScript数组方法","url":"/2020/03/13/15%E4%B8%AA%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84javascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","content":"<p>在JavaScript中，数组是一个特殊的变量，用于存储不同的元素。它具有一些内置属性和方法，可用于根据需要添加，删除，迭代或操作数。并且了解JavaScript数组方法可以提升你的开发技能。 在本文中，我们将介绍15种关于JavaScript的数组方法，这些方法可以帮助你正确地处理数据。 1.some() 2. reduce() 3. Every() 4. map() 5. flat() 6. filter() 7. forEach() 8. findIndex() 9. find() 10. sort() 11. concat() 12. fill() 13. includes() 14. reverse() 15. flatMap() 注意，大多数情况下，我们将简化作为参数传递的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Instead of using this way</span><br><span class=\"line\">myAwesomeArray.some(test &#x3D;&gt; &#123;</span><br><span class=\"line\">if (test &#x3D;&#x3D;&#x3D; &quot;d&quot;) &#123;</span><br><span class=\"line\">return test</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F; We&#39;ll use the shorter one</span><br><span class=\"line\">myAwesomeArray.some(test &#x3D;&gt; test &#x3D;&#x3D;&#x3D; &quot;d&quot;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1、some\"><a href=\"#1、some\" class=\"headerlink\" title=\"1、some()\"></a>1、some()</h3><p>此方法为参数传递的函数测试数组。如果有一个元素与测试元素匹配，则返回true，否则返回false。 译者注： some() 不会对空数组进行检测；some() 不会改变原始数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.some(test &#x3D;&gt; test &#x3D;&#x3D;&#x3D; &quot;d&quot;)</span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、reduce\"><a href=\"#2、reduce\" class=\"headerlink\" title=\"2、reduce()\"></a>2、reduce()</h3><p>此方法接收一个函数作为累加器。它为数组中的每个元素依次执行回调函数，不包括数组中被删除或者从未被赋值的元素。函数应用于累加器，数组中的每个值最后只返回一个值。 译者注：reduce() 方法接受四个参数：初始值（上一次回调的返回值），当前元素值，当前索引，原数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [1, 2, 3, 4, 5]</span><br><span class=\"line\">myAwesomeArray.reduce((total, value) &#x3D;&gt; total * value)</span><br><span class=\"line\">&#x2F;&#x2F; 1 * 2 * 3 * 4 * 5</span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output &#x3D; 120</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、Every\"><a href=\"#3、Every\" class=\"headerlink\" title=\"3、Every()\"></a>3、Every()</h3><p>此方法是对数组中每项运行给定函数，如果数组的每个元素都与测试匹配，则返回true，反之则返回false。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.every(test &#x3D;&gt; test &#x3D;&#x3D;&#x3D; &quot;d&quot;)</span><br><span class=\"line\">&#x2F;&#x2F; -------&gt; Output : false</span><br><span class=\"line\"></span><br><span class=\"line\">const myAwesomeArray2 &#x3D; [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray2.every(test &#x3D;&gt; test &#x3D;&#x3D;&#x3D; &quot;a&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、map\"><a href=\"#4、map\" class=\"headerlink\" title=\"4、map()\"></a>4、map()</h3><p>该方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。它按照原始数组元素顺序依次处理元素。 译者注：map() 不会对空数组进行检测；map() 不会改变原始数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [5, 4, 3, 2, 1]</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.map(x &#x3D;&gt; x * x)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : 25</span><br><span class=\"line\">&#x2F;&#x2F; 16</span><br><span class=\"line\">&#x2F;&#x2F; 9</span><br><span class=\"line\">&#x2F;&#x2F; 4</span><br><span class=\"line\">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、flat\"><a href=\"#5、flat\" class=\"headerlink\" title=\"5、flat()\"></a>5、flat()</h3><p>此方法创建一个新数组，其中包含子数组上的holden元素，并将其平整到新数组中。请注意，此方法只能进行一个级别的深度。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [[1, 2], [3, 4], 5]</span><br><span class=\"line\">myAwesomeArray.flat()</span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、filter\"><a href=\"#6、filter\" class=\"headerlink\" title=\"6、filter()\"></a>6、filter()</h3><p>该方法接收一个函数作为参数。并返回一个新数组，该数组包含该数组的所有元素，作为参数传递的过滤函数对其返回true。 译者注：filter()方法是对数据中的元素进行过滤，也就是说是不能修改原数组中的数据，只能读取原数组中的数据，callback需要返回布尔值；为true的时候，对应的元素留下来；为false的时候，对应的元素过滤掉。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [</span><br><span class=\"line\">&#123; id: 1, name: &quot;john&quot; &#125;, </span><br><span class=\"line\">&#123; id: 2, name: &quot;Ali&quot; &#125;,</span><br><span class=\"line\">&#123; id: 3, name: &quot;Mass&quot; &#125;, </span><br><span class=\"line\">&#123; id: 4, name: &quot;Mass&quot; &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.filter(element &#x3D;&gt; element.name &#x3D;&#x3D;&#x3D; &quot;Mass&quot;)</span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : 0:&#123;id: 3, name: &quot;Mass&quot;&#125;,</span><br><span class=\"line\">&#x2F;&#x2F; 1:&#123;id: 4, name: &quot;Mass&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7、forEach\"><a href=\"#7、forEach\" class=\"headerlink\" title=\"7、forEach()\"></a>7、forEach()</h3><p>此方法用于调用数组的每个元素。并将元素传递给回调函数。 译者注: forEach() 对于空数组是不会执行回调函数的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [</span><br><span class=\"line\">&#123; id: 1, name: &quot;john&quot; &#125;,</span><br><span class=\"line\">&#123; id: 2, name: &quot;Ali&quot; &#125;,</span><br><span class=\"line\">&#123; id: 3, name: &quot;Mass&quot; &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.forEach(element &#x3D;&gt; console.log(element.name))</span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : john</span><br><span class=\"line\">&#x2F;&#x2F; Ali</span><br><span class=\"line\">&#x2F;&#x2F; Mass</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8、-findIndex\"><a href=\"#8、-findIndex\" class=\"headerlink\" title=\"8、 findIndex()\"></a>8、 findIndex()</h3><p>此方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。它为数组中的每个元素都调用一次函数执行，当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1 译者注：findIndex() 对于空数组，函数是不会执行的， findIndex() 并没有改变数组的原始值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [</span><br><span class=\"line\">&#123; id: 1, name: &quot;john&quot; &#125;,</span><br><span class=\"line\">&#123; id: 2, name: &quot;Ali&quot; &#125;,</span><br><span class=\"line\">&#123; id: 3, name: &quot;Mass&quot; &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.findIndex(element &#x3D;&gt; element.id &#x3D;&#x3D;&#x3D; 3)</span><br><span class=\"line\">&#x2F;&#x2F; -------&gt; Output : 2</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.findIndex(element &#x3D;&gt; element.id &#x3D;&#x3D;&#x3D; 7)</span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : -1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9、-find\"><a href=\"#9、-find\" class=\"headerlink\" title=\"9、 find()\"></a>9、 find()</h3><p>此方法返回通过测试（函数内判断）的数组的第一个元素的值。find() 方法为数组中的每个元素都调用一次函数执行：当数组中的元素在测试条件时回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。 译者注: find() 对于空数组，函数是不会执行的；find() 并没有改变数组的原始值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [</span><br><span class=\"line\">&#123; id: 1, name: &quot;john&quot; &#125;,</span><br><span class=\"line\">&#123; id: 2, name: &quot;Ali&quot; &#125;,</span><br><span class=\"line\">&#123; id: 3, name: &quot;Mass&quot; &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">myAwesomeArray.find(element &#x3D;&gt; element.id &#x3D;&#x3D;&#x3D; 3)</span><br><span class=\"line\">&#x2F;&#x2F; -------&gt; Output : &#123;id: 3, name: &quot;Mass&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.find(element &#x3D;&gt; element.id &#x3D;&#x3D;&#x3D; 7)</span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : undefined</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10、-sort\"><a href=\"#10、-sort\" class=\"headerlink\" title=\"10、 sort()\"></a>10、 sort()</h3><p>此方法接收一个函数作为参数。它对数组的元素进行排序并返回它。也可以使用含有参数的sort()方法进行排序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [5, 4, 3, 2, 1]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Sort from smallest to largest</span><br><span class=\"line\">myAwesomeArray.sort((a, b) &#x3D;&gt; a - b)</span><br><span class=\"line\">&#x2F;&#x2F; -------&gt; Output : [1, 2, 3, 4, 5]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Sort from largest to smallest</span><br><span class=\"line\">myAwesomeArray.sort((a, b) &#x3D;&gt; b - a)</span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : [5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11、-concat\"><a href=\"#11、-concat\" class=\"headerlink\" title=\"11、 concat()\"></a>11、 concat()</h3><p>此方法用于连接两个或多个数组/值，它不会改变现有的数组。而仅仅返回被连接数组的一个新数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [1, 2, 3, 4, 5]</span><br><span class=\"line\">const myAwesomeArray2 &#x3D; [10, 20, 30, 40, 50]</span><br><span class=\"line\">myAwesomeArray.concat(myAwesomeArray2)</span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : [1, 2, 3, 4, 5, 10, 20, 30, 40, 50]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12、-fill\"><a href=\"#12、-fill\" class=\"headerlink\" title=\"12、 fill()\"></a>12、 fill()</h3><p>此方法的作用是使用一个固定值来替换数组中的元素。该固定值可以是字母、数字、字符串、数组等等。它还有两个可选参数，表示填充起来的开始位置（默认为0）与结束位置（默认为array.length）。 译者注：fill() 方法用于将一个固定值替换数组的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [1, 2, 3, 4, 5]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; The first argument (0) is the value</span><br><span class=\"line\">&#x2F;&#x2F; The second argument (1) is the starting index</span><br><span class=\"line\">&#x2F;&#x2F; The third argument (3) is the ending index</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.fill(0, 1, 3)</span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : [1, 0, 0, 4, 5]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13、-includes\"><a href=\"#13、-includes\" class=\"headerlink\" title=\"13、 includes()\"></a>13、 includes()</h3><p>此方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。 译者注：includes() 方法区分大小写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [1, 2, 3, 4, 5]</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.includes(3)</span><br><span class=\"line\">&#x2F;&#x2F; -------&gt; Output : true</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.includes(8)</span><br><span class=\"line\">&#x2F;&#x2F; -------&gt; Output : false</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14、-reverse\"><a href=\"#14、-reverse\" class=\"headerlink\" title=\"14、 reverse()\"></a>14、 reverse()</h3><p>此方法用于颠倒数组中元素的顺序。第一个元素成为最后一个，最后一个元素将成为第一个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span><br><span class=\"line\">myAwesomeArray.reverse()</span><br><span class=\"line\">&#x2F;&#x2F; -------&gt; Output : [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15、-flatMap\"><a href=\"#15、-flatMap\" class=\"headerlink\" title=\"15、 flatMap()\"></a>15、 flatMap()</h3><p>该方法将函数应用于数组的每个元素，然后将结果压缩为一个新数组。它在一个函数中结合了flat()和map()。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const myAwesomeArray &#x3D; [[1], [2], [3], [4], [5]]</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.flatMap(arr &#x3D;&gt; arr * 10)</span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : [10, 20, 30, 40, 50]</span><br><span class=\"line\">&#x2F;&#x2F; With .flat() and .map()</span><br><span class=\"line\"></span><br><span class=\"line\">myAwesomeArray.flat().map(arr &#x3D;&gt; arr * 10)</span><br><span class=\"line\">&#x2F;&#x2F;-------&gt; Output : [10, 20, 30, 40, 50]</span><br></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["concat()","Every()","fill()","filter","find()","findIndex()","flat()","flatMap()","forEach()","includes()","Map","reduce()","reverse()","some()","sort()"]},{"title":"CSS 垂直居中方法很简单","url":"/2018/12/09/CSS%20%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%E5%BE%88%E7%AE%80%E5%8D%95/","content":"<p>在 CSS 中对元素进行水平居中是非常简单的：如果它是一个行内元素，就对它的父元素应用 text-align: center；如果它是一个块级元素，就对它自身应用 margin: auto。然而如果要对一个元素进行垂直居中，可能光是想想就令人头皮发麻了。 多年以来，垂直居中已经成为了 CSS 领域的圣杯，它同样也是前端开发圈内广为流传的笑话。原因在于它同时具备以下几条特征。</p>\n<ul>\n<li>  它是极其常见的需求。</li>\n<li>  从理论上来看，它似乎极其简单。</li>\n<li>  在实践中，它往往难如登天，当涉及尺寸不固定的元素时尤其如此。</li>\n</ul>\n<p>长久以来，为了解决这一绝世难题，前端开发者们殚精竭虑，琢磨出了各种解决方法，大多数并不实用。在本篇攻略中，我们将探索现代 CSS 的强大威力，以全新的思路去攻克各种场景下的垂直居中难题。请注意，有几种技巧十分流行，但在这里并不会深入探讨，原因如下。</p>\n<ul>\n<li>  表格布局法（利用表格的显示模式）需要用到一些冗余的 HTML 元素，因此这里不多介绍。</li>\n<li>  行内块法也不作讨论，因为在我看来这种方法 hack 的味道很浓。</li>\n</ul>\n<p>如果你有兴趣，可以去看看 Chris Coyier 写的“不为人知的居中方法”（<a href=\"http://css-tricks.com/centering-in-the-unknown%EF%BC%89%E3%80%82%E8%BF%99%E7%AF%87%E5%87%BA%E8%89%B2%E7%9A%84%E6%96%87%E7%AB%A0%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%BF%B0%E4%BA%86%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%8A%80%E5%B7%A7%E3%80%82\">http://css-tricks.com/centering-in-the-unknown）。这篇出色的文章详细讲述了这两种技巧。</a> 除非特别注明，我们将一直使用如下所示的结构代码，并直接插入<body> 元素中（但实际上我们将要探索的这些技巧是与容器无关的）：</p>\n<main>\n<h1>我居中了吗?</h1>\n</main>\n\n<p>然后再用一些基本的 CSS 来设置背景、内边距等样式，运行一下就可以看到效果了。我们将以此作为起点。  </p>\n<h2 id=\"基于绝对定位的解决方案\"><a href=\"#基于绝对定位的解决方案\" class=\"headerlink\" title=\"基于绝对定位的解决方案\"></a>基于绝对定位的解决方案</h2><p>我们先来看一个早期的垂直居中方法，它要求元素具有固定的宽度和高度：</p>\n<p>main {<br>position: absolute;<br>top: 50%;<br>left: 50%;<br>margin-top: -3em; /* 6/2 = 3 */<br>margin-left: -9em; /* 18/2 = 9 */<br>width: 18em;<br>height: 6em;<br>}</p>\n<p>这段代码在本质上做了这样几件事情：先把这个元素的左上角放置在视口（或最近的、具有定位属性的祖先元素）的正中心，然后再利用负外边距把它向左、向上移动（移动距离相当于它自身宽高的一半），从而把元素的正中心放置在视口的正中心。借助强大的 calc() 函数，这段代码还可以省掉两行声明：</p>\n<p>main {<br>position: absolute;<br>top: calc(50% - 3em);<br>left: calc(50% - 9em);<br>width: 18em;<br>height: 6em;<br>}</p>\n<p>显然，这个方法最大的局限在于它要求元素的宽高是固定的。在通常情况下，对那些需要居中的元素来说，其尺寸往往是由其内容来决定的。如果能找到一个属性的百分比值以元素自身的宽高作为解析基准，那我们的难题就迎刃而解了！遗憾的是，对于绝大多数 CSS 属性（包括 margin）来说，百分比都是以其父元素的尺寸为基准进行解析的。 CSS 领域有一个很常见的现象，真正的解决方案往往来自于我们最意想不到的地方。在这个例子中，答案来自于 CSS 变形属性。当我们在translate() 变形函数中使用百分比值时，是以这个元素自身的宽度和高度为基准进行换算和移动的，而这正是我们所需要的。接下来，只要换用基于百分比的 CSS 变形来对元素进行偏移，就不需要在偏移量中把元素的尺寸写死了。这样我们就可以彻底解除对固定尺寸的依赖：</p>\n<p>main {<br>position: absolute;<br>top: 50%;<br>left: 50%;<br>transform: translate(-50%, -50%);<br>}</p>\n<p>你可以在下面demo中看到结果：这个容器已经完美居中了，完全满足我们的期望。 当然，没有任何技巧是十全十美的，上面这个方法也有一些需要注意的地方。</p>\n<ul>\n<li>  我们有时不能选用绝对定位，因为它对整个布局的影响太过强烈。</li>\n<li>  如果需要居中的元素已经在高度上超过了视口，那它的顶部会被视口裁切掉。有一些办法可以绕过这个问题，但 hack味道过浓。</li>\n<li>  在某些浏览器中，这个方法可能会导致元素的显示有一些模糊，因为元素可能被放置在半个像素上。这个问题可以用 transformstyle:preserve-3d 来修复，不过这个修复手段也可以认为是一个hack，而且很难保证它在未来不会出问题。</li>\n</ul>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/QJXewK/\">translate居中</a> by xianzhiding (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<blockquote>\n<p>实践证明，想要找到最先提出这个实用技巧的人确实不容易，不过所能挖掘到的最早起源似乎是 Stack Overflow（<a href=\"http://stackoverflow.com)的用户“charlie”(http//stackoverflow.com/users/479836/charlie%EF%BC%89%EF%BC%8C%E4%BB%96%E5%9C%A82013%E5%B9%B44%E6%9C%8816%E6%97%A5%E5%9B%9E%E7%AD%94%E4%BA%86%E2%80%9C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\">http://stackoverflow.com）的用户“Charlie”（http://stackoverflow.com/users/479836/charlie），他在2013年4月16日回答了“如何使用</a> CSS3 实现垂直对齐”（<a href=\"http://stackoverflow.com/a/16026893/90826%EF%BC%89%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E3%80%82\">http://stackoverflow.com/a/16026893/90826）这个问题。</a></p>\n</blockquote>\n<h2 id=\"基于视口单位的解决方案\"><a href=\"#基于视口单位的解决方案\" class=\"headerlink\" title=\"基于视口单位的解决方案\"></a>基于视口单位的解决方案</h2><p>假设我们不想使用绝对定位，仍然可以采用 translate() 技巧来把这个元素以其自身宽高的一半为距离进行移动；但是在缺少 left 和 top 的情况下，如何把这个元素的左上角放置在容器的正中心呢？ 我们的第一反应很可能是用 margin 属性的百分比值来实现，就像这样：</p>\n<p>main {<br>width: 18em;<br>padding: 1em 1.5em;<br>margin: 50% auto 0;<br>transform: translateY(-50%);<br>}</p>\n<p>不过，这段代码会产生十分离谱的结果。原因在于margin 的百分比值是以父元素的宽度作为解析基准的。没错，即使对于margin-top 和 margin-bottom 来说也是这样！ 不过幸运的是，如果只是想把元素相对于视口进行居中，仍然是有希望 的。CSS 值 与 单 位（ 第 三 版 ）（<a href=\"http://w3.org/TR/css-values-3/#viewportrelative-lengths%EF%BC%89%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E5%A5%97%E6%96%B0%E7%9A%84%E5%8D%95%E4%BD%8D%EF%BC%8C%E7%A7%B0%E4%B8%BA%E8%A7%86%E5%8F%A3%E7%9B%B8%E5%85%B3%E7%9A%84%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D%E3%80%82\">http://w3.org/TR/css-values-3/#viewportrelative-lengths）定义了一套新的单位，称为视口相关的长度单位。</a></p>\n<ul>\n<li>  vw 是与视口宽度相关的。与常人的直觉不符的是，1vw 实际上表示视口宽度的 1%，而不是 100%。</li>\n<li>  与 vw 类似，1vh 表示视口高度的 1%。</li>\n<li>  当视口宽度小于高度时，1vmin 等于 1vw，否则等于 1vh。</li>\n<li>  当视口宽度大于高度时，1vmax 等于 1vw，否则等于 1vh。</li>\n</ul>\n<p>在我们的这个例子中，适用于外边距的是 vh 单位：</p>\n<p>main {<br>width: 18em;<br>padding: 1em 1.5em;<br>margin: 50vh auto 0;<br>transform: translateY(-50%);<br>}</p>\n<blockquote>\n<p>“使用视口相关的长度单位，我们还可以生成一个正好铺满视口的区块，无需脚本的辅助。更多细节请参阅“用一行 CSS 实现全屏区块”（<a href=\"https://medium.com/@ckor/make-full-screensections-with-1-line-of-css-b82227c75cbd%EF%BC%89%E3%80%82%E2%80%9D\">https://medium.com/@ckor/make-full-screensections-with-1-line-of-css-b82227c75cbd）。”</a></p>\n</blockquote>\n<p>在下面DEMO中可以看到，其效果堪称完美。当然，这个技巧的实用性是相当有限的，因为它只适用于在视口中居中的场景。</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/BGgEYQ/\">transform-translateY居中</a> by xianzhiding (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"基于-Flexbox-的解决方案\"><a href=\"#基于-Flexbox-的解决方案\" class=\"headerlink\" title=\"基于 Flexbox 的解决方案\"></a>基于 Flexbox 的解决方案</h2><p>这是毋庸置疑的最佳解决方案，因为 Flexbox（伸缩盒）（<a href=\"http://w3.org/TR/css-flexbox%EF%BC%89%E6%98%AF%E4%B8%93%E9%97%A8%E9%92%88%E5%AF%B9%E8%BF%99%E7%B1%BB%E9%9C%80%E6%B1%82%E6%89%80%E8%AE%BE%E8%AE%A1%E7%9A%84%E3%80%82%E6%88%91%E4%BB%AC%E4%B9%8B%E6%89%80%E4%BB%A5%E8%A6%81%E8%AE%A8%E8%AE%BA%E5%85%B6%E4%BB%96%E6%96%B9%E6%A1%88%EF%BC%8C%E4%BB%85%E4%BB%85%E6%98%AF%E5%9B%A0%E4%B8%BA%E9%82%A3%E4%BA%9B%E6%96%B9%E6%A1%88%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%94%AF%E6%8C%81%E7%A8%8B%E5%BA%A6%E4%B8%8A%E7%A8%8D%E5%BE%AE%E5%A5%BD%E4%B8%80%E4%BA%9B%E8%80%8C%E5%B7%B2%E3%80%82%E5%85%B6%E5%AE%9E%E7%9B%AE%E5%89%8D%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9\">http://w3.org/TR/css-flexbox）是专门针对这类需求所设计的。我们之所以要讨论其他方案，仅仅是因为那些方案在浏览器的支持程度上稍微好一些而已。其实目前现代浏览器对</a> Flexbox 的支持度已经相当不错了。 我们只需写两行声明即可：先给这个待居中元素的父元素设置 display:flex（在这个例子中是 <body> 元素），再给这个元素自身设置我们再熟悉不过的 margin: auto（在这个例子中是 <main> 元素）：</p>\n<p>body {<br>display: flex;<br>min-height: 100vh;<br>margin: 0;<br>}<br>main {<br>margin: auto;<br>}</p>\n<p>请注意，当我们使用 Flexbox 时，margin: auto 不仅在水平方向上将元素居中，垂直方向上也是如此。还有一点，我们甚至不需要指定任何宽度（当然，如果需要的话，也是可以指定的）：这个居中元素分配到的宽度等于 maxcontent。（还记得“自适应内部元素”中提到的那些内部尺寸关键字吗？） 如果浏览器不支持 Flexbox，页面渲染结果看起来就跟我们的开篇代码是一样的了（如果设置了宽度的话）。虽然没有垂直居中效果，但也是完全可以接受的。 Flexbox 的另一个好处在于，它还可以将匿名容器（即没有被标签包裹的文本节点）垂直居中。举个例子，假设我们的结构代码是：</p>\n<main>我居中了吗?</main>\n\n<p>我们先给这个 main 元素指定一个固定的尺寸，然后借助 Flexbox 规范所引入的 align-items 和 justify-content 属性，我们可以让它内部的文本也实现居中（参见图 7-22）：</p>\n<p>main {<br>display: flex;<br>align-items: center;<br>justify-content: center;<br>width: 18em;<br>height: 10em;<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/RqzOZN/\">用 Flexbox 居中</a> by xianzhiding (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<blockquote>\n<p>根据盒对齐模型（第三版）（<a href=\"http://w3.org/TR/css-align-3%EF%BC%89%E7%9A%84%E8%AE%A1%E5%88%92%EF%BC%8C%E5%9C%A8%E6%9C%AA%E6%9D%A5%EF%BC%8C%E5%AF%B9%E4%BA%8E%E7%AE%80%E5%8D%95%E7%9A%84%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%9C%80%E6%B1%82%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AE%8C%E5%85%A8%E4%B8%8D%E9%9C%80%E8%A6%81%E5%8A%A8%E7%94%A8%E7%89%B9%E6%AE%8A%E7%9A%84%E5%B8%83%E5%B1%80%E6%A8%A1%E5%BC%8F%E4%BA%86%E3%80%82%E5%9B%A0%E4%B8%BA%E5%8F%AA%E9%9C%80%E8%A6%81%E4%B8%8B%E9%9D%A2%E8%BF%99%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%90%9E%E5%AE%9A%EF%BC%9A\">http://w3.org/TR/css-align-3）的计划，在未来，对于简单的垂直居中需求，我们完全不需要动用特殊的布局模式了。因为只需要下面这行代码就可以搞定：</a> align-self: center; 不管这个元素上还应用了其他什么属性，这样写就够了。这听起来可能如美梦一般令人难以置信，但或许你手边的浏览器很快就会让它成为现实！</p>\n</blockquote>\n<p>相关规范</p>\n<ul>\n<li>  CSS 变形 <a href=\"http://w3.org/TR/css-transforms\">http://w3.org/TR/css-transforms</a></li>\n<li>  CSS 值与单位 <a href=\"http://w3.org/TR/css-values\">http://w3.org/TR/css-values</a></li>\n<li>  CSS 伸缩盒布局模型 <a href=\"http://w3.org/TR/css-flexbox\">http://w3.org/TR/css-flexbox</a></li>\n<li>  CSS 盒对齐模型 <a href=\"http://w3.org/TR/css-align\">http://w3.org/TR/css-align</a></li>\n</ul>\n","categories":["HTML/CSS"],"tags":["css3","flex","flexbox","transforms","垂直居中"]},{"title":"CSS3 文本渐变（Gradient Text）","url":"/2019/07/20/CSS3%20%E6%96%87%E6%9C%AC%E6%B8%90%E5%8F%98%EF%BC%88Gradient%20Text%EF%BC%89/","content":"<p>如果你现在刚刚熟悉渐变是什么，我们会在你深入研究更强硬的东西之前为你画画。渐变是具有起点和终点的颜色的渐变 - 因此，线性渐变以一种颜色（如红色）开始，并逐渐沿直线过渡到另一种颜色（如蓝色）。就像我们在线性渐变文章中所说的那样，将日落视为线性渐变的最佳示例，以及每种颜色如何精美无缝地进入下一个。</p>\n<style>h2 {text-align: center;font-size: 48px !important;font-weight: 800;background: -webkit-linear-gradient(45deg, #09009f, #00ff95 80%);-webkit-background-clip: text;-webkit-text-fill-color: transparent;margin: 0;}</style>\n\n<h2 id=\"文字渐变\"><a href=\"#文字渐变\" class=\"headerlink\" title=\"文字渐变\"></a>文字渐变</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">h1 &#123;</span><br><span class=\"line\">  font-size：72px;</span><br><span class=\"line\">  background：-webkit-linear-gradient（#eee，＃333）;</span><br><span class=\"line\">  -webkit-background-clip：text;</span><br><span class=\"line\">  -webkit-text-fill-color：transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["HTML/CSS"],"tags":["CSS3 文本渐变","css3教程","css3渐变","Gradient Text"]},{"title":"CSS变量创建网页响应布局","url":"/2019/01/14/CSS%E5%8F%98%E9%87%8F%E5%88%9B%E5%BB%BA%E7%BD%91%E9%A1%B5%E5%93%8D%E5%BA%94%E5%B8%83%E5%B1%80/","content":"<p>在创新的2018年已经过去，在2019年看看如何简单做成响应性的网站</p>\n<p>如果你未曾听说过CSS变量，那么我告诉你，它就是CSS的一种新功能，可以让你拥有在样式表中使用变量的能力，这样做时并不需要什么特别的设置呦。</p>\n<p>从本质上讲，CSS变量可以让你摆脱老式的样式设置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">h1 &#123;</span><br><span class=\"line\">    font-size: 30px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">navbar&gt;a &#123;</span><br><span class=\"line\">    font-size: 30px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>…而是主张这样写：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">:root &#123;</span><br><span class=\"line\">    --base-font-size: 30px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">h1 &#123;</span><br><span class=\"line\">    font-size: var(--base-font-size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">navbar&gt;a &#123;</span><br><span class=\"line\">    font-size: var(--base-font-size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的语法看起来的确有点怪怪的，但有没有觉得它和less、sass中的变量有点类似呢，但如此一来，只要更改–base-font-size 变量，就能在整个应用中改变字号了。</p>\n<p>如果你想把CSS变量学明白，可以在Scrimba网站 这里有免费互动CSS变量课程，该课程包含8个互动截屏。</p>\n<h2 id=\"今天来讲一下如何用CSS变量创建响应布局\"><a href=\"#今天来讲一下如何用CSS变量创建响应布局\" class=\"headerlink\" title=\"今天来讲一下如何用CSS变量创建响应布局\"></a>今天来讲一下如何用CSS变量创建响应布局</h2><p>这是一段html</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul class=<span class=\"string\">&quot;item&quot;</span>&gt;</span><br><span class=\"line\">    &lt;li&gt;item 1&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;item 2&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;item 3&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;item 4&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"老方法：\"><a href=\"#老方法：\" class=\"headerlink\" title=\"老方法：\"></a>老方法：</h3><p>在以前即使不使用CSS变量也可以把这些事情搞定。只是需要把要改变的属性在重新重置一下，需要在媒体查询中拥有自己的选择器，但会招致额外的大量代码，像下面这样：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">    display: flex;</span><br><span class=\"line\">    flex-direction: column;</span><br><span class=\"line\">    flex-wrap: wrap;</span><br><span class=\"line\">    justify-content: space-around;</span><br><span class=\"line\">    padding: 10px;</span><br><span class=\"line\"></span><br><span class=\"line\">    li &#123;</span><br><span class=\"line\">        background-color: <span class=\"comment\">#ff6f69;</span></span><br><span class=\"line\">        border: 1px solid <span class=\"comment\">#fff;</span></span><br><span class=\"line\">        font-size: 20px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        list-style-type: none;</span><br><span class=\"line\">        width: 100%;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@media (min-width: 768px) &#123;</span><br><span class=\"line\">    .item &#123;</span><br><span class=\"line\">        flex-direction: row;</span><br><span class=\"line\">        li &#123;</span><br><span class=\"line\">            background-color: <span class=\"comment\">#ffcc5c;</span></span><br><span class=\"line\">            font-size: 50px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            width: 50%;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@media (min-width: 992px) &#123;</span><br><span class=\"line\">    .item &#123;</span><br><span class=\"line\">        flex-wrap: nowrap;</span><br><span class=\"line\">        li &#123;</span><br><span class=\"line\">            background-color: <span class=\"comment\">#ffeead;</span></span><br><span class=\"line\">            font-size: 100px;</span><br><span class=\"line\">            height: 500px;</span><br><span class=\"line\">            width: calc(100% / 4);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"新方法\"><a href=\"#新方法\" class=\"headerlink\" title=\"新方法\"></a>新方法</h3><p>下面让我们来看如何使用CSS变量来解决这个问题。首先，要把我们将重复利用和更改的数值存储在变量的内部：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">:root &#123;</span><br><span class=\"line\">--base-color: <span class=\"comment\">#ff6f69;</span></span><br><span class=\"line\">--base-font-size: 20px;</span><br><span class=\"line\">--direction: column;</span><br><span class=\"line\">--width: 100%;</span><br><span class=\"line\">--height: 200px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，在整个页面中简单地使用这些变量就行了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  padding: 10px;</span><br><span class=\"line\">  justify-content: space-around;</span><br><span class=\"line\">  flex-direction: var(--direction);</span><br><span class=\"line\">  flex-wrap: var(--wrap);</span><br><span class=\"line\">  li&#123;</span><br><span class=\"line\">    list-style-type: none;</span><br><span class=\"line\">    border: 1px solid <span class=\"comment\">#fff;</span></span><br><span class=\"line\">    height: var(--height);</span><br><span class=\"line\">    width: var(--width);</span><br><span class=\"line\">    background-color: var(--base-color);</span><br><span class=\"line\">    font-size: var(--base-font-size);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一旦进行了这样的设置之后，我们只要在媒体查询中简单地更改变量值就行了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">@media (min-width: 768px) &#123;</span><br><span class=\"line\">  :root &#123;</span><br><span class=\"line\">    --base-font-size: 60px;</span><br><span class=\"line\">    --base-color: <span class=\"comment\">#ffcc5c;</span></span><br><span class=\"line\">    --direction: row;</span><br><span class=\"line\">    --height: 300px;</span><br><span class=\"line\">    --width: 50%;</span><br><span class=\"line\">    --wrap:wrap;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@media (min-width: 992px) &#123;</span><br><span class=\"line\">  :root &#123;</span><br><span class=\"line\">    --base-font-size: 100px;</span><br><span class=\"line\">    --base-color: <span class=\"comment\">#ffeead;</span></span><br><span class=\"line\">    --direction: row;</span><br><span class=\"line\">    --height: 500px;</span><br><span class=\"line\">    --width: calc(100% / 4);</span><br><span class=\"line\">    --wrap:nowrap;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这比我们以往的方法简便多了。只需盯住 :root，而不必为所有的选择器指定值了。</p>\n<p>这只是一个简单的例子。设想成熟的网站会是什么样子吧，例如，用 –base-margin 来控制APP四周的多数自由空间。想翻转其值也是很容易的事情，不必用复杂的选择器来填充媒体查询了。</p>\n<p>总之，CSS变量绝对是提高响应速度时，所代表的未来。</p>\n","tags":["css var()"]},{"title":"CSS多种方法实现页面底部固定","url":"/2018/10/11/CSS%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E5%BA%95%E9%83%A8%E5%9B%BA%E5%AE%9A/","content":"<p>当我们在写页面时经常会遇到页面内容少的时候，footer会戳在页面中间或什么？反正就是不在最底部显示，反正就是很难看，下面要讲的布局就是解决如何使元素粘住浏览器底部，</p>\n<h3 id=\"方法一：footer高度固定-绝对定位\"><a href=\"#方法一：footer高度固定-绝对定位\" class=\"headerlink\" title=\"方法一：footer高度固定+绝对定位\"></a>方法一：footer高度固定+绝对定位</h3><p>html</p>\n<div class=\"dui-container\">\n<header>Header</header>\n<main class=\"content\">\n<h1>使用position定位footer布局</h1>\n<button id=\"add\">Add Content</button>\n</main>\n<footer class=\"footer\">\nFooter\n</footer>\n</div>\n\n<p>CSS</p>\n<p>.dui-container{<br>position: relative;<br>min-height: 100%;<br>}<br>header,main, footer{<br>padding: 0 calc(50% - 450px);<br>}<br>main {<br>padding-bottom: 100px;<br>}<br>header, footer{<br>font-size: 30px;<br>background-color: #333;<br>color: white;<br>line-height: 100px;<br>height: 100px;<br>}<br>footer{<br>width: 100%;<br>position: absolute;<br>bottom: 0<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/MZXbXO/\">position-sticky-footer</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p> </p>\n<h3 id=\"方法二：在主体content上的下边距增加一个负值等于底部高度\"><a href=\"#方法二：在主体content上的下边距增加一个负值等于底部高度\" class=\"headerlink\" title=\"方法二：在主体content上的下边距增加一个负值等于底部高度\"></a>方法二：在主体content上的下边距增加一个负值等于底部高度</h3><p>html</p>\n<body>\n<header>Header</header>\n<main>Content</main>\n<footer>Footer</footer>\n</body>\n\n<p>CSS</p>\n<p>html, body {<br>height: 100%;<br>}<br>main {<br>min-height: 100%;<br>padding-top: 100px;<br>padding-bottom: 100px;<br>margin-top: -100px;<br>margin-bottom: -100px;<br>}<br>header, footer{<br>line-height: 100px;<br>height: 100px;<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/JwZbra/\">margin And padding-sticky-footer</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p> </p>\n<h3 id=\"方法三：将页脚的margin-top设为负数\"><a href=\"#方法三：将页脚的margin-top设为负数\" class=\"headerlink\" title=\"方法三：将页脚的margin-top设为负数\"></a>方法三：将页脚的margin-top设为负数</h3><p>html</p>\n<header>Header</header>\n<main class=\"content\">\n<button id=\"add\">添加内容试试</button>\n</main>\n<footer class=\"footer\">\nFooter\n</footer>\n\n<p>CSS</p>\n<p>main {<br>min-height: 100%;<br>padding-top: 100px;<br>padding-bottom: 100px;<br>}<br>header, footer{<br>font-size: 30px;<br>background-color: #333;<br>color: white;<br>line-height: 100px;<br>height: 100px;<br>}<br>header{<br>margin-bottom: -100px;<br>}<br>footer{<br>margin-top: -100px;<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/VqdPdK/\">footer负值-sticky-footer</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p> </p>\n<h3 id=\"方法四：-通过设置flex，将footer的margin-top设置为auto\"><a href=\"#方法四：-通过设置flex，将footer的margin-top设置为auto\" class=\"headerlink\" title=\"方法四： 通过设置flex，将footer的margin-top设置为auto\"></a>方法四： 通过设置flex，将footer的margin-top设置为auto</h3><p>html</p>\n<header>Header</header>\n<main>\n<h1>在主体content上的下边距增加一个负值等于底部高度</h1>\n<button id=\"add\">添加内容</button>\n</main>\n<footer>Footer</footer>\n\n<p>CSS</p>\n<p>body{<br>display: flex;<br>min-height: 100vh;<br>flex-direction: column;<br>}<br>header,main, footer{<br>padding: 0 calc(50% - 450px);<br>}<br>header,footer{<br>font-size: 30px;<br>background-color: #333;<br>color: white;<br>line-height: 100px;<br>height: 100px;<br>}<br>footer{margin-top: auto;}</p>\n<p> </p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/EGRNbL/\">flex and margin-sticky-footer</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p> </p>\n<h3 id=\"方法五：-通过函数calc-计算内容的高度\"><a href=\"#方法五：-通过函数calc-计算内容的高度\" class=\"headerlink\" title=\"方法五： 通过函数calc()计算内容的高度\"></a>方法五： 通过函数calc()计算内容的高度</h3><p>html代码</p>\n<body>\n<header>Header</header>\n<main>Content</main>\n<footer>Footer</footer>\n</body>\n\n<p>CSS代码</p>\n<p>main{<br>min-height: calc(100vh - 200px); /* 这个200px是header和footer的高度 */<br>}<br>header,footer{<br>height: 100px;<br>line-height: 100px;<br>}</p>\n<p> </p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/BqWMGJ/\">calc-sticky-footer</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p> </p>\n<h3 id=\"方法六：-通过设置flexbox，将主体main设置为flex\"><a href=\"#方法六：-通过设置flexbox，将主体main设置为flex\" class=\"headerlink\" title=\"方法六： 通过设置flexbox，将主体main设置为flex\"></a>方法六： 通过设置flexbox，将主体main设置为flex</h3><p>关于flexbox还请查看具体<a href=\"http://www.w3cbest.com/?page_id=118\">怎么使用</a></p>\n<body>\n<header>Header</header>\n<main>Content</main>\n<footer>Footer</footer>\n</body>\n\n<p>CSS代码</p>\n<p>body{<br>display: flex;<br>min-height: 100vh;<br>flex-direction: column;<br>}<br>main{<br>flex: 1<br>}</p>\n<p> </p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/pxeGQQ/\">flex-sticky-footer</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p> </p>\n<h3 id=\"方法七：-使用grid布局\"><a href=\"#方法七：-使用grid布局\" class=\"headerlink\" title=\"方法七： 使用grid布局\"></a>方法七： 使用grid布局</h3><p>Html代码</p>\n<body>\n<header>Header</header>\n<main>Content</main>\n<footer>Footer</footer>\n</body>\n\n<p>CSS代码</p>\n<p>html {<br>height: 100%;<br>}<br>body {<br>min-height: 100%;<br>display: grid;<br>grid-template-rows: auto 1fr auto;<br>}<br>.footer {<br>grid-row-start: 3;<br>grid-row-end: 4;<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/bmqzOv/\">grid-sticky-footer</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p> </p>\n<h3 id=\"方法八：-display\"><a href=\"#方法八：-display\" class=\"headerlink\" title=\"方法八： display-*\"></a>方法八： display-*</h3><p>html</p>\n<header>Header</header>\n<button id=\"add\">添加内容试试</button>\n<footer class=\"footer\">Footer</footer>\n\n<p>CSS</p>\n<p>body {<br>min-height: 100%;<br>display: table;<br>width: 100%;<br>}<br>main {<br>display: table-row;<br>height: 100%;<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/ebKvKz/\">display:table-sticky-footer</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>  参考：<a href=\"https://css-tricks.com/couple-takes-sticky-footer/\">https://css-tricks.com/couple-takes-sticky-footer/</a></p>\n","categories":["HTML/CSS","资源"],"tags":["css3","flex","flexbox","calc()","footer","grid","底部固定"]},{"title":"Hexo搭建Github个人博客","url":"/2017/04/19/Hexo%E6%90%AD%E5%BB%BAGithub%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"<h2 id=\"建立自己的github-io\"><a href=\"#建立自己的github-io\" class=\"headerlink\" title=\"建立自己的github.io\"></a>建立自己的github.io</h2><p>建立自己的github.io，这个跟创建普通的github仓库一样，只是仓库的名字叫xxx.github.io。</p>\n<h2 id=\"配置git账号\"><a href=\"#配置git账号\" class=\"headerlink\" title=\"配置git账号\"></a>配置git账号</h2><p>如果本地已安装<a href=\"https://www.sourcetreeapp.com/\" target=\"_blank\" rel=\"noopener\">SourceTree</a>并已使用github账号下载过项目，则请忽略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;Your name&quot;</span><br><span class=\"line\">$ git config --global user.email xxx@email.com&#96;&#96;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置github账号的SSH-key\"><a href=\"#配置github账号的SSH-key\" class=\"headerlink\" title=\"配置github账号的SSH key\"></a>配置github账号的SSH key</h2><p>如果本地已安装<a href=\"https://www.sourcetreeapp.com/\" target=\"_blank\" rel=\"noopener\">SourceTree</a>并已使用github账号下载过项目，则请忽略。</p>\n<h4 id=\"生成ssh公钥\"><a href=\"#生成ssh公钥\" class=\"headerlink\" title=\"生成ssh公钥\"></a>生成ssh公钥</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -c &quot;xxx@xxx.com&quot;</span><br></pre></td></tr></table></figure>\n\n<p>三次回车即可生成ssh key，对于存放目录，可以使用默认，也可在默认的基础上添加自定义目录。个人倾向于自定义目录。</p>\n<h4 id=\"查看public-key，并把它添加到github公钥中\"><a href=\"#查看public-key，并把它添加到github公钥中\" class=\"headerlink\" title=\"查看public key，并把它添加到github公钥中\"></a>查看public key，并把它添加到github公钥中</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>\n<p>将#号后的内容拷贝到 <code>Github</code> 公钥中并保存即可。</p>\n<p>具体可参考<a href=\"https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/\" target=\"_blank\" rel=\"noopener\">Github</a>官网的配置，或参考<a href=\"http://git.mydoc.io/?t=154712\" target=\"_blank\" rel=\"noopener\">码云</a>关于ssh key的配置</p>\n<h2 id=\"Hexo安装\"><a href=\"#Hexo安装\" class=\"headerlink\" title=\"Hexo安装\"></a>Hexo安装</h2><h4 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install node</span><br></pre></td></tr></table></figure>\n<p>由于hexo的运行，依赖于<a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">Node.js</a>，所以在安装hexo前，请先安装<a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">Node.js</a>。</p>\n<h4 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>Hexo的具体安装可参见其<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">官网</a>。</p>\n<h2 id=\"hexo简单使用\"><a href=\"#hexo简单使用\" class=\"headerlink\" title=\"hexo简单使用\"></a>hexo简单使用</h2><h4 id=\"创建工程\"><a href=\"#创建工程\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo init myblog</span><br></pre></td></tr></table></figure>\n<p>创建新工程，名字就叫 <code>myblog</code> 。</p>\n<p>创建新工程后，里面会有一堆的文件。其中(<code>_config.yml</code>)文件为工程配置文件，这里面包含了整个工程的运行配置，我们待会会对其进行修改。</p>\n<h4 id=\"修改配置-amp-amp-git绑定\"><a href=\"#修改配置-amp-amp-git绑定\" class=\"headerlink\" title=\"修改配置 &amp;&amp; git绑定\"></a>修改配置 &amp;&amp; git绑定</h4><p>对(<code>_config.yml</code>)文件进行修改， 主要更改点为 <code>title</code> 、 <code>author</code> 、 <code>url</code>、<code>deploy</code> 等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: myblog</span><br><span class=\"line\">author: Tom</span><br><span class=\"line\">url: https:&#x2F;&#x2F;xianzhiding.github.io</span><br><span class=\"line\">...</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:xianzhiding&#x2F;xianzhiding.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建博文\"><a href=\"#创建博文\" class=\"headerlink\" title=\"创建博文\"></a>创建博文</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new myblog</span><br></pre></td></tr></table></figure>\n<p>新建一个名叫myblog的博文。</p>\n<h4 id=\"生成静态文件\"><a href=\"#生成静态文件\" class=\"headerlink\" title=\"生成静态文件\"></a>生成静态文件</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>该命令可简写为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n<p>此命令执行后，会在工程里生成一个<code>public</code>文件夹，这个文件夹里的文件，包含了整个静态网站运行的所有文件。这些文件，会在我们部署网站的时候，提交到我们创建的<code>github.io</code>仓库里。</p>\n<h4 id=\"本地预览\"><a href=\"#本地预览\" class=\"headerlink\" title=\"本地预览\"></a>本地预览</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>可简写为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n<p>启动本地服务环境后，可在浏览器中输入<code>http://localhost:4000/</code>预览工程的运行。</p>\n<h4 id=\"部署网站\"><a href=\"#部署网站\" class=\"headerlink\" title=\"部署网站\"></a>部署网站</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>可简写为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n<p>若前面已配置过<code>_config.yml</code>中的Deployment，则执行部署后，会将<code>public</code>里的内容提交到我们的<code>github.io</code>中。大约5~10分钟，就可以通过<code>github.io</code>访问到自己的静态网站了。</p>\n<h4 id=\"清理缓存\"><a href=\"#清理缓存\" class=\"headerlink\" title=\"清理缓存\"></a>清理缓存</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<p>在某些情况下（尤其是更改主题后），肯能出现站点运行异常，可执行此命令。</p>\n<p>需要注意的是：若清空了缓存，则站点需要重新生成静态文件并发布。</p>\n","tags":["Hexo"]},{"title":"JavaScript高级程序设计——闭包","url":"/2019/04/24/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E9%97%AD%E5%8C%85/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有很多人搞不清匿名函数和闭包这两个概念，经常混用。闭包是指有权访问另一个函数作用域中的变量的函数。匿名函数就是没有实际名字的函数。</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p><strong>概念</strong> 闭包，其实是一种语言特性，它是指的是程序设计语言中，允许将函数看作对象，然后能像在对象中的操作搬在函数中定义实例（局部）变量，而这些变量能在函数中保存到函数的实例对象销毁为止，其它代码块能通过某种方式获取这些实例（局部）变量的值并进行应用扩展。 <strong>条件</strong> 闭包是允许函数访问局部作用域之外的数据。即使外部函数已经退出，外部函数的变量仍可以被内部函数访问到。 因此闭包的实现需要三个条件：</p>\n<ol>\n<li> 内部函数实用了外部函数的变量</li>\n<li> 外部函数已经退出</li>\n<li> 内部函数可以访问</li>\n</ol>\n<p>function a() {<br>    var x = 0;<br>    return function(y) {<br>        x = x + y;<br>        // return x;<br>        console.log(x);<br>    }<br>}<br>var b = a();<br>b(1); //1<br>b(1); //2</p>\n<p>上述代码在执行的时候，<code>b</code>得到的是闭包对象的引用，虽然<code>a</code>执行完毕后，但是<code>a</code>的活动对象由于闭包的存在并没有被销毁，在执行<code>b(1)</code>的时候，仍然访问到了x变量，并将其加1，若再执行<code>b(1)</code>，则<code>x</code>是<code>2</code>，因为闭包的引用<code>b</code>并没有消除。（后面会解释，闭包返回了函数，函数可以创建独立的作用域）</p>\n<blockquote>\n<p>闭包，其实就是指程序语言中能让代码调用已运行的函数中所定义的局部变量。</p>\n</blockquote>\n<p>但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递。</p>\n<p>function fn() {<br>    var max = 10;<br>    return function bar(x) {<br>        if (x &gt; max) {<br>            console.log(x);<br>        }<br>    };<br>}<br>var f1 = fn();<br>f1(15);</p>\n<p>如上代码，<code>bar</code>函数作为返回值，赋值给<code>f1</code>变量。执行<code>f1(15)</code>时，用到了<code>fn</code>作用域下的<code>max</code>变量的值。至于如何跨作用域取值，可以参考上一篇文章。</p>\n<p>var max = 10,<br>    fn = function(x) {<br>        if (x &gt; max) {<br>            console.log(x); //15<br>        }<br>    };<br>(function(f) {<br>    var max = 100;<br>    f(15);<br>})(fn);</p>\n<p>如上代码中，<code>fn</code>函数作为一个参数被传递进入另一个函数，赋值给f参数。执行<code>f(15)</code>时，max变量的取值是<code>10</code>而不是<code>100</code>。 上一篇讲到自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单. 另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。 在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。</p>\n<blockquote>\n<p>有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。</p>\n</blockquote>\n<p>可以拿本文的之前代码（只做注释修改）来分析一下。</p>\n<p>1  //全局作用域<br>2  function fn() {<br>3      var max = 10;<br>4      // fn作用域<br>5      return function bar(x) {<br>6          if (x &gt; max) {<br>7              console.log(x);<br>8          }<br>9      }; //bar作用域<br>10 }<br>11 var f1 = fn();<br>12 f1(15);</p>\n<p>全局作用域为：代码1-12行；fn作用域为：代码2-10行；<code>bar</code>作用域为：代码5-9行。 <strong>举例</strong> 第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。 <img src=\"http://file.w3cbest.com/file/images/js-closure-1.jpg\"> 第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。 <img src=\"http://file.w3cbest.com/file/images/js-closure-2.jpg\"> 第三步，执行完第17行，<code>fn()</code>调用完成。按理说应该销毁掉<code>fn()</code>的执行上下文环境，但是这里不能这么做。注意，重点来了：</p>\n<blockquote>\n<p>因为执行<code>fn()</code>时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量<code>max</code>要引用<code>fn</code>作用域下的<code>fn()</code>上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。</p>\n</blockquote>\n<p>因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。 ——即，执行到第18行时，全局上下文环境将变为活动状态，但是<code>fn()</code>上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的<code>max</code>被赋值为<code>100</code>。如下图： <img src=\"http://file.w3cbest.com/file/images/js-closure-3.jpg\"> 第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。 <img src=\"http://file.w3cbest.com/file/images/js-closure-4.jpg\"> 执行<code>bar(15)</code>时，<code>max</code>是自由变量，需要向创建<code>bar</code>函数的作用域中查找，找到了<code>max</code>的值为10。这个过程在作用域链一节已经讲过。 这里的重点就在于，创建bar函数是在执行<code>fn()</code>时创建的。<code>fn()</code>早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此<code>bar(15)</code>时，<code>max</code>可以查找到。如果<code>fn()</code>上下文环境销毁了，那么<code>max</code>就找不到了。</p>\n<blockquote>\n<p>总结：使用闭包会增加内容开销</p>\n</blockquote>\n<p>第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。</p>\n<h2 id=\"闭包与变量\"><a href=\"#闭包与变量\" class=\"headerlink\" title=\"闭包与变量\"></a>闭包与变量</h2><p><strong>概念</strong> 闭包只能取得包含函数中任何变量的最后一个值,闭包所保存的是整个变量对象，而不是某个特殊变量。 例子</p>\n<p>function createFunctions() {<br>    var result = new Array();<br>    for (var i = 0; i &lt; 10; i++) {<br>        result[i] = function() {<br>            return i;<br>        };<br>    }<br>    return result;<br>}<br>var funcs = createFunctions();<br>//每个函数都输出10<br>for (var i = 0; i &lt; funcs.length; i++) {<br>    document.write(funcs[i]() + “<br />“);<br>}</p>\n<blockquote>\n<p>总结：每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值为10。</p>\n</blockquote>\n<p>我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。</p>\n<p>function createFunctions() {<br>    var result = new Array();<br>    for (var i = 0; i &lt; 10; i++) {<br>        result[i] = function(x) {<br>            return function() {<br>                return x;<br>            };<br>        }(i);<br>    }<br>    return result;<br>}<br>var funcs = createFunctions();<br>//循环输出0-10<br>for (var i = 0; i &lt; funcs.length; i++) {<br>    document.write(funcs[i]() + “<br />“);<br>}</p>\n<blockquote>\n<p>总结：没有直接把闭包赋值给数组，而是定义了一个匿名函数，并通过立即执行该匿名函数的结果赋值给数组，并带了for循环的参数i进去，让x能找到传入的参数值为0-10，这就解释了函数参数是按值传递的，所以会将变量i的当前值复制给参数x。而这个匿名函数内部又创建并返回了一个访问x的闭包。这样以来result数组中的每个函数都有自己x变量的一个副本，所以会符合我们的预期输出不同的值。</p>\n</blockquote>\n<p>小例子 html结构代码：</p>\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n    <li>6</li>\n</ul>\n\n<p>js结构代码:</p>\n<p>// 闭包不符合预期<br>var clickBoxs = new Array();<br>clickBoxs = $(“li”);<br>for (var i = 0; i &lt; 10; i++) {<br>    clickBoxs[i].onclick = function() {<br>        console.log(i);<br>    };<br>}</p>\n<p>解决方法：</p>\n<p>// 闭包1<br>var clickBoxs = new Array();<br>clickBoxs = $(“li”);<br>for (var i = 0; i &lt; 10; i++) {<br>    clickBoxs[i].onclick = (function(x) {<br>        return function() {<br>            console.log(x);<br>            return x;<br>        }<br>    })(i);<br>}</p>\n<p>// 闭包2<br>var clickBoxs = new Array();<br>clickBoxs = $(“li”);</p>\n<p>function foo(i) {<br>    var onclick = function(e) {<br>        console.log(i);<br>    }<br>    return onclick;<br>}<br>for (var i = 0; i &lt; 10; i++) {<br>    clickBoxs[i].onclick = foo(i);<br>}</p>\n<p>// es6语法<br>var clickBoxs = new Array();<br>clickBoxs = $(“li”);<br>for (let i = 0; i &lt; 10; i++) {<br>    clickBoxs[i].onclick = function() {<br>        console.log(i);<br>    };<br>}</p>\n<p><strong>函数按值传递</strong> 函数传参就两个类型，基本类型和引用类型，大家纠结的都是引用类型的传递。 引用类型作为参数传入函数，传的是个地址值，或者指针值，不是那个引用类型本身，它还好好的呆在堆内存呢。赋值给<code>argument</code>的同样是地址值或者指针。所以说是<code>value</code>值传递一点没错，传的是个地址值。通过两个例子看懂就行了。 例子1：</p>\n<p>function setName(obj) {<br>    obj.name = ‘aaa’;<br>    var obj = new Object(); // 如果是按引用传递的,此处传参进来obj应该被重新引用新的内存单元<br>    obj.name = ‘ccc’;<br>    return obj;<br>}<br>var person = new Object();<br>person.name = ‘bbb’;<br>var newPerson = setName(person);<br>console.log(person.name + ‘  ‘ + newPerson.name); // aaa  ccc</p>\n<p>从结果看，并没有显示两个<code>’ccc’</code>。这里是函数内部重写了<code>obj</code>，重写的<code>obj</code>是一个局部对象。当函数执行完后，立即被销毁。</p>\n<blockquote>\n<p>引用值：对象变量它里面的值是这个对象在堆内存中的内存地址。因此如果按引用传递，它传递的值也就是这个内存地址。那么<code>var obj = new Object();</code>会重新给<code>obj</code>分配一个地址，比如是0x321了，那么它就不在指向有<code>name = ‘aaa’</code>;属性的内存单元了。相当于把实参obj和形参obj的地址都改了，那么最终就是输出两个<code>ccc</code>了。</p>\n</blockquote>\n<p>例子2</p>\n<p>var a = {<br>    num: ‘1’<br>};<br>var b = {<br>    num: ‘2’<br>};</p>\n<p>function change(obj) {<br>    obj.num = ‘3’;<br>    obj = b;<br>    return obj.num;<br>}<br>var result = change(a);<br>console.log(result + ‘  ‘ + a.num); // 2  3</p>\n<ul>\n<li>  首先把a的值传到change函数内，obj.num = ‘3’;后a.name被修改为3;</li>\n<li>  a的地址被换成b的地址;</li>\n<li>  返回此时的a中a.num。</li>\n</ul>\n<h2 id=\"闭包中使用this对象\"><a href=\"#闭包中使用this对象\" class=\"headerlink\" title=\"闭包中使用this对象\"></a>闭包中使用this对象</h2><p><strong>概念</strong> <code>this</code>对象是在运行时基于函数的执行环境绑定的：全局函数中，<code>this</code>等于<code>window</code>;当函数被作用某个对象的方法调用时，<code>this</code>等于那个对象。 但在匿名函数中，由于匿名函数的执行环境具有全局性，因此<code>this</code>对象通常指向<code>window</code>(在通过call或<code>apply</code>函数改变函数执行环境的情况下，会指向其他对象)。</p>\n<p>var name = “The Window”;</p>\n<p>var object = {<br>    name: “My Object”,</p>\n<pre><code>getNameFunc: function() &#123;\n    return function() &#123;\n        return this.name;\n    &#125;;\n&#125;\n</code></pre>\n<p>};</p>\n<p>console.log(object.getNameFunc()()); //“The Window”</p>\n<p>通过修改把作用域中的<code>this</code>对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了。如下代码：</p>\n<p>var name = “The Window”;</p>\n<p>var object = {<br>    name: “My Object”,</p>\n<pre><code>getNameFunc: function() &#123;\n    var that = this;\n    return function() &#123;\n        return that.name;\n    &#125;;\n&#125;\n</code></pre>\n<p>};</p>\n<p>console.log();<br>(object.getNameFunc()()); //“MyObject”</p>\n<p>变量声明提前</p>\n<p>var scope = “global”;</p>\n<p>function scopeTest() {<br>    console.log(scope);<br>    var scope = “local”;<br>}<br>scopeTest(); //undefined</p>\n<p>此处的输出是<code>undefined</code>，并没有报错，这是因为在前面我们提到的函数内的声明在函数体内始终可见，上面的函数等效于：</p>\n<p>var scope = “global”;</p>\n<p>function scopeTest() {<br>    var scope;<br>    console.log(scope);<br>    scope = “local”;<br>}<br>scopeTest(); //undefined</p>\n<p>注意，如果忘记<code>var</code>，那么变量就被声明为全局变量了。结果就是global</p>\n<h2 id=\"没有块级作用域\"><a href=\"#没有块级作用域\" class=\"headerlink\" title=\"没有块级作用域\"></a>没有块级作用域</h2><p>和其他我们常用的语言不同，在Javascript中没有块级作用域：</p>\n<p>function scopeTest() {<br>    var scope = {};<br>    if (scope instanceof Object) {<br>        var j = 1;<br>        for (var i = 0; i &lt; 10; i++) {<br>            console.log(i); //输出0-9<br>        }<br>        console.log(i); //输出10<br>    }<br>    console.log(j); //输出1<br>}<br>scopeTest();</p>\n<p>在javascript中变量的作用范围是函数级的，即在函数中所有的变量在整个函数中都有定义，这也带来了一些我们稍不注意就会碰到的“潜规则”：</p>\n<p>var scope = “hello”;</p>\n<p>function scopeTest() {<br>    console.log(scope); //①<br>    var scope = “no”;<br>    console.log(scope); //②<br>}</p>\n<p>在①处输出的值竟然是<code>undefined</code>，简直丧心病狂啊，我们已经定义了全局变量的值啊，这地方不应该为hello吗？其实，上面的代码等效于：</p>\n<p>var scope = “hello”;</p>\n<p>function scopeTest() {<br>    var scope;<br>    console.log(scope); //①<br>    scope = “no”;<br>    console.log(scope); //②<br>}</p>\n<p>声明提前、全局变量优先级低于局部变量，根据这两条规则就不难理解为什么输出<code>undefined</code>了。</p>\n","categories":["JavaScript"],"tags":["javascript","javascript 闭包","javascript教程","作用域"]},{"title":"分享一个生成二维码的插件–QRCode.js","url":"/2021/04/02/QR-code-plug-in/","content":"<p>随着移动设备的普及，日常生活中随处可见二维码，大有一码走天下之势。那么前端如何来生成二维码？</p>\n<p>通过QRCode.js我们可以快速生成二维码啦，一起来看看怎么使用吧。</p>\n<h3 id=\"1、引入插件\"><a href=\"#1、引入插件\" class=\"headerlink\" title=\"1、引入插件\"></a>1、引入插件</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*html*/</span><br><span class=\"line\">&lt;div id=<span class=\"string\">&quot;qrcode&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">/*js*/</span><br><span class=\"line\">&lt;script src=<span class=\"string\">&quot;qrcode.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、基本用法\"><a href=\"#2、基本用法\" class=\"headerlink\" title=\"2、基本用法\"></a>2、基本用法</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">var qrcode = document.getElementById(<span class=\"string\">&#x27;qrcode&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">/*直接生成二维码*/</span><br><span class=\"line\">new QRCode(qrcode, <span class=\"string\">&#x27;http://www.w3cbest.com&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">/*也可以配置二维码的宽高等*/</span><br><span class=\"line\">var qrcodeObj = new QRCode(<span class=\"string\">&#x27;qrcode&#x27;</span>, &#123;</span><br><span class=\"line\">    text: <span class=\"string\">&#x27;http://www.w3cbest.com&#x27;</span>,</span><br><span class=\"line\">    width: 256,</span><br><span class=\"line\">    height: 256,</span><br><span class=\"line\">    colorDark : <span class=\"string\">&#x27;#000000&#x27;</span>, //前景色</span><br><span class=\"line\">    colorLight : <span class=\"string\">&#x27;#ffffff&#x27;</span>  //背景色</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、API\"><a href=\"#3、API\" class=\"headerlink\" title=\"3、API\"></a>3、API</h3><p>设置二维码内容–makeCode</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">qrcodeObj.makeCode(<span class=\"string\">&#x27;http://www.w3cbest.com/?p=6518&amp;preview=true&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>清除二维码–clear</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">qrcodeObj.clear()</span><br></pre></td></tr></table></figure>","tags":["二维码"]},{"title":"Array.from() 五个超好用的用途","url":"/2019/09/03/array-from-%E4%BA%94%E4%B8%AA%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84%E7%94%A8%E9%80%94/","content":"<p>任何一种编程语言都具有超出基本用法的功能，它得益于成功的设计和试图去解决广泛问题。 JavaScript 中有一个这样的函数: Array.from：允许在 JavaScript 集合(如: 数组、类数组对象、或者是字符串、map 、set 等可迭代对象) 上进行有用的转换。 在本文中，我将描述5个有用且有趣的 Array.from() 用例。</p>\n<h2 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h2><p>在开始之前，我们先回想一下 Array.from() 的作用。语法:</p>\n<blockquote>\n<p>Array.from(arrayLike[, mapFunction[, thisArg]])</p>\n</blockquote>\n<p>arrayLike：必传参数，想要转换成数组的伪数组对象或可迭代对象。 mapFunction：可选参数，mapFunction(item，index){…} 是在集合中的每个项目上调用的函数。返回的值将插入到新集合中。 thisArg：可选参数，执行回调函数 mapFunction 时 this 对象。这个参数很少使用。 例如，让我们将类数组的每一项乘以2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const someNumbers &#x3D; &#123; &#39;0&#39;: 10, &#39;1&#39;: 15, length: 2 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Array.from(someNumbers, value &#x3D;&gt; value * 2); &#x2F;&#x2F; &#x3D;&gt; [20, 30]</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"2-将类数组转换成数组\"><a href=\"#2-将类数组转换成数组\" class=\"headerlink\" title=\"2.将类数组转换成数组\"></a>2.将类数组转换成数组</h2><p>Array.from() 第一个用途：将类数组对象转换成数组。 通常，你会碰到的类数组对象有：函数中的 arguments 关键字，或者是一个 DOM 集合。 在下面的示例中，让我们对函数的参数求和：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function sumArguments() &#123;</span><br><span class=\"line\">return Array.from(arguments).reduce((sum, num) &#x3D;&gt; sum + num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sumArguments(1, 2, 3); &#x2F;&#x2F; &#x3D;&gt; 6</span><br></pre></td></tr></table></figure>\n\n\n<p>Array.from(arguments) 将类数组对象 arguments 转换成一个数组，然后使用数组的 reduce 方法求和。 此外，Array.from() 的第一个参数可以是任意一个可迭代对象，我们继续看一些例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Array.from(&#39;Hey&#39;); &#x2F;&#x2F; &#x3D;&gt; [&#39;H&#39;, &#39;e&#39;, &#39;y&#39;]</span><br><span class=\"line\">Array.from(new Set([&#39;one&#39;, &#39;two&#39;])); &#x2F;&#x2F; &#x3D;&gt; [&#39;one&#39;, &#39;two&#39;]</span><br><span class=\"line\"></span><br><span class=\"line\">const map &#x3D; new Map();</span><br><span class=\"line\">map.set(&#39;one&#39;, 1)</span><br><span class=\"line\">map.set(&#39;two&#39;, 2);</span><br><span class=\"line\">Array.from(map); &#x2F;&#x2F; &#x3D;&gt; [[&#39;one&#39;, 1], [&#39;two&#39;, 2]]</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"3-克隆一个数组\"><a href=\"#3-克隆一个数组\" class=\"headerlink\" title=\"3.克隆一个数组\"></a>3.克隆一个数组</h2><p>在 JavaScript 中有很多克隆数组的方法。正如你所想，Array.from() 可以很容易的实现数组的浅拷贝。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const numbers &#x3D; [3, 6, 9];</span><br><span class=\"line\">const numbersCopy &#x3D; Array.from(numbers);</span><br><span class=\"line\"></span><br><span class=\"line\">numbers &#x3D;&#x3D;&#x3D; numbersCopy; &#x2F;&#x2F; &#x3D;&gt; false</span><br></pre></td></tr></table></figure>\n\n\n<p>Array.from(numbers) 创建了对 numbers 数组的浅拷贝，numbers === numbersCopy 的结果是 false，意味着虽然 numbers 和 numbersCopy有着相同的项，但是它们是不同的数组对象。 是否可以使用 Array.from() 创建数组的克隆，包括所有嵌套的？挑战一下！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function recursiveClone(val) &#123;</span><br><span class=\"line\">return Array.isArray(val) ? Array.from(val, recursiveClone) : val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const numbers &#x3D; [[0, 1, 2], [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]];</span><br><span class=\"line\">const numbersClone &#x3D; recursiveClone(numbers);</span><br><span class=\"line\">numbersClone; &#x2F;&#x2F; &#x3D;&gt; [[0, 1, 2], [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]]</span><br><span class=\"line\">numbers[0] &#x3D;&#x3D;&#x3D; numbersClone[0] &#x2F;&#x2F; &#x3D;&gt; false</span><br></pre></td></tr></table></figure>\n\n\n<p>recursiveClone() 能够对数组的深拷贝，通过判断 数组的 item 是否是一个数组，如果是数组，就继续调用 recursiveClone() 来实现了对数组的深拷贝。 你能编写一个比使用 Array.from() 递归拷贝更简短的数组深拷贝吗？如果可以的话，请写在下面的评论区。</p>\n<h2 id=\"4-使用值填充数组\"><a href=\"#4-使用值填充数组\" class=\"headerlink\" title=\"4. 使用值填充数组\"></a>4. 使用值填充数组</h2><p>如果你需要使用相同的值来初始化数组，那么 Array.from() 将是不错的选择。 我们来定义一个函数，创建一个填充相同默认值的数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const length &#x3D; 3;</span><br><span class=\"line\">const init &#x3D; 0;</span><br><span class=\"line\">const result &#x3D; Array.from(&#123; length &#125;, () &#x3D;&gt; init);</span><br><span class=\"line\">result; &#x2F;&#x2F; &#x3D;&gt; [0, 0, 0]</span><br></pre></td></tr></table></figure>\n\n\n<p>result 是一个新的数组，它的长度为3，数组的每一项都是0。调用 Array.from() 方法，传入一个类数组对象 { length } 和 返回初始化值的 mapFunction 函数。 但是，有一个替代方法 array.fill() 可以实现同样的功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const length &#x3D; 3;</span><br><span class=\"line\">const init &#x3D; 0;</span><br><span class=\"line\">const result &#x3D; Array(length).fill(init);</span><br><span class=\"line\">fillArray2(0, 3); &#x2F;&#x2F; &#x3D;&gt; [0, 0, 0]</span><br></pre></td></tr></table></figure>\n\n\n<p>fill() 使用初始值正确填充数组。</p>\n<h3 id=\"4-1-使用对象填充数组\"><a href=\"#4-1-使用对象填充数组\" class=\"headerlink\" title=\"4.1 使用对象填充数组\"></a>4.1 使用对象填充数组</h3><p>当初始化数组的每个项都应该是一个新对象时，Array.from() 是一个更好的解决方案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const length &#x3D; 3;</span><br><span class=\"line\">const resultA &#x3D; Array.from(&#123; length &#125;, () &#x3D;&gt; (&#123;&#125;));</span><br><span class=\"line\">const resultB &#x3D; Array(length).fill(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">resultA; &#x2F;&#x2F; &#x3D;&gt; [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br><span class=\"line\">resultB; &#x2F;&#x2F; &#x3D;&gt; [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">resultA[0] &#x3D;&#x3D;&#x3D; resultA[1]; &#x2F;&#x2F; &#x3D;&gt; false</span><br><span class=\"line\">resultB[0] &#x3D;&#x3D;&#x3D; resultB[1]; &#x2F;&#x2F; &#x3D;&gt; true</span><br></pre></td></tr></table></figure>\n\n\n<p>由 Array.from 返回的 resultA 使用不同空对象实例进行初始化。之所以发生这种情况是因为每次调用时，mapFunction，即此处的 () =&gt; ({}) 都会返回一个新的对象。 然后，fill() 方法创建的 resultB 使用相同的空对象实例进行初始化。不会跳过空项。</p>\n<h3 id=\"4-2-使用-array-map-怎么样？\"><a href=\"#4-2-使用-array-map-怎么样？\" class=\"headerlink\" title=\"4.2 使用 array.map 怎么样？\"></a>4.2 使用 array.map 怎么样？</h3><p>是不是可以使用 array.map() 方法来实现？我们来试一下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const length &#x3D; 3;</span><br><span class=\"line\">const init &#x3D; 0;</span><br><span class=\"line\">const result &#x3D; Array(length).map(() &#x3D;&gt; init);</span><br><span class=\"line\"></span><br><span class=\"line\">result; &#x2F;&#x2F; &#x3D;&gt; [undefined, undefined, undefined]</span><br></pre></td></tr></table></figure>\n\n\n<p>map() 方法似乎不正常，创建出来的数组不是预期的 [0, 0, 0]，而是一个有3个空项的数组。 这是因为 Array(length) 创建了一个有3个空项的数组(也称为稀疏数组)，但是 map() 方法会跳过空项。</p>\n<h2 id=\"5-生成数字范围\"><a href=\"#5-生成数字范围\" class=\"headerlink\" title=\"5. 生成数字范围\"></a>5. 生成数字范围</h2><p>你可以使用 Array.from() 生成值范围。例如，下面的 range 函数生成一个数组，从0开始到 end - 1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function range(end) &#123;</span><br><span class=\"line\">return Array.from(&#123; length: end &#125;, (_, index) &#x3D;&gt; index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">range(4); &#x2F;&#x2F; &#x3D;&gt; [0, 1, 2, 3]</span><br></pre></td></tr></table></figure>\n\n\n<p>在 range() 函数中，Array.from() 提供了类似数组的 {length：end} ，以及一个简单地返回当前索引的 map 函数 。这样你就可以生成值范围。</p>\n<h2 id=\"6-数组去重\"><a href=\"#6-数组去重\" class=\"headerlink\" title=\"6.数组去重\"></a>6.数组去重</h2><p>由于 Array.from() 的入参是可迭代对象，因而我们可以利用其与 Set 结合来实现快速从数组中删除重复项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">return Array.from(new Set(array));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">unique([1, 1, 2, 3, 3]); &#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>\n\n\n<p>首先，new Set(array) 创建了一个包含数组的集合，Set 集合会删除重复项。 因为 Set 集合是可迭代的，所以可以使用 Array.from() 将其转换为一个新的数组。 这样，我们就实现了数组去重。</p>\n<h2 id=\"7-结论\"><a href=\"#7-结论\" class=\"headerlink\" title=\"7.结论\"></a>7.结论</h2><p>Array.from() 方法接受类数组对象以及可迭代对象，它可以接受一个 map 函数，并且，这个 map 函数不会跳过值为 undefined 的数值项。这些特性给 Array.from() 提供了很多可能。 如上所述，你可以轻松的将类数组对象转换为数组，克隆一个数组，使用初始化填充数组，生成一个范围，实现数组去重。 实际上，Array.from() 是非常好的设计，灵活的配置，允许很多集合转换。 你知道 Array.from() 的其他有趣用例吗？可以写在评论区。</p>\n","categories":["JavaScript"],"tags":["Array.from()","Array.isArray()","map.set()"]},{"title":"art-template.js关于checkbox、radio选中后返回数据如何渲染","url":"/2018/09/10/art-template-js%E5%85%B3%E4%BA%8Echeckbox%E3%80%81radio%E9%80%89%E4%B8%AD%E5%90%8E%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93/","content":"<p>假如我们有一个多选和单选列表, 图片 我们从后端拿到数据后想在初始化的时候按照数据的值进行渲染，是选中的就显示选中状态，没有选中的就显示默认状态, 假如这是我们拿到的数据（理想中的数据应该是这样的）,如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123; &quot;code&quot;: &quot;1&quot;, &quot;name&quot;: &quot;语文&quot;, &quot;content&quot;: &quot;1&quot;, &quot;checked&quot;: false &#125;,</span><br><span class=\"line\">    &#123; &quot;code&quot;: &quot;2&quot;, &quot;name&quot;: &quot;数学&quot;, &quot;content&quot;: &quot;2&quot;, &quot;checked&quot;: true &#125;,</span><br><span class=\"line\">    &#123; &quot;code&quot;: &quot;3&quot;, &quot;name&quot;: &quot;英语&quot;, &quot;content&quot;: &quot;3&quot;, &quot;checked&quot;: true &#125;,</span><br><span class=\"line\">    &#123; &quot;code&quot;: &quot;4&quot;, &quot;name&quot;: &quot;物理&quot;, &quot;content&quot;: &quot;4&quot;, &quot;checked&quot;: false &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>那么就很简单的了，就可以直接进行数据渲染，如下： html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class&#x3D;&quot;form-check&quot; id&#x3D;&quot;formCheckBox&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">res &#x3D; [</span><br><span class=\"line\">    &#123; &quot;code&quot;: &quot;1&quot;, &quot;name&quot;: &quot;语文&quot;, &quot;content&quot;: &quot;1&quot;, &quot;checked&quot;: false &#125;,</span><br><span class=\"line\">    &#123; &quot;code&quot;: &quot;2&quot;, &quot;name&quot;: &quot;数学&quot;, &quot;content&quot;: &quot;2&quot;, &quot;checked&quot;: true &#125;,</span><br><span class=\"line\">    &#123; &quot;code&quot;: &quot;3&quot;, &quot;name&quot;: &quot;英语&quot;, &quot;content&quot;: &quot;3&quot;, &quot;checked&quot;: true &#125;,</span><br><span class=\"line\">    &#123; &quot;code&quot;: &quot;4&quot;, &quot;name&quot;: &quot;物理&quot;, &quot;content&quot;: &quot;4&quot;, &quot;checked&quot;: false &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">document.getElementById(&#39;formCheckBox&#39;).innerHTML &#x3D; template(&#39;checkboxTemp&#39;, &#123; data: res &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>template</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;checkboxTemp&quot;&gt;</span><br><span class=\"line\">&#123;&#123;each data item&#125;&#125;</span><br><span class=\"line\">&lt;label for&#x3D;&quot;checkbox&#123;&#123;item.code&#125;&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;input class&#x3D;&quot;form-check-input&quot; type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;checkbox&#123;&#123;item.code&#125;&#125;&quot; value&#x3D;&quot;&#123;&#123;item.content&#125;&#125;&quot; &#123;&#123;if item.checked &#x3D;&#x3D; true&#125;&#125;checked&#123;&#123;&#x2F;if&#125;&#125;&gt; &#123;&#123;item.name&#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;label&gt;</span><br><span class=\"line\">&#123;&#123;&#x2F;each&#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果拿到的数据是乱七八糟的后端给出来的怎么办，那我就需要处理一下数据，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&quot;data&quot;: [</span><br><span class=\"line\">    &#123; &quot;code&quot;: &quot;1&quot;, &quot;name&quot;: &quot;语文&quot;, &quot;content&quot;: &quot;1&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;code&quot;: &quot;2&quot;, &quot;name&quot;: &quot;数学&quot;, &quot;content&quot;: &quot;2&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;code&quot;: &quot;3&quot;, &quot;name&quot;: &quot;英语&quot;, &quot;content&quot;: &quot;3&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;code&quot;: &quot;4&quot;, &quot;name&quot;: &quot;物理&quot;, &quot;content&quot;: &quot;4&quot; &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">&quot;select&quot;: [1, 4]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果是这种的话我们就先渲染，然后再用JQ的each循环改变选中状态，如下： html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class&#x3D;&quot;form-check&quot; id&#x3D;&quot;formCheckBox&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">res &#x3D; &#123;</span><br><span class=\"line\">    &quot;data&quot;: [</span><br><span class=\"line\">        &#123; &quot;code&quot;: &quot;1&quot;, &quot;name&quot;: &quot;语文&quot;, &quot;content&quot;: &quot;1&quot; &#125;,</span><br><span class=\"line\">        &#123; &quot;code&quot;: &quot;2&quot;, &quot;name&quot;: &quot;数学&quot;, &quot;content&quot;: &quot;2&quot; &#125;,</span><br><span class=\"line\">        &#123; &quot;code&quot;: &quot;3&quot;, &quot;name&quot;: &quot;英语&quot;, &quot;content&quot;: &quot;3&quot; &#125;,</span><br><span class=\"line\">        &#123; &quot;code&quot;: &quot;4&quot;, &quot;name&quot;: &quot;物理&quot;, &quot;content&quot;: &quot;4&quot; &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;select&quot;: [1, 4]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">document.getElementById(&#39;formCheckBox&#39;).innerHTML &#x3D; template(&#39;tpl&#39;, &#123; data: res.data &#125;);</span><br><span class=\"line\">$(&#39;#formCheckBox label&#39;).each(function() &#123;</span><br><span class=\"line\">    var cont &#x3D; $(this).find(&#39;input&#39;).val();</span><br><span class=\"line\">    for (var i &#x3D; 0; i &lt; check.value.length; i++) &#123;</span><br><span class=\"line\">        if (check.select[i] &#x3D;&#x3D; val) &#123;</span><br><span class=\"line\">            $(this).find(&#39;input&#39;).prop(&#39;checked&#39;, true)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>template</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;tpl&quot;&gt;</span><br><span class=\"line\">    &#123;&#123;each data&#125;&#125;</span><br><span class=\"line\">    &lt;label for&#x3D;&quot;checkbox&#123;&#123;$value.code&#125;&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;input class&#x3D;&quot;form-check-input&quot; type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;checkbox&#123;&#123;$value.code&#125;&#125;&quot; value&#x3D;&quot;&#123;&#123;$value.content&#125;&#125;&quot;&gt; &#123;&#123;$value.name&#125;&#125;&lt;&#x2F;label&gt;</span><br><span class=\"line\">    &#123;&#123;&#x2F;each&#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>后记：其实拿到的数据基本上如果可以直接用的话就不必处理，但是有的数据是需要重新处理重新组合成我们用的那种结果，比如上面最后一个例子提到的，他有两个checkbox被选中，但是我们渲染的时候会用data数据渲染，那么你可以把select的两标记组合到data里面，如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">res &#x3D; &#123; </span><br><span class=\"line\">    &quot;data&quot;: [</span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            &quot;code&quot;: &quot;1&quot;, </span><br><span class=\"line\">            &quot;name&quot;: &quot;语文&quot;, </span><br><span class=\"line\">            &quot;content&quot;: &quot;1&quot;, </span><br><span class=\"line\">            &quot;select&quot;: true&#x2F;&#x2F; 这个就是标记被选中</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以直接渲染数据了，方法有很多种，就看你怎么理解，想怎么用</p>\n","categories":["JavaScript"],"tags":["art template","artTemplate","checkbox","radio","template"]},{"title":"artTemplate模板引擎之偶数奇数解析","url":"/2018/09/26/art-template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%B9%8B%E5%81%B6%E6%95%B0%E5%A5%87%E6%95%B0%E8%A7%A3%E6%9E%90/","content":"<p>如果有一个数组，我们只取其中的偶数或奇数该如何取值呢，下面一组数据是我们通过接口拿到的，其实我们只要奇数的一部分，1，3，5，7…等，如图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\[&quot;1701班&quot;,11,0,&quot;0%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,1,&quot;9.09%&quot;,7,&quot;63.64%&quot;,2,&quot;18.18%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,1,&quot;9.09%&quot;\\]</span><br><span class=\"line\"></span><br><span class=\"line\">!\\[](http:&#x2F;&#x2F;www.w3cbest.com&#x2F;wp-content&#x2F;uploads&#x2F;2018&#x2F;09&#x2F;20180926133157.jpg) 我们只要一个if条件判断就可以了，操作如下： js</span><br><span class=\"line\"></span><br><span class=\"line\">res &#x3D; &#123;&quot;data&quot;:&#123;</span><br><span class=\"line\">  &quot;head&quot;:\\[&quot;人数&quot;,&quot;比例&quot;\\],</span><br><span class=\"line\">  &quot;datas&quot;:\\[</span><br><span class=\"line\">  &#123;&quot;data&quot;:\\[&quot;1701班&quot;,11,0,&quot;0%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,1,&quot;9.09%&quot;,7,&quot;63.64%&quot;,2,&quot;18.18%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,1,&quot;9.09%&quot;\\]&#125;,</span><br><span class=\"line\">  &#123;&quot;data&quot;:\\[&quot;班级平均&quot;,21,&quot;0&quot;,&quot;0%&quot;,&quot;0&quot;,&quot;0%&quot;,&quot;0&quot;,&quot;0%&quot;,&quot;3&quot;,&quot;28.57%&quot;,&quot;5&quot;,&quot;47.62%&quot;,&quot;1.5&quot;,&quot;14.29%&quot;,&quot;0&quot;,&quot;0%&quot;,&quot;0&quot;,&quot;0%&quot;,&quot;0.5&quot;,&quot;4.76%&quot;,&quot;0.5&quot;,&quot;4.76%&quot;\\]&#125;,</span><br><span class=\"line\">  &#123;&quot;data&quot;:\\[&quot;全年级&quot;,21,0,&quot;0%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,6,&quot;28.57%&quot;,10,&quot;47.62%&quot;,3,&quot;14.29%&quot;,0,&quot;0%&quot;,0,&quot;0%&quot;,1,&quot;4.76%&quot;,1,&quot;4.76%&quot;\\]&#125;</span><br><span class=\"line\">  \\],</span><br><span class=\"line\">  &quot;title&quot;:\\[&quot;90以下&quot;,&quot;90 ~ 97&quot;,&quot;97 ~ 104&quot;,&quot;104 ~ 111&quot;,&quot;111 ~ 118&quot;,&quot;118 ~ 125&quot;,&quot;125 ~ 132&quot;,&quot;132 ~ 139&quot;,&quot;139 ~ 146&quot;,&quot;146以上&quot;\\]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">document.getElementById(&#39;id&#39;).innerHTML &#x3D; template(&#39;tpl&#39;, res);</span><br></pre></td></tr></table></figure>\n<p>template</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script id&#x3D;&quot;tpl&quot; type&#x3D;&quot;text&#x2F;html&quot;&gt;</span><br><span class=\"line\">  &lt;thead&gt;</span><br><span class=\"line\">    &lt;tr&gt;</span><br><span class=\"line\">      &lt;th&gt;班级&lt;&#x2F;th&gt;</span><br><span class=\"line\">      &#123;&#123;each title value i&#125;&#125;</span><br><span class=\"line\">      &lt;th&gt;&#123;&#123;value&#125;&#125;&lt;&#x2F;th&gt;</span><br><span class=\"line\">      &#123;&#123;&#x2F;each&#125;&#125;</span><br><span class=\"line\">    &lt;&#x2F;tr&gt;</span><br><span class=\"line\">&lt;&#x2F;thead&gt;</span><br><span class=\"line\">&lt;tbody&gt;</span><br><span class=\"line\">  &#123;&#123;each datas item&#125;&#125;</span><br><span class=\"line\">  &lt;tr&gt;</span><br><span class=\"line\">    &#123;&#123;each item.data value i&#125;&#125;</span><br><span class=\"line\">    &#123;&#123;if (i % 2 &#x3D;&#x3D; 0)&#125;&#125;</span><br><span class=\"line\">    &lt;td&gt;&#123;&#123;value&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\">    &#123;&#123;&#x2F;if&#125;&#125;</span><br><span class=\"line\">    &#123;&#123;&#x2F;each&#125;&#125;</span><br><span class=\"line\">  &lt;&#x2F;tr&gt;</span><br><span class=\"line\">  &#123;&#123;&#x2F;each&#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;tbody&gt;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n<p>其实很简单，就跟跟平时普通的if判断一样，都是取模，但是要注意在这里面要有始有终，有<code>&#123;&#123;if&#125;&#125;</code>就得有对应的<code>&#123;&#123;/if&#125;&#125;</code>，有<code>&#123;&#123;each&#125;&#125;</code>就得有对应的<code>&#123;&#123;/each&#125;&#125;</code></p>\n","categories":["JavaScript"],"tags":["javascript","art template","artTemplate","template","偶数奇数"]},{"title":"art-template模板引擎数组渲染的方法","url":"/2018/09/17/art-template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E6%95%B0%E7%BB%84%E6%B8%B2%E6%9F%93%E7%9A%84%E6%96%B9%E6%B3%95/","content":"<p>JavaScript 模板引擎作为数据与界面分离工作中最重要一环，越来越受开发者关注，模板引擎种类也是五花八门，我就说几个安全性高、错误处理调试优，执行速度快的有artTemplate(腾讯 14k)、juicer(国外 12k)这俩个，doT除了错误处理调试差以外其他的都和这两个一样,他有一个优点是小(4k)，扯远啦。 art-template 是一个简约、超快的模板引擎。 它采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行性能，并且同时支持 NodeJS 和浏览器。<a href=\"https://aui.github.io/art-template/rendering-test/\">在线速度测试</a>。 我们就讲一下讲简洁语法的渲染方式，template(filename, content)根据模板名渲染模板。前提是你已经对artTemplate有所了解， 今天我们就讲一下数组渲染的方法 数组渲染有数组对象和纯数组两种形式，我们先说数组对象，如后端返回我们接口，收到的就是一个数组。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const res &#x3D; [</span><br><span class=\"line\">  &#123;&quot;name&quot;:&quot;小明&quot;, &quot;age&quot;:16, &quot;marry&quot;:&quot;单身&quot;&#125;,</span><br><span class=\"line\">  &#123;&quot;name&quot;:&quot;小花&quot;,&quot;age&quot;:15, &quot;marry&quot;:&quot;有男朋友&quot;&#125;,</span><br><span class=\"line\">  &#123;&quot;name&quot;:&quot;小胖&quot;,&quot;age&quot;:15, &quot;marry&quot;:&quot;有女朋友&quot;&#125;,</span><br><span class=\"line\">  &#123;&quot;name&quot;:&quot;小丽&quot;,&quot;age&quot;:15, &quot;marry&quot;:&quot;单身&quot;&#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>用artTemplate有个好处就是除了你的数据需要重组，其他的完全可以拿来直接用。如下 html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;person&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  const res &#x3D; [</span><br><span class=\"line\">    &#123;&quot;name&quot;:&quot;小明&quot;, &quot;age&quot;:16, &quot;marry&quot;:&quot;单身&quot;&#125;,</span><br><span class=\"line\">    &#123;&quot;name&quot;:&quot;小花&quot;,&quot;age&quot;:15, &quot;marry&quot;:&quot;有男朋友&quot;&#125;,</span><br><span class=\"line\">    &#123;&quot;name&quot;:&quot;小胖&quot;,&quot;age&quot;:15, &quot;marry&quot;:&quot;有女朋友&quot;&#125;,</span><br><span class=\"line\">    &#123;&quot;name&quot;:&quot;小丽&quot;,&quot;age&quot;:15, &quot;marry&quot;:&quot;单身&quot;&#125;</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  document.getElementById(&#39;person&#39;).innerHTML &#x3D; template(&#39;tpl&#39;, &#123;data:res&#125;); </span><br><span class=\"line\">  &#x2F;&#x2F; 其实这里是把数组转为对象的形式传进的</span><br><span class=\"line\">&lt;&#x2F;scrtip&gt;</span><br></pre></td></tr></table></figure>\n\n<p>template</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;tpl&quot;&gt;</span><br><span class=\"line\">  &#x2F;&#x2F;写法一</span><br><span class=\"line\">  &#123;&#123;each data&#125;&#125;</span><br><span class=\"line\">  &lt;li&gt;&#123;&#123;$index&#125;&#125;索引 我叫&#123;&#123;$value.name&#125;&#125;，今年&#123;&#123;$value.age&#125;&#125;岁，&#123;&#123;$value.marry&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class=\"line\">  &#123;&#123;&#x2F;each&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F;写法二</span><br><span class=\"line\">  &#123;&#123;each data item index&#125;&#125;</span><br><span class=\"line\">  &lt;li&gt;&#123;&#123;index&#125;&#125;索引 我叫&#123;&#123;item.name&#125;&#125;，今年&#123;&#123;item.age&#125;&#125;岁，&#123;&#123;item.marry&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class=\"line\">  &#123;&#123;&#x2F;each&#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>下面在看数组渲染，这是一个数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const res &#x3D; [&#39;文艺&#39;, &#39;博客&#39;, &#39;摄影&#39;, &#39;电影&#39;, &#39;民谣&#39;, &#39;旅行&#39;, &#39;吉他&#39;];</span><br></pre></td></tr></table></figure>\n\n<p>html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;interest&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  const res &#x3D; [&#39;文艺&#39;, &#39;博客&#39;, &#39;摄影&#39;, &#39;电影&#39;, &#39;民谣&#39;, &#39;旅行&#39;, &#39;吉他&#39;];</span><br><span class=\"line\">  document.getElementById(&#39;interest&#39;).innerHTML &#x3D; template(&#39;tpl&#39;, &#123;data:res&#125;);</span><br><span class=\"line\">  &#x2F;&#x2F; 其实这里是把数组转为对象的形式传进的</span><br><span class=\"line\">&lt;&#x2F;scrtip&gt;</span><br></pre></td></tr></table></figure>\n\n<p>template</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;tpl&quot;&gt;</span><br><span class=\"line\">  &#x2F;&#x2F;写法一</span><br><span class=\"line\">  &#123;&#123;each data&#125;&#125;</span><br><span class=\"line\">  &lt;li&gt;&#123;&#123;$index&#125;&#125;索引 我喜欢&#123;&#123;$value.name&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class=\"line\">  &#123;&#123;&#x2F;each&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F;写法二</span><br><span class=\"line\">  &#123;&#123;each data item index&#125;&#125;</span><br><span class=\"line\">  &lt;li&gt;&#123;&#123;index&#125;&#125;索引 我喜欢&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class=\"line\">  &#123;&#123;&#x2F;each&#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>就说这么多吧，其实这种模板用着挺简单的很顺手。</p>\n","categories":["资源","JavaScript"],"tags":["javascript","art template","artTemplate","template"]},{"title":"background-attachment 背景图片固定文字滚动","url":"/2018/12/08/background-attachment-%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E5%9B%BA%E5%AE%9A%E6%96%87%E5%AD%97%E6%BB%9A%E5%8A%A8/","content":"<p>关于background-attachment 也不算是一个比较生僻的属性，基本上在做背景图片固定特别是全屏页面时用时就会用到。</p>\n<h3 id=\"概述节\"><a href=\"#概述节\" class=\"headerlink\" title=\"概述节\"></a>概述节</h3><p>如果指定了 background-image ，那么 background-attachment 决定背景是在视口中固定的还是随包含它的区块滚动的。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>background-attachment: scroll;<br>background-attachment: fixed;<br>background-attachment: local;<br>background-attachment: inherit;</p>\n<h3 id=\"取值节\"><a href=\"#取值节\" class=\"headerlink\" title=\"取值节\"></a>取值节</h3><h4 id=\"fixed\"><a href=\"#fixed\" class=\"headerlink\" title=\"fixed\"></a>fixed</h4><p>此关键字表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。</p>\n<h4 id=\"local\"><a href=\"#local\" class=\"headerlink\" title=\"local\"></a>local</h4><p>此关键字表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动，且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。</p>\n<h4 id=\"scroll\"><a href=\"#scroll\" class=\"headerlink\" title=\"scroll\"></a>scroll</h4><p>此关键字表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）。</p>\n<blockquote>\n<p>注意： fixed是相对视口固定，而scroll是相对元素本身固定，它和 position 定位的 absolute 和 fixed有点像。</p>\n</blockquote>\n<p> </p>\n<h4 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h4><p>section {<br>background-image: url(“<a href=\"https://picjumbo.com/wp-content/uploads/christmas-backgrounds-2210x1473.jpg&quot;\">https://picjumbo.com/wp-content/uploads/christmas-backgrounds-2210x1473.jpg&quot;</a>);<br>background-attachment: fixed;<br>}</p>\n<section>\n<p>子曰：“学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？”</p>\n<p>有子曰：“其为人也孝弟，而好犯上者，鲜矣；不好犯上而好作乱者，未之有也。君子务本，本立而道生。孝弟也者，其为仁之本与！”</p>\n<p>子曰：“巧言令色，鲜矣仁！”</p>\n<p>曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？”</p>\n<p>子曰：“道千乘之国，敬事而信，节用而爱人，使民以时。”</p>\n<p>子曰：“弟子入则孝，出则弟，谨而信，泛爱众，而亲仁，行有余力，则以学文。”</p>\n</section>\n\n<p> </p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/qQzQaP/\">单背景支持</a> by xianzhiding (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h3 id=\"多背景图支持\"><a href=\"#多背景图支持\" class=\"headerlink\" title=\"多背景图支持\"></a>多背景图支持</h3><p>此属性支持多张背景图片。你可以用逗号分隔来为每一张背景图片指定不同的<attachment>。每一张背景图片顺序对应相应的attachment 类型。</p>\n<p>section{<br>background-image: url(“<a href=\"https://picjumbo.com/wp-content/uploads/gingerbread-decorating-1080x1620.jpg&quot;\">https://picjumbo.com/wp-content/uploads/gingerbread-decorating-1080x1620.jpg&quot;</a>), url(“<a href=\"https://picjumbo.com/wp-content/uploads/woman-working-in-modern-office-space-2210x3315.jpg&quot;\">https://picjumbo.com/wp-content/uploads/woman-working-in-modern-office-space-2210x3315.jpg&quot;</a>);<br>background-attachment: fixed, scroll;<br>background-repeat: no-repeat, repeat-y;<br>}</p>\n<section>\n<p>子曰：“学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？”</p>\n<p>有子曰：“其为人也孝弟，而好犯上者，鲜矣；不好犯上而好作乱者，未之有也。君子务本，本立而道生。孝弟也者，其为仁之本与！”</p>\n<p>子曰：“巧言令色，鲜矣仁！”</p>\n<p>曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？”</p>\n<p>子曰：“道千乘之国，敬事而信，节用而爱人，使民以时。”</p>\n<p>子曰：“弟子入则孝，出则弟，谨而信，泛爱众，而亲仁，行有余力，则以学文。”</p>\n</section>\n\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/vQqQga/\">多背景图支持节</a> by xianzhiding (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h3 id=\"使用-fixed-实现多模块背景固定效果\"><a href=\"#使用-fixed-实现多模块背景固定效果\" class=\"headerlink\" title=\"使用 fixed 实现多模块背景固定效果\"></a>使用 fixed 实现多模块背景固定效果</h3><p>fixed 此关键字表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。也就是说，背景图从一开始就已经被固定死在初始所在的位置。  </p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/zMVMdw/\">视差效果</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>)on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n","categories":["HTML/CSS"],"tags":["css","background","background-attachment"]},{"title":"box-shadow和drop-shadow实现不规则投影","url":"/2018/10/09/box-shadow%E5%92%8Cdrop-shadow%E5%AE%9E%E7%8E%B0%E4%B8%8D%E8%A7%84%E5%88%99%E6%8A%95%E5%BD%B1/","content":"<p>当我们想给一个矩形或其他能用 border-radius 生成的形状（在“自适应的椭圆”一节中可以看到一些示例）加投影时，box-shadow 的表现都堪称完美。但是，当元素添加了一些伪元素或半透明的装饰之后，它就有些力不从心了，因为 border-radius 会无耻地忽视透明部分。这类情况包括：</p>\n<ul>\n<li>  半透明图像、背景图像、或者 border-image（比如老式的金质像框）；</li>\n<li>  元素设置了点状、虚线或半透明的边框，但没有背景（或者当background-clip 不是 border-box 时）；</li>\n<li>  对话气泡，它的小尾巴通常是用伪元素生成的；</li>\n</ul>\n<p>如果我们打算对这类元素直接应用 box-shadow，那只能得到不完全投影的结果。难道我们只能完全放弃投影效果吗？有没有办法可以解决这个难题？ <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/10/20181009131023.png\"> 滤镜效果规范（<a href=\"http://w3.org/TR/filter-effects%EF%BC%89%E4%B8%BA%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82%E5%AE%83%E5%BC%95%E5%85%A5%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8F%AB%E4%BD%9C\">http://w3.org/TR/filter-effects）为这个问题提供了一个解决方案。它引入了一个叫作</a> filter 的新属性，这个属性也是从 SVG 那里借鉴过来的。尽管 CSS 滤镜基本上就是 SVG 滤镜，但我们并不需要掌握任何SVG 知识。相反，只需要一些函数就可以很方便地指定滤镜效果了，比如blur()、grayscale() 以及我们需要的 drop-shadow() ！如果你喜欢，甚至可以把多个滤镜串连起来，只要用空格把它们分隔开就可以了，比如：</p>\n<p>filter: blur() grayscale() drop-shadow();</p>\n<p>drop-shadow() 滤镜可接受的参数基本上跟 box-shadow 属性是一样的，但不包括扩张半径，不包括 inset 关键字，也不支持逗号分割的多层投影语法。举个例子，上面的投影：</p>\n<p>box-shadow: 2px 2px 10px rgba(0,0,0,.5);</p>\n<p>可以这样来写：</p>\n<p>filter: drop-shadow(2px 2px 10px rgba(0,0,0,.5));</p>\n<p><img src=\"http://www.w3cbest.com/wp-content/uploads/2018/10/20181009131101.png\"> CSS 滤镜最大的好处在于，它们可以平稳退化：当浏览器不支持时，不会出现问题，只不过没有任何效果而已。如果你确实需要这个效果在尽可能多的浏览器中显示出来，可以同时附上一个 SVG 滤镜，这样可以得到稍微好一些的浏览器支持度。你可以在滤镜效果规范（<a href=\"http://www.w3.org/TR/filter-effects/%EF%BC%89%E4%B8%AD%E4%B8%BA%E6%AF%8F%E4%B8%AA%E6%BB%A4%E9%95%9C%E5%87%BD%E6%95%B0%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84\">http://www.w3.org/TR/filter-effects/）中为每个滤镜函数找到对应的</a> SVG 滤镜版本。你可以把 SVG滤镜和简化的 CSS 滤镜放在一起使用，让层叠机制来决定哪一行最终生效：</p>\n<p>filter: url(drop-shadow.svg#drop-shadow);<br>filter: drop-shadow(2px 2px 10px rgba(0,0,0,.5));</p>\n<p>不幸的是，如果 SVG 滤镜是存放在一个独立文件里的，那它就无法像一个简洁易用的函数那样在 CSS 代码中进行随意配置；如果它是内联的，则又会搅乱你的代码。参数需要写死在文件内部，因此每当我们新加一种哪怕是大同小异的投影效果时，都需要多准备一个文件，这显然是难以接受的。当然，我们还可以使用 data URI（它也会省掉额外的 HTTP 请求），但这个方法仍然会带来文件体积的增长。总的来说，这个方法只是一种回退方案，因此只要我们把SVG 滤镜控制在一定数量以内，哪怕它们的效果大同小异，也是说得过去的。 另外一件需要牢记的事情就是，任何非透明的部分都会被一视同仁地打上投影，包括文本（如果背景是透明的），正如我们刚刚看到的那样。你可能会想，是不是可以通过 text-shadow: none; 来取消掉文本上的投影呢？其实 text-shadow 跟它是完全不相干的两码事，因此这样做并不能取消文本上的 drop-shadow() 效果。此外，如果你已经用 textshadow在文本上加了投影效果，文本投影还会被 drop-shadow() 滤镜再加上投影，这本质上是给投影打了投影！看看下面这段示例代码（请原谅它惨不忍睹的效果，这样只是为了凸显这个怪异的问题）：</p>\n<p>color: deeppink;<br>border: 2px solid;<br>text-shadow: .1em .2em yellow;<br>filter: drop-shadow(.05em .05em .1em gray);</p>\n<p>你可以看到它的渲染效果，图中的文字被同时打上了 textshadow和 drop-shadow()。</p>\n","categories":["HTML/CSS"],"tags":["css","filter","css3","box-shadow","text-shadow"]},{"title":"calc()实现满屏背景定宽内容","url":"/2018/10/09/calc%E5%AE%9E%E7%8E%B0%E6%BB%A1%E5%B1%8F%E8%83%8C%E6%99%AF%E5%AE%9A%E5%AE%BD%E5%86%85%E5%AE%B9/","content":"<p>在过去的几年间，有一种网页设计手法逐渐流行起来，我将它称作背景宽度满屏，内容宽度固定。这个设计的一些典型特征如下。 页面中包含多个大区块，每个区块都占据了整个视口的宽度，区块的背景也各不相同。 内容是定宽的，即使在不同分辨率下的宽度不一样，那也只是因为媒体查询改变了这个固定的宽度值而已。在某些情况下，不同区块的内容也可能具有不同的宽度。 有时候，整个网页都是由这种风格的多个区块组成的满屏背景的定宽内容。不过在更多的情况下，页面中只有某个特定区域是以这个风格来设计的，最典型的就是导航或页脚。 要实现这种设计风格，最常见的方法就是为每个区块准备两层元素：外层用来实现满屏的背景，内层用来实现定宽的内容。后者是通过 margin: auto实现水平居中的。举例来说，采用这种设计的页脚通常需要把结构代码写成：</p>\n<footer>\n<div class=\"wrapper\">\n<!-- 页脚的内容写在这里 -->\n</div>\n</footer>\n\n<p>同时用 CSS 来设置这两层元素的样式：</p>\n<p>footer {<br>background: #333;<br>}<br>.wrapper {<br>max-width: 900px;<br>margin: 1em auto;<br>}</p>\n<p>看起来很眼熟对不对？目前绝大多数的前端工程师都是这样写的。难道为了这个效果就一定要添加一层额外的元素？我们能否在现代 CSS的帮助下彻底抛弃这个累赘？ 我们先来想一想，margin: auto 在这个场景下到底发挥了什么作用。这条声明所产生的左右外边距实际上都等于视口宽度的一半减去内容宽度的一半。由于百分比在这里是基于视口宽度来解析的（假设所有祖先元素都没有显式指定宽度），我们可以把这个外边距的值表达为 50% - 450px。幸好CSS3定义了这样一个 <code>calc()</code> 函数，它允许我们在 CSS 中直接以这种简单的算式来指定属性的值。如果用 <code>calc()</code> 取代原先的 auto，这个内层容器的样式就会变成：</p>\n<p>.wrapper {<br>max-width: 900px;<br>margin: 1em calc(50% - 450px);<br>}</p>\n<p>之所以要在页脚内加一层容器元素，唯一的原因就是为了给它的margin 指定神奇的 auto 关键字，从而实现内容的水平居中布局。不过，现在我们已经用 <code>calc()</code> 替代了这个神奇的 auto，而且这个新值实际上可以作为一个通用的 CSS 长度值应用到任何一个接受长度值的属性上。这意味着如果我们愿意，还可以把这个长度值应用到父元素的 padding 上，而整个效果是保持不变的：</p>\n<p>footer {<br>max-width: 900px;<br>padding: 1em calc(50% - 450px);<br>background: #333;<br>}<br>.wrapper {}</p>\n<p>经过这一番改造之后，我们已经把内层容器上的所有 CSS代码都剥离干净了。也就是说，它其实已经不需要参与布局了，我们可以安全地把它从结构代码中去掉。终于，我们在纯净无冗余的 HTML 结构上实现了想要的设计风格。这个方案还有进一步优化的空间吗？没错。你要相信，追求卓越的道路是永无止境的！ 如果把 width 这一行声明注释掉，你会发现其实没有影响。视觉效果是完全一样的，而且不论视口尺寸如何变化都是如此。这是为什么呢？因为当内边距是 50% - 450px 时，只可能给内容留出 900px（2×450px）的可用空间。只有把 width 显式地设置为 900px 之外（或大或小）的其他值，我们才有可能看出区别。由于我们想要得到的内容宽度本来就是 900px，这一行声明其实就是冗余的，我们可以把它去掉，让代码更加简洁。 另一个可以优化的地方在于，我们可以增加一条回退样式来增强向后兼容性。这样即使浏览器不支持 <code>calc()</code>，我们也至少可以得到一个相对合理的内边距：</p>\n<p>footer {<br>padding: 1em;<br>padding: 1em calc(50% - 450px);<br>background: #333;<br>}</p>\n<p>终于大功告成了。我们抛弃了冗余的标签，花费了三行 CSS 代码，最终达成了这个完美的结果：样式灵活、代码简练，还具有良好的兼容性！ <a href=\"https://jshare.com.cn/temp/YK51q6/share/pure\">代码演示一下</a></p>\n","categories":["HTML/CSS"],"tags":["css","css3","calc()"]},{"title":"checkbox和radio 取值、赋值、选中、事件监听等操作","url":"/2018/09/04/checkbox%E5%92%8Cradio-%E5%8F%96%E5%80%BC%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E9%80%89%E4%B8%AD%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%AD%89%E6%93%8D%E4%BD%9C/","content":"<p>先来看这是一句常见的input类型为checkbox的复选框我们把它的值设置为“1”</p>\n<p>```<br><input type=\"checkbox\" name=\"check\" value=\"1\"></p>\n<p>``</p>\n<p>1，如何获取选中的 jquery方法</p>\n<p>$(“input[type=’checkbox’]“).attr(‘value’);<br>$(“input[type=’checkbox’]“).val();</p>\n<p>js方法</p>\n<p>document.getElementsByName(‘check’)[0].value;</p>\n<p>2，如何设置为选中状态 jquery方法</p>\n<p>$(“input[type=’checkbox’]“).attr(“checked”,”checked”);<br>$(“input[type=’checkbox’]“).attr(“checked”,true);<br>$(“input[type=’checkbox’]“).prop(“checked”,”checked”); //jquery1.6+<br>$(“input[type=’checkbox’]“).prop(“checked”,true); //jquery1.6+</p>\n<p>js方法</p>\n<p>document.getElementsByName(‘check’)[0].setAttribute(‘checked’, true);</p>\n<p>3，如何获取是否选中 jquery方法</p>\n<p>$(“input[type=’checkbox’]“).attr(‘checked);<br>$(“input[type=’checkbox’]“).prop(‘checked’); //推荐<br>$(“input[type=’checkbox’]“).is(‘:checked’);</p>\n<p>js方法</p>\n<p>document.getElementsByName(‘check’)[0].checked;</p>\n<p>4，change()事件选中监听 jquery方法</p>\n<p>$(“input[type=’checkbox’]“).change(function() {<br>console.log(“checked”);<br>});</p>\n<p>js方法</p>\n<p>document.getElementsByName(‘check’)[0].onchange = function(){<br>console.log(“checked”)<br>};</p>\n<p>document.getElementsByName(‘check’)[0].addEventListener(‘click’, function(){<br>console.log(“checked”)<br>});</p>\n","categories":["JavaScript"],"tags":["javascript","checkbox","radio"]},{"title":"ckeditor 从入门到放弃","url":"/2019/04/02/ckeditor-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/","content":"<p>CKEDITOR网页编辑器还是挺复杂的，有一个 CKEDITOR 的全局空间，有一个 CKEDITOR.instances的全局实例引用，有 Classic 编辑和 Inline 编辑两种模式，有 Plugin 也有 Widget，有自成一体的编译打包工具，与 AMD\\CMD\\UMD社区不兼容。</p>\n<h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><script src=\"http://example.com/js/ckeditor/ckeditor.js\"></script>\n\n<h2 id=\"生成编辑器\"><a href=\"#生成编辑器\" class=\"headerlink\" title=\"生成编辑器\"></a>生成编辑器</h2><h3 id=\"经典编辑（Classic-Editing）\"><a href=\"#经典编辑（Classic-Editing）\" class=\"headerlink\" title=\"经典编辑（Classic Editing）\"></a>经典编辑（Classic Editing）</h3><p><textarea id=\"editor\"></textarea></p>\n<script>\nCKEDITOR.replace('editor')\n</script>\n\n<h3 id=\"内嵌编辑（Inline-Editing）\"><a href=\"#内嵌编辑（Inline-Editing）\" class=\"headerlink\" title=\"内嵌编辑（Inline Editing）\"></a>内嵌编辑（Inline Editing）</h3><div id=\"editor\" contenteditable=\"true\"></div>\n\n<script>\nCKEDITOR.disableAutoInline = true; // 关闭自动内嵌编辑\nCKEDITOR.inline('editor'); // 手动对 #editor 元素开启内嵌编辑\n</script>\n\n<h2 id=\"按钮面板定制（Toolbar）\"><a href=\"#按钮面板定制（Toolbar）\" class=\"headerlink\" title=\"按钮面板定制（Toolbar）\"></a>按钮面板定制（Toolbar）</h2><h3 id=\"一组一组定义\"><a href=\"#一组一组定义\" class=\"headerlink\" title=\"一组一组定义\"></a>一组一组定义</h3><p>config.toolbarGroups = [<br>    { name: ‘clipboard’,   groups: [ ‘clipboard’, ‘undo’ ] },<br>    { name: ‘editing’,     groups: [ ‘find’, ‘selection’, ‘spellchecker’ ] },<br>    { name: ‘links’ },<br>    { name: ‘insert’ },<br>    { name: ‘forms’ },<br>    { name: ‘tools’ },<br>    { name: ‘document’,    groups: [ ‘mode’, ‘document’, ‘doctools’ ] },<br>    { name: ‘others’ },<br>    ‘/‘,<br>    { name: ‘basicstyles’, groups: [ ‘basicstyles’, ‘cleanup’ ] },<br>    { name: ‘paragraph’,   groups: [ ‘list’, ‘indent’, ‘blocks’, ‘align’, ‘bidi’ ] },<br>    { name: ‘styles’ },<br>    { name: ‘colors’ },<br>    { name: ‘about’ }<br>];</p>\n<h3 id=\"一个一个定义\"><a href=\"#一个一个定义\" class=\"headerlink\" title=\"一个一个定义\"></a>一个一个定义</h3><p>config.toolbar = [<br>    { name: ‘document’, items: [ ‘Source’, ‘-‘, ‘NewPage’, ‘Preview’, ‘-‘, ‘Templates’ ] },<br>    { name: ‘clipboard’, items: [ ‘Cut’, ‘Copy’, ‘Paste’, ‘PasteText’, ‘PasteFromWord’, ‘-‘, ‘Undo’, ‘Redo’ ] },<br>    ‘/‘,<br>    { name: ‘basicstyles’, items: [ ‘Bold’, ‘Italic’ ] }<br>];</p>\n<h2 id=\"插件机制\"><a href=\"#插件机制\" class=\"headerlink\" title=\"插件机制\"></a>插件机制</h2><p>假如我们开发一个插入当前时间戳的插件</p>\n<h3 id=\"插件目录结构\"><a href=\"#插件目录结构\" class=\"headerlink\" title=\"插件目录结构\"></a>插件目录结构</h3><ul>\n<li>ckeditor root/<ul>\n<li>plugins/<ul>\n<li>timestamp/<ul>\n<li>icons/<ul>\n<li>  timestamp.png</li>\n</ul>\n</li>\n<li>  plugin.js</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"插件代码\"><a href=\"#插件代码\" class=\"headerlink\" title=\"插件代码\"></a>插件代码</h3><p>CKEDITOR.plugins.add(‘timestamp’, {<br>    icons: ‘timestamp’,<br>    init: function(editor) {<br>        editor.addCommand(‘insertTimestamp’, {<br>            exec: function(editor) {<br>                var now = new Date();<br>                editor.insertHtml(‘The current date and time is: <em>‘ + now.toString() + ‘</em>‘);<br>            }<br>        });<br>        editor.ui.addButton(‘Timestamp’, {<br>            label: ‘Insert Timestamp’,<br>            command: ‘insertTimestamp’,<br>            toolbar: ‘insert’<br>        });<br>    }<br>});</p>\n<p>通过 <code>CKEDITOR.plugins.add</code>方法添加插件，第一个参数为插件名，后面为参数列表。 通过<code>editor.addCommand</code>方法添加一个 insertTimestamp 的命令 通过<code>editor.ui.addButton</code>方法添加一个按钮控件，并绑定其执行的 command 通过 <code>editor.insertHtml</code>方法往编辑内容区域追加内容</p>\n<h3 id=\"加载插件\"><a href=\"#加载插件\" class=\"headerlink\" title=\"加载插件\"></a>加载插件</h3><p>通过配置文件来开启插件</p>\n<p>config.extraPlugins = ‘timestamp’;</p>\n<p>如果这是一个会出现在 Toolbar 的插件，且 Toolbar 被定制过，则需要显性配置 toolbar让其显示</p>\n<p>config.toolbar = {<br>  {name: ‘insert’, [‘Timestamp’]}<br>}</p>\n<h2 id=\"挂件（Widget）\"><a href=\"#挂件（Widget）\" class=\"headerlink\" title=\"挂件（Widget）\"></a>挂件（Widget）</h2><p>挂件是由一组 html 元素组成的特殊富文本单元，类似于模板机制 <strong>与插件的区别</strong> 挂件有 template 字段，插件没有 <strong>挂件目录结构</strong> 与插件一致</p>\n<h3 id=\"挂件代码\"><a href=\"#挂件代码\" class=\"headerlink\" title=\"挂件代码\"></a>挂件代码</h3><p>CKEDITOR.plugins.add( ‘simplebox’, {</p>\n<p>  // 表明这是一个 widget<br>  requires: ‘widget’,</p>\n<pre><code>icons: &#39;simplebox&#39;,\n\ninit: function( editor ) &#123;\n    CKEDITOR.dialog.add( &#39;simplebox&#39;, this.path + &#39;dialogs/simplebox.js&#39; );\n\n    editor.widgets.add( &#39;simplebox&#39;, &#123;\n\n   // 鼠标 hover 在 toolbar 上出现的提示\n        button: &#39;Create a simple box&#39;,\n\n        // 挂件模板\n        template:\n            &#39;&lt;div class=&quot;simplebox&quot;&gt;&#39; +\n                &#39;&lt;h2 class=&quot;simplebox-title&quot;&gt;Title&lt;/h2&gt;&#39; +\n                &#39;&lt;div class=&quot;simplebox-content&quot;&gt;&lt;p&gt;Content...&lt;/p&gt;&lt;/div&gt;&#39; +\n            &#39;&lt;/div&gt;&#39;,\n\n        // 定义挂件中可编辑的部分\n        editables: &#123;\n            title: &#123;\n                selector: &#39;.simplebox-title&#39;,\n                allowedContent: &#39;br strong em&#39;\n            &#125;,\n            content: &#123;\n                selector: &#39;.simplebox-content&#39;,\n                allowedContent: &#39;p br ul ol li strong em&#39;\n            &#125;\n        &#125;,\n\n        // 挂件内允许出现的组合\n        allowedContent:\n            &#39;div(!simplebox,align-left,align-right,align-center)&#123;width&#125;;&#39; +\n            &#39;div(!simplebox-content); h2(!simplebox-title)&#39;,\n\n        // 挂件最小组合，如果这个 div 被删除，则自动清除该挂件\n        requiredContent: &#39;div(simplebox)&#39;,\n\n        dialog: &#39;simplebox&#39;,\n\n        upcast: function( element ) &#123;\n            return element.name \\== &#39;div&#39; &amp;&amp; element.hasClass( &#39;simplebox&#39; );\n        &#125;,\n\n        init: function() &#123;\n            var width \\= this.element.getStyle( &#39;width&#39; );\n            if ( width )\n                this.setData( &#39;width&#39;, width );\n            if ( this.element.hasClass( &#39;align-left&#39; ) )\n                this.setData( &#39;align&#39;, &#39;left&#39; );\n            if ( this.element.hasClass( &#39;align-right&#39; ) )\n                this.setData( &#39;align&#39;, &#39;right&#39; );\n            if ( this.element.hasClass( &#39;align-center&#39; ) )\n                this.setData( &#39;align&#39;, &#39;center&#39; );\n        &#125;,\n\n        data: function() &#123;\n\n            if ( this.data.width \\== &#39;&#39; )\n                this.element.removeStyle( &#39;width&#39; );\n            else\n                this.element.setStyle( &#39;width&#39;, this.data.width );\n\n            this.element.removeClass( &#39;align-left&#39; );\n            this.element.removeClass( &#39;align-right&#39; );\n            this.element.removeClass( &#39;align-center&#39; );\n            if ( this.data.align )\n                this.element.addClass( &#39;align-&#39; + this.data.align );\n        &#125;\n    &#125; );\n&#125;\n</code></pre>\n<p>} );</p>\n<h2 id=\"ACF\"><a href=\"#ACF\" class=\"headerlink\" title=\"ACF\"></a>ACF</h2><p>CKEditor 的高级内容过滤器，当用户在源码输入模式、<code>editor.setData</code>输入、直接粘贴 html 代码等输入时候，将不希望出现的内容给过滤掉。</p>\n<h3 id=\"自动模式（Automatic-Mode）\"><a href=\"#自动模式（Automatic-Mode）\" class=\"headerlink\" title=\"自动模式（Automatic Mode）\"></a>自动模式（Automatic Mode）</h3><p>当 <code>config.allowedContent</code> 没有设置的时候，ACF 就会进入自动模式。 自动模式通过<code>config.removePlugins</code> 、<code>config.removeButtons</code> 和 <code>config.format_tag</code> 来做过滤微调</p>\n<p>config.removePlugins = ‘image,table,tabletools,horizontalrule’;<br>config.removeButtons = ‘Anchor,Underline,Strike,Subscript,Superscript’;<br>config.format_tags = ‘p;h1;h2;pre’;</p>\n<h3 id=\"自定义模式（Custom-Mode）\"><a href=\"#自定义模式（Custom-Mode）\" class=\"headerlink\" title=\"自定义模式（Custom Mode）\"></a>自定义模式（Custom Mode）</h3><p>通过 <code>config.allowedContent</code> 来进入自定义模式</p>\n<p>config.allowedContent =<br>    ‘h1 h2 h3 p blockquote strong em;’ +<br>    ‘a[!href];’ +<br>    ‘img(left,right)[!src,alt,width,height];’;</p>\n<h3 id=\"ACF语法\"><a href=\"#ACF语法\" class=\"headerlink\" title=\"ACF语法\"></a>ACF语法</h3><blockquote>\n<p><em>elements [attributes]{styles}(classes)</em></p>\n</blockquote>\n<p>例如我们需要保留<span class=”mod\\_fillblank”>这样的富文本内容，规则为span(mod_fillblank)，其 attributes 对 class 无效。</p>\n<h2 id=\"实战建议\"><a href=\"#实战建议\" class=\"headerlink\" title=\"实战建议\"></a>实战建议</h2><ul>\n<li>  能用 CKEditor 社区插件解决的问题，用插件解决</li>\n<li>  插件解决不了的问题，业务自己写plugin 或者 widget 解决</li>\n<li>  业务自己写的部分，尽量不要用 CKEditor 自带的 <code>CKEDITOR.dialog</code> ，他们的实现是用 JS 去码DOM 结构，太复杂了。随便一个 Dialog 控件都能用得很舒服</li>\n<li>  不要用CKEditor 的 jQuery Adapter，他家的 Adapter 对于同一个 DOM 的进行实例化、销毁等操作有 bug，时不时给你冒一个错误。自己包裹一个 Adapter 则肯定没有 bug</li>\n<li>  工程化的时候，构建工具做依赖分析的时候，记得排除掉 CKEditor 目录，否则他家一堆的插件，会严重拖慢依赖分析那步</li>\n</ul>\n","categories":["JavaScript"],"tags":["ckeditor","config.allowedContent","网页编辑器"]},{"title":"适配深色模式方案","url":"/2021/04/19/color-scheme/","content":"<h2 id=\"1-声明-color-scheme\"><a href=\"#1-声明-color-scheme\" class=\"headerlink\" title=\"1.声明 color-scheme\"></a>1.声明 color-scheme</h2><p>有两种方式。</p>\n<h3 id=\"1-1-meta\"><a href=\"#1-1-meta\" class=\"headerlink\" title=\"1.1 meta\"></a>1.1 meta</h3><p>在head中声明 meta，声明当前页面支持 light 和 dark 两种模式，系统切换到深色模式时，浏览器默认样式也会切换到深色；</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">&quot;color-scheme&quot;</span> content=<span class=\"string\">&quot;light dark&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-CSS\"><a href=\"#1-2-CSS\" class=\"headerlink\" title=\"1.2 CSS\"></a>1.2 CSS</h3><p>下面的 css 同样可以实现上面 meta 声明的效果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">:root &#123;</span><br><span class=\"line\">    color-scheme: light dark;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：此声明并非为页面做自动适配，只影响浏览器默认样式</p>\n<p>更多信息可查阅：<br>    W3C文档：<a href=\"https://drafts.csswg.org/css-color-adjust-1/\"> CSS Color Adjustment Module Level 1</a><br>    微信开放文档：<a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/DarkMode.html\">DarkMode 适配指南</a></p>\n<h2 id=\"2-通过-CSS-媒体查询\"><a href=\"#2-通过-CSS-媒体查询\" class=\"headerlink\" title=\"2.通过 CSS 媒体查询\"></a>2.通过 CSS 媒体查询</h2><p>prefers-color-scheme CSS 媒体特性用于检测用户是否有将系统的主题色设置为亮色或者暗色。</p>\n<p>no-preference<br>表示系统未得知用户在这方面的选项。在布尔值上下文中，其执行结果为 false。</p>\n<p>light<br>表示用户已告知系统他们选择使用浅色主题的界面。</p>\n<p>dark<br>表示用户已告知系统他们选择使用暗色主题的界面。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">:root &#123;</span><br><span class=\"line\">    color-scheme: light dark;</span><br><span class=\"line\">    background: white;</span><br><span class=\"line\">    color: black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@media (prefers-color-scheme: dark) &#123;</span><br><span class=\"line\">    :root &#123;</span><br><span class=\"line\">        background: black;</span><br><span class=\"line\">        color: white;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>颜色较多的情况，建议使用CSS变量对颜色值进行管理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">:root &#123;</span><br><span class=\"line\">    color-scheme: light dark;</span><br><span class=\"line\">    --nav-bg-color: <span class=\"comment\">#F7F7F7;</span></span><br><span class=\"line\">    --content-bg-color: <span class=\"comment\">#FFFFFF;</span></span><br><span class=\"line\">    --font-color: rgba(0,0,0,.9);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@media (prefers-color-scheme: dark) &#123;</span><br><span class=\"line\">    :root &#123;</span><br><span class=\"line\">        --nav-bg-color: <span class=\"comment\">#2F2F2F;</span></span><br><span class=\"line\">        --content-bg-color: <span class=\"comment\">#2C2C2C;</span></span><br><span class=\"line\">        --font-color: rgba(255, 255, 255, .8);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">:root &#123;</span><br><span class=\"line\">    color: var(--font-color)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.header &#123;</span><br><span class=\"line\">    background-color: var(--nav-bg-color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.content &#123;</span><br><span class=\"line\">    background-color: var(--content-bg-color);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-图片适配\"><a href=\"#3-图片适配\" class=\"headerlink\" title=\"3.图片适配\"></a>3.图片适配</h2><p>利用picture+source标签，设置不同模式下的图片 url。</p>\n<p>HTML <picture>元素通过包含零或多个 <source> 元素和一个 <img> 元素来为不同的显示/设备场景提供图像版本。浏览器会选择最匹配的子 <source> 元素，如果没有匹配的，就选择 <img> 元素的 src 属性中的URL。然后，所选图像呈现在<img>元素占据的空间中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;picture&gt;</span><br><span class=\"line\">    &lt;!-- 深色模式下的图片 --&gt;</span><br><span class=\"line\">    &lt;<span class=\"built_in\">source</span> srcset=<span class=\"string\">&quot;dark.jpg&quot;</span> media=<span class=\"string\">&quot;(prefers-color-scheme: dark)&quot;</span> /&gt;</span><br><span class=\"line\">    &lt;!-- 默认模式下的图片 --&gt;</span><br><span class=\"line\">    &lt;img src=<span class=\"string\">&quot;light.jpg&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/picture&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-JavaScript中判断当前模式-amp-监听模式变化\"><a href=\"#4-JavaScript中判断当前模式-amp-监听模式变化\" class=\"headerlink\" title=\"4. JavaScript中判断当前模式&amp;监听模式变化\"></a>4. JavaScript中判断当前模式&amp;监听模式变化</h2><h3 id=\"4-1-matchMedia\"><a href=\"#4-1-matchMedia\" class=\"headerlink\" title=\"4.1 matchMedia\"></a>4.1 matchMedia</h3><p>Window 的matchMedia() 方法返回一个新的MediaQueryList 对象，表示指定的媒体查询 (en-US)字符串解析后的结果。返回的MediaQueryList 可被用于判定Document是否匹配媒体查询，或者监控一个document 来判定它匹配了或者停止匹配了此媒体查询。</p>\n<h3 id=\"4-2-addListener\"><a href=\"#4-2-addListener\" class=\"headerlink\" title=\"4.2 addListener()\"></a>4.2 addListener()</h3><p>MediaQueryList接口的addListener()方法向MediaQueryListener添加一个侦听器，该侦听器将运行自定义回调函数以响应媒体查询状态的更改。</p>\n<p>具体用法参考以下例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">const mediaQuery = window.matchMedia(<span class=\"string\">&#x27;(prefers-color-scheme: dark)&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">darkModeHandler</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mediaQuery.matches) &#123;</span><br><span class=\"line\">        console.log(<span class=\"string\">&#x27;现在是深色模式&#x27;</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        console.log(<span class=\"string\">&#x27;现在是浅色模式&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断当前模式</span><br><span class=\"line\">darkModeHandler()</span><br><span class=\"line\">// 监听模式变化</span><br><span class=\"line\">mediaQuery.addListener(darkModeHandler)</span><br></pre></td></tr></table></figure>","tags":["适配深色"]},{"title":"CSS Grid VS Flexbox：实用比较","url":"/2019/04/25/css-grid-vs-flexbox%EF%BC%9A%E5%AE%9E%E7%94%A8%E6%AF%94%E8%BE%83/","content":"<p>不久以前，所有 HTML 页面的布局还都是通过 tables、floats 以及其他的 CSS 属性来完成的。面对复杂页面的布局，却没有很好的办法。 然而 <a href=\"http://www.w3cbest.com/490.html\">Flexbox</a> 的出现，便轻松的解决了复杂的 Web 布局。它是一种专注于创建稳定的响应式页面的布局模式，并可以轻松地正确对齐元素及其内容。如今已是大多数 Web 开发人员首选的 CSS 布局方式。 现在，又出现了一个构建 HTML 最佳布局体系的新竞争者。（霸主地位正在争夺中…）它就是强大的 CSS <a href=\"http://www.w3cbest.com/494.html\">Grid 布局</a>。直到本月月底，它也将在 Firefox 52 和 Chrome 57 上得到原生支持，相信不久也会得到其他浏览器兼容性的支持。</p>\n<h2 id=\"基本布局测试\"><a href=\"#基本布局测试\" class=\"headerlink\" title=\"基本布局测试\"></a>基本布局测试</h2><p>要了解这两个体系构建布局的方式，我们将通过相同的 HTML 页面，利用不同的布局方式 （即 Flexbox 与 CSS Grid）为大家区分。同时，你也可以通过文章顶部附近的下载按钮，下载演示项目进行对比，或者通过在线演示来察看它们： <a href=\"https://demo.tutorialzine.com/2017/03/css-grid-vs-flexbox/\"><img src=\"http://file.w3cbest.com/file/images/html-layout.png\"></a> 该页面的设计相对比较简单 – 它是由一个居中的容器组成，在其内部则包含了标头、主要内容部分、侧边栏和页脚。接下来，我们要完成同时保持 CSS 和 HTML 尽可能整洁的挑战事项：</p>\n<ol>\n<li> 在布局中将四个主要的部分进行定位。</li>\n<li> 将页面变为响应式页面；</li>\n<li> 对齐标头：导航朝左对齐，按钮向右对齐。</li>\n</ol>\n<p>如你所见，为了便于比较，我们将所有事项从简处理。那么，让我们从第一个挑战事项开始吧！</p>\n<h2 id=\"挑战-1：定位页面部分\"><a href=\"#挑战-1：定位页面部分\" class=\"headerlink\" title=\"挑战 1：定位页面部分\"></a>挑战 1：定位页面部分</h2><p><strong>Flexbox 解决方案</strong> 我们将从 Flexbox 解决方案开始。我们将为容器添加 display: flex 来指定为 Flex 布局，并指定子元素的垂直方向。</p>\n<p>.container {<br>    display: flex;<br>    flex-direction: column;<br>}</p>\n<p>现在我们需要使主要内容部分和侧边栏彼此相邻。由于 Flex 容器通常是单向的，所以我们需要添加一个包装器元素。</p>\n<header></header>\n<div class=\"main-and-sidebar-wrapper\">\n    <section class=\"main\"></section>\n    <aside class=\"sidebar\"></aside>\n</div>\n<footer></footer>\n\n<p>然后，我们给包装器在反向添加 display: flex 和 flex-direction 属性。</p>\n<p>.main-and-sidebar-wrapper {<br>    display: flex;<br>    flex-direction: row;<br>}</p>\n<p>最后一步，我们将设置主要内容部分与侧边栏的大小。通过 Flex 实现后，主要内容部分会比侧边栏大三倍。</p>\n<p>.main {<br>    flex: 3;<br>    margin-right: 60px;<br>}<br>.sidebar {<br>    flex: 1;<br>}</p>\n<p>如你所见，Flex 将其很好的实现了出来，但是仍需要相当多的 CSS 属性，并借助了额外的 HTML 元素。那么，让我们看看 CSS Grid 如何实现的。 <strong>CSS Grid 解决方案</strong> 针对本项目，有几种不同的 CSS Grid 解决方法，但是我们将使用网格模板区域语法来实现，因为它似乎最适合我们要完成的工作。 首先，我们将定义四个网格区域，所有的页面各一个：</p>\n<header></header>\n<!-- Notice there isn't a wrapper this time -->\n<section class=\"main\"></section>\n<aside class=\"sidebar\"></aside>\n<footer></footer>\n\n<p>header {<br>    grid-area: header;<br>}<br>.main {<br>    grid-area: main;<br>}<br>.sidebar {<br>    grid-area: sidebar;<br>}<br>footer {<br>    grid-area: footer;<br>}</p>\n<p>然后，我们会设置网格并分配每个区域的位置。初次接触 Grid 布局的朋友，可能感觉以下的代码会有些复杂，但当你了解了网格体系，就很容易掌握了。</p>\n<p>.container {<br>    display: grid;</p>\n<pre><code>/\\* Define the size and number of columns in our grid. \n</code></pre>\n<p>The fr unit works similar to flex:<br>fr columns will share the free space in the row in proportion to their value.<br>We will have 2 columns - the first will be 3x the size of the second. */<br>    grid-template-columns: 3fr 1fr;</p>\n<pre><code>/\\* Assign the grid areas we did earlier to specific places on the grid. \n</code></pre>\n<p>First row is all header.<br>Second row is shared between main and sidebar.<br>Last row is all footer. */<br>    grid-template-areas:<br>        “header header”<br>        “main sidebar”<br>        “footer footer”;</p>\n<pre><code>/\\* The gutters between each grid cell will be 60 pixels. \\*/\ngrid-gap: 60px;\n</code></pre>\n<p>}</p>\n<p>就是这样！ 我们现在将遵循上述结构进行布局，甚至不需要我们处理任何的 margins 或 paddings 。</p>\n<h2 id=\"挑战-2：将页面变为响应式页面\"><a href=\"#挑战-2：将页面变为响应式页面\" class=\"headerlink\" title=\"挑战 2：将页面变为响应式页面\"></a>挑战 2：将页面变为响应式页面</h2><p><strong>Flexbox 解决方案</strong> 这一步的执行与上一步密切相关。对于 Flexbox 解决方案，我们将更改包装器的 flex-direction 属性，并调整一些 margins。</p>\n<p>@media (max-width: 600px) {<br>    .main-and-sidebar-wrapper {<br>        flex-direction: column;<br>    }<br>    .main {<br>        margin-right: 0;<br>        margin-bottom: 60px;<br>    }<br>}</p>\n<p>由于网页比较简单，所以我们在媒体查询上不需要太多的重写。但是，如果遇见更为复杂的布局，那么将会重新的定义相当多的内容。 <strong>CSS Grid 解决方案</strong> 由于我们已经定义了网格区域，所以我们只需要在媒体查询中重新排序它们。 我们可以使用相同的列设置。</p>\n<p>@media (max-width: 600px) {<br>    .container {<br>        /* Realign the grid areas for a mobile layout. */<br>        grid-template-areas:<br>            “header header”<br>            “main main”<br>            “sidebar sidebar”<br>            “footer footer”;<br>    }<br>}</p>\n<p>或者，我们可以从头开始重新定义整个布局。</p>\n<p>@media (max-width: 600px) {<br>    .container {<br>        /* Redefine the grid into a single column layout. */<br>        grid-template-columns: 1fr;<br>        grid-template-areas:<br>            “header”<br>            “main”<br>            “sidebar”<br>            “footer”;<br>    }<br>}</p>\n<h2 id=\"挑战-3：对齐标头组件\"><a href=\"#挑战-3：对齐标头组件\" class=\"headerlink\" title=\"挑战 3：对齐标头组件\"></a>挑战 3：对齐标头组件</h2><p><strong>Flexbox 解决方案</strong> 我们的标头包含了导航和一个按钮的相关链接。我们希望导航朝左对齐，按钮向右对齐。而导航中的链接务必正确对齐，且彼此相邻。</p>\n<header>\n    <nav>\n        <li><a href=\"#\">\n                <h1>Logo</h1>\n            </a></li>\n        <li><a href=\"#\">Link</a></li>\n        <li><a href=\"#\">Link</a></li>\n    </nav>\n    <button>Button</button>\n</header>\n\n<p>我们曾在一篇较早的文章中使用 Flexbox 做了类似的布局：响应式标头最简单的制作方法。这个技术很简单：</p>\n<p>header {<br>    display: flex;<br>    justify-content: space-between;<br>}</p>\n<p>现在导航列表和按钮已正确对齐。下来我们将使 内的 items 进行水平移动。这里最简单的方法就是使用 display：inline-block 属性，但目前我们需要使用一个 Flexbox 解决方案：</p>\n<p>header nav {<br>    display: flex;<br>    align-items: baseline;<br>}</p>\n<p>仅两行代码就搞定了！ 还不错吧。接下来让我们看看如何使用 CSS Grid 解决它。 <strong>CSS Grid 解决方案</strong> 为了拆分导航和按钮，我们要为标头定义 display: grid 属性，并设置一个 2 列的网格。同时，我们还需要两行额外的 CSS 代码，将它们定位在相应的边界上。</p>\n<p>header {<br>    display: grid;<br>    grid-template-columns: 1fr 1fr;<br>}<br>header nav {<br>    justify-self: start;<br>}<br>header button {<br>    justify-self: end;<br>}</p>\n<p>至于导航中的内链 – 这是我们使用 CSS grid 最好的布局展示： <img src=\"http://file.w3cbest.com/file/images/css-grid-header.png\"> 虽然链接为内链形式，但它们不能正确的对齐。由于 CSS grid 不具备基线选项（不像 Flexbox 具备的 align-items 属性），所以我们只能再定义一个子网格。</p>\n<p>header nav {<br>    display: grid;<br>    grid-template-columns: auto 1fr 1fr;<br>    align-items: end;<br>}</p>\n<p>CSS grid 在此步骤中，存在一些明显的布局上的缺陷。但你也不必过于惊讶。因为它的目标是对齐容器，而不是内部的内容。所以，用它来处理收尾工作，或许不是很好的选择哦。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>如果你已经浏览完整篇文章，那么结论不会让你感到意外。事实上，并不存在最好的布局方式。Flexbox 和 CSS grid 是两种不同的布局形式，我们应该根据具体的场景将它们搭配使用，而不是相互替代。 对于那些跳过文章只想看结论的朋友（不用担心，我们也这样做），这里是通过实例比较后的总结：</p>\n<ul>\n<li>  CSS Grid 适用于布局整体页面。它们使页面的布局变得非常容易，甚至可以处理一些不规则和非对称的设计。</li>\n<li>  Flexbox 非常适合对齐元素内的内容。你可以使用 Flexbox 来定位设计上一些较小的细节问题。</li>\n<li>  CSS Grid 适用于二维布局（行与列）。</li>\n<li>  Flexbox 适用于一维布局（行或列）。</li>\n<li>  同时学习它们，并配合使用。</li>\n</ul>\n<p>原文地址：<a href=\"https://tutorialzine.com/2017/03/css-grid-vs-flexbox\">https://tutorialzine.com</a></p>\n","categories":["HTML/CSS"],"tags":["css","flexbox","grid","Flexbox 布局","Grid 布局","tables 布局"]},{"title":"CSS 函数calc() 与 CSS 变量var()的混合使用","url":"/2019/04/03/css-%E5%87%BD%E6%95%B0calc-%E4%B8%8E-css-%E5%8F%98%E9%87%8Fvar%E7%9A%84%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/","content":"<h2 id=\"CSS-变量混合使用加法减法\"><a href=\"#CSS-变量混合使用加法减法\" class=\"headerlink\" title=\"CSS 变量混合使用加法减法\"></a><a href=\"http://www.w3cbest.com/592.html\">CSS 变量</a>混合使用加法减法</h2><p>当设置一个变量为200px时后期不满足需求需要增加10px或20px时而需要扩展； 例如我们需要给一个div的宽度设置为210px，但我们的变量是200px，这时我们就可以用变量的值加上10px就行了，如下 （本篇所使用的宽度属性是<a href=\"http://www.w3cbest.com/469.html\">CSS逻辑属性</a>）</p>\n<p>:root{<br>    –base-size-200: 200px;<br>}</p>\n<p>div{<br>    inline-size: calc(var(–base-size-200) + 10px);<br>}</p>\n<p>或者我们的变量里面已经有10px这个变量了，那么可以这样做</p>\n<p>:root{<br>    –base-size-200: 200px;<br>    –base-size-10: 10px;<br>}</p>\n<p>div{<br>    inline-size: calc(var(–base-size-200) + var(–base-size-10));<br>}</p>\n<p>如果的话减法同上面一样，就是把加号换做减号就行了</p>\n<p>div{<br>    inline-size: calc(var(–base-size-200) - var(–base-size-10));<br>}</p>\n<h2 id=\"CSS-变量混合使用乘法除法\"><a href=\"#CSS-变量混合使用乘法除法\" class=\"headerlink\" title=\"CSS 变量混合使用乘法除法\"></a>CSS 变量混合使用乘法除法</h2><p>乘法就是把你现在大小乘以你想要的值就是你的尺寸，我们还以上面的为例，将200px设为2倍或3倍来运算</p>\n<p>:root{<br>    –base-size-200: 200px;<br>}</p>\n<p>div{<br>    inline-size: calc(var(–base-size-200) * 2);<br>}</p>\n<p>除法同上面一样将乘号换为除号</p>\n<p>div{<br>    inline-size: calc(var(–base-size-200) / 2);<br>}</p>\n<h2 id=\"CSS-变量加法与乘法混合使用\"><a href=\"#CSS-变量加法与乘法混合使用\" class=\"headerlink\" title=\"CSS 变量加法与乘法混合使用\"></a>CSS 变量加法与乘法混合使用</h2><p>其实这个也很简但，就是将上面的两种方法加起来运算就可以了</p>\n<p>:root{<br>    –base-size-200: 200px;<br>    –base-size-10: 10px;<br>}<br>div{<br>    inline-size: calc(var(–base-size-200) * 2 + var(–base-size-10));<br>}</p>\n<p>好了全是废话，篇幅较小不喜勿喷</p>\n","categories":["HTML/CSS"],"tags":["css3","css3教程","css var()","calc()","CSS Variables","css函数"]},{"title":"CSS3 径向渐变（Radial Gradients）","url":"/2019/07/19/css3-%E5%BE%84%E5%90%91%E6%B8%90%E5%8F%98%EF%BC%88radial-gradients%EF%BC%89/","content":"<p>径向渐变由它的中心定义。 为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。 <strong>语法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: radial-gradient(center, shape size, start-color, ..., last-color);</span><br></pre></td></tr></table></figure>\n\n\n<p>径向渐变 - 颜色结点均匀分布</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: radial-gradient(red, green, blue); &#x2F;* 标准的语法 *&#x2F;</span><br></pre></td></tr></table></figure>\n\n\n<p>径向渐变 - 颜色结点不均匀分布</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: radial-gradient(red 5%, green 15%, blue 60%); &#x2F;* 标准的语法 *&#x2F;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"设置形状\"><a href=\"#设置形状\" class=\"headerlink\" title=\"设置形状\"></a>设置形状</h2><p>shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: radial-gradient(circle, red, yellow, green); &#x2F;* 标准的语法 *&#x2F;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"不同尺寸大小关键字的使用\"><a href=\"#不同尺寸大小关键字的使用\" class=\"headerlink\" title=\"不同尺寸大小关键字的使用\"></a>不同尺寸大小关键字的使用</h3><p>size 参数定义了渐变的大小。它可以是以下四个值：</p>\n<ul>\n<li>  closest-side</li>\n<li>  farthest-side</li>\n<li>  closest-corner</li>\n<li>  farthest-corner</li>\n</ul>\n<p>带有不同尺寸大小关键字的径向渐变</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: radial-gradient(60% 55%, closest-side,blue,green,yellow,black);</span><br><span class=\"line\"></span><br><span class=\"line\">background: radial-gradient(60% 55%, farthest-side,blue,green,yellow,black);</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"重复的径向渐变\"><a href=\"#重复的径向渐变\" class=\"headerlink\" title=\"重复的径向渐变\"></a>重复的径向渐变</h2><p>repeating-radial-gradient() 函数用于重复径向渐变</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: repeating-radial-gradient(red, yellow 10%, green 15%);</span><br></pre></td></tr></table></figure>","categories":["HTML/CSS"],"tags":["css3教程","css3渐变","radial-gradient"]},{"title":"CSS3线性渐变（Linear Gradients）","url":"/2019/07/18/css3-%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98%EF%BC%88linear-gradients%EF%BC%89/","content":"<p>CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。 以前，你必须使用图像来实现这些效果。但是，通过使用 CSS3 渐变（gradients），你可以减少下载的时间和宽带的使用。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。 CSS3 定义了两种类型的渐变（gradients）：</p>\n<ul>\n<li>  线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向</li>\n<li>  径向渐变（Radial Gradients）- 由它们的中心定义</li>\n</ul>\n<h2 id=\"CSS3-线性渐变\"><a href=\"#CSS3-线性渐变\" class=\"headerlink\" title=\"CSS3 线性渐变\"></a>CSS3 线性渐变</h2><p>为了创建一个线性渐变，你必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。 <strong>语法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: linear-gradient(direction, color-stop1, color-stop2, ...);</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>线性渐变 - 从上到下（默认情况下）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: linear-gradient(red, blue); &#x2F;* 标准的语法 *&#x2F;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>线性渐变 - 从左到右</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: linear-gradient(to right, red , blue); &#x2F;* 标准的语法 *&#x2F;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>线性渐变 - 对角</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: linear-gradient(to bottom right, red , blue); &#x2F;* 标准的语法 *&#x2F;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"使用角度\"><a href=\"#使用角度\" class=\"headerlink\" title=\"使用角度\"></a>使用角度</h3><p>如果你想要在渐变的方向上做更多的控制，你可以定义一个角度，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）。 <strong>语法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: linear-gradient(angle, color-stop1, color-stop2);</span><br></pre></td></tr></table></figure>\n\n\n<p>角度是指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。 <a href=\"http://www.w3cbest.com/wp-content/uploads/2019/07/7B0CC41A-86DC-4E1B-8A69-A410E6764B91.jpg\">http://www.w3cbest.com/wp-content/uploads/2019/07/7B0CC41A-86DC-4E1B-8A69-A410E6764B91.jpg</a> 但是，请注意很多浏览器(Chrome,Safari,fiefox等)的使用了旧的标准，即 0deg 将创建一个从左到右的渐变，90deg 将创建一个从下到上的渐变。换算公式 90 - x = y 其中 x 为标准角度，y为非标准角度。 <strong>带有指定的角度的线性渐变</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: linear-gradient(180deg, red, blue); &#x2F;* 标准的语法 *&#x2F;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>使用多个颜色结点</strong> 带有多个颜色结点的从上到下的线性渐变</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: linear-gradient(red, green, blue); &#x2F;* 标准的语法 *&#x2F;</span><br></pre></td></tr></table></figure>\n\n\n<p>带有多个颜色结点的从左到右的线性渐变</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: linear-gradient(to right, red,orange,yellow,green,blue,indigo,violet);</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"使用透明度（transparent）\"><a href=\"#使用透明度（transparent）\" class=\"headerlink\" title=\"使用透明度（transparent）\"></a>使用透明度（transparent）</h2><p>CSS3 渐变也支持透明度（transparent），可用于创建减弱变淡的效果。 为了添加透明度，我们使用 rgba() 函数来定义颜色结点。rgba() 函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); &#x2F;* 标准的语法 *&#x2F;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"重复的线性渐变\"><a href=\"#重复的线性渐变\" class=\"headerlink\" title=\"重复的线性渐变\"></a>重复的线性渐变</h2><p>repeating-linear-gradient() 函数用于重复线性渐变：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">background: repeating-linear-gradient(red, yellow 10%, green 20%);</span><br></pre></td></tr></table></figure>\n","categories":["HTML/CSS"],"tags":["css3渐变","gradients","linear-gradient"]},{"title":"CSS3中的 Scroll Snap：控制滚动动作（类似滚动图片）","url":"/2018/09/28/css3%E4%B8%AD%E7%9A%84-scroll-snap%EF%BC%9A%E6%8E%A7%E5%88%B6%E6%BB%9A%E5%8A%A8%E5%8A%A8%E4%BD%9C%EF%BC%88%E7%B1%BB%E4%BC%BC%E6%BB%9A%E5%8A%A8%E5%9B%BE%E7%89%87%EF%BC%89/","content":"<p>随着Web平台的发展，它也获得了类似原生应用的特点。其中一个功能是<a href=\"https://drafts.csswg.org/css-scroll-snap-1/\">CSS Scroll Snap Module</a>。Scroll snap允许开发人员定义界面在滚动操作期间应该移动的距离。您可以使用它来构建幻灯片放映或分页界面 - 目前需要JavaScript和DOM操作才能完成。 Scroll snap作为一项功能经历了很多变化。早期的2013版规范 - 当时称为Scroll Snap Points–定义了一种基于坐标和像素的方法来指定滚动距离。此版本的规范是在Microsoft Edge，Internet Explorer 11和Firefox中实现的。 Chrome 69+和Safari 11+实现了规范的最新版本，该版本使用了盒子对齐模型。这就是我们将在本节中关注的内容。 警告： 当前浮动在Web上的许多滚动快照教程都基于早期的CSS Scroll Snap Points规范。标题中“points”一词的出现是教程可能依赖于旧规范的一个标志。然而，更可靠的指标是存在scroll-snap-points-x或scroll-snap-points-y属性。 由于滚动捕捉非常适合幻灯片放映布局，这就是我们要构建的内容。这是我们的标记。</p>\n<div class=\"slideshow\">\n<img src=\"avocado-and-bacon-salad.jpg\">\n<img src=\"salad-eggs-and-scallops.jpg\">\n<img src=\"seafood-and-noodles.jpg\">\n<img src=\"grilled-salmon-and-side-salad.jpg\">\n<img src=\"avocado-toast-with-egg.jpg\">\n</div>\n\n<p>这就是我们所需要的一切。我们不需要具有外部包裹元件和内部滑动容器。我们也不需要任何JavaScript。 现在我们的CSS：</p>\n<p>* {<br>box-sizing: border-box;<br>}</p>\n<p>html, body {<br>padding: 0;<br>margin: 0;<br>}</p>\n<p>.slideshow {<br>scroll-snap-type: x mandatory; /* Indicates scroll axis and behavior */<br>overflow-x: auto; /* Should be either `scroll` or `auto` */<br>display: flex;<br>height: 100vh;<br>}</p>\n<p>.slideshow img {<br>width: 100vw;<br>height: 100vh;<br>scroll-snap-align: center;<br>}</p>\n<p>添加scroll-snap-type以.slideshow创建滚动容器。此属性的值x mandatory描述了我们要滚动的方向以及滚动快照严格性。在这种情况下，该mandatory值告诉浏览器，当没有活动的滚动操作时，它必须捕捉到捕捉位置。使用display: flex只是确保我们的所有图像水平堆叠。 现在我们需要的另一个属性是scroll-snap-align。此属性指示如何在滚动容器的捕捉端口内对齐每个图像的滚动捕捉区域。它接受三个值：start，end，和center。在这种情况下，我们使用了center这意味着每个图像将在视口中居中，如下所示。 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/ScrollSnap.png\"></p>\n","categories":["HTML/CSS","资源"],"tags":["css","css3","scroll-snap-align","scroll-snap-type"]},{"title":"CSS3条纹背景","url":"/2018/06/02/css3%E6%9D%A1%E7%BA%B9%E8%83%8C%E6%99%AF/","content":"<p>不论是在网页设计中，还是在其他传统媒介中（比如杂志和墙纸等），各种尺寸、颜色、角度的条纹图案在视觉设计中无处不在。要想在网页中实现条纹图案，其过程还远远不够理想。通常，我们的方法是创建一个单独的位图文件，然后每次需要做些调整时，都用图像编辑器来修改它。可能有人试过用 SVG 来取代位图，但这样还是会有一个独立的文件，而且它的语法也远远不够友好。如果可以直接在 CSS 中创建条纹图案，那该有多棒啊！你可能会惊讶地发现，我们居然真的可以。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>假设我们有一条基本的垂直线性渐变，颜色从 #fb3 过渡到 #58a（参见图 1）：</p>\n<p>这是一个示例 (图1)</p>\n<p>渐变现在出现在总高的 60% 区域，剩下的部分显示为实色；色标的位置用虚线标示出来了  </p>\n<p>background: linear-gradient(#fb3, #58a);</p>\n<p>现在，让我们试着把这两个色标拉近一点（参见图 2）：</p>\n<p>这是一个示例 (图2)</p>\n<p> </p>\n<p>background: linear-gradient(#fb3 20%, #58a 80%);</p>\n<p>现在容器顶部的 20% 区域被填充为 #fb3 实色，而底部 20% 区域被填充为 #58a 实色。真正的渐变只出现在容器 60% 的高度区域。如果我们把两个色标继续拉近（分别改为 40% 和 60%，参见图 3），那真正的渐变区域就变得更窄了。你是不是开始好奇，如果我们把两个色标重合在一起，会发生什么？</p>\n<p>这是一个示例 (图3)</p>\n<p> </p>\n<p>background: linear-gradient(#fb3 50%, #58a 50%);</p>\n<p>“如果多个色标具有相同的位置，它们会产生一个无限小的过渡区域，过渡的起止色分别是第一个和最后一个指定值。从效果上看，颜色会在那个位置突然变化，而不是一个平滑的渐变过程。” ——CSS 图像（第三版）（<a href=\"http://w3.org/TR/css3-images%EF%BC%89\">http://w3.org/TR/css3-images）</a> 你在图 3 中可以看到，已经没有任何渐变效果了，只有两块实色，各占据了 background-image 一半的面积。本质上，我们已经创建了两条巨大的水平条纹。 因为渐变是一种由代码生成的图像，我们能像对待其他任何背景图像那样对待它，而且还可以通过 background-size 来调整其尺寸：</p>\n<p>这是一个示例 (图4)</p>\n<p> </p>\n<p>background: linear-gradient(#fb3 50%, #58a 50%);<br>background-size: 100% 30px;</p>\n<p>在图 24 中可以看到，我们把这两条条纹的高度都缩小到了 15px。由于背景在默认情况下是重复平铺的，整个容器其实已经被填满了水平条纹（参见图 4）。 我们还可以用相同的方法来创建不等宽的条纹，只需调整色标的位置值即可（参见图 5）：</p>\n<p>这是一个示例 (图5)</p>\n<p> </p>\n<p>background: linear-gradient(#fb3 30%, #58a 30%);<br>background-size: 100% 30px;</p>\n<p>为了避免每次改动条纹宽度时都要修改两个数字，我们可以再次从规范那里找到捷径。 “如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值。” ——CSS 图像（第三版）（<a href=\"http://w3.org/TR/css3-images%EF%BC%89\">http://w3.org/TR/css3-images）</a> 这意味着，如果我们把第二个色标的位置值设置为 0，那它的位置就总是会被浏览器调整为前一个色标的位置值，这个结果正是我们想要的。 因此，下面的代码会产生跟图 5 完全一样的条纹背景，但代码会更加DRY：  </p>\n<p>background: linear-gradient(#fb3 30%, #58a 0);<br>background-size: 100% 30px;</p>\n<p>如果要创建超过两种颜色的条纹，也是很容易的。举例来说，下面的代码可以生成三种颜色的水平条纹（参见图 6）：</p>\n<p>这是一个示例 (图6)</p>\n<p> </p>\n<p>background: linear-gradient(#fb3 33.3%, #58a 0, #58a 66.6%, yellowgreen 0);<br>background-size: 100% 45px;</p>\n<p>垂直条纹 水平条纹是最容易用代码写出来的，但我们在网页上看到的条纹图案并不都是水平的。有些条纹是垂直的（参见图 7），而且某些形态的斜条纹或许更受欢迎，或者看起来更加有趣。幸运的是，CSS 渐变同样也能帮助我们创建出这些效果，只是难度稍有不同。 垂直条纹的代码跟水平条纹几乎是一样的，差别主要在于：我们需要在开头加上一个额外的参数来指定渐变的方向。在水平条纹的代码中，我们其实也可以加上这个参数，只不过它的默认值 to bottom 本来就跟我们的意图一致，于是就省略了。最后，我们还需要把 background-size 的值颠倒一下，原因应该不用多说了吧：</p>\n<p>这是一个示例 (图7)</p>\n<p> </p>\n<p>background: linear-gradient(to right, #fb3 50%, #58a 0);<br>background-size: 30px 100%;</p>\n<p>斜向条纹 在完成了水平和垂直条纹之后，我们可能会顺着往下想：如果我们再次改变 background-size的值和渐变的方向，是不是就可以得到斜向（比如45°）的条纹图案呢？比如这样（结果如图 8 所示）：</p>\n<p>这是一个示例 (图8)</p>\n<p> </p>\n<p>background: linear-gradient(45deg, #fb3 50%, #58a 0);<br>background-size: 30px 30px;</p>\n<p>可以发现，这个办法行不通。原因在于我们只是把每个“贴片”1①内部的渐变旋转了 45°，而不是把整个重复的背景都旋转了。试着回忆一下我们以前用位图来生成斜向条纹时是怎么做的吧，做法类似图 9。单个贴片包含了四条条纹，而不是两条，只有这样才有可能做到无缝拼接。它正是我们需要在 CSS 代码中重新实现的贴片，因此我们需要增加一些色标：</p>\n<p>这是一个示例 (图9)</p>\n<p>background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0);<br>background-size: 30px 30px;</p>\n<p>我们可以在图 9 中看到结果。如你所见，我们成功地创建了斜向条纹，但这些条纹看起来要比我们在前面制作的水平和垂直条纹细一些。为了理解这其中的道理，我们需要再次回忆起在学校里学过的勾股定理，用它来计算直角三角形的斜边长度。这个定理表示，当 a 和 b 是直角三角形的直角边时，则斜边的长度等于 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901153413.jpg\"> 。对于一个 45°的直角三角形来说，它的两条直角边是等长的，因此这个算式会变成<img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180902172701.jpg\"> =a<img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901153522.jpg\"> 。在我们的斜向条纹中，背景尺寸指定的长度值决定了直角三角形的斜边长度，但条纹的宽度实际上是直角三角形的高。在图 10 中可以看到图形化的解释。 这意味着，如果想让条纹的宽度变化为我们原本想要的 15px，就需要把 background-size 指定为 2x 15<img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901153522.jpg\"> ≈ 42.426 406 871 像素：</p>\n<p>这是一个示例 (图10)</p>\n<p>background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0);<br>background-size: 42.426406871px 42.426406871px;</p>\n<p>你可以在图 10 中看到最终效果。但是，除非有人拿枪顶着你的脑袋威胁你必须把斜向条纹的宽度设置为完全精确的 15 像素，我会强烈推荐你把这一长串数字取整，写成 42.4px，或者甚至是 42px。（当然，在上述情形之下，你还是会被干掉。因为 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901153522.jpg\"> 不是整数，我们最终得到的条纹宽度永远都只能是一个近似值——尽管它已经相当精确了。）</p>\n<h4 id=\"更好的斜向条纹\"><a href=\"#更好的斜向条纹\" class=\"headerlink\" title=\"更好的斜向条纹\"></a>更好的斜向条纹</h4><p>在前面的段落中展示的方法还不够灵活。假设我们想让条纹不是 45°而是 60°怎么办？或者是 30°？又或者是 3.141 592 653 5°？如果我们只是把渐变的角度改一下，那么结果看起来会相当糟糕。（比如在图 10 中，我们尝试实现 60°条纹，但以失败告终。） 幸运的是，我们还有更好的方法来创建斜向条纹。一个鲜为人知的真相是 linear-gradient() 和 radial-gradient() 还各有一个循环式的加强版：repeating-linear-gradient() 和 repeating-radial-gradient()。它们的工作方式跟前两者类似，只有一点不同：色标是无限循环重复的，直到填满整个背景。下面是一个重复渐变的例子（效果参见图 10）：</p>\n<p>这是一个示例 (图10)</p>\n<p>background: repeating-linear-gradient(45deg, #fb3, #58a 30px);</p>\n<h4 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h4><p>CSS 图像 <a href=\"http://w3.org/TR/css-images\">http://w3.org/TR/css-images</a> CSS 背景与边框 <a href=\"http://w3.org/TR/css-backgrounds\">http://w3.org/TR/css-backgrounds</a> CSS 图像（第四版） <a href=\"http://w3.org/TR/css4-images\">http://w3.org/TR/css4-images</a></p>\n","categories":["HTML/CSS"],"tags":["css","css3","css3渐变"]},{"title":"CSS中的变量:自定义属性","url":"/2019/02/12/css%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/","content":"<p>多年来，变量一直是最常用的CSS特性之一。变量可以更容易地管理颜色、字体、大小和动画值，并确保它们在代码库中的一致性。 花了数年的时间来研究语法的细节，并决定变量如何适应管理级联和继承的现有规则。现在它们以CSS“自定义属性”的形式提供给开发人员。 在本章中，我们将讨论CSS自定义属性的语法。我们来看看：</p>\n<ul>\n<li>  如何定义属性并为这些属性设置默认值</li>\n<li>  级联和继承的规则如何与自定义属性一起工作</li>\n<li>  如何在媒体查询中使用自定义属性</li>\n</ul>\n<p>最后，您应该很好地掌握了如何在项目中使用自定义属性。 注意:浏览器对自定义变量的支持是健壮的，存在于每个主流浏览器的最新版本中。然而，在较老但最近发布的浏览器版本中还没有支持，这些版本可能仍然被站点的受众广泛使用。微软15之前的Edge版本和9.1之前的Safari版本完全缺乏支持。任何版本的Internet Explorer都是如此。Microsoft Edge 15有支持，但也有一些文档记录的bug。</p>\n<h2 id=\"定义自定义属性\"><a href=\"#定义自定义属性\" class=\"headerlink\" title=\"定义自定义属性\"></a>定义自定义属性</h2><p>要定义自定义属性，请选择一个名称并在其前面加上两个连字符。任何字母数字字符都可以是名称的一部分。也允许使用连字符(-)和下划线(_)字符。广泛的unicode字符可以作为自定义属性名称的一部分，包括表情符号。为了清晰易读，请坚持使用字母数字名称。 这里有一个例子:</p>\n<p>--primarycolor: #0ad0f9ff; /* Using #rrggbbaa color notation */</p>\n<p>--向CSS解析器表明这是一个自定义属性。属性的值将替换作为变量使用的属性。 自定义属性名区分大小写。换句话说，<code>--primaryColor</code>和<code>--primaryColor</code>被认为是两个不同的属性名。这与传统的CSS有所不同，在传统CSS中，属性和值并不重要。然而，它与ECMAScript处理变量的方式是一致的。 与显示或字体等其他属性一样，CSS自定义属性必须在声明块中定义。一个常见的模式是在使用<code>:root</code> <code>psuedo-element</code>作为选择器的规则集中定义自定义属性:</p>\n<p>:root {<br>    –primarycolor: #0ad0f9ff;<br>}</p>\n<p><code>:root</code>是引用文档根元素的伪元素。对于HTML文档，这是HTML元素。对于SVG文档，它是SVG元素。通过使用<code>:root</code>，属性可以立即在整个文档中可用。 使用自定义属性 要使用自定义属性值作为变量，我们需要使用<code>var()</code>函数。例如，如果我们想使用<code>--primarycolor</code>自定义属性作为背景色，我们可以使用以下方法:</p>\n<p>body {<br>    background-color: var(–primarycolor);<br>}</p>\n<p>我们自定义属性的值将成为<code>background-color</code>属性的计算值。 到目前为止，自定义属性只能用作为标准CSS属性设置值的变量。例如，您不能将属性名存储为变量，然后重用它。下面的CSS不工作:</p>\n<p>:root {<br>    –top-border: border-top; /* Can’t set a property as custom property’s value */<br>    var(–top-border): 10px solid #bc84d8 /* Can’t use a variable as a property */<br>}</p>\n<p>您也不能将属性-值对存储为变量并重用它。下面的例子也是无效的:</p>\n<p>:root {<br>   –text-color: ‘color: orange’; /* Invalid property value */<br>}<br>body {<br>  var(–text-color); /* Invalid use of a property */<br>}</p>\n<p>最后，您也不能将变量作为值字符串的一部分连接起来:</p>\n<p>:root {<br>    –base-font-size: 10;<br>}<br>body {<br>    font: var(–base-font-size)px / 1.25 sans-serif; /* Invalid CSS syntax. */<br>}</p>\n<p>定制属性被设计成根据CSS规范解析的属性。如果浏览器厂商采用<a href=\"https://drafts.csswg.org/css-extensions/#custom-selectors\">CSS扩展规范</a>，将来我们可以使用自定义属性来创建自定义选择器组或自定义at规则。但是，目前我们仅限于使用它们作为变量来设置标准属性值。 设置回滚值 <code>var()</code>函数实际上最多接受两个参数。第一个参数应该是自定义属性名。第二个参数是可选的，但应该是一个声明值。如果自定义属性值没有定义，则此声明值作为一种回退值。 让我们看看下面的CSS:</p>\n<p>.btn__call-to-action {<br>    background: var(–accent-color, salmon);<br>}</p>\n<p>如果<code>--accent-color</code>被定义(假设它的值是<code>#f30</code>)那么具有<code>.btn__call-to-action</code>类属性的任何路径的填充颜色都将是红橙色的。如果没有定义，填充色将是橙红色。 声明值也可以嵌套。换句话说，您可以使用一个变量作为var函数的回退值：</p>\n<p>body {<br>    background-color: var(–books-bg, var(–arts-bg));<br>}</p>\n<p>在上面的CSS中，如果<code>--books-bg</code>被定义，背景颜色将被设置为<code>--books-bg</code>属性的值。如果不是，背景颜色将改为指定的任何值<code>--arts-bg</code>。如果它们都没有定义，背景颜色将是属性的初始值——在本例中是<code>transparent</code>。 当自定义属性被赋予一个值，而该值对于它所使用的属性无效时，也会发生类似的情况。考虑以下CSS:</p>\n<p>:root {<br>    –footer-link-hover: #0cg; /* Not a valid color value. */<br>}<br>a:link {<br>     color: blue;<br>}<br>a:hover {<br>    color: red;<br>}<br>footer a:hover {<br>    color: var(–footer-link-hover);<br>}</p>\n<p>在这种情况下，<code>--footer-link-hover</code>属性的值不是有效颜色。在microsoftedge中，页脚链接的悬停状态颜色将从<code>a:hover</code>选择器继承。在大多数其他浏览器中，悬停状态颜色将继承body元素的文本颜色。 自定义属性和级联 自定义属性也遵循级联规则。它们的值可以被后续规则覆盖:</p>\n<p>:root {<br>    –text-color: #190736; /* navy */<br>}<br>body {<br>   –text-color: #333;  /* Dark gray */<br>}<br>body {<br>  color: var(–text-color);<br>}</p>\n<p>在上面的例子中，我们的正文是深灰色的。我们还可以在每个选择器的基础上重置值。让我们添加更多的规则到这个CSS:</p>\n<p>:root {<br>    –text-color: #190736; /* navy */<br>}<br>body {<br>   –text-color: #333;  /* Dark gray */<br>}<br>p {<br>  –text-color: #f60; /* Orange */<br>}<br>body {<br>  color: var(–text-color);<br>}<br>p {<br>  color: var(–text-color)<br>}</p>\n<p>在本例中，包装在p元素标记中的任何文本都是橙色的。但是div或其他元素中的文本仍然是深灰色的。 还可以使用style属性(例如<code>style=&quot;--brand-color: #9a09af&quot;</code>)设置自定义属性的值，这在基于组件的前端体系结构中非常有用。</p>\n","categories":["HTML/CSS"],"tags":["css3教程","css var()","CSS Variables","css 布局","css 排版","css教程"]},{"title":"CSS中的变量：自定义属性","url":"/2018/09/29/css%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/","content":"<p>多年来，变量是最常请求的CSS功能之一。变量可以更轻松地管理颜色，字体，大小和动画值，并确保它们在代码库中的一致性。 花了几年时间研究语法的细节，并决定变量如何适应控制级联和继承的现有规则。现在，它们以CSS“自定义属性”的形式供开发人员使用。 在本章中，我们将讨论CSS自定义属性的语法。我们来看看：</p>\n<ul>\n<li>  如何定义属性并为这些属性设置默认值 级联和继承的规则如何与自定义属性一起使用 如何在媒体查询中使用自定义属性 最后，您应该很好地掌握如何在项目中使用自定义属性。</li>\n</ul>\n<p>注意：浏览器对自定义变量的支持非常强大，存在于每个主要浏览器的最新版本中。但是，旧版但最近发布的浏览器版本仍然不支持这些版本，这些版本可能仍会被您网站的受众广泛使用。15之前的Microsoft Edge版本和9.1版之前的Safari版本完全缺乏支持。任何版本的Internet Explorer都是如此。Microsoft Edge 15有支持，但也有一些记录的错误。</p>\n<h4 id=\"定义自定义属性\"><a href=\"#定义自定义属性\" class=\"headerlink\" title=\"定义自定义属性\"></a>定义自定义属性</h4><p>要定义自定义属性，请选择一个名称，并使用两个连字符作为前缀。任何字母数字字符都可以是名称的一部分。也允许使用连字符（-）和下划线（_）字符。广泛的unicode字符可以是自定义属性名称的一部分，包括emojis。为了清晰和可读性，请坚持使用字母数字名称。 这是一个例子：</p>\n<p>--primarycolor: #0ad0f9ff; /* Using #rrggbbaa color notation */</p>\n<p>该–指示的CSS解析器，这是一个自定义属性。无论将属性用作变量，属性的值都将替换该属性。 自定义属性名称区分大小写。换句话说，–primaryColor并且–primarycolor被认为是两个不同的属性名称。这与传统的CSS背道而驰，其中财产和价值案例并不重要。但是，它与ECMAScript处理变量的方式一致。 与其他属性（如displayor）一样font，必须在声明块中定义CSS自定义属性。一种常见的模式是在规则:root集中定义使用psuedo-element作为选择器的自定义属性：</p>\n<p>:root {<br>–primarycolor: #0ad0f9ff;<br>}</p>\n<p>:root是一个伪元素，它引用文档的根元素。对于HTML文档，这是html元素。对于SVG文档，它是svg元素。通过使用:root，可以在整个文档中立即获得属性。</p>\n<h4 id=\"使用自定义属性\"><a href=\"#使用自定义属性\" class=\"headerlink\" title=\"使用自定义属性\"></a>使用自定义属性</h4><p>要将自定义属性值用作变量，我们需要使用该var()函数。例如，如果我们想将–primarycolor自定义属性用作背景颜色，我们将使用以下内容：</p>\n<p>body {<br>background-color: var(–primarycolor);<br>}</p>\n<p>我们的自定义属性的值将成为属性的计算值background-color。 到目前为止，自定义属性只能用作变量来设置标准CSS属性的值。例如，您不能将属性名称存储为变量，然后重复使用它。以下CSS不起作用：</p>\n<p>:root {<br>–top-border: border-top; /* Can’t set a property as custom property’s value */<br>var(–top-border): 10px solid #bc84d8 /* Can’t use a variable as a property */<br>}</p>\n<p>您也不能将属性 - 值对存储为变量并重用它。以下示例也无效：</p>\n<p>:root {<br>–text-color: ‘color: orange’; /* Invalid property value */<br>}<br>body {<br>var(–text-color); /* Invalid use of a property */<br>}</p>\n<p>最后，您也无法将变量连接为值字符串的一部分：</p>\n<p>:root {<br>–base-font-size: 10;<br>}<br>body {<br>font: var(–base-font-size)px / 1.25 sans-serif; /* Invalid CSS syntax. */<br>}</p>\n<p>自定义属性被设计为用作根据CSS规范解析的属性。如果浏览器供应商采用CSS扩展规范，我们有一天可能会使用自定义属性来创建自定义选择器组或自定义规则。但是，目前我们仅限于将它们用作变量来设置标准属性值。</p>\n<h4 id=\"设置后备值\"><a href=\"#设置后备值\" class=\"headerlink\" title=\"设置后备值\"></a>设置后备值</h4><p>该var()函数实际上最多接受两个参数。第一个参数应该是自定义属性名称。第二个参数是可选的，但应该是声明值。如果尚未定义自定义属性值，则此声明值将用作一种回退值。 我们来看下面的CSS：</p>\n<p>.btn__call-to-action {<br>background: var(–accent-color, salmon);<br>}</p>\n<p>如果–accent-color已定义 - 让我们说它的值是#f30- 然后具有.btn__call-to-actionclass属性的任何路径的填充颜色将具有红橙色填充。如果没有定义，填充将是鲑鱼。 声明值也可以嵌套。换句话说，您可以使用变量作为var函数的回退值：</p>\n<p>body {<br>background-color: var(–books-bg, var(–arts-bg));<br>}</p>\n<p>在上面的CSS中，如果–books-bg已定义，则背景颜色将设置为–books-bg属性的值。如果没有，背景颜色将改为分配给的任何值–arts-bg。如果这两个都没有定义，那么背景颜色将是属性的初始值 - 在这种情况下transparent。 当自定义属性被赋予对其所使用的属性无效的值时，会发生类似的事情。考虑以下CSS：</p>\n<p>:root {<br>–footer-link-hover: #0cg; /* Not a valid color value. */<br>}<br>a:link {<br>color: blue;<br>}<br>a:hover {<br>color: red;<br>}<br>footer a:hover {<br>color: var(–footer-link-hover);<br>}</p>\n<p>在这种情况下，–footer-link-hover属性的值不是有效颜色。在Microsoft Edge中，页脚链接的悬停状态颜色将从a:hover选择器继承。在大多数其他浏览器中，悬停状态颜色将从body元素的文本颜色继承。 自定义属性和级联 自定义属性也遵循级联规则。后续规则可以覆盖它们的值：</p>\n<p>:root {<br>–text-color: #190736; /* navy */<br>}<br>body {<br>–text-color: #333; /* Dark gray */<br>}<br>body {<br>color: var(–text-color);<br>}</p>\n<p>在上面的示例中，我们的正文将为深灰色。我们还可以基于每个选择器重置值。让我们为这个CSS添加更多规则：</p>\n<p>:root {<br>–text-color: #190736; /* navy */<br>}<br>body {<br>–text-color: #333; /* Dark gray */<br>}<br>p {<br>–text-color: #f60; /* Orange */<br>}<br>body {<br>color: var(–text-color);<br>}<br>p {<br>color: var(–text-color)<br>}</p>\n<p>在这种情况下，包含在p元素标记中的任何文本都将为橙色。但是内部div或其他元素中的文本仍然是深灰色的。 也可以使用style属性设置自定义属性的值- 例如，style=”–brand-color: #9a09af”- 这在基于组件的前端体系结构中很有用。</p>\n","categories":["HTML/CSS"],"tags":["css","css3",":root","变量","自定义属性"]},{"title":"CSS在单行文本开头添加省略号字符","url":"/2018/12/28/css%E5%9C%A8%E5%8D%95%E8%A1%8C%E6%96%87%E6%9C%AC%E5%BC%80%E5%A4%B4%E6%B7%BB%E5%8A%A0%E7%9C%81%E7%95%A5%E5%8F%B7%E5%AD%97%E7%AC%A6/","content":"<p>css实现单行文本溢出显示省略号的方法大家应该在网上已经得到想要的答案了吧，就是用text-overflow:ellipsis属性来实现，当然还需要加宽度width属来兼容部分浏览。</p>\n<p>实现方法：</p>\n<p>.ellipsize-right{<br>white-space: nowrap;<br>overflow: hidden;<br>text-overflow:ellipsis;<br>width: 200px;<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/Bvwyvr/\">ellipsize-right</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>css的text-overflow:ellipsis文本溢出显示省略号功能非常棒，但本质上只在文本结尾实现省略字符串，假如我们想在文本的开头实现省略字符串，该怎么办？</p>\n<p>那么今天我们就来实现以下这个疑问</p>\n<p>.ellipsize-left {<br>/* 标准CSS省略号 */<br>white-space: nowrap;<br>overflow: hidden;<br>text-overflow: ellipsis;<br>width: 200px;<br>/* 字符串的开头 */<br>direction: rtl;<br>text-align: left;<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/PXJwXE/\">ellipsize-left</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>若要在字符串的开头添加省略号，请使用RTL和text-align来剪辑字符串的开头！</p>\n","categories":["HTML/CSS"],"tags":["css3","css教程","CSS省略号","text-overflow","white-space","文本溢出"]},{"title":"css多种方法实现一个tips带有描边的小箭头","url":"/2018/12/21/css%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAtips%E5%B8%A6%E6%9C%89%E6%8F%8F%E8%BE%B9%E7%9A%84%E5%B0%8F%E7%AE%AD%E5%A4%B4/","content":"<p>我们在网页开发中实现一个tips时会有一个小箭头，实现这种方法的文章网上已经泛滥了，但有时实现这个小箭头不止只有单纯的三角它还有描边，今天我们就借那些现有的文章在深入一点来说说如何给tips小箭头描边，本章不涉及svg/canvas，没必要因为我讲的是css。</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/WLOvqR/\">第一种border描边双层覆盖</a> by w3cbest.com (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<div class=\"dui-tips\">\n  <a href=\"www.w3cbest.com\">w3cbest我是一个tips</a>\n</div>\n\n<p>.dui-tips{<br>position: relative;<br>padding: 10px;<br>text-align: center;<br>border: 1px solid #f60;<br>border-radius: 5px;<br>background-color: #fff;<br>}</p>\n<h2 id=\"第一种border描边双层覆盖：\"><a href=\"#第一种border描边双层覆盖：\" class=\"headerlink\" title=\"第一种border描边双层覆盖：\"></a>第一种border描边双层覆盖：</h2><p>就是大家常用的border，实现原理就是给其中一条边设置颜色宽度及样式，我这里使用了两个伪类进行折叠，将一个白色的覆盖在有颜色的伪类上面，再偏移1px来模拟实现1px的描边效果，代码如下：</p>\n<p>.dui-tips {<br>&amp;:before, &amp;:after {<br>position: absolute;<br>left: 50%;<br>display: table;<br>width: 0;<br>height: 0;<br>content: ‘’;<br>transform: translate(-50%, 0);<br>border-width: 10px 10px 0 10px;<br>border-style: solid;<br>}<br>&amp;:before {<br>z-index: 0;<br>bottom: -10px;<br>border-color: #f60 transparent transparent transparent;<br>}<br>&amp;:after {<br>z-index: 1;<br>bottom: -8px;<br>border-color: #fff transparent transparent transparent;<br>}<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/WLOvqR/\">第一种border描边双层覆盖</a> by w3cbest.com (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"第二种border描边结合滤镜drop-shadow属性：\"><a href=\"#第二种border描边结合滤镜drop-shadow属性：\" class=\"headerlink\" title=\"第二种border描边结合滤镜drop-shadow属性：\"></a>第二种border描边结合滤镜drop-shadow属性：</h2><p>第二种是第一种的延伸，使用滤镜filter的drop-shadow描边来实现，box-shadow和drop-shadow实现不规则投影 <a href=\"http://www.w3cbest.com/?p=172\">http://www.w3cbest.com/?p=172</a></p>\n<p>.dui-tips {<br>&amp;:after {<br>    position: absolute;<br>    left: 50%;<br>    display: table;<br>    width: 0;<br>    height: 0;<br>    content: ‘’;<br>    transform: translate(-50%, 0);<br>    border-width: 10px 10px 0 10px;<br>    border-style: solid;<br>}<br>&amp;:after {<br>    bottom: -9px;<br>    border-color: #fff transparent transparent transparent;<br>    filter: drop-shadow(0px 2px 0px #f60);<br>}<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/aPwOga/\">第二种border描边结合滤镜drop-shadow属性</a> by w3cbest.com (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"第三种通过特殊符号”◆”字体双层覆盖\"><a href=\"#第三种通过特殊符号”◆”字体双层覆盖\" class=\"headerlink\" title=\"第三种通过特殊符号”◆”字体双层覆盖\"></a>第三种通过特殊符号”◆”字体双层覆盖</h2><p>第三种方法和第一种类似，通过两层颜色叠加在有层级的偏移来实现</p>\n<p>.dui-tips {<br>&amp;:before, &amp;:after {<br>    font-size: 24px;<br>    line-height: 18px;<br>    position: absolute;<br>    left: 50%;<br>    display: table;<br>    content: ‘◆’;<br>    transform: translate(-50%, 0);<br>    text-align: center;<br>}<br>&amp;:before {<br>    z-index: 0;<br>    bottom: -10px;<br>    color: #f60;<br>}<br>&amp;:after {<br>    z-index: 1;<br>    bottom: -8px;<br>    color: #fff;<br>}<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/pqwJMr/\">第三种通过特殊符号”◆”字体双层覆盖</a> by w3cbest.com (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"第四种通过text-shadow实现\"><a href=\"#第四种通过text-shadow实现\" class=\"headerlink\" title=\"第四种通过text-shadow实现\"></a>第四种通过text-shadow实现</h2><p>这种放发通过给文子设置1px的阴影来显描边效果</p>\n<p>.dui-tips {<br>&amp;:after {<br>    font-size: 24px;<br>    line-height: 18px;<br>    position: absolute;<br>    left: 50%;<br>    display: table;<br>    content: ‘◆’;<br>    transform: translate(-50%, 0);<br>    text-align: center;<br>}<br>&amp;:after {<br>    z-index: 1;<br>    bottom: -8px;<br>    color: #fff;<br>    text-shadow: 0 2px 0 #f60;<br>}<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/vvZOoo/\">第四种通过text-shadow实现</a> by w3cbest.com (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"第五种-background双层覆盖\"><a href=\"#第五种-background双层覆盖\" class=\"headerlink\" title=\"第五种 background双层覆盖\"></a>第五种 background双层覆盖</h2><p>这种方式设置两个宽度和高度分别为10px的方块背景，再给两层背景分别设置不同的颜色，再通过两层背景颜色叠加，经过层级偏移再有transform的rotate属性旋转角度，来实现箭头的朝向。</p>\n<p>.dui-tips {<br>&amp;:before, &amp;:after {<br>    position: absolute;<br>    left: 50%;<br>    display: table;<br>    width: 10px;<br>    height: 10px;<br>    content: ‘’;<br>    margin-left: -5px;<br>    transform: rotate(-45deg);<br>}<br>&amp;:before {<br>    z-index: 0;<br>    bottom: -6px;<br>    background-color: #f60;<br>}<br>&amp;:after {<br>    z-index: 1;<br>    bottom: -5px;<br>    background-color: #fff;<br>}<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/KbqdPq/\">第五种 background双层覆盖</a> by w3cbest.com (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"第六种background和border背景描边旋转\"><a href=\"#第六种background和border背景描边旋转\" class=\"headerlink\" title=\"第六种background和border背景描边旋转\"></a>第六种background和border背景描边旋转</h2><p>此方法就是设置一个宽度和高度分别为10px的方块背景，然后背景相邻的两条边描边再有transform的rotate属性旋转角度，来实现箭头的朝向。</p>\n<p>.dui-tips {<br>&amp;:after {<br>    position: absolute;<br>    left: 50%;<br>    display: table;<br>    width: 10px;<br>    height: 10px;<br>    margin-left: -5px;<br>    content: ‘’;<br>    transform: rotate(-45deg);<br>}<br>&amp;:after {<br>    z-index: 1;<br>    bottom: -6px;<br>    border-bottom: 1px solid #f60;<br>    border-left: 1px solid #f60;<br>    background-color: #fff;<br>}<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/YdQyKm/\">第六种background和border背景描边旋转</a> by w3cbest.com (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"第七种background和box-shadow\"><a href=\"#第七种background和box-shadow\" class=\"headerlink\" title=\"第七种background和box-shadow\"></a>第七种background和box-shadow</h2><p>.dui-tips {<br>&amp;:after {<br>    position: absolute;<br>    left: 50%;<br>    display: table;<br>    width: 10px;<br>    height: 10px;<br>    content: ‘’;<br>    margin-left: -5px;<br>    transform: rotate(-45deg);<br>}<br>&amp;:after {<br>    z-index: 1;<br>    bottom: -5px;<br>    background-color: #fff;<br>    box-shadow: -1px 1px 0 #f60;<br>}<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/QzgjWv/\">第七种background和box-shadow</a> by w3cbest.com (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"第八种linear-gradient\"><a href=\"#第八种linear-gradient\" class=\"headerlink\" title=\"第八种linear-gradient\"></a>第八种linear-gradient</h2><p>.dui-tips{<br>&amp;:before, &amp;:after{<br>    position: absolute;<br>    left: 50%;<br>    display: table;<br>    width: 10px;<br>    height: 10px;<br>    content: ‘’;<br>    margin-left: -5px;<br>    transform: rotate(-135deg);<br>}<br>&amp;:before {<br>    z-index: 0;<br>    bottom: -6px;<br>    background: linear-gradient(-45deg, transparent 7px, #f60 0);<br>}<br>&amp;:after {<br>    z-index: 1;<br>    bottom: -5px;<br>    background: linear-gradient(-45deg, transparent 7px, #fff 0);<br>}<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/EGXVxe/\">第八种linear-gradient</a> by w3cbest.com (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"第九种linear-gradient和box-shadow\"><a href=\"#第九种linear-gradient和box-shadow\" class=\"headerlink\" title=\"第九种linear-gradient和box-shadow\"></a>第九种linear-gradient和box-shadow</h2><p>.dui-tips{<br>&amp;:after{<br>    position: absolute;<br>    left: 50%;<br>    display: table;<br>    width: 10px;<br>    height: 10px;<br>    content: ‘’;<br>    margin-left: -5px;<br>    transform: rotate(-135deg);<br>}<br>&amp;:after {<br>    z-index: 1;<br>    bottom: -5px;<br>    background: linear-gradient(-45deg, transparent 7px, #fff 0);<br>    box-shadow: -1px -1px 0 #f60<br>}<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/REgWNw/\">第九种linear-gradient和box-shadow</a> by w3cbest.com (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"第十种linear-gradient和border\"><a href=\"#第十种linear-gradient和border\" class=\"headerlink\" title=\"第十种linear-gradient和border\"></a>第十种linear-gradient和border</h2><p>.dui-tips{<br>&amp;:after{<br>    position: absolute;<br>    left: 50%;<br>    display: table;<br>    width: 10px;<br>    height: 10px;<br>    content: ‘’;<br>    margin-left: -5px;<br>    transform: rotate(-135deg);<br>}<br>&amp;:after {<br>    z-index: 1;<br>    bottom: -6px;<br>    background: linear-gradient(-45deg, transparent 7px, #fff 0);<br>    border-top: 1px solid #f60;<br>    border-left: 1px solid #f60;<br>}<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/LMLpEa/\">第十种linear-gradient和border</a> by w3cbest.com (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"第十一种ouline\"><a href=\"#第十一种ouline\" class=\"headerlink\" title=\"第十一种ouline\"></a>第十一种ouline</h2><p>.dui-tips {<br>  &amp;:before, &amp;:after {<br>    position: absolute;<br>    left: 50%;<br>    display: table;<br>    width: 0;<br>    height: 0;<br>    content: ‘’;<br>    transform: rotate(45deg);<br>    outline-style: solid;<br>    outline-width: 5px;<br>  }<br>  &amp;:before {<br>    z-index: 0;<br>    bottom: -1px;<br>    outline-color: #f60;<br>  }<br>  &amp;:after {<br>    z-index: 1;<br>    bottom: 0;<br>    outline-color: #fff;<br>  }<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/vvJmXj/\">第十一种outline</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n","categories":["HTML/CSS"],"tags":["css3","transforms","box-shadow","text-shadow","css tips","css三角","translate"]},{"title":"css多重边框","url":"/2018/06/02/css%E5%A4%9A%E9%87%8D%E8%BE%B9%E6%A1%86/","content":"<p>回首往事，当背景与边框（第三版）（<a href=\"http://w3.org/TR/css3-background%EF%BC%89%E8%BF%98%E5%9C%A8%E8%8D%89%E6%A1%88%E9%98%B6%E6%AE%B5%E6%97%B6%EF%BC%8CCSS\">http://w3.org/TR/css3-background）还在草案阶段时，CSS</a> 工作组内部有过很多讨论，关于是否应该允许多重边框，就像多重背景那样。不幸的是，当时一致认为这个特性并没有足够多的使用场景，而且网页开发者还可以使用 border-image 来达到相同的效果。然而工作组忽略了一点：我们通常希望在 CSS 代码层面以更灵活的方式来调整边框样式。因此，网页开发者们最终不得不折腾出各种丑陋的 hack，比如使用多个元素来模拟多重边框。不过，我们还有更好的办法来解决这个难题，并不需要添加无用的额外元素来污染我们的结构。</p>\n<h2 id=\"box-shadow-方案\"><a href=\"#box-shadow-方案\" class=\"headerlink\" title=\"box-shadow 方案\"></a>box-shadow 方案</h2><p>目前为止，我们大多数人可能已经用过（或滥用过）box-shadow 来生成投影。不太为人所知的是，它还接受第四个参数（称作“扩张半径”），通过指定正值或负值，可以让投影面积加大或者减小。一个正值的扩张半径加上两个为零的偏移量以及为零的模糊值，得到的“投影”其实就像一道实线边框。如图 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901141127.jpg\"></p>\n<p>用 box-shadow 来模拟外框</p>\n<p>background: yellowgreen;<br>box-shadow: 0 0 0 10px #655;</p>\n<p>这并没有什么了不起的，因为你完全可以用 border 属性来生成完全一样的边框效果。不过 box-shadow 的好处在于，它支持逗号分隔语法，我们可以创建任意数量的投影。因此，我们可以非常轻松地在上面的示例中再加上一道 deeppink 颜色的“边框”：</p>\n<p>background: yellowgreen;<br>box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink;</p>\n<p>唯一需要注意的是，box-shadow 是层层叠加的，第一层投影位于最顶层，依次类推。因此，你需要按此规律调整扩张半径。比如说，在前面的代码中，我们想在外圈再加一道 5px 的外框，那就需要指定扩张半径的值为15px（10px+5px）。如果你愿意，甚至还可以在这些“边框”的底下再加一层常规的投影：</p>\n<p>background: yellowgreen;<br>box-shadow: 0 0 0 10px #655,0 0 0 15px deeppink,0 2px 5px 15px rgba(0,0,0,.6)</p>\n<p>多重投影解决方案在绝大多数场合都可以很好地工作，但有一些注意事项。</p>\n<ul>\n<li>  投影的行为跟边框不完全一致，因为它不会影响布局，而且也不会受到 box-sizing 属性的影响。不过，你还是可以通过内边距或外边距（这取决于投影是内嵌和还是外扩的）来额外模拟出边框所需要占据的空间。</li>\n<li>  上述方法所创建出的假“边框”出现在元素的外圈。它们并不会响应鼠标事件，比如悬停或点击。如果这一点非常重要，你可以给box-shadow 属性加上 inset 关键字，来使投影绘制在元素的内圈。请注意，此时你需要增加额外的内边距来腾出足够的空隙。</li>\n</ul>\n<h2 id=\"outline-方案\"><a href=\"#outline-方案\" class=\"headerlink\" title=\"outline 方案\"></a>outline 方案</h2><p>在某些情况下，你可能只需要两层边框，那就可以先设置一层常规边框，再加上 outline（描边）属性来产生外层的边框。这种方法的一大优点在于边框样式十分灵活，不像上面的 box-shadow 方案只能模拟实线边框（假设我们需要产生虚线边框效果，box-shadow 就没辙了）。如果要得到下图的效果，代码可以这样写： <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901141716.jpg\"></p>\n<p>使用 box-shadow 来模拟双层外框</p>\n<p>background: yellowgreen;<br>border: 10px solid #655;<br>outline: 5px solid deeppink;</p>\n<p>描边的另一个好处在于，你可以通过 outline-offset 属性来控制它跟元素边缘之间的间距，这个属性甚至可以接受负值。这对于某些效果来说非常有用。举个例子，下图就实现了简单的缝边效果。 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901141906.jpg\"></p>\n<p>对一层 dashed（虚线）描边使用负 的 outline-offset 后， 可 以得到简单的缝边效果</p>\n<p>这个方案同样也有一些需要注意的地方。</p>\n<ul>\n<li>  如上所述，它只适用于双层“边框”的场景，因为 outline 并不能接受用逗号分隔的多个值。如果我们需要获得更多层的边框，前一种方案就是我们唯一的选择了。</li>\n<li>  边框不一定会贴合 border-radius 属性产生的圆角，因此如果元素是圆角的，它的描边可能还是直角的（参见下图）。请注意，这种行为被 CSS 工作组认为是一个 bug，因此未来可能会改为贴合 border-radius 圆角。</li>\n</ul>\n<p><img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901142225.jpg\"> 通 过 outline 属 性 实 现 的“ 边框”不会贴合元素的圆角，不过这一行为在未来可能会发生变化</p>\n<ul>\n<li>  根据 CSS 基本 UI 特性（第三版）规范（<a href=\"http://w3.org/TR/css3-ui%EF%BC%89%E6%89%80%E8%BF%B0%EF%BC%8C%E2%80%9C%E6%8F%8F%E8%BE%B9%E5%8F%AF%E4%BB%A5%E4%B8%8D%E6%98%AF%E7%9F%A9%E5%BD%A2%E2%80%9D%E3%80%82%E5%B0%BD%E7%AE%A1%E5%9C%A8%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%8F%8F%E8%BE%B9%E9%83%BD%E6%98%AF%E7%9F%A9%E5%BD%A2%E7%9A%84%EF%BC%8C%E4%BD%86%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%83%B3%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%B7%E5%88%87%E8%AE%B0%EF%BC%9A%E6%9C%80%E5%A5%BD%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%AE%8C%E6%95%B4%E5%9C%B0%E6%B5%8B%E8%AF%95%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C%E3%80%82\">http://w3.org/TR/css3-ui）所述，“描边可以不是矩形”。尽管在绝大多数情况下，描边都是矩形的，但如果你想使用这个方法，请切记：最好在不同浏览器中完整地测试最终效果。</a></li>\n</ul>\n<h4 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h4><p>CSS 背景与边框： <a href=\"http://w3.org/TR/css-backgrounds\">http://w3.org/TR/css-backgrounds</a> CSS 基本 UI 特性： <a href=\"http://w3.org/TR/css3-ui\">http://w3.org/TR/css3-ui</a></p>\n","categories":["HTML/CSS"],"tags":["css","css3","css多重边框"]},{"title":"CSS灵活的背景定位","url":"/2018/06/01/css%E7%81%B5%E6%B4%BB%E7%9A%84%E8%83%8C%E6%99%AF%E5%AE%9A%E4%BD%8D/","content":"<p>很多时候，我们想针对容器某个角对背景图片做偏移定位，如右下角。在 CSS 2.1 中，我们只能指定距离左上角的偏移量，或者干脆完全靠齐到其他三个角。但是，我们有时希望图片和容器的边角之间能留出一定的空隙（类似内边距的效果），以免得到像下图这样的效果。 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901143342.jpg\"></p>\n<p>background-position: bottom right; 通常不会产生在审美上让人非常舒服的结果，因为图片跟容器的边缘之间没有空隙</p>\n<p>对于具有固定尺寸的容器来说，使用 CSS 2.1 来做到这一点是可能的，但很麻烦：可以基于它自身的尺寸以及我们期望它距离右下角的偏移量，计算出背景图片距离左上角的偏移量，然后再把计算结果设置给 background-position。当容器元素的尺寸不固定时（因为内容往往是可变的），这就不可能做到了。网页开发者通常只能把 background-position 设置为某个接近 100% 的百分比值，以便近似地得到想要的效果。如你所愿，借助现代的CSS 特性，我们已经拥有了更好的解决方案！</p>\n<h4 id=\"background-position-的扩展语法方案\"><a href=\"#background-position-的扩展语法方案\" class=\"headerlink\" title=\"background-position 的扩展语法方案\"></a>background-position 的扩展语法方案</h4><p>在 CSS 背景与边框（第三版）（<a href=\"http://w3.org/TR/css3-background%EF%BC%89%E4%B8%AD%EF%BC%8Cbackground-position\">http://w3.org/TR/css3-background）中，background-position</a> 属性已经得到扩展，它允许我们指定背景图片距离任意角的偏移量，只要我们在偏移量前面指定关键字。举例来说，如果想让背景图片跟右边缘保持 20px 的偏移量，同时跟底边保持 10px 的偏移量，可以这样做（结果如图所示）： <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901143405.jpg\"></p>\n<p>我们可以指定距离其他各边的偏移量；为了更清楚地看到偏移是怎么工作的，背景图片的外圈加了一层虚线框</p>\n<p>background: url(code-pirate.svg) no-repeat #58a;<br>background-position: right 20px bottom 10px;</p>\n<p>最后一步，我们还需要提供一个合适的回退方案。因为对上述方案来说，在不支持 background-position 扩展语法的浏览器中，背景图片会紧贴在左上角（背景图片的默认位置）。这看起来会很奇怪，而且它会干扰到文字的可读性（参见下图）。提供一个回退方案也很简单，就是把老套的bottom right 定位值写进 background 的简写属性中： <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901143424.jpg\"></p>\n<p>如果我们不希望旧版浏览器的用户看到这个结果，还需要指定一个回退方案</p>\n<p>background: url(code-pirate.svg) no-repeat bottom right #58a;<br>background-position: right 20px bottom 10px;</p>\n<h4 id=\"background-origin-方案\"><a href=\"#background-origin-方案\" class=\"headerlink\" title=\"background-origin 方案\"></a>background-origin 方案</h4><p>在给背景图片设置距离某个角的偏移量时，有一种情况极其常见：偏移量与容器的内边距一致。如果采用上面提到的 background-position 的扩展语法方案，代码看起来会是这样的：</p>\n<p>padding: 10px;<br>background: url(code-pirate.svg) no-repeat #58a;<br>background-position: right 10px bottom 10px;</p>\n<p>我们可以在下图中看到结果。如你所见，它起作用了，但代码不够DRY：每次改动内边距的值时，我们都需要在三个地方更新这个值！谢天谢地，还有一个更简单的办法可以实现这个需求：让它自动地跟着我们设定的内边距走，不用另外声明偏移量的值。 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901143446.jpg\"></p>\n<p>对背景图片应用的偏移量往往跟内边距的值正好一致</p>\n<p>在网页开发生涯中，你很可能多次写过类似 background-position:top left; 这样的代码。你是否曾经有过疑惑：这个 top left 到底是哪个左上角？你可能知道，每个元素身上都存在三个矩形框（参见下图）：border box（边框的外沿框）、padding box（内边距的外沿框）和 content box（内容区的外沿框）。那 background-position 这个属性指定的到底是哪个矩形框的左上角？默认情况下，background-position 是以 padding box 为准的，这样边框才不会遮住背景图片。因此，top left 默认指的是 padding box 的左上角。不过，在背景与边框（第三版）（<a href=\"http://w3.org/TR/css3-background%EF%BC%89%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BE%97%E5%88%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B1%9E%E6%80%A7\">http://w3.org/TR/css3-background）中，我们得到了一个新的属性</a> background-origin，可以用它来改变这种行为。 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901143511.jpg\">   在默认情况下，它的值是（闭着眼睛也猜得到）padding-box。如果把它的值改成 content-box（参见下面的代码），我们在 background-position 属性中使用的边角关键字将会以内容区的边缘作为基准（也就是说，此时背景图片距离边角的偏移量就跟内边距保持一致了）：</p>\n<p>padding: 10px;<br>background: url(“code-pirate.svg”) no-repeat #58a<br>bottom right; /* 或 100% 100% */<br>background-origin: content-box;</p>\n<p>它的视觉效果跟图 4 是完全一样的，但我们的代码变得更加 DRY了。另外别忘了，在必要时可以把这两种技巧组合起来！如果你想让偏移量与内边距稍稍有些不同（比如稍微收敛或超出），那么可以在使用background-origin: content-box 的同时，再通过 background-position的扩展语法来设置这些额外的偏移量。</p>\n<h4 id=\"calc-方案\"><a href=\"#calc-方案\" class=\"headerlink\" title=\"calc() 方案\"></a>calc() 方案</h4><p>让我们回顾一下本节开头的挑战：把背景图片定位到距离底边 10px 且距离右边 20px 的位置。如果我们仍然以左上角偏移的思路来考虑，其实就是希望它有一个 100% - 20px 的水平偏移量，以及 100% - 10px 的垂直偏移量。谢天谢地，calc() 函数允许我们执行此类运算，它可以完美地在background-position 属性中使用：</p>\n<p>background: url(“code-pirate.svg”) no-repeat;<br>background-position: calc(100% - 20px) calc(100% - 10px);</p>\n<h4 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h4><p>CSS 背景与边框 <a href=\"http://w3.org/TR/css-backgrounds\">http://w3.org/TR/css-backgrounds</a> CSS 值与单位 <a href=\"http://w3.org/TR/css-values\">http://w3.org/TR/css-values</a></p>\n","categories":["HTML/CSS"],"tags":["css","css3","CSS背景定位"]},{"title":"CSS边框内圆角","url":"/2018/06/01/css%E8%BE%B9%E6%A1%86%E5%86%85%E5%9C%86%E8%A7%92/","content":"<p>有时我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外部仍然保持直角的形状，如图(1)。这是一个有趣的效果，目前还没有被滥用。用两个元素可以实现这个效果，这并没有什么特别的：</p>\n<p>这是一个实例 (图1)</p>\n<p>容器外围有一道边框，但只在内侧有圆角</p>\n<div class=\"demo\"><div>这是一个实例</div></div>\n.demo {\nbackground: #655;\npadding: .8em;\n}\n.demo > div {\nbackground: tan;\nborder-radius: .8em;\npadding: 1em;\n}\n\n<p>这个方法很好，但要求我们使用两个元素，而我们只需要一个元素。有没有办法可以只用一个元素达成同样的效果呢？</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>其实上述方案要更加灵活一些，因为它允许我们充分运用背景的能力。举个例子，如果我们希望这一圈“边框”不只是纯色的，而是要加一层淡淡的纹理，它也可以很容易地做到。不过，如果只需要达成简单的实色效果，那我们就还有另一条路可走，只需用到一个元素（但这个办法有一些 hack的味道）。我们来看看以下 CSS 代码：</p>\n<p>background: tan;<br>border-radius: .8em;<br>padding: 1em;<br>box-shadow: 0 0 0 .6em #655;<br>outline: .6em solid #655;</p>\n<p>你能猜到视觉效果是怎样的吗？它产生的效果正如上图所示。我们基本上受益于两个事实：描边并不会跟着元素的圆角走（因而显示出直角，参见图 2），但 box-shadow 却是会的（参见图 3）。因此，如果我 把这两者叠加到一起，box-shadow 会刚好填补描边和容器圆角之间的空隙，这两者的组合达成了我们想要的效果。图4 把投影和描边显示为不同的颜色，从而在视觉上提供了更清晰的解释。</p>\n<p>这是一个实例 (图2)</p>\n<p>对一个有圆角的元素使用 outli-ne 属性</p>\n<p>这是一个实例 (图3)</p>\n<p>对一个有圆角的元素使用没有偏移量、没有模糊效果的 box-shadow 属性</p>\n<p>这是一个实例 (图4)</p>\n<p>为了事情的真相看起来更清楚，我们把描边显示为黑色，把投影显示为品红色；请注意描边是绘制在上层的</p>\n<p>请注意，我们为 box-shadow 属性指定的扩张值并不一定等于描边的宽度，我们只需要指定一个足够填补“空隙”的扩张值就可以了。事实上，指定一个等于描边宽度的扩张值在某些浏览器中可能会得到渲染异常，因此我推荐一个稍小些的值。这又引出了另一个问题：到底多大的投影扩张值可以填补这些空隙呢？ 为了解答这个问题，我们需要回忆起中学时学过的勾股定理，用来计算直角三角形各边的长度。勾股定理表明，如果直角边分别是 a 和 b，则斜边（正对着直角的最长边）等于 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901153413.jpg\">。当两条直角边的长度相等时，这 算式会演化为<img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901153429.jpg\">。 你可能还很纳闷，中学几何到底是怎么跟我们的内圆角效果扯上关系的？关于怎样用它来计算我们需要的最小扩张值，请看下图中图形化的解释。在我们的例子中，border-radius 是 .8em，那么最小的扩张值就是 0.8 (<img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901153522.jpg\">-1 ) ≈ 0.331 370 85 em 。我们要做的就是把稍微向上取个整， 把 .34em 设置为投影的扩张半径。为了避免每次都要计算，你可以直接使用圆角半径的一半，因为 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901153522.jpg\">—1 &lt; 0.5 。 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901150033-300x190.jpg\"> 请注意，该计算过程揭示了这个方法的另一个限制：为了让这个效果得以达成，扩张半径需要比描边的宽度值小，但它同时又要比 (<img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901153522.jpg\"> −1)r 大（这里的 r 表示 border-radius）。这意味着，如果描边的宽度比 ( <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/20180901153522.jpg\"> −1)r 小，那我们是不可能用这个方法达成该效果的。</p>\n<h4 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h4><p>CSS 背景与边框 <a href=\"http://w3.org/TR/css-backgrounds\">http://w3.org/TR/css-backgrounds</a> CSS 基本 UI 特性 <a href=\"http://w3.org/TR/css3-ui\">http://w3.org/TR/css3-ui</a></p>\n","categories":["HTML/CSS"],"tags":["css","css3","CSS边框内圆角"]},{"title":"display-grid定义一个网格","url":"/2019/05/22/display-grid%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BD%91%E6%A0%BC/","content":"<p>要定义网格，请在父元素上使用display: grid或display:inline-grid。然后可以使用grid-template-columns和grid-template-rows属性创建网格。 我使用grid-gap属性在列和行之间创建一个10px的空白。此属性是grid-column-gap和grid-row-gap的简写，因此可以单独设置这些值。 父元素的所有直接子元素现在都成为网格项，自动放置算法将它们放置在每个网格单元中。根据需要会自动创建所需要的行</p>\n<div class=\"wrapper\">\n  <div class=\"box a\">A</div>\n  <div class=\"box b\">B</div>\n  <div class=\"box c\">C</div>\n  <div class=\"box d\">D</div>\n  <div class=\"box e\">E</div>\n  <div class=\"box f\">F</div>\n</div>\n\n<p>.wrapper {<br>    display: grid;<br>    grid-template-columns: 100px 100px 100px;<br>    grid-gap: 10px;<br>    background-color: #fff;<br>    color: #444;<br>}<br>.box {<br>    background-color: #444;<br>    color: #fff;<br>    border-radius: 5px;<br>    padding: 20px;<br>    font-size: 150%;<br>}</p>\n<p><a href=\"http://www.w3cbest.com/example?pid=788\">查看示例</a></p>\n","categories":["HTML/CSS"],"tags":["grid","Grid 布局","grid-area","grid-template-areas","grid-template-columns","grid-template-rows","grid教程"]},{"title":"echarts 为雷达图设置极坐标","url":"/2019/07/04/echarts-%E4%B8%BA%E9%9B%B7%E8%BE%BE%E5%9B%BE%E8%AE%BE%E7%BD%AE%E6%9E%81%E5%9D%90%E6%A0%87/","content":"<p>ECharts 雷达图可以使用 <code>series[i]-radar</code>设置 ，雷达图主要用于表现多变量的数据，例如玩”和平精英”战况的各个属性分析，雷达图依赖<code>radar</code>组件。 关于雷达图其他的一些属性自行去查看官网，我们在这里讲的是在雷达图上设置极坐标。 首先要了解极坐标系，因为实现极坐标需要一个系列三个属性完成，分别是<code>polar:&#123;&#125;</code>极坐标系、<code>radiusAxis:&#123;&#125;</code>极坐标系的径向轴、<code>angleAxis:&#123;&#125;</code>极坐标系的角度轴完成，<a href=\"https://www.echartsjs.com/gallery/editor.html?c=doc-example/polar-start-angle\">查看示例</a> 如何把极坐标系和雷达图合并呢，下面我们就来说说如何设置，还是需要用到<code>radar</code>组件，<code>radar</code>组件下面有一个<code>indicator</code>属性， 它是雷达图的指示器，用来指定雷达图中的多个变量（维度）。 然后我们它的最大值<code>radar.indicator[i].max</code>和最小值<code>radar.indicator[i].min</code>设为统一的值，要注意它的这里的最大值要大于或等于你的数据的最大值，最小值要小于或等于你的数据的最小值。 下面是用雷达图表现的示例。</p>\n<p class=\"codepen\" data-height=\"460\" data-theme-id=\"0\" data-default-tab=\"result\" data-user=\"w3cbest\" data-slug-hash=\"zVLxKV\" style=\"height: 456px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\" data-pen-title=\"echarts 雷达图设置极坐标\">\n  <span>See the Pen <a href=\"https://codepen.io/w3cbest/pen/zVLxKV/\">\n  echarts 雷达图设置极坐标</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\n</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var max &#x3D; 4, min &#x3D; -4;</span><br><span class=\"line\">option &#x3D; &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    radar: &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        indicator: [&#123;</span><br><span class=\"line\">                name: &#39;销售&#39;,</span><br><span class=\"line\">                max: max,</span><br><span class=\"line\">                min: min</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                name: &#39;管理&#39;,</span><br><span class=\"line\">                max: max,</span><br><span class=\"line\">                min: min</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                name: &#39;技术&#39;,</span><br><span class=\"line\">                max: max,</span><br><span class=\"line\">                min: min</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        splitArea: &#123;</span><br><span class=\"line\">            show: false</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        splitLine: &#123;</span><br><span class=\"line\">            show: false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    polar: &#123;&#125;,</span><br><span class=\"line\">    angleAxis: &#123;</span><br><span class=\"line\">        min: 0,</span><br><span class=\"line\">        max: 360,</span><br><span class=\"line\">        interval: 5,</span><br><span class=\"line\">        clockwise: false,</span><br><span class=\"line\">        axisTick: &#123;</span><br><span class=\"line\">            show: false</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        axisLabel: &#123;</span><br><span class=\"line\">            show: false</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        axisLine: &#123;</span><br><span class=\"line\">            show: false</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        splitLine: &#123;</span><br><span class=\"line\">            show: false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    radiusAxis: &#123;</span><br><span class=\"line\">        min: min,</span><br><span class=\"line\">        max: max,</span><br><span class=\"line\">        interval: 2,</span><br><span class=\"line\">        splitArea: &#123;</span><br><span class=\"line\">            show: true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    series: [&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        data: [&#123;</span><br><span class=\"line\">            value: [4, -4, 1]</span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","categories":["ECharts"],"tags":["echarts","echarts 坐标","echarts 雷达图"]},{"title":"Echarts 改变markPoint标注(气泡)颜色","url":"/2018/11/12/echarts-%E6%94%B9%E5%8F%98markpoint%E6%A0%87%E6%B3%A8%E6%B0%94%E6%B3%A1%E9%A2%9C%E8%89%B2/","content":"<p>改变markPoint 标注(气泡)颜色的方法很简单，其实还是多翻文档，markPoint属性有很多下面列了几个也不一一介绍了，<a href=\"http://echarts.baidu.com/option.html#series-line.markPoint\">自己翻文档。</a> <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/11/echartimg.jpg\"></p>\n<p>markPoint:{<br>  symbol: ‘pin’, //标记(气泡)的图形<br>  symbolSize: 50, //标记(气泡)的大小<br>  …<br>  itemStyle: {…}, //标注(气泡)的样式<br>}</p>\n<h3 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a>symbol</h3><p>标记的图形，默认是个气泡型的，看上图很清晰，</p>\n<h3 id=\"symbolSize\"><a href=\"#symbolSize\" class=\"headerlink\" title=\"symbolSize\"></a>symbolSize</h3><p>标记的大小，设置标记的大小，可根据自己的嗜好设置大小</p>\n<h3 id=\"itemStyle\"><a href=\"#itemStyle\" class=\"headerlink\" title=\"itemStyle\"></a>itemStyle</h3><p>标注(气泡)的样式就是这个属性，其实文档讲的都很清晰，<a href=\"http://echarts.baidu.com/option.html#series-line.markPoint.itemStyle\">只是有的人真的很懒只会问不会找</a></p>\n<p>itemStyle:{<br>  color: ‘#4587E7’,<br>  borderColor: ‘#000’,<br>  borderWidth: 0,<br>  borderType: ‘solid’,<br>  …<br>}</p>\n<h4 id=\"color-default-自适应\"><a href=\"#color-default-自适应\" class=\"headerlink\" title=\"color [ default: 自适应 ]\"></a>color [ default: 自适应 ]</h4><p>图形的颜色。</p>\n<h4 id=\"borderColor-default-“-000”\"><a href=\"#borderColor-default-“-000”\" class=\"headerlink\" title=\"borderColor [ default: “#000” ]\"></a>borderColor [ default: “#000” ]</h4><p>图形的描边颜色。支持的颜色格式同 color，不支持回调函数。</p>\n<h4 id=\"borderWidth-default-0\"><a href=\"#borderWidth-default-0\" class=\"headerlink\" title=\"borderWidth [ default: 0 ]\"></a>borderWidth [ default: 0 ]</h4><p>描边线宽。为 0 时无描边。</p>\n<h4 id=\"borderType-default-‘solid’\"><a href=\"#borderType-default-‘solid’\" class=\"headerlink\" title=\"borderType [ default: ‘solid’ ]\"></a>borderType [ default: ‘solid’ ]</h4><p>柱条的描边类型，默认为实线，支持 ‘solid’, ‘dashed’, ‘dotted’。   在结束之前，提一下如何给每个值都加上标注(气泡)，在文档代码看到的气泡是在最大值或最小值上，那么如何给每个值都加上标注(气泡)呢，其实这些值就是你的坐标轴上data值，如果想在每个值的上面显示标注，就要循环你的data值，但是在那循环呢，还是在markPoint对象里面，看文档API里面markPoint还有个<a href=\"http://echarts.baidu.com/option.html#series-line.markPoint.data\">data数组对象属性</a>，文档是这样说的；</p>\n<h3 id=\"series-i-line-markPoint-data-i\"><a href=\"#series-i-line-markPoint-data-i\" class=\"headerlink\" title=\"series[i]-line.markPoint.data[i]\"></a>series[i]-line.markPoint.data[i]</h3><p>标注的数据数组。每个数组项是一个对象，有下面几种方式指定标注的位置。</p>\n<ul>\n<li>  通过 x, y 属性指定相对容器的屏幕坐标，单位像素，支持百分比。</li>\n<li>  用 coord 属性指定数据在相应坐标系上的坐标位置，单个维度支持设置 ‘min’, ‘max’, ‘average’。</li>\n<li>  直接用 type 属性标注系列中的最大值，最小值。这时候可以使用 valueIndex 指定是在哪个维度上的最大值、最小值、平均值。或者可以使用 valueDim 指定在哪个维度上的最大值、最小值、平均值。</li>\n</ul>\n<p>当多个属性同时存在时，优先级按上述的顺序。 那么我们可以把数据组装成多个对象，例如我有一个数组</p>\n<p>series: {<br>  data: [820, 932, 901, 934, 129, 670],<br>  …<br>  markPoint: {…},<br>}</p>\n<p>那么我要在markPoint里面应该是这样组装的</p>\n<p>series: {<br>  data: [820, 932, 901, 934, 129, 670],<br>  …<br>  markPoint: {<br>    …<br>    data: [<br>      {value: 820, xAxis: 0, yAxis: 820},<br>      {value: 932, xAxis: 1, yAxis: 932},<br>      {value: 901, xAxis: 2, yAxis: 901},<br>      {value: 934, xAxis: 3, yAxis: 934},<br>      {value: 129, xAxis: 4, yAxis: 129},<br>      {value: 670, xAxis: 5, yAxis: 670}<br>    ]<br>  }<br>  …<br>}</p>\n<p>这样就如上图一样效果就出来了 来个?，假设一组数组，大于50显示红色，小于则显示绿色</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/gVwvqQ/\">echarts markPoint 气泡</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n","categories":["JavaScript","ECharts"],"tags":["javascript","echarts","markPoint","可视化","插件"]},{"title":"echarts 雷达图遇到负值中心点偏移的设置","url":"/2019/07/04/echarts-%E9%9B%B7%E8%BE%BE%E5%9B%BE%E9%81%87%E5%88%B0%E8%B4%9F%E5%80%BC%E4%B8%AD%E5%BF%83%E7%82%B9%E5%81%8F%E7%A7%BB%E7%9A%84%E8%AE%BE%E7%BD%AE/","content":"<p>ECharts 雷达图可以使用<code>series[i]-radar</code>设置 ，雷达图主要用于表现多变量的数据，例如玩”和平精英”战况的各个属性分析，雷达图依赖<code>radar</code>组件。 关于雷达图其他的一些属性自行去查看官网，我们在这里讲的是在遇到负值的时候如何设置雷达图的中心点，通过官网的例子来设置的话，遇到负值无法找到中心位置，使得雷达图的内部图形发生变异。 下面我们就来说说如何设置，想要设置负值还需要从<code>radar</code>组件出发，<code>radar</code>组件下面有一个<code>indicator</code>属性， 它是雷达图的指示器，用来指定雷达图中的多个变量（维度）。 然后我们它的最大值<code>radar.indicator[i].max</code>和最小值<code>radar.indicator[i].min</code>设为统一的值，要注意它的这里的最大值要大于或等于你的数据的最大值，最小值要小于或等于你的数据的最小值 下面是用雷达图表现的示例。</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/dBjymx/\">echarts 雷达图遇到负值中心点偏移的设置</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>var max = 100, min = -50;<br>option = {<br>    …<br>    radar: {<br>        …<br>        indicator: [{<br>                name: ‘销售’,<br>                max: max,<br>                min: min<br>            },<br>            {<br>                name: ‘管理’,<br>                max: max,<br>                min: min<br>            },<br>            {<br>                name: ‘技术’,<br>                max: max,<br>                min: min<br>            }<br>        ],<br>    },<br>    series: [{<br>        …<br>        data: [{<br>            value: [100, 80, -40]<br>        }]<br>    }]<br>};</p>\n","categories":["ECharts"],"tags":["echarts","echarts 雷达图","echarts 负值","echarts 雷达图负值"]},{"title":"ECharts柱状图点击柱子改变颜色并且回调柱子的位置","url":"/2018/11/07/echarts%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%82%B9%E5%87%BB%E6%9F%B1%E5%AD%90%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B2%E5%B9%B6%E4%B8%94%E5%9B%9E%E8%B0%83%E6%9F%B1%E5%AD%90%E7%9A%84%E4%BD%8D%E7%BD%AE/","content":"<p>在项目开发中用到echarts有这样的需求，点击点击柱子改变颜色并且回调柱子的信息，看官网方法很简单，就是<a href=\"http://www.echartsjs.com/tutorial.html#ECharts%20%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E8%A1%8C%E4%B8%BA\">官网的例子</a></p>\n<p>myChart.on(‘click’, function (params) {<br>//params 就是点击柱子的返回信息<br>});</p>\n<p>那么如何改变柱子的颜色呢？请在 如何给ECharts柱状图设置一个高亮色 文中阅读，讲的是如何设置高亮色，其实实现方法是一样的，只不过这里只是添加了点击事件而已，实现方法如下：</p>\n<p>var curInt = null;<br>option = {<br>  …<br>  series:[{<br>    …<br>    data:[…],<br>    itemStyle:{<br>      color: function(params){<br>        var key = params.dataIndex;<br>        if(key === curInt){<br>          return ‘#E062AE’<br>        }else{<br>          return ‘#37A2DA’<br>        }<br>      }<br>    },<br>    …<br>   }],<br>   …<br>};</p>\n<p>myChart.on(‘click’, function (params) {<br>curInt = params.dataIndex;<br>myChart.setOption(option)<br>});</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/aXPabg/\">Echarts给柱子设置不同颜色点击变色</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>我用的是4.0.0版本，测试了一下4.2版本以上有bug，无法重新绘制颜色</p>\n","categories":["JavaScript","ECharts"],"tags":["javascript","echarts","可视化","插件"]},{"title":"Echarts给X轴或Y轴添加%号或自定义值信息","url":"/2019/02/21/echarts%E7%BB%99x%E8%BD%B4%E6%88%96y%E8%BD%B4%E6%B7%BB%E5%8A%A0%E5%8F%B7%E6%88%96%E8%87%AA%E5%AE%9A%E4%B9%89%E5%80%BC%E4%BF%A1%E6%81%AF/","content":"<p>如何给Echarts的xAxis轴或yAxis轴添加%号或自定义值信息，首先得需要了解<a href=\"https://www.echartsjs.com/option.html#xAxis\">xAxis轴</a>或<a href=\"https://www.echartsjs.com/option.html#yAxis\">yAxis</a>轴的一些配置项，不然是不知道该如何下手的，如下图： <img src=\"http://file.w3cbest.com/file/images/20190221163332.jpg\"> 现在看来显然是<code>axisLabel</code>项了，<code>xAxis.axisLabel</code> 坐标轴刻度标签的相关设置。 <img src=\"http://file.w3cbest.com/file/images/20190221164332.jpg\"> 那我们再往下看，<code>xAxis.axisLabel.formatter</code>，刻度标签的内容格式器，支持字符串模板和回调函数两种形式。 看官网示例：</p>\n<p>// 使用字符串模板，模板变量为刻度默认标签 {value}<br>formatter: ‘{value} kg’</p>\n<p>// 使用函数模板，函数参数分别为刻度数值（类目），刻度的索引<br>formatter: function(value, index) {<br>    // 格式化成月/日，只在第一个刻度显示年份<br>    var date = new Date(value);<br>    var texts = [(date.getMonth() + 1), date.getDate()];<br>    if (index === 0) {<br>        texts.unshift(date.getYear());<br>    }<br>    return texts.join(‘/‘);<br>}</p>\n<p>通过示例我们知道它有两种形式，一种是字符串模板，另一种是函数模板。一般情况下我们使用第一种字符串模板，第二种函数模板参杂的信息量比较大，适合较复杂的一些自定义配置这里就不多讲了。</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/GzaJNW/\">Echarts给X轴或Y轴添加%号或自定义值信息</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n","categories":["ECharts"],"tags":["axisLabel","Echarts xAxis","Echarts x轴","formatter","xAxis","yAxis"]},{"title":"Echarts给柱子设置不同颜色点击并改变颜色","url":"/2018/11/29/echarts%E7%BB%99%E6%9F%B1%E5%AD%90%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E9%A2%9C%E8%89%B2%E7%82%B9%E5%87%BB%E5%B9%B6%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B2/","content":"<p>关于给Echarts柱子设置不同颜色的方案网上已经有了，不多啰嗦。其实就是通过设置itemStyle的color函数(可以当作函数回调)，使其设置一组颜色值通过函数返回值的下标一一对应将颜色赋给柱子上，大致操作就是下面的一段代码</p>\n<p>var colors = [‘#4587E7’,’#35AB33’,’#F5AD1D’,’#ff7f50’,’#da70d6’,’#32cd32’,’#6495ed’];<br>option = {<br>    …<br>    series:[{<br>        …<br>        itemStyle: {<br>            color: function(params) {<br>                //通过返回值的下标一一对应将颜色赋给柱子上<br>                return colors[params.dataIndex];<br>            }<br>        }<br>        …<br>    }]<br>}</p>\n<p> </p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/dawKPV/\">dawKPV</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p> </p>\n<h3 id=\"下面我们讲一下如何点击改变颜色\"><a href=\"#下面我们讲一下如何点击改变颜色\" class=\"headerlink\" title=\"下面我们讲一下如何点击改变颜色\"></a>下面我们讲一下<a href=\"http://www.w3cbest.com/?p=228\">如何点击改变颜色</a></h3><p>为啥子要讲这个呢，这是我在项目中遇到的需求,看下图:</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/xMmzyY/\">Echarts给柱子设置不同颜色点击变色</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>需求是这样的，分值在小于20%的时候柱子显示红色，默认是蓝色，点击后为深蓝色，需求知道了接下来该如何实现呢？通过循环判断小于20%的值赋上颜色这样把data数组结构就改变成数组对象，这样效果已经出来了，就是在点击的时候不会换色，红色柱子已被定死了不能改变了，也就是说这个方法是行不通的，换其他方法，再不改变data数组的前提下是否可以呢，然后就结合了文章开头的给柱子添加不同颜色的思想和刚刚的那个点击变色没实现的方法实现了下面的效果，也就是我的需求</p>\n<p>data = [7, 10, 20, 30, 10, 29, 16];<br>var colors = [];<br>for (var i = 0; i &lt; data.length; i++) {<br>    if(data[i] &lt; 20){<br>        colors.push(‘#EE4B46’);<br>    }else{<br>         colors.push(‘#00A1E9’);<br>    }<br>};</p>\n<p>option = {<br>    …<br>    data: data,<br>    itemStyle: {<br>        color: function(params) {<br>            var key = params.dataIndex + 1;<br>            if (key === curInt) {<br>                return ‘#4587E7’;<br>            } else {<br>                return colors[params.dataIndex]<br>            }<br>        }<br>    }<br>    …<br>}</p>\n<p> </p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/OdrwGp/\">Echarts给柱子设置不同颜色点击变色</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n","categories":["ECharts"],"tags":["javascript","echarts","可视化","插件"]},{"title":"echarts设置坐标轴区域中的分隔线颜色","url":"/2019/04/04/echarts%E8%AE%BE%E7%BD%AE%E5%9D%90%E6%A0%87%E8%BD%B4%E5%8C%BA%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%88%86%E9%9A%94%E7%BA%BF%E9%A2%9C%E8%89%B2/","content":"<p>想要设置区域分割线颜色首先要知道他的属性是什么，<code>splitLine</code> 顾名思义”分割线”。知道了分割线是什么属性后我来看看他都包含哪些特性。 从API中可以看出他是坐标轴<code>xAxis</code>和<code>yAxis</code>中的一个<code>splitLine:&#123;&#125;</code> 对象，证明他的内部有多个属性和值。我们以X轴为例</p>\n<p>splitLine: {<br>show: true,<br>interval: ‘auto’,<br>lineStyle: {<br>color: [‘#ccc’],<br>width: 1,<br>type: ‘solid’,<br>shadowBlur: …,<br>shadowColor: …,<br>shadowOffsetX: 0,<br>shadowOffsetY: 0,<br>opacity: …,<br>}<br>}</p>\n<p><strong><code>xAxis.splitLine.show</code></strong>      boolean 值 [ default: true ] 是否显示分隔线。默认数值轴显示，类目轴不显示。 <strong><code>xAxis.splitLine.interval</code></strong>   number, Function [ default: ‘auto’ ] 坐标轴分隔线的显示间隔，在类目轴中有效。默认同 axisLabel.interval 一样。 默认会采用标签不重叠的策略间隔显示标签。 可以设置成 0 强制显示所有标签。 如果设置为 1，表示『隔一个标签显示一个标签』，如果值为 2，表示隔两个标签显示一个标签，以此类推。 可以用数值表示间隔的数据，也可以通过回调函数控制。回调函数格式如下： (index:number, value: string) =&gt; boolean 第一个参数是类目的 index，第二个值是类目名称，如果跳过则返回 false。 <strong><code>xAxis.splitLine.lineStyle</code></strong>      Object</p>\n<blockquote>\n<p><code>xAxis.splitLine.lineStyle.**color**</code>      Array, string</p>\n</blockquote>\n<p>[ default: [‘#ccc’] ] 分隔线颜色，可以设置成单个颜色。 也可以设置成颜色数组，分隔线会按数组中颜色的顺序依次循环设置颜色。 示例</p>\n<p>splitLine: {<br>    lineStyle: {<br>        // 使用深浅的间隔色<br>        color: [‘#aaa’, ‘#ddd’]<br>    }<br>}</p>\n<blockquote>\n<p><code>xAxis.splitLine.lineStyle.**width**</code>      number</p>\n</blockquote>\n<p>[ default: 1 ] 分隔线线宽。</p>\n<blockquote>\n<p><code>xAxis.splitLine.lineStyle.**type**</code>      string</p>\n</blockquote>\n<p>[ default: ‘solid’ ] 分隔线线的类型。 可选：</p>\n<ul>\n<li>  <code>&#39;solid&#39;</code></li>\n<li>  <code>&#39;dashed&#39;</code></li>\n<li>  <code>&#39;dotted&#39;</code></li>\n</ul>\n<blockquote>\n<p><code>xAxis.splitLine.lineStyle.**shadowBlur**</code>      number</p>\n</blockquote>\n<p>图形阴影的模糊大小。该属性配合 <code>shadowColor</code>,<code>shadowOffsetX</code>, <code>shadowOffsetY</code>一起设置图形的阴影效果。 示例：</p>\n<p>{<br>    shadowColor: ‘rgba(0, 0, 0, 0.5)’,<br>    shadowBlur: 10<br>}</p>\n<blockquote>\n<p><code>xAxis.splitLine.lineStyle.**shadowColor**</code>      Color</p>\n</blockquote>\n<p>阴影颜色。支持的格式同color。</p>\n<blockquote>\n<p><code>xAxis.splitLine.lineStyle.**shadowOffsetX**</code>      number</p>\n</blockquote>\n<p>[ default: 0 ] 阴影水平方向上的偏移距离。</p>\n<blockquote>\n<p><code>xAxis.splitLine.lineStyle.**shadowOffsetY**</code>      number</p>\n</blockquote>\n<p>[ default: 0 ] 阴影垂直方向上的偏移距离。</p>\n<blockquote>\n<p><code>xAxis.splitLine.lineStyle.**opacity**</code>      number</p>\n</blockquote>\n<p>图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。 通过上面的解释我们可以了解到坐标轴区域的分割线可以设置 分割线颜色、分割线大小、分割线类型、分割线阴影以及分割线的透明度</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/BEjxKJ/\">Echarts设置坐标轴区域中的分隔线颜色</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n","categories":["ECharts"],"tags":["echarts","Echarts xAxis","Echarts x轴","echarts分割线","echarts分割线颜色","echarts颜色"]},{"title":"Flexbox完整指南","url":"/2018/09/02/flexbox%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在Flexbox Layout（柔性盒）模块（W3C候选推荐为2017年10月）的目的在于提供一种更有效的方式来布置，调整和项目之间在一个容器中分配空间，即使它们的大小是未知的和/或动态的（因此单词“flex”）。 flex布局背后的主要思想是让容器能够改变其项目的宽度/高度（和顺序），以最好地填充可用空间（主要是为了适应所有类型的显示设备和屏幕尺寸）。Flex容器扩展项目以填充可用空间，或缩小它们以防止溢出。 最重要的是，flexbox布局与方向无关，而不是常规布局（基于垂直的块和基于水平的内联块）。虽然这些页面适用于页面，但它们缺乏灵活性（没有双关语）来支持大型或复杂的应用程序（特别是在方向更改，调整大小，拉伸，缩小等方面）。 注意： Flexbox布局最适合应用程序的组件和小规模布局，而Grid布局则适用于更大规模的布局。</p>\n<h2 id=\"基础知识和术语\"><a href=\"#基础知识和术语\" class=\"headerlink\" title=\"基础知识和术语\"></a>基础知识和术语</h2><p><img src=\"http://file.w3cbest.com/file/images/01-container.svg\"></p>\n<h3 id=\"display\"><a href=\"#display\" class=\"headerlink\" title=\"display\"></a>display</h3><p>用来定义一个 flex 容器。如果设置为 flex 则容器呈现为块状元素，设置为inline-flex 则容器呈现为行内元素。它为所有直接子元素提供了 flex 上下文。</p>\n<p>.container {<br>  display: flex; /* or inline-flex */<br>}</p>\n<p>请注意，CSS 列对 flex 容器没有影响。当然这是 Flexbox 布局的开始。</p>\n<h3 id=\"flex-direction\"><a href=\"#flex-direction\" class=\"headerlink\" title=\"flex-direction\"></a>flex-direction</h3><p><img src=\"http://file.w3cbest.com/file/images/flex-direction.svg\"> flex-direction 属性确立了主轴，从而定义了 flex 项在 flex 容器中的排布方向。 Flexbox 是单向布局，有些时候我们也称作一维布局。 可以将 flex 项视为主要沿着水平行或垂直列排布。</p>\n<p>.container {<br>  flex-direction: row  row-reverse  column  column-reverse;<br>}</p>\n<ul>\n<li>  row (默认值) :行排布。在 ltr (left to right， 从左到右)排版方式下，flex 项从左到右排列，在 rtl (right to left， 从右到左)排版方式下，flex 项从右到左排列。</li>\n<li>  row-reverse: 反向行排布，即 row 的反方向，在 ltr 中从右向左，在 rtl 中从左到右。</li>\n<li>  column: 列排布，与 row 相似，但是 flex 项从上到下排布。</li>\n<li>  column-reverse: 反向列排布，即 column 反方向，与 row-reverse 相似，只是 flex 项从上到下排布。</li>\n</ul>\n<h3 id=\"flex-wrap\"><a href=\"#flex-wrap\" class=\"headerlink\" title=\"flex-wrap\"></a>flex-wrap</h3><p><img src=\"http://file.w3cbest.com/file/images/flex-wrap.svg\"> 默认情况下，flex 项会尽可能地尝试排在同一行上（行或列），通过设置 flex-wrap 来决定 flex 项是否允需要换行。</p>\n<p>.container{<br>  flex-wrap: nowrap  wrap  wrap-reverse;<br>}</p>\n<ul>\n<li>  nowrap (默认值) : 所有的 flex 项都会在同一行上排布，也就是我们常说的单行，或不换行。</li>\n<li>  wrap: flex 项将从上到下根据实际情况排布再多行上，也就是我们常说的多行，或会换行。</li>\n<li>  wrap-reverse: flex 项将 从下到上 根据实际情况排布再多行上折行。</li>\n</ul>\n<h2 id=\"下面有个演示\"><a href=\"#下面有个演示\" class=\"headerlink\" title=\"下面有个演示\"></a>下面有个演示</h2><ul>\n<li>  红色列表设置为 nowrap</li>\n<li>  黄色列表设置为 wrap</li>\n<li>  蓝色列表设置为 wrap-reverse</li>\n</ul>\n<blockquote>\n<p>注意：将flex-direction的默认值设置为：row。</p>\n</blockquote>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/omvbEx/\">Flex-wrap: demo</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h3 id=\"flex-flow-（适用于父级-flex-容器）\"><a href=\"#flex-flow-（适用于父级-flex-容器）\" class=\"headerlink\" title=\"flex-flow （适用于父级 flex 容器）\"></a>flex-flow （适用于父级 flex 容器）</h3><p>这是 flex-direction 和 flex-wrap 属性的缩写形式。同时定义 flex 容器的主轴和交叉轴。默认是 row nowrap。</p>\n<p>flex-flow: &lt;’flex-direction’&gt;  &lt;’flex-wrap’&gt;</p>\n<h3 id=\"justify-content\"><a href=\"#justify-content\" class=\"headerlink\" title=\"justify-content\"></a>justify-content</h3><p><img src=\"http://file.w3cbest.com/file/images/justify-content.svg\"> justify-content 属性定义了flex 项沿主轴方向的对齐方式。 当一行中的所有 flex 项都是固定大小，或者是灵活大小但已经达到最大 main size 时，它可以帮助分配主轴上的剩余空间。当 flex 项溢出主轴的时候，它还可以用来控制flex 项的对齐方式。</p>\n<p>.container {<br>  justify-content: flex-start  flex-end  center  space-between  space-around  space-evenly;<br>}</p>\n<ul>\n<li>  flex-start (默认值) : flex 项从主轴的开始位置（main-start）开始排布。</li>\n<li>  flex-end : flex 项从主轴的结束位置（main-end）开始排布</li>\n<li>  center: flex 项沿主轴居中排布。</li>\n<li>  space-between: flex 项沿主轴均匀排布，即我们常说的沿主轴 两端对齐 ，第一个flex 项在主轴开始位置，最后一个flex 项在主轴结束位置。</li>\n<li>  space-around: flex 项沿主轴均匀排布。要注意的是 flex 项看起来间隙是不均匀的，因为所有 flex 项两边的空间是相等的。第一项在容器边缘有一个单位的空间，但是在两个 flex 项之间有两个单位的间隙，因为每个 flex 项的两侧都有一个单位的间隙。</li>\n<li>  space-evenly: 任何两个 flex 项之间的间距（以及到 flex 容器边缘的空间）相等。</li>\n</ul>\n<h3 id=\"align-items\"><a href=\"#align-items\" class=\"headerlink\" title=\"align-items\"></a>align-items</h3><p><img src=\"http://file.w3cbest.com/file/images/align-items.svg\"> align-items 定义了 flex 项如何沿当前行在交叉轴上排布的默认行为。可以将其视为交叉轴（垂直于主轴）上的对齐方式。</p>\n<p>.container {<br>  align-items: flex-start  flex-end  center  baseline  stretch;<br>}</p>\n<ul>\n<li>  flex-start: flex 项按照交叉轴的开始位置（cross-start）对齐。</li>\n<li>  flex-end: flex 项按照交叉轴的结束位置（cross-end）对齐。</li>\n<li>  center: flex 项以交叉轴为中心，居中对齐。</li>\n<li>  baseline: flex 项按照他们的文字基线对齐。</li>\n</ul>\n<p>stretch (默认值) : 拉伸 flex 项以填充整个容器（这里特别要注意：如果 flex 项有尺寸属性（min-width / max-width / width / min-height / max-height / height），那么首先应用这些尺寸属性。）</p>\n<h3 id=\"align-content\"><a href=\"#align-content\" class=\"headerlink\" title=\"align-content\"></a>align-content</h3><p><img src=\"http://file.w3cbest.com/file/images/align-content.svg\"> 当交叉轴上有剩余空间时，align-content 可以设置 flex 容器中的 行 在交叉轴上如何分配剩余空间，类似于 justify-content 在主轴上对齐单个 flex 项的方式。</p>\n<blockquote>\n<p>注意：当只有一行 flex 项时，此属性不起作用。</p>\n</blockquote>\n<p>.container {<br>  align-content: flex-start  flex-end  center  space-between  space-around  stretch;<br>}</p>\n<ul>\n<li>  flex-start：多行在容器的开始位置排布</li>\n<li>  flex-end：多行在容器的结束位置排布</li>\n<li>  center：多行在容器的总结位置排布</li>\n<li>  space-between：多行均匀分布；第一行分布在容器的开始位置，最后一行分布在容器的结束位置</li>\n<li>  space-around: 多行均匀分布，并且每行的间距（包括离容器边缘的间距）相同；</li>\n<li>  strech (默认值)：多行拉伸以填充满整个剩余空间</li>\n</ul>\n<h2 id=\"flex-项子属性-flex-items\"><a href=\"#flex-项子属性-flex-items\" class=\"headerlink\" title=\"flex 项子属性(flex items)\"></a>flex 项子属性(flex items)</h2><p><img src=\"http://file.w3cbest.com/file/images/02-items.svg\"></p>\n<h3 id=\"order\"><a href=\"#order\" class=\"headerlink\" title=\"order\"></a>order</h3><p><img src=\"http://file.w3cbest.com/file/images/order.svg\"> 默认情况下，flex 项按源（HTML结构）顺序排布。但是，order 属性可以控制它们在 flex 容器中的显示顺序。</p>\n<p>.item {<br>  order: <integer>;  /* 默认值是 0 */<br>}</p>\n<h3 id=\"flex-grow\"><a href=\"#flex-grow\" class=\"headerlink\" title=\"flex-grow\"></a>flex-grow</h3><p><img src=\"http://file.w3cbest.com/file/images/flex-grow.svg\"> flex-grow 定义了 flex 项在有可用剩余空间时拉伸比例。它接受的值作为比例，无单位。它规定了 flex 项应该占 flex 容器中可用空间的比例。 如果所有 flex 项的 flex-grow 都设置为 1 ，则父容器中的剩余空间将平均分配给所有子项。 如果其中一个子项的值为 2 ，则该子项占用的剩余空间是其他子项的两倍（或者至少会尽力获得）。</p>\n<p>.item {<br>  flex-grow: <number>; /* default 0 */<br>}</p>\n<blockquote>\n<p>注：负值对于 flex-grow 无效。</p>\n</blockquote>\n<h3 id=\"flex-shrink\"><a href=\"#flex-shrink\" class=\"headerlink\" title=\"flex-shrink\"></a>flex-shrink</h3><p>flex-shrink 定义了 flex 项的收缩的能力。（愚人码头注：与 flex-grow 拉伸正好相反，flex-shrink 决定 flex 项允许收缩多少比例。）</p>\n<p>.item {<br>  flex-shrink: <number>; /* default 1 */<br>}</p>\n<blockquote>\n<p>注：负值对于 flex-shrink 无效。</p>\n</blockquote>\n<h3 id=\"flex-basis\"><a href=\"#flex-basis\" class=\"headerlink\" title=\"flex-basis\"></a>flex-basis</h3><p>flex-basis 定义了在分配剩余空间之前 flex 项默认的大小。可以设置为某个长度值（e.g. 20%, 5rem,等）或者关键字。关键字 auto 意味着 flex 项会按照其本来的大小显示（暂时由 main-size 关键字完成，直到弃用）。关键字 content 意味着根据内容来确定大小——这个关键字到目前没有被很好地支持，所以测试起来比较困难，与content的类似的关键字还有max-content, min-content, fit-content。</p>\n<p>.item {<br>  flex-basis: <length>  auto; /* default auto */<br>}</p>\n<p>如果设置为 0 , 则 flex 项内容周围的空隙不会根据 flex-grow 按比例分配，如果设置为 auto，则 flex 项周围额外的空袭会根据 flex-grow 按照比例分配，如下图： <img src=\"http://file.w3cbest.com/file/images/rel-vs-abs-flex.svg\"></p>\n<h3 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h3><p>flex 是 flex-grow、flex-shrink、flex-basis 三个属性的缩写。其中第二个和第三个参数(flex-shrink 和 flex-basis)是可选的。默认值为0 1 auto。</p>\n<p>.item {<br>  flex: none  [ &lt; ‘flex-grow’&gt; &lt; ‘flex-shrink’&gt;?  &lt; ‘flex-basis’&gt; ]<br>}</p>\n<p>推荐使用缩写形式而不是单独地设置每一个属性，缩写形式中会更加智能地计算出相关值。</p>\n<h3 id=\"align-self\"><a href=\"#align-self\" class=\"headerlink\" title=\"align-self\"></a>align-self</h3><p><img src=\"http://file.w3cbest.com/file/images/align-self.svg\"> align-self 属性允许某个单独的 flex 项覆盖默认的对齐方式（或由 align-items 指定的对齐方式）。 具体的属性值得含义可以参考 align-items的解释。</p>\n<p>.item {<br>  align-self: auto  flex-start  flex-end  center  baseline  stretch;<br>}</p>\n<blockquote>\n<p>注：float,clear和vertical-align 对 flex 项没有任何作用。</p>\n</blockquote>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>我们从一个非常非常简单的例子开始，解决一个几乎每天会遇到的问题：水平垂直居中。如果使用flexbox 布局会非常简单。</p>\n<p>.parent {<br>  display: flex;<br>  height: 300px; /* 随意设定大小 */<br>}<br>.child {<br>  width: 100px;  /* 随意设定大小，比父元素要小 */<br>  height: 100px; /* 同上 */<br>  margin: auto;  /* 见证奇迹的时刻 */<br>}</p>\n<p>这依赖于在 flex 容器中设置 margin 为 auto 会自动吸收额外空间。 因此，设置水平垂直的margin都为 auto 会使flex 项在水平垂直方向上都完美居中。 现在我们考虑用更多的属性。考虑有 6 个有固定的尺寸的 flex 项，但是我们希望他们能够在改变浏览器宽度的时候仍然可以在水平轴上完美地显示（没有使用媒体查询（media queries））。</p>\n<p>.flex-container {<br>  /* 首先我们先创建一个flex布局上下文 */<br>  display: flex;</p>\n<p>  /* 然后我们定义flex方向和是否允许flex 项换行<br>   * 注意这与以下代码等价：<br>   * flex-direction: row;<br>   * flex-wrap: wrap;<br>   */<br>  flex-flow: row wrap;</p>\n<p>  /* 然后我们定义在剩余空间上flex 项如何排布 */<br>  justify-content: space-around;<br>}</p>\n<p>完成。剩下的就是一些其他样式如颜色的设置了。下面是在 CodePen 中实现的这个例子。一定要去CodePen，并尝试调整你的窗口看看会发生什么。</p>\n<p>See the Pen <a href=\"https://codepen.io/team/css-tricks/pen/EKEYob/\">Demo Flexbox 1</a> by CSS-Tricks (<a href=\"https://codepen.io/css-tricks\">@css-tricks</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>让我们再尝试一些别的东西。假设我们有一个向右对齐的导航栏在我们网页的最上端，但是我们希望它在中屏上显示时为居中，在小屏上显示为单列。同样使用flex布局，实现起来会很简单。</p>\n<p>/* 大屏 */<br>.navigation {<br>  display: flex;<br>  flex-flow: row wrap;<br>  /* 这里设置对齐主轴方向的末端 */<br>  justify-content: flex-end;<br>}</p>\n<p>/* 中屏 */<br>@media all and (max-width: 800px) {<br>  .navigation {<br>    /* 当在中屏上，设置居中，并设置剩余空间环绕在flex 项左右 */<br>    justify-content: space-around;<br>  }<br>}</p>\n<p>/* 小屏 */<br>@media all and (max-width: 500px) {<br>  .navigation {<br>    /* 在小屏上，我们不在使用行作为主轴，而以列为主轴 */<br>    flex-direction: column;<br>  }<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/team/css-tricks/pen/YqaKYR/\">Demo Flexbox 2</a> by CSS-Tricks (<a href=\"https://codepen.io/css-tricks\">@css-tricks</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>我们通过灵活使用 flexbox 布局尝试一些更好玩的布局。来做一个移动优先的 3 列布局并带有全屏宽的header和footer。</p>\n<p>.wrapper {<br>  display: flex;<br>  flex-flow: row wrap;<br>}</p>\n<p>/* 我们要告诉所有的flex 项宽度 100% */<br>.wrapper &gt; * {<br>  flex: 1 100%;<br>}</p>\n<p>/* 移动优先依赖于源代码默认的渲染顺序<br> * in this case:<br> * 1. header<br> * 2. nav<br> * 3. main<br> * 4. aside<br> * 5. footer<br> */</p>\n<p>/* 中屏 */<br>@media all and (min-width: 600px) {<br>  /* 我们要告诉两边的sidebar共享一个行 */<br>  .aside { flex: 1 auto; }<br>}</p>\n<p>/* 大屏幕 */<br>@media all and (min-width: 800px) {<br>  /* 通过order设定各个面板的渲染顺序<br>   * 告诉主要面板元素占用侧栏两倍的空间<br>   */<br>  .main { flex: 2 0px; }</p>\n<p>  .aside-1 { order: 1; }<br>  .main    { order: 2; }<br>  .aside-2 { order: 3; }<br>  .footer  { order: 4; }<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/chriscoyier/pen/vWEMWw/\">Demo Flexbox 3</a> by Chris Coyier (<a href=\"https://codepen.io/chriscoyier\">@chriscoyier</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"浏览器前缀\"><a href=\"#浏览器前缀\" class=\"headerlink\" title=\"浏览器前缀\"></a>浏览器前缀</h2><p>Flexbox 布局需要一些浏览器前缀来最大力度地兼容大多数的浏览器。Flex布局的前缀不只是在属性前面添加浏览器前缀，不同浏览器下的属性名和属性值都不同，这是因为Flexbox布局的标准一直在变，一共有 “old”, “tweener”, 和 “new” 三个版本。 可能处理前缀的最好方法是使用新的语法书写CSS并通过 Autoprefixer 运行CSS，能够很好地处理这个问题。 另外，这里有一个Sass中 @mixin 来处理一些前缀，也可以给你一些处理前缀的启发：</p>\n<p>@mixin flexbox() {<br>  display: -webkit-box;<br>  display: -moz-box;<br>  display: -ms-flexbox;<br>  display: -webkit-flex;<br>  display: flex;<br>}</p>\n<p>@mixin flex($values) {<br>  -webkit-box-flex: $values;<br>  -moz-box-flex:  $values;<br>  -webkit-flex:  $values;<br>  -ms-flex:  $values;<br>  flex:  $values;<br>}</p>\n<p>@mixin order($val) {<br>  -webkit-box-ordinal-group: $val;<br>  -moz-box-ordinal-group: $val;<br>  -ms-flex-order: $val;<br>  -webkit-order: $val;<br>  order: $val;<br>}</p>\n<p>.wrapper {<br>  @include flexbox();<br>}</p>\n<p>.item {<br>  @include flex(1 200px);<br>  @include order(2);<br>}</p>\n<p>相关属性</p>\n<ul>\n<li>  <a href=\"//css-tricks.com/snippets/css/complete-guide-grid/\">网格完整指南</a></li>\n<li>  网格属性上的年历条目，如<a href=\"https://css-tricks.com/almanac/properties/g/grid-row-column/\">网格行/网格列</a></li>\n</ul>\n<p>其他资源</p>\n<ul>\n<li>  <a href=\"http://www.w3.org/TR/css3-flexbox/\">CSS规范中的Flexbox</a></li>\n<li>  <a href=\"https://developer.mozilla.org/en-US/docs/CSS/Tutorials/Using_CSS_flexible_boxes\">MDN上的Flexbox</a></li>\n<li>  <a href=\"http://dev.opera.com/articles/view/flexbox-basics/\">Opera的Flexbox</a></li>\n<li>  <a href=\"http://weblog.bocoup.com/dive-into-flexbox/\">通过Bocoup潜入Flexbox</a></li>\n<li>  <a href=\"/using-flexbox/\">混合语法以获得CSS-Tricks上的最佳浏览器支持</a></li>\n<li>  <a href=\"http://www.alsacreations.com/tuto/lire/1493-css3-flexbox-layout-module.html\">Flexhael by Raphael Goetter（FR）</a></li>\n<li>  <a href=\"http://bennettfeely.com/flexplorer/\">Bennett Feely的Flexplorer</a></li>\n</ul>\n<h2 id=\"Bugs\"><a href=\"#Bugs\" class=\"headerlink\" title=\"Bugs\"></a>Bugs</h2><p>我见过的最棒的flexbox bug总结是Philip Walton 和 Greg Whitworth的<a href=\"https://github.com/philipwalton/flexbugs\">Flexbugs</a>，是开源的，你可以在上面跟踪动态。</p>\n<h2 id=\"浏览器支持\"><a href=\"#浏览器支持\" class=\"headerlink\" title=\"浏览器支持\"></a>浏览器支持</h2><ul>\n<li>  首先看一下 flexbox 布局的三个版本</li>\n<li>  (new)是指标准中最近的语法(e.g. display:flex;)。</li>\n<li>  (tweener)是指2011年以后非官方的临时版本(e.g. display:flexbox;)。</li>\n<li>  (old)是指2009年以后的旧语法(e.g. display:box;)</li>\n</ul>\n<p>复制代码</p>\n<h2 id=\"Blackberry-browser-10-支持新语法。\"><a href=\"#Blackberry-browser-10-支持新语法。\" class=\"headerlink\" title=\"Blackberry browser 10+ 支持新语法。\"></a>Blackberry browser 10+ 支持新语法。</h2><p>更多混合使用语法达到最佳浏览器兼容，可以参考 <a href=\"https://css-tricks.com/using-flexbox/\">这篇文章 (CSS-Tricks)</a> 或者 <a href=\"http://dev.opera.com/articles/view/advanced-cross-browser-flexbox/#fallbacks\">这篇文章(DevOpera)</a>。 原文链接：<a href=\"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\">https://css-tricks.com/</a></p>\n","categories":["HTML/CSS"],"tags":["css","css3","flex","flexbox","align-content","align-items","align-self","flex container","flex item","flex-basis","flex-direction","flex-flow","flex-grow","flex-shrink","flex-wrap","flex布局","justify-content","order","place-content","对齐方式","布局拉伸","排列方向","收缩"]},{"title":"for..in与for..of循环对比","url":"/2019/05/02/for-in%E4%B8%8Efor-of%E5%BE%AA%E7%8E%AF%E5%AF%B9%E6%AF%94/","content":"<p>Javascript中最基本的迭代方法是<code>for</code>循环。它需要三个表达式：变量声明、在每次迭代之前要计算的表达式以及在每次迭代结束时要计算的表达式。例如，这个<code>for</code>循环将<code>console.log</code>数组中的每个项。</p>\n<p>const array = [‘a’, ‘b’, ‘c’, ‘d’];<br>for (let i = 0; i &lt; array.length; i++) {<br>console.log(array[i]);<br>}<br>// Result: a, b, c, d</p>\n<p>除了<code>for</code>循环之外，我们还可以使用另外两种<code>for</code>迭代方法：<code>for..in</code>和<code>for..of</code>。</p>\n<h2 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for..in\"></a>for..in</h2><p><code>for..in</code>是一种迭代对象的“可枚举”属性的方法。因此，它适用于所有具有这些属性的对象(不仅是<code>object()</code>)。 可枚举属性定义为可枚举值为<code>true</code>的对象的属性。从本质上讲，如果一个属性是可枚举的，它就是“可枚举的”。我们可以通过调用<code>property.Enumerable</code>来检查属性是否可枚举，它将返回<code>true</code>或<code>false</code>。 我们使用<code>for..in</code>循环与以下语法一起使用</p>\n<p>for (variable in enumerable) {<br>// do stuff<br>}</p>\n<p>例如，要循环遍历<code>console.log</code>此<code>Object</code>中的所有值，我们可以执行以下操作 -</p>\n<p>const obj = {<br>a: 1,<br>b: 2,<br>c: 3,<br>d: 4<br>}<br>for (const key in obj) {<br>console.log( obj[key] )<br>}</p>\n<p><code>for…in</code>循环也将迭代继承的属性，只要它们是可枚举的属性。<code>for…in</code>迭代以任意顺序发生。因此，如果需要按照定义的顺序发生，则不应使用它。</p>\n<h3 id=\"for-in-和-Object\"><a href=\"#for-in-和-Object\" class=\"headerlink\" title=\"for..in 和 Object\"></a>for..in 和 Object</h3><p><code>for..in</code>方法为我们提供了循环对象键和值的最简单方法，因为对象不能访问数组所使用的<code>forEach</code>方法。</p>\n<h3 id=\"for-in-和-Array\"><a href=\"#for-in-和-Array\" class=\"headerlink\" title=\"for..in 和 Array\"></a>for..in 和 Array</h3><p>数组中值的“键”是数字索引。因此，这些索引本质上只是可枚举的属性，就像<code>Object</code>键一样，只是它们是整数而不是字符串。 这意味着我们可以通过使用<code>for..in</code>来检索数组中的索引来循环数组中的所有值。</p>\n<p>const array = [‘a’, ‘b’, ‘c’, ‘d’];</p>\n<p>for (const index in array) {<br>console.log(array[index])<br>}</p>\n<p>// Result: a, b, c, d</p>\n<p>但是，一般建议不要将<code>for..in</code>与数组一起使用，特别是因为不能保证迭代按顺序进行，这通常对数组很重要。</p>\n<h3 id=\"for-in-和-String\"><a href=\"#for-in-和-String\" class=\"headerlink\" title=\"for..in 和 String\"></a>for..in 和 String</h3><p>字符串中的每个字符都有一个索引。因此，与<code>Array</code>类似，索引是可枚举的属性，恰好是整数。</p>\n<p>const string = ‘Ire Aderinokun’;</p>\n<p>for (const index in string) {<br>console.log(string[index])<br>}</p>\n<p>// Result: I, r, e, , A, d, e, r, i, n, o, k, u, n</p>\n<h2 id=\"for-of\"><a href=\"#for-of\" class=\"headerlink\" title=\"for..of\"></a>for..of</h2><p><code>for..of</code>是在ES2015中引入的一种方法，用于迭代“iterable collections”。这些对象具有<code>[symbol.iterator]</code>属性。 <code>[symbol.iterator]</code>属性允许我们通过调用<code>[symbol.iterator]().next()</code>方法来检索集合中的下一项，从而手动迭代集合。</p>\n<p>const array = [‘a’,’b’,’c’, ‘d’];<br>const iterator = array[Symbol.iterator]();<br>console.log( iterator.next().value )<br>console.log( iterator.next().value )<br>console.log( iterator.next().value )<br>console.log( iterator.next().value )</p>\n<p>// Result: a, b, c, d</p>\n<p><code>for..of</code>语法实质上是围绕<code>[symbol.iterator]</code>的包装，以创建循环。它使用以下语法-</p>\n<p>for (variable of iterable) {<br>// do stuff<br>}</p>\n<h3 id=\"for-of-和-Object\"><a href=\"#for-of-和-Object\" class=\"headerlink\" title=\"for..of 和 Object\"></a>for..of 和 Object</h3><p><code>for..of</code>循环不适用于对象，因为他们不是“迭代”，因此不具有<code>[Symbol.iterator]</code>属性。</p>\n<h3 id=\"for-of-和-Array-String\"><a href=\"#for-of-和-Array-String\" class=\"headerlink\" title=\"for..of 和 Array/String\"></a>for..of 和 Array/String</h3><p><code>for..of</code>循环使用数组和字符串的效果很好，因为它们是可迭代。此这种方法是一种更可靠的循环遍历数组的方法。</p>\n<p>const array = [‘a’, ‘b’, ‘c’, ‘d’];<br>for (const item of array) {<br>console.log(item)<br>}<br>// Result: a, b, c, d</p>\n<p>const string = ‘Ire Aderinokun’;<br>for (const character of string) {<br>console.log(character)<br>}<br>// Result: I, r, e, , A, d, e, r, i, n, o, k, u, n</p>\n<h3 id=\"for-of-和-NodeLists\"><a href=\"#for-of-和-NodeLists\" class=\"headerlink\" title=\"for..of 和 NodeLists\"></a>for..of 和 NodeLists</h3><p>最后，另一个非常有用的案例<code>for..of</code>是迭代<code>NodeLists</code>。当我们在文档中查询一组元素时，返回的是<code>NodeList</code>，而不是<code>Array</code>。这意味着我们不能使用<code>forEach</code>等数组方法对列表进行迭代。 为了解决这个问题，我们可以使用<code>Array.from()</code>或者使用<code>for..of</code>循环将其转换为数组，这不仅仅适用于数组。</p>\n<p>const elements = document.querySelectorAll(‘.foo’);</p>\n<p>for (const element of elements) {<br>    element.addEventListener(‘click’, doSomething);<br>}</p>\n<h2 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h2><p><code>for..in</code></p>\n<p><code>for..of</code></p>\n<p>适用于</p>\n<p>可枚举属性</p>\n<p>无法检索的集合</p>\n<p>与Object一起使用?</p>\n<p>Yes</p>\n<p>No</p>\n<p>与Array一起使用?</p>\n<p>Yes, 不建议</p>\n<p>Yes</p>\n<p>与String一起使用?</p>\n<p>Yes, 不建议</p>\n<p>Yes</p>\n","categories":["JavaScript"],"tags":["array()","javascript教程","for","for..in","for..of","Object"]},{"title":"http和https的区别, get和post的区别, cookie、sessionStorage、localStorage的区别","url":"/2020/07/20/get%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA%E3%80%81get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E5%9C%A8%E7%BC%93%E5%AD%98%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<h2 id=\"1，http和https的区别\"><a href=\"#1，http和https的区别\" class=\"headerlink\" title=\"1，http和https的区别\"></a>1，http和https的区别</h2><p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。主要的区别如下：</p>\n<ul>\n<li>Https协议需要ca证书，费用较高。</li>\n<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>\n<li>使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443</li>\n<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>\n</ul>\n<h2 id=\"2，get请求传参长度的误区、get和post请求在缓存方面的区别\"><a href=\"#2，get请求传参长度的误区、get和post请求在缓存方面的区别\" class=\"headerlink\" title=\"2，get请求传参长度的误区、get和post请求在缓存方面的区别\"></a>2，get请求传参长度的误区、get和post请求在缓存方面的区别</h2><p>误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。</p>\n<p>实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:</p>\n<ul>\n<li>HTTP 协议 未规定 GET 和POST的长度限制</li>\n<li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li>\n<li>不同的浏览器和WEB服务器，限制的最大长度不一样</li>\n<li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</li>\n</ul>\n<h4 id=\"补充补充一个get和post在缓存方面的区别：\"><a href=\"#补充补充一个get和post在缓存方面的区别：\" class=\"headerlink\" title=\"补充补充一个get和post在缓存方面的区别：\"></a>补充补充一个get和post在缓存方面的区别：</h4><ul>\n<li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li>\n<li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li>\n</ul>\n<h2 id=\"3-cookie、sessionStorage、localStorage的区别\"><a href=\"#3-cookie、sessionStorage、localStorage的区别\" class=\"headerlink\" title=\"3,cookie、sessionStorage、localStorage的区别\"></a>3,cookie、sessionStorage、localStorage的区别</h2><p>共同点：都是保存在浏览器端，并且是同源的</p>\n<ul>\n<li>Cookie：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。（key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右）</li>\n<li>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）</li>\n<li>localStorage：localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）</li>\n</ul>\n<h4 id=\"补充说明一下cookie的作用：\"><a href=\"#补充说明一下cookie的作用：\" class=\"headerlink\" title=\"补充说明一下cookie的作用：\"></a>补充说明一下cookie的作用：</h4><p>保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。</p>\n<p>跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便</p>\n<p>定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。</p>\n","tags":["http","https","get","post"]},{"title":"HTML语法","url":"/2019/01/24/html%E8%AF%AD%E6%B3%95/","content":"<h2 id=\"什么是HTML？\"><a href=\"#什么是HTML？\" class=\"headerlink\" title=\"什么是HTML？\"></a>什么是HTML？</h2><p>超文本标记语言，标准通用标记语言下的一个应用。是 网页制作必备的编程语言 “超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。 超文本标记语言的结构包括“头”部分（英语：Head）、和“主体”部分（英语：Body），其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。 摘自:<a href=\"https://baike.baidu.com/item/HTML\">百度百科</a></p>\n<h3 id=\"简短一点\"><a href=\"#简短一点\" class=\"headerlink\" title=\"简短一点\"></a>简短一点</h3><p>HTML 是用来描述网页的一种语言。</p>\n<ul>\n<li>  HTML 指的是超文本标记语言 (Hyper Text Markup Language)</li>\n<li>  HTML 不是一种编程语言，而是一种标记语言 (markup language)</li>\n<li>  标记语言是一套标记标签 (markup tag)</li>\n<li>  HTML 使用标记标签来描述网页</li>\n</ul>\n<p>我们将在本文中学习HTML语法… HTML的构建块称为元素，元素的构建块称为标记。当它们组合在一起时，就形成了一个网站——有点像原子和亚原子粒子（HTML元素当然与科学元素无关，只是我的一个奇怪的比喻）。我们开始吧！</p>\n<h2 id=\"HTML元素-Elements\"><a href=\"#HTML元素-Elements\" class=\"headerlink\" title=\"HTML元素 (Elements)\"></a>HTML元素 (Elements)</h2><p>现在，我将向你们展示一些代码，不要恐慌。你不必理解这一切意味着什么，我将在下面解释:</p>\n<h1>Blog Posts.</h1>\n<div class=\"controls\">\n    <input type=\"number\" id=\"first\" placeholder=\"First\" oninput=\"inputsChanged()\">\n    <input type=\"number\" id=\"last\" placeholder=\"Last\" oninput=\"inputsChanged()\">\n</div>\n<span class=\"total-word-count\"><b>Total Word Count:</b> <span id=\"word-count\">0000</span></span>\n<table>\n    <tbody>\n        <tr>\n            <th>Post number</th>\n            <th>Post Date</th>\n            <th>Post Name</th>\n            <th>Word count</th>\n        </tr>\n        <tr>\n            <td class=\"post-num\">#1</td>\n            <td class=\"post-date\">2019年01月24日(星期四)</td>\n            <td class=\"post-title\"><a href=\"http://www.w3cbest.com/\" target=\"\\_blank\">Welcome to W3C前端开发!</a></td>\n            <td class=\"post-words\">1373</td>\n        </tr>\n    </tbody>\n</table>\n\n<p>看到了吗?你活下来了(我希望)。首先，不要担心这些意味着什么——我们现在只关心结构。 元素基本上是一些内容(文本)，由HTML标记包围(稍后我将详细介绍)。标签告诉浏览器里面有什么。例如，<code>&lt;h1&gt;Blog Posts。&lt;/h1&gt;</code>告诉浏览器“Blog Posts”。是h1元素——标题的一种类型。您不需要记住这一点，我将在后面的文章中详细介绍。 元素引用内容和两个标签。这是一个元素的例子:</p>\n<td class=\"post-num\">#1</td>\n\n<p>元素可以彼此嵌套。嵌套元素时，通常最好将元素放在新行上，并正确地缩进。也有一些例外，比如</p>\n<td class=\"post-title\"><a href=\"http://www.w3cbest.com/\" target=\"\\_blank\">Welcome to W3C前端开发!</a></td>\n\n<p>请注意，将嵌套元素放在新行中并不是强制的，它们只是我们所谓的良好代码实践。好的代码实践有点像编程的礼仪。好的代码实践的目的是使您的代码更容易阅读，更容易让其他人理解(在大型项目中进行协作时，这一点尤为重要)。 另一个元素中的元素称为子元素。类似地，一个元素的周围元素称为它的父元素。在上面的例子中，<code>&lt;th&gt;Post number&lt;/th&gt;</code>，是<code>&lt;tr&gt;</code>的子元素，<code>tr&gt;</code>是<code>&lt;tbody&gt;</code>的子元素，<code>&lt;tbody&gt;</code>是<code>&lt;table&gt;</code>的子元素。我们可以把它表示为:</p>\n<p>table &gt; tbody &gt; tr &gt; th</p>\n<p>注意，这不是代码。这是一种简单的可视化元素之间嵌套方式。</p>\n<h2 id=\"HTML标签（Tags）\"><a href=\"#HTML标签（Tags）\" class=\"headerlink\" title=\"HTML标签（Tags）\"></a>HTML标签（Tags）</h2><p>如前所述，标签是围绕内容的代码位，例如:</p>\n<p class=\"test\"> ... </p>\n\n<p>标签总是包含<code>&lt;&gt;</code>中。</p>\n<h2 id=\"类型标签-Type-tags\"><a href=\"#类型标签-Type-tags\" class=\"headerlink\" title=\"类型标签(Type tags)\"></a>类型标签(Type tags)</h2><p>标签分为两类:开始标签和结束标签。请看下面的例子: <img src=\"http://file.w3cbest.com/file/images/tag-structure-1.jpg\"> 开始标签总是遵循<code>&lt;x&gt;</code>的基本模式，其中x是元素的类型(例如，<code>&lt;h1&gt;</code>)。开始标签也可以有属性(我们马上会讲到)。每个元素至少必须有一个开始标签。 结束标签是在元素内容之后出现的标签。它们总是遵循<code>&lt;/x&gt;</code>的模式，其中x又是元素的类型。<code>&lt;/h1&gt;</code>)。结束标签看起来总是一样的(当然元素名除外)，不能有属性。 如果元素中没有任何内容，它就不需要关闭标签。举个例子:</p>\n<img src=\"/file/images/tag-structure-1.jpg\">\n\n<p>因为它没有内容(只有属性)，所以不需要<code>&lt;/img&gt;</code>关闭标签。</p>\n<h2 id=\"属性（Attributes）\"><a href=\"#属性（Attributes）\" class=\"headerlink\" title=\"属性（Attributes）\"></a>属性（Attributes）</h2><p>元素除了具有内容外，还可以具有属性。属性存储关于元素的其他数据，并存储在开始标签中。例如:</p>\n<h1>W3C前端开发</h1>\n\n<p>在这里，我们只知道它是一个<code>&lt;h1&gt;</code>元素。现在，当我们添加属性时是这样的:</p>\n<h1 id=\"code-the-web-title\" class=\"banner-title\" onclick=\"titleClicked()\">W3C前端开发</h1>\n\n<p>现在我们知道了更多关于元素的信息。我们知道它是id和class(用于使用CSS对其进行样式化)，还知道在单击它时运行JavaScript函数<code>titleClicked()</code>(我们将在稍后详细讨论)。如您所见，属性可以告诉我们关于元素的更多信息。属性的语法是:</p>\n<h1 attribute=\"value\" otherattribute=\"othervalue\">\n\n<p>引号是非常重要的，所以不要忘记它们!还要注意等号两边都没有空格(但是属性之间必须有空格)。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>让我们把我们所知道的HTML标签和元素整合到这个图表中: <img src=\"http://file.w3cbest.com/file/images/tag-structure-2.jpg\"> 唷。这可能有点令人困惑，但最终你会掌握它的窍门。如果你有什么不明白的地方，你可以在评论中问我。如果你喜欢这篇文章，不要忘记和你的朋友分享，下次我会讲到HTML网站的一般结构。</p>\n","categories":["HTML/CSS"],"tags":["html","html5","html教程","前端开发","前端教程"]},{"title":"JavaScript Class 类的私有和公共属性","url":"/2018/11/08/javascript-class-%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%AC%E5%85%B1%E5%B1%9E%E6%80%A7/","content":"<blockquote>\n<p>本文为<a href=\"http://www.w3cbest.com/720.html\">JavaScript Prototype(原型) 初学者指南</a>续篇。</p>\n</blockquote>\n<p>我最喜欢的 JavaScript 社区的一部分原因是每个人似乎总是问 “为什么？” 。 为什么我们要按照这种方式做事？ 一般来说，这个问题的答案需要充满理性和回顾历史背景。 但有时，答案往往更简单 – “因为我们一直以来都是这么做的。” 在 <a href=\"http://www.w3cbest.com/720.html\">上一篇文章</a> 中，我们学习了如何在 ES5 和 ES6 中创建 JavaScript 类。 我们还讨论了如何通过构造函数向这些类的实例添加 state(状态) ，以及如何通过类的原型在实例之间共享方法。 这是一个简单的 Player 类，它包含了我们讨论的有关 ES6 类的所有内容。</p>\n<p>class Player {<br>  constructor() {<br>    this.points = 0<br>    this.assists = 0<br>    this.rebounds = 0<br>    this.steals = 0<br>  }<br>  addPoints(amount) {<br>    this.points += amount<br>  }<br>  addAssist() {<br>    this.assists++<br>  }<br>  addRebound() {<br>    this.rebounds++<br>  }<br>  addSteal() {<br>    this.steals++<br>  }<br>}</p>\n<p>我们看看这段代码，我们能不能让它更直观一点呢？方法很好理解，都很自然。那么构造函数呢？什么是 constructor ？为什么我们必须在这里定义实例值？现在，这些问题已经有了答案，但是为什么我们不能向实例中添加 state(状态) ，就像方法那样？比如：</p>\n<p>class Player {<br>  points = 0<br>  assists = 0<br>  rebounds = 0<br>  steals = 0<br>  addPoints(amount) {<br>    this.points += amount<br>  }<br>  addAssist() {<br>    this.assists++<br>  }<br>  addRebound() {<br>    this.rebounds++<br>  }<br>  addSteal() {<br>    this.steals++<br>  }<br>}</p>\n<p>事实上，这是 <a href=\"https://github.com/tc39/proposal-class-fields\">Class Fields Declaration</a> 提案的基础，该提案目前处于 TC-39 流程的 <a href=\"https://tylermcginnis.com/ecmascript/\">第3阶段</a> 。 此提议允许您直接将实例属性添加为类的属性，而无需使用构造方法。 非常漂亮，但是如果我们看一些 React 代码，这个提案真的很棒。 这是一个典型的 React 组件。 它具有本地 state(状态) ，一些方法以及一些静态属性被添加到类中。</p>\n<p>class PlayerInput extends Component {<br>  constructor(props) {<br>    super(props)<br>    this.state = {<br>      username: ‘’<br>    }</p>\n<pre><code>this.handleChange = this.handleChange.bind(this)\n</code></pre>\n<p>  }<br>  handleChange(event) {<br>    this.setState({<br>      username: event.target.value<br>    })<br>  }<br>  render() {<br>    …<br>  }<br>}</p>\n<p>PlayerInput.propTypes = {<br>  id: PropTypes.string.isRequired,<br>  label: PropTypes.string.isRequired,<br>  onSubmit: PropTypes.func.isRequired,<br>}</p>\n<p>PlayerInput.defaultProps = {<br>  label: ‘Username’,<br>}</p>\n<p>让我们看看新的 Class Fields 提议如何改进上面的代码首先，我们可以将 state(状态) 变量从构造函数中取出，并将其直接定义为类的属性（或“字段”）。</p>\n<p>class PlayerInput extends Component {<br>  state = {<br>    username: ‘’<br>  }<br>  constructor(props) {<br>    super(props)</p>\n<pre><code>this.handleChange = this.handleChange.bind(this)\n</code></pre>\n<p>  }<br>  handleChange(event) {<br>    this.setState({<br>      username: event.target.value<br>    })<br>  }<br>  render() {<br>    …<br>  }<br>}</p>\n<p>PlayerInput.propTypes = {<br>  id: PropTypes.string.isRequired,<br>  label: PropTypes.string.isRequired,<br>  onSubmit: PropTypes.func.isRequired,<br>}</p>\n<p>PlayerInput.defaultProps = {<br>  label: ‘Username’,<br>}</p>\n<p>很酷，但没什么好兴奋的。 我们继续吧。 在上一篇文章中，我们讨论了如何使用 static 关键字向类本身添加静态方法。 但是，根据 ES6 类规范，这只对方法有效，对于值则无效。 这就是为什么在上面的代码中，我们必须在我们定义完 PlayerInput 之后，再在 class 外面将 propTypes 和 defaultProps 添加到 PlayerInput ，而不是在 class 体内定义他们的原因。 再说一遍，它们不能像静态方法那样直接放入 class 体内呢? 好消息是，这也包含在 Class Fields 提案中。 所以现在不仅可以在类体中定义静态方法，还可以定义静态值。 这对我们的代码意味着我们可以将 propTypes 和 defaultProps 移动到 class 体内定义。</p>\n<p>class PlayerInput extends Component {<br>  static propTypes = {<br>    id: PropTypes.string.isRequired,<br>    label: PropTypes.string.isRequired,<br>    onSubmit: PropTypes.func.isRequired,<br>  }<br>  static defaultProps = {<br>    label: ‘Username’<br>  }<br>  state = {<br>    username: ‘’<br>  }<br>  constructor(props) {<br>    super(props)</p>\n<pre><code>this.handleChange = this.handleChange.bind(this)\n</code></pre>\n<p>  }<br>  handleChange(event) {<br>    this.setState({<br>      username: event.target.value<br>    })<br>  }<br>  render() {<br>    …<br>  }<br>}</p>\n<p>这样代码看上去好多了，但我们仍然有丑陋的 constructor 方法和 super 调用。 同样，我们现在需要构造函数的原因是为了将 handleChange 方法绑定到恰当的上下文中。 如果我们能找到另一种方法来确保始终在恰当的上下文中调用 handleChange ，那么我们可以摆脱掉 constructor 。 如果您以前使用过箭头函数，就会知道它们没有自己的 this 关键字。相反，this 关键字是按 lexically(词法) 绑定的。这是一种奇特的说法，当你在箭头函数中使用 this 关键字时，事情会按照你所期望的方式运行。利用这些知识并将其与 “Class Fields” 提案相结合起来，如果我们将 handleChange 方法替换为箭头函数呢？这看起来有点奇怪，但是通过这样做，我们可以解决绑定问题，因为，箭头函数是通过 lexically(词法) 绑定 this 的。</p>\n<p>class PlayerInput extends Component {<br>  static propTypes = {<br>    id: PropTypes.string.isRequired,<br>    label: PropTypes.string.isRequired,<br>    onSubmit: PropTypes.func.isRequired,<br>  }<br>  static defaultProps = {<br>    label: ‘Username’<br>  }<br>  state = {<br>    username: ‘’<br>  }<br>  handleChange = (event) =&gt; {<br>    this.setState({<br>      username: event.target.value<br>    })<br>  }<br>  render() {<br>    …<br>  }<br>}</p>\n<p>你看上面的代码，这比我们开始的原始类要好得多，这都要感谢 “Class Fields” 提案，它将很快成为 EcmaScript 规范的一部分。 从开发者体验的角度来看，Class Fields 提案优势很明显。 然而，他们有一些缺点，很少被谈论。 在上一篇文章中，我们讨论了 ES6 类实际上只是 Pseudoclassical Instantiation(伪类实例化) 模式的语法糖。也就是说，当你向类添加方法时，这就像在函数原型中添加方法一样。</p>\n<p>class Animal {<br>  eat() {}<br>}</p>\n<p>// 等价于</p>\n<p>function Animal () {}<br>Animal.prototype.eat = function () {}</p>\n<p>这是高效的，因为 eat 定义一次并在类的所有实例之间共享。 这与 Class Fields 有什么关系？ 好吧，正如我们上面所看到的， Class Fields 被添加到实例中。 这意味着对于我们创建的每个实例，我们将创建一个新的 eat 方法。</p>\n<p>class Animal {<br>  eat() {}<br>  sleep = () =&gt; {}<br>}</p>\n<p>// 等价于</p>\n<p>function Animal () {<br>  this.sleep = function () {}<br>}</p>\n<p>Animal.prototype.eat = function () {}</p>\n<p>请注意 sleep 如何放在实例上，而不是放在 Animal.prototype 上。这是件坏事吗？嗯，有可能。在不进行度量的情况下对性能进行宽泛的描述通常不是一个好主意。您需要在应用程序中回答的问题是，您从 Class Fields 中获得的开发人员体验是否超过了潜在的性能损失。</p>\n<blockquote>\n<p>如果你想在你的应用程序中使用我们之前谈到的任何内容，你需要使用 <a href=\"https://babeljs.io/docs/en/babel-plugin-proposal-class-properties\">babel-plugin-transform-class-properties</a> 插件。</p>\n</blockquote>\n<h2 id=\"Private-私有-属性\"><a href=\"#Private-私有-属性\" class=\"headerlink\" title=\"Private(私有) 属性\"></a>Private(私有) 属性</h2><p>Class Fields 提案的另一个内容时是 “private fields (私有属性)” 。 有时，当您构建一个类时，您希望拥有不暴露给外界的私有值。 从历史上看， JavaScript 缺乏真正私有值 的能力，所以我们通过约定，用下划线标记它们。</p>\n<p>class Car {<br>  _milesDriven = 0<br>  drive(distance) {<br>    this._milesDriven += distance<br>  }<br>  getMilesDriven() {<br>    return this._milesDriven<br>  }<br>}</p>\n<p>在上面的示例中，我们依靠 Car class（类）的实例通过调用 getMilesDriven 方法来获取汽车的里程数。但是，因为没有什么能使 _milesDriven成为私有的，所以任何实例都可以访问它。</p>\n<p>const tesla = new Car()<br>tesla.drive(10)<br>console.log(tesla._milesDriven)</p>\n<p>有个奇特的（hacky）方法，就是使用 WeakMaps 可以解决这个问题，但如果存在更简单的解决方案，那将会很好。 同样，Class Fields 提案正在拯救我们。 根据提议，您可以使用 ＃ 创建私有字段。 是的，你没有看错， ＃ 。 我们来看看它对我们的代码有什么影响，</p>\n<p>class Car {<br>  #milesDriven = 0<br>  drive(distance) {<br>    this.#milesDriven += distance<br>  }<br>  getMilesDriven() {<br>    return this.#milesDriven<br>  }<br>}</p>\n<p>我们可以用速记语法更进一步简化</p>\n<p>class Car {<br>  #milesDriven = 0<br>  drive(distance) {<br>    #milesDriven += distance<br>  }<br>  getMilesDriven() {<br>    return #milesDriven<br>  }<br>}</p>\n<p>const tesla = new Car()<br>tesla.drive(10)<br>tesla.getMilesDriven() // 10<br>tesla.#milesDriven // Invalid</p>\n<p>如果您对私有属性背后的更多细节/决策感兴趣，那么这里有一篇 <a href=\"https://github.com/tc39/proposal-private-fields/blob/master/FAQ.md\">很好的文章</a>。</p>\n<blockquote>\n<p>目前 <a href=\"https://github.com/babel/proposals/issues/12\">有一个 PR</a> 将私有属性添加到 Babel ，以便您可以在应用中使用它们。</p>\n</blockquote>\n<p>文章来源：<a href=\"https://tylermcginnis.com/javascript-private-and-public-class-fields/\">https://tylermcginnis.com</a></p>\n","categories":["JavaScript"],"tags":["javascript教程","ECMAScript2016","ECMAScript教程","js教程"]},{"title":"javascript 实现可伸缩性导航","url":"/2018/10/12/javascript-%E5%AE%9E%E7%8E%B0%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%E5%AF%BC%E8%88%AA/","content":"<p>上篇文章写的是利用<a href=\"http://www.w3cbest.com/?p=186\">CSS3 选择器:target制作一个可伸缩的导航菜单</a>，可以在兼容这个选择器的基础可以使用，但是如果在低版本浏览器就可能使用不了了，这篇文章是通过JavaScript实现可伸缩性导航，我们看下面代码：</p>\n<nav class=\"tabs\">\n<ul class=\"primary\">\n<li><a href=\"http://www.w3cbest.com/\">首页</a></li>\n<li><a href=\"http://www.w3cbest.com/?cat=2\">html/css</a></li>\n<li><a href=\"http://www.w3cbest.com/?cat=1\">javascript</a></li>\n<li><a href=\"http://www.w3cbest.com/?p=176\">vue</a></li>\n<li><a href=\"http://www.w3cbest.com/?p=158\">anjular</a></li>\n<li><a href=\"http://www.w3cbest.com/?p=155\">react</a></li>\n<li><a href=\"http://www.w3cbest.com/?p=163\">php</a></li>\n<li><a href=\"http://www.w3cbest.com/?p=172\">python</a></li>\n<li><a href=\"http://www.w3cbest.com/?p=191\">highcharts</a></li>\n<li><a href=\"http://www.w3cbest.com/?p=114\">echarts</a></li>\n</ul>\n</nav>\n\n<p>CSS代码：</p>\n<p>.tabs {<br>position: relative;<br>}<br>.tabs:not(.jsfied) {<br>overflow-x: auto;<br>-webkit-overflow-scrolling: touch;<br>}<br>.tabs .hidden {<br>display: none;<br>}<br>.tabs a,<br>.tabs button {<br>width: 100%;<br>height: 100%;<br>display: block;<br>font-size: 1em;<br>line-height: 1.2;<br>text-align: center;<br>color: #FAF3DD;<br>background-color: transparent;<br>}<br>.tabs .primary {<br>display: flex;<br>}<br>.tabs .primary &gt; li {<br>flex-grow: 1;<br>background-color: #5a5a5a;<br>}<br>.tabs .primary &gt; li + li {<br>border-left: 1px solid #414141;<br>}<br>.tabs .primary &gt; li &gt; a,<br>.tabs .primary &gt; li &gt; button {<br>white-space: nowrap;<br>padding: 1em 0.6em;<br>box-shadow: inset 0 -0.2em 0 #414141;<br>}<br>.tabs .primary &gt; li &gt; a:hover,<br>.tabs .primary &gt; li &gt; button:hover {<br>background-color: #414141;<br>}<br>.tabs .primary &gt; li &gt; a:active,<br>.tabs .primary &gt; li &gt; button:active {<br>background-color: #4a4a4a;<br>}<br>.tabs .primary .more {<br>background-color: #414141;<br>}<br>.tabs .primary .more &gt; button span {<br>display: inline-block;<br>transition: -webkit-transform 0.2s;<br>transition: transform 0.2s;<br>transition: transform 0.2s, -webkit-transform 0.2s;<br>}<br>.tabs.show-secondary .primary .more &gt; button span {<br>-webkit-transform: rotate(180deg);<br>transform: rotate(180deg);<br>}<br>.tabs .secondary {<br>max-width: 100%;<br>min-width: 10em;<br>display: none;<br>position: absolute;<br>top: 100%;<br>right: 0;<br>box-shadow: 0 0.3em 0.5em rgba(0, 0, 0, 0.3);<br>-webkit-animation: nav-secondary 0.2s;<br>animation: nav-secondary 0.2s;<br>}<br>.tabs .secondary li {<br>border-top: 1px solid #353535;<br>background-color: #414141;<br>}<br>.tabs .secondary a,<br>.tabs .secondary button {<br>padding: 0.6em;<br>}<br>.tabs .secondary a:hover,<br>.tabs .secondary button:hover {<br>background-color: #4a4a4a;<br>}<br>.tabs .secondary a:active,<br>.tabs .secondary button:active {<br>background-color: #353535;<br>}<br>.tabs.show-secondary .secondary {<br>display: block;<br>}</p>\n<p>@-webkit-keyframes nav-secondary {<br>0% {<br>opacity: 0;<br>-webkit-transform: translateY(-1em);<br>transform: translateY(-1em);<br>}<br>100% {<br>opacity: 1;<br>-webkit-transform: translateY(0);<br>transform: translateY(0);<br>}<br>}</p>\n<p>@keyframes nav-secondary {<br>0% {<br>opacity: 0;<br>-webkit-transform: translateY(-1em);<br>transform: translateY(-1em);<br>}<br>100% {<br>opacity: 1;<br>-webkit-transform: translateY(0);<br>transform: translateY(0);<br>}<br>}</p>\n<p>JS:</p>\n<p>const container = document.querySelector(‘.tabs’)<br>const primary = container.querySelector(‘.primary’)<br>const primaryItems = container.querySelectorAll(‘.primary &gt; li:not(.more)’)<br>container.classList.add(‘jsfied’)</p>\n<p>primary.insertAdjacentHTML(‘beforeend’, `</p>\n<li class=\"more\">\n<button type=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">\nMore <span>&darr;</span>\n</button>\n<ul class=\"secondary\">\n${primary.innerHTML}\n</ul>\n</li>\n\\`)\nconst secondary = container.querySelector('.secondary')\nconst secondaryItems = secondary.querySelectorAll('li')\nconst allItems = container.querySelectorAll('li')\nconst moreLi = primary.querySelector('.more')\nconst moreBtn = moreLi.querySelector('button')\nmoreBtn.addEventListener('click', (e) => {\ne.preventDefault()\ncontainer.classList.toggle('show-secondary')\nmoreBtn.setAttribute('aria-expanded', container.classList.contains('show-secondary'))\n})\n\n<p>// 调整选项卡</p>\n<p>const doAdapt = () =&gt; {<br>// 显示所有项目<br>allItems.forEach((item) =&gt; {<br>item.classList.remove(‘hidden’)<br>})</p>\n<p>// 隐藏已经超过导航的其他项目<br>let stopWidth = moreBtn.offsetWidth<br>let hiddenItems = []<br>const primaryWidth = primary.offsetWidth<br>primaryItems.forEach((item, i) =&gt; {<br>if(primaryWidth &gt;= stopWidth + item.offsetWidth) {<br>stopWidth += item.offsetWidth<br>} else {<br>item.classList.add(‘hidden’)<br>hiddenItems.push(i)<br>}<br>})</p>\n<p>// 切换更多按钮<br>if(!hiddenItems.length) {<br>moreLi.classList.add(‘hidden’)<br>container.classList.remove(‘show-secondary’)<br>moreBtn.setAttribute(‘aria-expanded’, false)<br>}<br>else {<br>secondaryItems.forEach((item, i) =&gt; {<br>if(!hiddenItems.includes(i)) {<br>item.classList.add(‘hidden’)<br>}<br>})<br>}<br>}</p>\n<p>doAdapt()<br>window.addEventListener(‘resize’, doAdapt)</p>\n<p>document.addEventListener(‘click’, (e) =&gt; {<br>let el = e.target<br>while(el) {<br>if(el === secondary  el === moreBtn) {<br>return;<br>}<br>el = el.parentNode<br>}<br>container.classList.remove(‘show-secondary’)<br>moreBtn.setAttribute(‘aria-expanded’, false)<br>})</p>\n","categories":["HTML/CSS","JavaScript"],"tags":["javascript","css3","导航","导航菜单"]},{"title":"JavaScript中Array方法的正确打开方式","url":"/2018/12/08/javascript%E4%B8%ADarray%E6%96%B9%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/","content":"<blockquote>\n<p>在过去的几个月，我发现我的拉取请求中存在四个完全相同的 JavaScript 错误。于是我写了这篇文章，总结了如何在 JavaScript 中正确使用地使用 Array 的方法！</p>\n</blockquote>\n<h3 id=\"用-Array-includes-代替-Array-indexOf\"><a href=\"#用-Array-includes-代替-Array-indexOf\" class=\"headerlink\" title=\"用 Array.includes 代替 Array.indexOf\"></a>用 <code>Array.includes</code> 代替 <code>Array.indexOf</code></h3><p>“如果你要在数组中查找元素，请使用 Array.indexOf”。我记得在学习 JavaScript 的时候，在教材中读到这样的一句话。毫无疑问，这句话是真的！ MDN 文档写道，<code>Array.indexOf</code> 将“返回第一次出现给定元素的索引”。因此，如果我们稍后要在代码中使用这个返回的索引，那么使用 <code>Array.indexOf</code> 找到索引就对了。 但是，如果我们只想知道数组是否包含某个值，该怎么办？这似乎是一个是与否的问题，或者说是一个布尔值问题。对于这种情况，我建议使用返回布尔值的 <code>Array.includes</code>。</p>\n<p>‘use strict’;</p>\n<p>const characters = [<br>‘ironman’,<br>‘black_widow’,<br>‘hulk’,<br>‘captain_america’,<br>‘hulk’,<br>‘thor’,<br>];</p>\n<p>console.log(characters.indexOf(‘hulk’));<br>// 2<br>console.log(characters.indexOf(‘batman’));<br>// -1</p>\n<p>console.log(characters.includes(‘hulk’));<br>// true<br>console.log(characters.includes(‘batman’));<br>// false</p>\n<h3 id=\"使用-Array-find-而不是-Array-filter\"><a href=\"#使用-Array-find-而不是-Array-filter\" class=\"headerlink\" title=\"使用 Array.find 而不是 Array.filter\"></a>使用 <code>Array.find</code> 而不是 <code>Array.filter</code></h3><p><code>Array.filter</code> 是一个非常有用的方法。它接受一个回调函数作为参数，基于一个包含所有元素的数组创建出一个新的数组。正如它的名字一样，我们使用这个方法来过滤元素，获得更短的数组。 但是，如果回调函数只能返回一个元素，那么我就不推荐使用这个方法，例如使用回调函数来过滤唯一 ID。在这种情况下，<code>Array.includes</code> 将返回一个只包含一个元素的新数组。我们的意图可能是通过查找特定的 ID 找到数组中包含的唯一值。 我们来看看这个方法的性能。要返回与回调函数匹配的所有元素，<code>Array.filter</code> 必须遍历整个数组。此外，我们假设有数百个元素可以满足回调参数，那么过滤后的数组会非常大。 为了避免这种情况，我建议使用 <code>Array.find</code>。它需要一个像 <code>Array.filter</code> 一样的回调函数作为参数，并返回满足回调函数的第一个元素的值。此外，只要找到第一个满足回调函数的元素，<code>Array.find</code> 就会停止，无需遍历整个数组。通过 <code>Array.find</code> 来查找元素，我们可以更好地理解我们的意图。</p>\n<p>‘use strict’;</p>\n<p>const characters = [<br>{ id: 1, name: ‘ironman’ },<br>{ id: 2, name: ‘black_widow’ },<br>{ id: 3, name: ‘captain_america’ },<br>{ id: 4, name: ‘captain_america’ },<br>];</p>\n<p>function getCharacter(name) {<br>return character =&gt; character.name === name;<br>}</p>\n<p>console.log(characters.filter(getCharacter(‘captain_america’)));<br>// [<br>// { id: 3, name: ‘captain_america’ },<br>// { id: 4, name: ‘captain_america’ },<br>// ]</p>\n<p>console.log(characters.find(getCharacter(‘captain_america’)));<br>// { id: 3, name: ‘captain_america’ }</p>\n<h3 id=\"用-Array-some-代替-Array-find\"><a href=\"#用-Array-some-代替-Array-find\" class=\"headerlink\" title=\"用 Array.some 代替 Array.find\"></a>用 <code>Array.some</code> 代替 <code>Array.find</code></h3><p>我承认这个错误我犯了很多次。然后，一位善良的朋友告诉我，最好可以先参考 MDN 文档。这与上面的 <code>Array.indexOf</code>/<code>Array.includes</code> 非常相似。 在前面的例子中，我们看到 <code>Array.find</code> 需要一个回调函数作为参数，并返回一个元素。如果我们想要知道数组是否包含某个值，<code>Array.find</code> 是最好的解决方案吗？可能不是，因为它返回的是一个元素值，而不是一个布尔值。 对于这种情况，我建议使用 <code>Array.some</code>，它返回所需的布尔值。另外，从语义上看，<code>Array.some</code> 表示我们只想知道某个元素是否存在，而不需要得到这个元素。</p>\n<p>‘use strict’;</p>\n<p>const characters = [<br>{ id: 1, name: ‘ironman’, env: ‘marvel’ },<br>{ id: 2, name: ‘black_widow’, env: ‘marvel’ },<br>{ id: 3, name: ‘wonder_woman’, env: ‘dc_comics’ },<br>];</p>\n<p>function hasCharacterFrom(env) {<br>return character =&gt; character.env === env;<br>}</p>\n<p>console.log(characters.find(hasCharacterFrom(‘marvel’)));<br>// { id: 1, name: ‘ironman’, env: ‘marvel’ }</p>\n<p>console.log(characters.some(hasCharacterFrom(‘marvel’)));<br>// true</p>\n<h3 id=\"使用-Array-reduce-而不是链接-Array-filter-和-Array-map\"><a href=\"#使用-Array-reduce-而不是链接-Array-filter-和-Array-map\" class=\"headerlink\" title=\"使用 Array.reduce 而不是链接 Array.filter 和 Array.map\"></a>使用 <code>Array.reduce</code> 而不是链接 <code>Array.filter</code> 和 <code>Array.map</code></h3><p>让我们面对现实吧，<code>Array.reduce</code> 不容易理解。事实确实如此！但是，如果我们使用 <code>Array.filter</code> 和 Array.map的组合，感觉缺少了什么，对吧？ 我的意思是，我们遍历了两次数组。第一次过滤数组并创建一个较短的数组，第二次又基于 <code>Array.filter</code> 获得数组创建一个包含新值的数组。为了获得我们想要的新数组，我们使用了两个 Array 方法。每个方法都有自己的回调函数和一个用不到的数组——由 <code>Array.filter</code> 创建的那个数组。 为了避免这种性能损耗，我的建议是使用 <code>Array.reduce</code>。结果是一样的，代码却更简单！ 我们可以使用 <code>Array.reduce</code> 进行过滤，并将目标元素添加到累加器中。累加器可以是递增的数字、要填充的对象、要连接的字符串或数组。 在我们的例子中，因为之前使用了 <code>Array.map</code>，所以我建议使用 <code>Array.reduce</code> 将满足条件的数组元素加入到累加器中。在下面的示例中，根据 env 值的具体情况，我们将它添加到累加器中或保持累加器不变。</p>\n<p>‘use strict’;</p>\n<p>const characters = [<br>{ name: ‘ironman’, env: ‘marvel’ },<br>{ name: ‘black_widow’, env: ‘marvel’ },<br>{ name: ‘wonder_woman’, env: ‘dc_comics’ },<br>];</p>\n<p>console.log(<br>characters<br>.filter(character =&gt; character.env === ‘marvel’)<br>.map(character =&gt; Object.assign({}, character, { alsoSeenIn: [‘Avengers’] }))<br>);<br>// [<br>// { name: ‘ironman’, env: ‘marvel’, alsoSeenIn: [‘Avengers’] },<br>// { name: ‘black_widow’, env: ‘marvel’, alsoSeenIn: [‘Avengers’] }<br>// ]</p>\n<dl><dt>console.log(<br>characters<br>.reduce((acc, character) =&gt; {<br>return character.env === ‘marvel’<br>? acc.concat(Object.assign({}, character, { alsoSeenIn: [‘Avengers’] }))</dt><dd>acc;<br>}, [])<br>)<br>// [<br>// { name: ‘ironman’, env: ‘marvel’, alsoSeenIn: [‘Avengers’] },<br>// { name: ‘black_widow’, env: ‘marvel’, alsoSeenIn: [‘Avengers’] }<br>// ]</dd></dl><p>英文原文 <a href=\"https://medium.freecodecamp.org/heres-how-you-can-make-better-use-of-javascript-arrays-3efd6395af3c\">https://medium.freecodecamp.org/heres-how-you-can-make-better-use-of-javascript-arrays-3efd6395af3c</a></p>\n","categories":["资源","JavaScript"],"tags":["javascript","Array.filter","Array.find","Array.includes","Array.indexOf","Array.some"]},{"title":"javascript数据类型 —— String 类型","url":"/2019/05/07/javascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-string-%E7%B1%BB%E5%9E%8B/","content":"<p>String 类型用于表示由零或多个16位 Unicode 字符组成的字符序列，即字符串 。</p>\n<h2 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h2><p>由于计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。在计算机中，1个字节（byte）由 8个比特（bit）组成，所以 1 个字节能表示的最大整数就是 255，如果想表示更大整数，就必须用更多的字节，比如 2 个字节可以表示的最大整数为 65535 。最早，只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。 但如果要表示中文字符，显然一个字节是不够的，至少需要两个字节。所以，中国制定了GB2312编码，用来表示中文字符。基于同样的原因，各个国家都制定了自己的编码规则。这样就会出现一个问题，即在多语言混合的文本中，不同的编码会出现冲突，导致乱码出现。 为了解决这个问题，Unicode 编码应运而生，它把所有的语言都统一到一套编码中，采用2个字节表示一个字符，即最多可以表示65535个字符，这样基本上可以覆盖世界上常用的文字，如果要表示更多的文字，也可以采用4个字节进行编码，这是一种通用的编码规范。 因此，JavaScript中的字符也采用Unicode来编码，也就是说，JavaScript中的英文字符和中文字符都会占用2个字节的空间大小，这种多字节字符，通常被称为宽字符。</p>\n<h2 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h2><p>在JavaScript中，字符串是基本数据类型，本身不存任何操作方法。为了方便的对字符串进行操作，ECMAScript提供了一个基本包装类型：<code>String()</code>对象。它是一种特殊的引用类型，JS引擎每当读取一个字符串的时候，就会在内部创建一个对应的<code>String()</code>对象，该对象提供了很多操作字符的方法，这就是为什么能对字符串调用方法的原因。</p>\n<p>var name = ‘JavaScript’;<br>var value = name.substr(2,1);</p>\n<p>当第二行代码访问变量str时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，引擎内部会自动完成下列处理：</p>\n<ol>\n<li> 创建String类型的一个实例</li>\n<li> 在实例上调用指定的方法</li>\n<li> 销毁这个实例</li>\n</ol>\n<p>用伪代码形象的模拟以上三个步骤：</p>\n<p>var obj = new String(‘JavaScript’);<br>var value = obj.substr(2,1);<br>name = null;</p>\n<p>可以看出，基本包装类型是一种特殊的引用类型。它和普通引用类型有一个很重要的区别，就是对象的生存期不同。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。在JavaScript中，类似的基本包装类型还有<code>Number</code>、<code>Boolean</code>对象 。</p>\n<h2 id=\"常用操作方法\"><a href=\"#常用操作方法\" class=\"headerlink\" title=\"常用操作方法\"></a>常用操作方法</h2><p>作为字符串的基本包装类型，String()对象提供了以下几类方法，用以操作字符串：</p>\n<ul>\n<li>  字符操作：<code>charAt()</code>、<code>charCodeAt()</code>、<code>fromCharCode()</code></li>\n<li>  字符串提取：<code>substr()</code>、<code>substring()</code>、<code>slice()</code></li>\n<li>  位置索引：<code>indexOf()</code>、<code>lastIndexOf()</code></li>\n<li>  大小写转换：<code>toLowerCase()</code>、<code>toUpperCase()</code></li>\n<li>  模式匹配：<code>match()</code>、<code>search()</code>、<code>replace()</code>、<code>split()</code></li>\n<li>  其他操作：<code>concat()</code>、<code>trim()</code>、<code>localeCompare()</code></li>\n</ul>\n<p><code>charCodeAt()</code>方法的作用是获取字符的Unicode编码，俗称“Unicode码点”。<code>fromCharCode()</code>是<code>String()</code>对象上的静态方法，作用是根据Unicode编码返回对应的字符。</p>\n<p>var a = ‘a’;<br>// 获取Unicode编码<br>var code = a.charCodeAt(0); // 97<br>// 根据Unicode编码获取字符<br>String.fromCharCode(code); // a</p>\n<p>通过<code>charCodeAt()</code>方法获取字符的Unicode编码，然后再把这个编码转化成二进制，就可以得到该字符的二进制表示。</p>\n<p>var a = ‘a’;<br>var code = a.charCodeAt(0); // 97<br>code.toString(2); // 1100001</p>\n<p>对于字符串的提取操作，有三个相类似的方法，分别如下：</p>\n<p>substr(start [, length])<br>substring(start [, end])<br>slice(start [, end])</p>\n<p>从定义上看，<code>substring()</code>和<code>slice()</code>是同类的，参数都是字符串的某个start位置到某个end位置（但end位置的字符不包括在结果中）；而<code>substr()</code>则是字符串的某个start位置起，数length个长度的字符才结束。二者的共性是：从start开始，如果没有第2个参数，都是直到字符串末尾。 <code>substring()</code>和<code>slice()</code>的区别则是：<code>slice()</code>可以接受“负数”，表示从字符串尾部开始计数；而<code>substring()</code>则把负数或其它无效的数当作0。</p>\n<p>‘hello world!’.slice(-6, -1) // ‘world’<br>‘hello world!’.substring(“abc”, 5) // ‘hello’</p>\n<p><code>substr()</code>的start也可接受负数，也表示从字符串尾部计数，这点和<code>slice()</code>相同；但<code>substr()</code>的length则不能小于1，否则返回空字符串。</p>\n<p>‘hello world!’.substr(-6, 5) // ‘world’<br>‘hello world!’.substr(0, -1) // ‘’</p>\n","categories":["JavaScript"],"tags":["slice()","charAt()","indexOf()","match()","replace()","split()","substr()","substring()"]},{"title":"JavaScript数组","url":"/2019/05/08/javascript%E6%95%B0%E7%BB%84/","content":"<blockquote>\n<p>简介：在本教程中，您将了解JavaScript数组类型及其一些独特的特性。</p>\n</blockquote>\n<h2 id=\"JavaScript数组简介\"><a href=\"#JavaScript数组简介\" class=\"headerlink\" title=\"JavaScript数组简介\"></a>JavaScript数组简介</h2><p>在 JavaScript 中，数组是有序的数据列表。与其他编程语言（如Java，C / C ++等）的数组相比，数组具有以下特殊特性。</p>\n<ul>\n<li>  首先，数组可以在每个槽中保存不同类型的数据，即数组可以保存具有数字，字符串，对象等的混合的元素。</li>\n<li>  其次，数组的长度是动态调整大小和自动增长的。</li>\n</ul>\n<h2 id=\"创建JavaScript数组\"><a href=\"#创建JavaScript数组\" class=\"headerlink\" title=\"创建JavaScript数组\"></a>创建JavaScript数组</h2><p>JavaScript 为您提供了两种创建数组的方法。 第一个是使用Array构造函数如下：</p>\n<p>var scores = new Array();</p>\n<p>该scores 数组为空即，它不包含任何元素。 如果您知道数组将包含的元素数，则可以创建一个具有初始大小的数组，如以下示例所示：</p>\n<p>var scores = Array(10);</p>\n<p>要使用初始元素创建数组，可以在Array()构造函数中将元素作为逗号分隔列表传递。以下示例创建scores包含五个数字的数组：</p>\n<p>var scores = new Array(9,10,8,7,6);</p>\n<p>重要的是要注意，如果使用数组构造函数创建数组并传入数字，则需要创建一个具有初始大小的数组。但是，如果传入另一个类型的一个参数，则创建一个包含该元素的数组。 请参阅以下示例：</p>\n<p>var athletes = new Array(3); // creates an array with initial size 3<br>var scores = new Array(1, 2, 3); // create an array with three numbers 1,2 3<br>var signs = new Array(‘Red’); // creates an array with one element ‘Red’</p>\n<p>JavaScript 允许您new在使用数组构造函数时省略运算符。例如，以下语句创建artists数组。</p>\n<p>var artists = Array();</p>\n<p>第二种方式，也许是更优选的方式，创建一个数组是使用数组文字表示法，如下所示：</p>\n<p>var array_name = [element1, element2, element3];</p>\n<p>数组文字形式使用方括号[]来包装逗号分隔的元素列表。例如，以下语句创建三种颜色的colors数组：</p>\n<p>var colors = [‘red’, ‘green’, ‘blue’];</p>\n<p>可以使用空方括号创建一个空数组。</p>\n<p>var emptyArray = [];</p>\n<p>以下示例创建一个包含两个未定义元素的数组。</p>\n<p>var nonEmptyArry = [,,];<br>console.log(nonEmptyArray); // [undefined, undefined]</p>\n<h2 id=\"访问-JavaScript-数组元素\"><a href=\"#访问-JavaScript-数组元素\" class=\"headerlink\" title=\"访问 JavaScript 数组元素\"></a>访问 JavaScript 数组元素</h2><p>您可以使用方括号[]访问数组的元素。数组的第一个元素以0开头，第二个元素以1开头，依此类推。 例如，以下示例创建一个包含三个字符串的数组。</p>\n<p>var mountains = [‘Everest’, ‘Fuji’, ‘Nanga Parbat’];</p>\n<p>以下语句显示如何访问mountains数组的元素。</p>\n<p>console.log(mountains[0]); // ‘Everest’<br>console.log(mountains[1]); // ‘Fuji’<br>console.log(mountains[2]); // ‘Nanga Parbat’</p>\n<p>要更改数组中元素的值，可以使用为该元素赋值，如下所示：</p>\n<p>mountains[2] = ‘K2’;</p>\n<h2 id=\"数组的大小\"><a href=\"#数组的大小\" class=\"headerlink\" title=\"数组的大小\"></a>数组的大小</h2><p>数组使用length属性来存储它保存的当前元素数。您可以访问获取length属性的值，如以下示例所示。</p>\n<p>console.log(mountains.length); // 3</p>\n<p>该length属性是可写的，因此您可以 通过更改属性的值来插入或删除元素length。 如果将length属性设置为大于数组中元素数的值，则新元素将添加初始值undefined。 例如，我们将mountains数组的length属性更改为4，那么数组末尾将会附加一个初始值为undefined的元素。</p>\n<p>// append 1 element<br>mountains.length = 4;<br>console.log(mountains[3]); // undefined</p>\n<p>类似地，下面的示例将mountains数组的length属性设置为2，那么将会删除数组的最后两个元素。当我们访问数组的第三个元素时，它返回undefined。</p>\n<p>// remove the last 2 elements<br>mountains.length = 2;<br>console.log(mountains[2]); // undefined</p>\n<p>请注意，JavaScript 数组可容纳的最大元素数为4,294,967,295，足以满足典型应用程序的要求。</p>\n<h2 id=\"数组的基本操作\"><a href=\"#数组的基本操作\" class=\"headerlink\" title=\"数组的基本操作\"></a>数组的基本操作</h2><p>所有数组都是该Array类型的实例。因此，数组变量的typeof返回object如下例所示：</p>\n<p>var seas = [‘Black Sea’, ‘Caribbean Sea’, ‘North Sea’, ‘Baltic Sea’];<br>console.log(typeof seas); // object</p>\n<p>要检查变量是否为数组，可以使用Array.isArray()方法进行检测：</p>\n<p>console.log(Array.isArray(seas)); // true</p>\n<p>当您调用数组的toString()和valueOf()方法时，您将获得一个以逗号分隔的元素列表表示的字符串，如以下示例所示：</p>\n<p>console.log(seas.toString()); // Black Sea,Caribbean Sea,North Sea,Baltic Sea<br>console.log(seas.valueOf());</p>\n<p>如果要以不同的方式使用数组的字符串表示形式，可以使用join()方法。 以下示例使用join()方法返回mountains数组的字符串表示形式。但是元素由()字符分隔。</p>\n<p>console.log(seas.join(‘’));<br>// Black SeaCaribbean SeaNorth SeaBaltic Sea</p>\n<p>如果数组的元素是null或undefined时，toString(), valueOf()以及join()将其视为得到的字符串中一个空字符串。这是一个例子。</p>\n<p>var mixedValues = [1, 2, null, ‘A’, undefined, 3];<br>console.log(mixedValues.toString()); // 1,2,,A,,3</p>\n<p>现在您应该对JavaScript数组及其一些独特的特性有基本的了解。</p>\n","categories":["JavaScript"],"tags":["array()","Array.isArray()","join()","toString()","valueOf()"]},{"title":"JavaScript骚操作之单行程序","url":"/2019/04/30/javascript%E9%AA%9A%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%8D%95%E8%A1%8C%E7%A8%8B%E5%BA%8F/","content":"<p>单行简洁的代码很难维护（有时甚至难以理解），但这并不能阻止广大攻城狮们脑洞，在编写简洁的代码后获得一定的满足感。 以下我最近的一些收藏javascript精简代码集合。它们都可以在你的开发控制台中运行，你可以从控制台中查看运行结果。同时，我希望你能在评论中分享一些自己的藏品</p>\n<h2 id=\"日历\"><a href=\"#日历\" class=\"headerlink\" title=\"日历\"></a>日历</h2><p>创建过去七天的数组，如果将代码中的减号换成加号，你将得到未来7天的数组集合</p>\n<p>// 创建过去七天的数组<br>[…Array(7).keys()].map(days =&gt; new Date(Date.now() - 86400000 * days));</p>\n<p>Array.from(Array(7).keys(),(days) =&gt; new Date(Date.now() - 86400000 * days));</p>\n<p>Array.from({length:7},(_,days) =&gt; new Date(Date.now() - 86400000 * days));</p>\n<h2 id=\"生成随机ID\"><a href=\"#生成随机ID\" class=\"headerlink\" title=\"生成随机ID\"></a>生成随机ID</h2><p>在原型设计时经常使用的创建ID功能。但是我在实际项目中看到有人使用它。其实这并不安全</p>\n<p>// 生成长度为11的随机字母数字字符串<br>Math.random().toString(36).substring(2);</p>\n<h2 id=\"取URL的查询参数\"><a href=\"#取URL的查询参数\" class=\"headerlink\" title=\"取URL的查询参数\"></a>取URL的查询参数</h2><p>这个获取URL的查询参数代码，是我见过最精简的QAQ <code>?foo=bar&amp;baz=bing =&gt; &#123;foo: bar, baz: bing&#125;</code></p>\n<p>// 获取URL的查询参数<br>q={};location.search.replace(/([^?&amp;=]+)=([^&amp;]+)/g,(_,k,v)=&gt;q[k]=v);q;</p>\n<p>Object.fromEntries(new URLSearchParams(‘a=1&amp;b=2’))</p>\n<h2 id=\"本地时间\"><a href=\"#本地时间\" class=\"headerlink\" title=\"本地时间\"></a>本地时间</h2><p>通过一堆HTML，您可以创建一个本地时间，其中包含您可以一口气读出的源代码，它每秒都会用当前时间更新页面</p>\n<p>// 创建本地时间</p>\n<body onload=\"setInterval(()=>document.body.innerHTML=new Date().toLocaleString().slice(10,19))\"></body>\n\n<p>new Date().toLocaleTimeString()</p>\n<h2 id=\"数组混淆\"><a href=\"#数组混淆\" class=\"headerlink\" title=\"数组混淆\"></a>数组混淆</h2><p>随机更改数组元素顺序，混淆数组</p>\n<p>// 随机更改数组元素顺序，混淆数组<br>(arr) =&gt; arr.slice().sort(() =&gt; Math.random() - 0.5)<br>/*<br>let a = (arr) =&gt; arr.slice().sort(() =&gt; Math.random() - 0.5)<br>let b = a([1,2,3,4,5])<br>console.log(b)<br>*/</p>\n<p>或者</p>\n<p>function shuffle(arr) {<br>    const newArr = […arr];<br>    for (let i = 0, len = newArr.length; i &lt; len; i += 1) {<br>const random = Math.floor(Math.random() * (i + 1));<br>    if (i !== random){<br>        [newArr[i], newArr[random]] = [newArr[random], newArr[i]];<br>    }<br>    }<br>    return newArr;<br>}</p>\n<p>或者</p>\n<p>function shuffle(arr) {<br>    let i = arr.length, j;<br>    while (i) {<br>        j = Math.floor(Math.random() * i–);<br>        [arr[i], arr[j]] = [arr[j], arr[i]];<br>    }<br>    return arr;<br>}</p>\n<h2 id=\"生成随机十六进制代码（生成随机颜色）\"><a href=\"#生成随机十六进制代码（生成随机颜色）\" class=\"headerlink\" title=\"生成随机十六进制代码（生成随机颜色）\"></a>生成随机十六进制代码（生成随机颜色）</h2><p>使用JavaScript简洁代码生成随机十六进制代码</p>\n<p>// before<br>‘#’ + Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, ‘0’);</p>\n<p>// after<br>‘#’ + (0x1000000 + Math.random() * 0xffffff).toString(16).slice(1, 6);</p>\n<p>Array.from({ length: 6 }, () =&gt; Math.floor(Math.random() * 16).toString(16)).join(“”)</p>\n<h2 id=\"一个面试题\"><a href=\"#一个面试题\" class=\"headerlink\" title=\"一个面试题\"></a>一个面试题</h2><p>这是一个臭名昭著的面试题，让你写出他的运行结果</p>\n<p>for (i = 0; ++i &lt; 101; console.log(i % 5 ? f  i : f + ‘Buzz’)) f = i % 3 ? ‘’ : ‘Fizz’</p>\n<h2 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h2><p>这是一个原生的JS函数但是非常简洁，Set接受任何可迭代对象，如数组[1,2,3,3]，并删除重复项</p>\n<p>// 数组去重<br>[…new Set(arr)]<br>// 或者<br>arr.filter((x, index, self) =&gt; self.indexOf(x) === index)</p>\n<h2 id=\"创建特定大小的数组\"><a href=\"#创建特定大小的数组\" class=\"headerlink\" title=\"创建特定大小的数组\"></a>创建特定大小的数组</h2><p>方便快捷创建特定大小的数组</p>\n<p>// 创建一个数组<br>[…Array(3).keys()]</p>\n<p>或者</p>\n<p>Array.from({length: 3}, (val, i) =&gt; i)</p>\n<h2 id=\"返回一个键盘\"><a href=\"#返回一个键盘\" class=\"headerlink\" title=\"返回一个键盘\"></a>返回一个键盘</h2><p>这是一个很难看懂的简洁代码，但是运行后你会惊呆的，他竟然返回一个图形键盘</p>\n<p>// 用字符串返回一个键盘图形<br>(_=&gt;[…”`1234567890-=<del>QWERTYUIOP[]\\\\~ASDFGHJKL;’</del>ZXCVBNM,./~”].map(x=&gt;(o+=`/${b=’_‘.repeat(w=x&lt;y?2:’ 667699’[x=[“BS”,”TAB”,”CAPS”,”ENTER”][p++]‘SHIFT’,p])}\\\\`,m+=y+(x+’ ‘).slice(0,w)+y+y,n+=y+b+y+y,l+=’ __‘+b)[73]&amp;&amp;(k.push(l,m,n,o),l=’’,m=n=o=y),m=n=o=y=’’,p=l=k=[])&amp;&amp;k.join`<br>`)()</p>\n<p>参考文章来源：<a href=\"https://dev.to/healeycodes/javascript-one-liners-that-make-me-excited-56aj\">https://dev.to</a></p>\n","categories":["JavaScript"],"tags":["Array.map","Math.ceil()","Math.floor()","Math.random()"]},{"title":"jQuery的deferred对象详解","url":"/2019/05/24/jquery%E7%9A%84deferred%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/","content":"<h2 id=\"一、什么是deferred对象？\"><a href=\"#一、什么是deferred对象？\" class=\"headerlink\" title=\"一、什么是deferred对象？\"></a>一、什么是deferred对象？</h2><p>开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。 通常的做法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。 但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了<a href=\"http://api.jquery.com/category/deferred-object/\">deferred对象</a>。 简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行。 它解决了如何处理耗时操作的问题，对那些操作提供了更好的控制，以及统一的编程接口。它的主要功能，可以归结为四点。下面我们通过示例代码，一步步来学习。</p>\n<h2 id=\"二、ajax操作的链式写法\"><a href=\"#二、ajax操作的链式写法\" class=\"headerlink\" title=\"二、ajax操作的链式写法\"></a>二、ajax操作的链式写法</h2><p>首先，回顾一下jQuery的ajax操作的传统写法：</p>\n<p>$.ajax({<br>    url: “test.html”,<br>    success: function() {<br>        console.log(“success”);<br>    },<br>    error: function() {<br>        console.log(“error”);<br>    }<br>});</p>\n<p>在上面的代码中，$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调函数，error方法指定操作失败后的回调函数。 $.ajax()操作完成后，如果使用的是低于1.5.0版本的jQuery，返回的是XHR对象，你没法进行链式操作；如果高于1.5.0版本，返回的是deferred对象，可以进行链式操作。 现在，新的写法是这样的：</p>\n<p>$.ajax({<br>url: ‘/path/to/file’,<br>type: ‘default GET (Other values: POST)’,<br>dataType: ‘default: Intelligent Guess (Other values: xml, json, script, or html)’,<br>data: {param1: ‘value1’},<br>})<br>.done(function() {<br>console.log(“success”);<br>})<br>.fail(function() {<br>console.log(“error”);<br>})<br>.always(function() {<br>console.log(“complete”);<br>});</p>\n<p>可以看到，<a href=\"http://api.jquery.com/deferred.done/\">done()</a>相当于success方法，<a href=\"http://api.jquery.com/deferred.fail/\">fail()</a>相当于error方法。采用链式写法以后，代码的可读性大大提高。</p>\n<h2 id=\"三、指定同一操作的多个回调函数\"><a href=\"#三、指定同一操作的多个回调函数\" class=\"headerlink\" title=\"三、指定同一操作的多个回调函数\"></a>三、指定同一操作的多个回调函数</h2><p>deferred对象的一大好处，就是它允许你自由添加多个回调函数。 还是以上面的代码为例，如果ajax操作成功后，除了原来的回调函数，我还想再运行一个回调函数，怎么办？ 很简单，直接把它加在后面就行了。</p>\n<p>$.ajax(“test.html”)</p>\n<p>.done(function(){ console.log(“哈哈，成功了！”);} )</p>\n<p>.fail(function(){ console.log(“出错啦！”); } )</p>\n<p>.done(function(){ console.log(“第二个回调函数！”);} );</p>\n<p>回调函数可以添加任意多个，它们按照添加顺序执行。</p>\n<h2 id=\"四、为多个操作指定回调函数\"><a href=\"#四、为多个操作指定回调函数\" class=\"headerlink\" title=\"四、为多个操作指定回调函数\"></a>四、为多个操作指定回调函数</h2><p>deferred对象的另一大好处，就是它允许你为多个事件指定一个回调函数，这是传统写法做不到的。 请看下面的代码，它用到了一个新的方法<a href=\"http://api.jquery.com/jQuery.when/\">$.when()</a>：</p>\n<p>$.when($.ajax(“test1.html”), $.ajax(“test2.html”))</p>\n<p>.done(function(){ console.log(“哈哈，成功了！”); })</p>\n<p>.fail(function(){ console.log(“出错啦！”); });</p>\n<p>这段代码的意思是，先执行两个操作$.ajax(“test1.html”)和$.ajax(“test2.html”)，如果都成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。</p>\n<h2 id=\"五、普通操作的回调函数接口（上）\"><a href=\"#五、普通操作的回调函数接口（上）\" class=\"headerlink\" title=\"五、普通操作的回调函数接口（上）\"></a>五、普通操作的回调函数接口（上）</h2><p>deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。也就是说，任何一个操作—-不管是ajax操作还是本地操作，也不管是异步操作还是同步操作—-都可以使用deferred对象的各种方法，指定回调函数。 我们来看一个具体的例子。假定有一个很耗时的操作wait：</p>\n<p>　　var wait = function() {<br>    var tasks = function() {<br>        console.log(“执行完毕！”);<br>    };<br>    setTimeout(tasks, 5000);<br>};</p>\n<p>我们为它指定回调函数，应该怎么做呢？ 很自然的，你会想到，可以使用$.when()：</p>\n<p>$.when(wait())</p>\n<p>.done(function(){ console.log(“哈哈，成功了！”); })</p>\n<p>.fail(function(){ console.log(“出错啦！”); });</p>\n<p>但是，这样写的话，done()方法会立即执行，起不到回调函数的作用。原因在于$.when()的参数只能是deferred对象，所以必须对wait()进行改写：</p>\n<p>var dtd = $.Deferred(); // 新建一个deferred对象<br>var wait = function(dtd) {<br>    var tasks = function() {<br>        console.log(“执行完毕！”);<br>        dtd.resolve(); // 改变deferred对象的执行状态<br>    };<br>    setTimeout(tasks, 5000);<br>    return dtd;<br>};</p>\n<p>现在，wait()函数返回的是deferred对象，这就可以加上链式操作了。</p>\n<p>$.when(wait(dtd))</p>\n<p>.done(function(){ console.log(“哈哈，成功了！”); })</p>\n<p>.fail(function(){ console.log(“出错啦！”); });</p>\n<p>wait()函数运行完，就会自动运行done()方法指定的回调函数。</p>\n<h2 id=\"六、deferred-resolve-方法和deferred-reject-方法\"><a href=\"#六、deferred-resolve-方法和deferred-reject-方法\" class=\"headerlink\" title=\"六、deferred.resolve()方法和deferred.reject()方法\"></a>六、deferred.resolve()方法和deferred.reject()方法</h2><p>如果仔细看，你会发现在上面的wait()函数中，还有一个地方我没讲解。那就是dtd.resolve()的作用是什么？ 要说清楚这个问题，就要引入一个新概念”执行状态”。jQuery规定，deferred对象有三种执行状态—-未完成，已完成和已失败。如果执行状态是”已完成”（resolved）,deferred对象立刻调用done()方法指定的回调函数；如果执行状态是”已失败”，调用fail()方法指定的回调函数；如果执行状态是”未完成”，则继续等待，或者调用progress()方法指定的回调函数（jQuery1.7版本添加）。 前面部分的ajax操作时，deferred对象会根据返回结果，自动改变自身的执行状态；但是，在wait()函数中，这个执行状态必须由程序员手动指定。dtd.resolve()的意思是，将dtd对象的执行状态从”未完成”改为”已完成”，从而触发done()方法。 类似的，还存在一个deferred.reject()方法，作用是将dtd对象的执行状态从”未完成”改为”已失败”，从而触发fail()方法。</p>\n<p>var dtd = $.Deferred(); // 新建一个Deferred对象<br>var wait = function(dtd) {<br>    var tasks = function() {<br>        console.log(“执行完毕！”);<br>        dtd.reject(); // 改变Deferred对象的执行状态<br>    };<br>    setTimeout(tasks, 5000);<br>    return dtd;<br>};</p>\n<p>$.when(wait(dtd))<br> .done(function() { console.log(“哈哈，成功了！”); })<br> .fail(function() { console.log(“出错啦！”); });</p>\n<h2 id=\"七、deferred-promise-方法\"><a href=\"#七、deferred-promise-方法\" class=\"headerlink\" title=\"七、deferred.promise()方法\"></a>七、deferred.promise()方法</h2><p>上面这种写法，还是有问题。那就是dtd是一个全局对象，所以它的执行状态可以从外部改变。 请看下面的代码：</p>\n<p>var dtd = $.Deferred(); // 新建一个Deferred对象<br>var wait = function(dtd) {<br>    var tasks = function() {<br>        console.log(“执行完毕！”);<br>        dtd.resolve(); // 改变Deferred对象的执行状态<br>    };<br>    setTimeout(tasks, 5000);<br>    return dtd;<br>};</p>\n<p>$.when(wait(dtd))<br>.done(function() { console.log(“哈哈，成功了！”); })<br>.fail(function() { console.log(“出错啦！”); });<br>dtd.resolve();</p>\n<p>我在代码的尾部加了一行dtd.resolve()，这就改变了dtd对象的执行状态，因此导致done()方法立刻执行，跳出”哈哈，成功了！”的提示框，等5秒之后再跳出”执行完毕！”的提示框。 为了避免这种情况，jQuery提供了deferred.promise()方法。它的作用是，在原来的deferred对象上返回另一个deferred对象，后者只开放与改变执行状态无关的方法（比如done()方法和fail()方法），屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），从而使得执行状态不能被改变。 请看下面的代码：</p>\n<p>var dtd = $.Deferred(); // 新建一个Deferred对象<br>var wait = function(dtd) {<br>    var tasks = function() {<br>        console.log(“执行完毕！”);<br>        dtd.resolve(); // 改变Deferred对象的执行状态<br>    };<br>    setTimeout(tasks, 5000);<br>    return dtd.promise(); // 返回promise对象<br>};</p>\n<p>var d = wait(dtd); // 新建一个d对象，改为对这个对象进行操作<br>$.when(d)<br>    .done(function() { console.log(“哈哈，成功了！”); })<br>    .fail(function() { console.log(“出错啦！”); });<br>d.resolve(); // 此时，这个语句是无效的</p>\n<p>在上面的这段代码中，wait()函数返回的是promise对象。然后，我们把回调函数绑定在这个对象上面，而不是原来的deferred对象上面。这样的好处是，无法改变这个对象的执行状态，要想改变执行状态，只能操作原来的deferred对象。 不过，更好的写法是allenm所指出的，将dtd对象变成wait(）函数的内部对象。</p>\n<p>var dtd = $.Deferred(); //在函数内部，新建一个Deferred对象<br>    var tasks = function() {<br>        console.log(“执行完毕！”);<br>        dtd.resolve(); // 改变Deferred对象的执行状态<br>    };<br>    setTimeout(tasks, 5000);<br>    return dtd.promise(); // 返回promise对象<br>};</p>\n<p>$.when(wait())<br>    .done(function() { console.log(“哈哈，成功了！”); })<br>    .fail(function() { console.log(“出错啦！”); });</p>\n<h2 id=\"八、普通操作的回调函数接口（中）\"><a href=\"#八、普通操作的回调函数接口（中）\" class=\"headerlink\" title=\"八、普通操作的回调函数接口（中）\"></a>八、普通操作的回调函数接口（中）</h2><p>另一种防止执行状态被外部改变的方法，是使用deferred对象的建构函数$.Deferred()。 这时，wait函数还是保持不变，我们直接把它传入$.Deferred()：</p>\n<p>$.Deferred(wait)<br>　　.done(function(){ console.log(“哈哈，成功了！”); })<br>　　.fail(function(){ console.log(“出错啦！”); });</p>\n<p>jQuery规定，$.Deferred()可以接受一个函数名（注意，是函数名）作为参数，$.Deferred()所生成的deferred对象将作为这个函数的默认参数。</p>\n<h2 id=\"九、普通操作的回调函数接口（下）\"><a href=\"#九、普通操作的回调函数接口（下）\" class=\"headerlink\" title=\"九、普通操作的回调函数接口（下）\"></a>九、普通操作的回调函数接口（下）</h2><p>除了上面两种方法以外，我们还可以直接在wait对象上部署deferred接口。</p>\n<p>var dtd = $.Deferred(); // 生成Deferred对象<br>var wait = function(dtd) {<br>    var tasks = function() {<br>        console.log(“执行完毕！”);<br>        dtd.resolve(); // 改变Deferred对象的执行状态<br>    };<br>    setTimeout(tasks, 5000);<br>};</p>\n<p>dtd.promise(wait);<br>wait.done(function() { console.log(“哈哈，成功了！”); })<br>    .fail(function() { console.log(“出错啦！”); });<br>wait(dtd);</p>\n","categories":["JavaScript"],"tags":[".den()",".fail()","$.ajax()","$.get()","$.post()","then()"]},{"title":"JS中原始类型有哪几种？null 是对象吗？原始数据类型和复杂数据类型有什么区别？","url":"/2019/09/04/js%E4%B8%AD%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9Fnull-%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"<p>目前，JS原始类型有六种，分别为:</p>\n<ul>\n<li>  Boolean</li>\n<li>  String</li>\n<li>  Number</li>\n<li>  Undefined</li>\n<li>  Null</li>\n<li>  Symbol(ES6新增)</li>\n<li>  ES10新增了一种基本数据类型：BigInt</li>\n</ul>\n<h2 id=\"复杂数据类型只有一种-Object\"><a href=\"#复杂数据类型只有一种-Object\" class=\"headerlink\" title=\"复杂数据类型只有一种: Object\"></a>复杂数据类型只有一种: Object</h2><p>null 不是一个对象，尽管 typeof null 输出的是 object，这是一个历史遗留问题，JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，null 表示为全零，所以将它错误的判断为 object 。 基本数据类型和复杂数据类型的区别为: 1、内存的分配不同</p>\n<ul>\n<li>  基本数据类型存储在栈中。</li>\n<li>  复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址。</li>\n</ul>\n<p>2、访问机制不同</p>\n<ul>\n<li>  基本数据类型是按值访问</li>\n<li>  复杂数据类型按引用访问，JS不允许直接访问保存在堆内存中的对象，在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值。</li>\n</ul>\n<p>3、复制变量时不同(a=b)</p>\n<ul>\n<li>  基本数据类型：a=b;是将b中保存的原始值的副本赋值给新变量a，a和b完全独立，互不影响</li>\n<li>  复杂数据类型：a=b;将b保存的对象内存的引用地址赋值给了新变量a;a和b指向了同一个堆内存地址，其中一个值发生了改变，另一个也会改变。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let b &#x3D; &#123;</span><br><span class=\"line\">age: 10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let a &#x3D; b;</span><br><span class=\"line\">a.age &#x3D; 20;</span><br><span class=\"line\">console.log(a); &#x2F;&#x2F;&#123; age: 20 &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数传递的不同-实参-形参\"><a href=\"#参数传递的不同-实参-形参\" class=\"headerlink\" title=\"参数传递的不同(实参/形参)\"></a>参数传递的不同(实参/形参)</h2><p>函数传参都是按值传递(栈中的存储的内容)：基本数据类型，拷贝的是值；复杂数据类型，拷贝的是引用地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;基本数据类型</span><br><span class=\"line\">let b &#x3D; 10</span><br><span class=\"line\"></span><br><span class=\"line\">function change(info) &#123;</span><br><span class=\"line\">info&#x3D;20;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;info&#x3D;b;基本数据类型，拷贝的是值得副本，二者互不干扰</span><br><span class=\"line\">change(b);</span><br><span class=\"line\">console.log(b);&#x2F;&#x2F;10</span><br><span class=\"line\">&#x2F;&#x2F;复杂数据类型</span><br><span class=\"line\">let b &#x3D; &#123;</span><br><span class=\"line\">age: 10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function change(info) &#123;</span><br><span class=\"line\">info.age &#x3D; 20;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;info&#x3D;b;根据第三条差异，可以看出，拷贝的是地址的引用，修改互相影响。</span><br><span class=\"line\">change(b);</span><br><span class=\"line\">console.log(b);&#x2F;&#x2F;&#123; age: 20 &#125;</span><br></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["Boolean","Number","String","Undefined","原始数据类型"]},{"title":"localStorage 使用指南-你所不知道的 localStorage","url":"/2019/02/20/localstorage-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-localstorage/","content":"<p>相信大家对于本地存储的 <code>localStorage</code> 和 <code>sessionStorage</code> 对象已经非常熟悉了。那么首先花点小篇幅稍微回顾一下。 localStorage 数据存储也是跨浏览器会话。localStorage 类似于sessionStorage。区别在于，数据存储在 localStorage 是无期限的，而当页面会话结束——也就是说当页面被关闭时,数据存储在 sessionStorage 会被清除。 常用的四个 API 也很简单 ：</p>\n<p>// 增加了一个 localStorage ‘myCat’ 数据项<br>localStorage.setItem(‘myCat’, ‘Tom’);</p>\n<p>// 读取 localStorage ‘myCat’ 数据项<br>let cat = localStorage.getItem(‘myCat’);</p>\n<p>// 移除 localStorage ‘myCat’ 数据项<br>localStorage.removeItem(‘myCat’);</p>\n<p>// 移除所有的 localStorage 数据项<br>localStorage.clear();</p>\n<p>相信大家对这些已经非常熟悉了，也没什么好说的，我们接下来说说大家可能陌生的，不常用的一些东西。 localStorage 对象 和 Storage 对象 首先来说说 <code>Storage</code> 对象，<code>Storage</code> 提供了访问特定域名下的会话存储（session storage）或本地存储（local storage）的功能，例如，可以添加、修改或删除存储的数据项。 <code>Storage</code> 对象通过 <code>Window.sessionStorage</code> 和 <code>Window.localStorage</code> 属性使用（更确切的说，在支持的浏览器中 <code>Window</code> 对象实现了 <code>WindowLocalStorage</code> 和 <code>WindowSessionStorage</code> 对象并挂在其 <code>localStorage</code> 和 <code>sessionStorage</code> 属性下）—— 调用其中任一对象会创建相应的 <code>Storage</code> 对象，通过 <code>Storage</code> 对象，可以设置、获取和移除数据项。对于每个源（origin）sessionStorage 和 localStorage 使用不同的 <code>Storage</code> 对象——独立运行和控制。 有点绕口是吧？我们说的直接一点。 <code>localStorage</code> 对象其实就是 <code>Storage</code> 对象的实例对象。我们可以在 Firefox 的开发者工具的控制台(Console)面板中输入 <code>Storage</code>，<code>localStorage</code>，查看这两个对象，再输入 <code>localStorage instanceof Storage</code> 或者 <code>localStorage.constructor == Storage</code> 查看这两个对象的关系： <img src=\"http://file.w3cbest.com/file/images/1543401637592.jpg\"> Chrome 控制台(Console)面板中输入 <code>Storage</code> 看不到内容，但是原理是一样的： <img src=\"http://file.w3cbest.com/file/images/WeChat42ea82bb9fbae5a615243d1b718fb27c.png\"> 我们可以看出 <strong><code>localStorage</code> 是 <code>Storage</code> 对象的实例对象！</strong> 那么这就和我们所理解的 JavaScript 实例对象和原型继承完全是同一套逻辑了，是吧？也就是说我们接下来可以和我们自己编写的实例对象一样，随意使用 <code>localStorage</code> 对象。</p>\n<h2 id=\"localStorage-一些不为人知的方法\"><a href=\"#localStorage-一些不为人知的方法\" class=\"headerlink\" title=\"localStorage 一些不为人知的方法\"></a>localStorage 一些不为人知的方法</h2><p>上面已经说过的，我们熟知的 <code>localStorage.setItem()</code>，<code>localStorage.getItem()</code>，<code>localStorage.removeItem()</code>，<code>localStorage.clear()</code> 方法我们不再赘述。</p>\n<h3 id=\"访问和设置数据\"><a href=\"#访问和设置数据\" class=\"headerlink\" title=\"访问和设置数据\"></a>访问和设置数据</h3><p><code>localStorage</code> 对象是简单的键值存储，类似于对象。 <strong>键和值始终是字符串</strong>。 您可以像对象一样，使用点语法<code>.</code>或者中括号<code>[]</code>的形式访问这些值，也可以使用 <code>localStorage.getItem()</code> 和 <code>localStorage.setItem()</code> 方法访问或者设置这些值。 下面的代码是等价的：</p>\n<p>// 设置值<br>localStorage.myCat = ‘Tom’;<br>localStorage[‘myCat’] = ‘Tom’;<br>localStorage.setItem(‘myCat’, ‘Tom’);</p>\n<p>// 获取值<br>localStorage.myCat; // ‘Tom’<br>localStorage[‘myCat’]; // ‘Tom’<br>localStorage.getItem(‘myCat’); // ‘Tom’</p>\n<p>我一般都使用点语法，但是官方建议使用 <code>setItem</code>, <code>getItem</code>, <code>removeItem</code> 这些API，来防止与使用普通对象作为键值存储相关的 <a href=\"http://www.2ality.com/2012/01/objects-as-maps.html\">陷阱</a>。</p>\n<h3 id=\"使用localStorage-hasOwnProperty-检查localStorage中存储的数据里是否保存某个值\"><a href=\"#使用localStorage-hasOwnProperty-检查localStorage中存储的数据里是否保存某个值\" class=\"headerlink\" title=\"使用localStorage.hasOwnProperty()检查localStorage中存储的数据里是否保存某个值\"></a>使用<code>localStorage.hasOwnProperty()</code>检查<code>localStorage</code>中存储的数据里是否保存某个值</h3><p><code>hasOwnProperty()</code> 方法检查对象自身属性中是否具有指定的属性，返回一个布尔值。换句话说就是检查<code>localStorage</code>中存储的数据里是否保存某个值。 假设，我们得本地存储了<code>myCat</code>数据，没存<code>youCat</code>数据。之前你要判断本地是否存储了<code>youCat</code>数据，你可能需要这么做：</p>\n<p>localStorage.getItem(‘youCat’) //null</p>\n<p>有了 <code>hasOwnProperty()</code> 方法就简单多了：</p>\n<p>localStorage.hasOwnProperty(‘myCat’) // true<br>localStorage.hasOwnProperty(‘youCat’) // false</p>\n<p><img src=\"http://file.w3cbest.com/file/images/WeChat22313c6712c57a7db3542a013c0ccd64.png\"></p>\n<h3 id=\"Object-keys-localStorage-查看-localStorage-中存储数据所有的键\"><a href=\"#Object-keys-localStorage-查看-localStorage-中存储数据所有的键\" class=\"headerlink\" title=\"Object.keys(localStorage) 查看 localStorage 中存储数据所有的键\"></a>Object.keys(localStorage) 查看 localStorage 中存储数据所有的键</h3><p>想知道<code>localStorage</code>中存储了哪些值，我们可以直接使用<code>Object.keys(localStorage)</code>查看，很方便。 <img src=\"http://file.w3cbest.com/file/images/WeChat59edf3d5c4c34793b1c961b69569aa98.png\"></p>\n<h3 id=\"localStorage-key-index-方法\"><a href=\"#localStorage-key-index-方法\" class=\"headerlink\" title=\"localStorage.key(index) 方法\"></a>localStorage.key(index) 方法</h3><p>读取第<code>index</code>个数据的名字或键经常(从0开始索引)，感觉这个方法没什么用。</p>\n<p>localStorage.key(5); // “myCat”</p>\n<h3 id=\"localStorage-length属性\"><a href=\"#localStorage-length属性\" class=\"headerlink\" title=\"localStorage.length属性\"></a><code>localStorage.length</code>属性</h3><p>localStorage 存储了多少个数具，感觉用处不大。</p>\n<p>localStorage.length; // 6</p>\n<h2 id=\"其他实用技巧\"><a href=\"#其他实用技巧\" class=\"headerlink\" title=\"其他实用技巧\"></a>其他实用技巧</h2><p>接下来再来说说实际应用的技巧。</p>\n<h3 id=\"将-JSON-存储到-localStorage-里\"><a href=\"#将-JSON-存储到-localStorage-里\" class=\"headerlink\" title=\"将 JSON 存储到 localStorage 里\"></a>将 JSON 存储到 localStorage 里</h3><p>为了方便起见，我们通常会将一个大数组或者对象存储到<code>localStorage</code>中。而<code>localStorage</code>只能存储字符串，所以我们可以使用JSON方法对存取值进行转换：</p>\n<p>var users = [{<br>        name: “xiaoming”,<br>        grade: 1<br>    },<br>    {<br>        name: “teemo”,<br>        grade: 3<br>    }<br>];</p>\n<p>// 存数据<br>usersStr = JSON.stringify(users); //将JSON转为字符串<br>localStorage.users = usersStr; // 将字符串存到 localStorage users 键下</p>\n<p>// 取数据<br>var newUsers = JSON.parse(localStorage.users); // 转为JSON<br>console.log(newUsers); // 打印出原先对象</p>\n<h3 id=\"为-localStorage-设置过期时间\"><a href=\"#为-localStorage-设置过期时间\" class=\"headerlink\" title=\"为 localStorage 设置过期时间\"></a>为 localStorage 设置过期时间</h3><p><code>localstorage</code>原生是不支持设置过期时间的，想要设置的话，就只能自己来封装一层逻辑来实现：</p>\n<p>function set(key, value) {<br>    var curtime = new Date().getTime(); //获取当前时间<br>    localStorage.setItem(key, JSON.stringify({ val: value, time: curtime })); //转换成json字符串序列<br>}</p>\n<p>function get(key, exp) //exp是设置的过期时间<br>{<br>    var val = localStorage.getItem(key); //获取存储的元素<br>    var dataobj = JSON.parse(val); //解析出json对象<br>    if (new Date().getTime() - dataobj.time &gt; exp) //如果当前时间-减去存储的元素在创建时候设置的时间 &gt; 过期时间<br>    {<br>        console.log(“expires”); //提示过期<br>    } else {<br>        console.log(“val=” + dataobj.val);<br>    }<br>}</p>\n<p>原理就是在存值得时候附带一个设置的时间，取值的时候传一个时间过期时间（毫秒），和存的时间做比较，然后做相应的操作。</p>\n<h3 id=\"storage-事件\"><a href=\"#storage-事件\" class=\"headerlink\" title=\"storage 事件\"></a>storage 事件</h3><p>当存储数据发生变化时，会触发<code>storage</code>事件。值得特别注意的是，该事件不在导致数据变化的当前页面触发。如果浏览器同时打开一个域名下面的多个页面，当其中的一个页面改变<code>sessionStorage</code>或<code>localStorage</code>的数据时，其他所有页面的<code>storage</code>事件会被触发，而原始页面并不触发<code>storage</code>事件。可以通过这种机制，实现多个窗口之间的通信。（当然 ie 这个特例除外，它包含自己本事也会触发storage事件）。 例如我们全局下监storage事件，</p>\n<p>window.addEventListener(“storage”, function onStorageChange(event) {<br>    // event 对象中几个主要属性：<br>    console.log(event.key); //更新值得键<br>    console.log(event.oldValue); //更新前的值。如果该键为新增加，则这个属性为null。<br>    console.log(event.newValue); //更新后的值。如果该键被删除，则这个属性为null。<br>    // 如果 Storage 调用的是 clear 方法，则事件中的 key 、oldValue 、newValue 都是为 null<br>    console.log(event.url); //原始触发storage事件的那个网页的网址。<br>});</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文列出了<code>localStorage</code>中一些常用和不常用的方法，<code>sessionStorage</code>也是一样的原理，只是会话结束后<code>sessionStorage</code>会被清空。</p>\n","categories":["JavaScript"],"tags":["API过期时间","hasOwnProperty","localStorage","sessionStorage","storage 事件","web Storage"]},{"title":":matches() (:any()) 方便好用的伪类函数选择器","url":"/2018/12/06/matches-any-%E6%96%B9%E4%BE%BF%E5%A5%BD%E7%94%A8%E7%9A%84%E4%BC%AA%E7%B1%BB%E5%87%BD%E6%95%B0%E9%80%89%E6%8B%A9%E5%99%A8/","content":"<p><code>:matches()</code> CSS 伪类函数将选择器列表作为参数，并选择该列表中任意一个选择器可以选择的元素。这对于以更紧凑的形式编写大型选择器非常有用。</p>\n<blockquote>\n<p>注意，许多浏览器通过一个更旧的、带前缀的伪类:any()来支持这个功能，包括旧版本的Chrome、Firefox和Safari。这与<code>:matches()</code>的工作方式完全相同，只是它需要厂商前缀，不支持复杂的选择器。</p>\n</blockquote>\n<p>/* 选择header, main, footer里的任意一个悬浮状态的段落(p标签) */<br>:matches(header, main, footer) p:hover {<br>color: red;<br>cursor: pointer;<br>}</p>\n<p>/* 以上内容相当于以下内容 */<br>header p:hover,<br>main p:hover,<br>footer p:hover {<br>color: red;<br>cursor: pointer;<br>}</p>\n<p>/* 向后兼容的版本:-*-any() */<br>:-moz-any(header, main, footer) p:hover,<br>:-webkit-any(header, main, footer) p:hover,<br>:matches(header, main, footer) p:hover {<br>color: red;<br>cursor: pointer;<br>}</p>\n<h4 id=\"来个例子：\"><a href=\"#来个例子：\" class=\"headerlink\" title=\"来个例子：\"></a>来个例子：</h4><header>\n<p>一段标题信息</p>\n</header>\n\n<main>\n<ul>\n<li><p>一段列表</p><p>列表项</p></li>\n<li><p>一段列表</p><p>列表项</p></li>\n</ul>\n</main>\n\n<footer>\n<p>一段底部信息</p>\n</footer>\n\n<p>:matches(header, main, footer) p:hover {<br>color: red;<br>cursor: pointer;<br>}</p>\n<p>:-webkit-any(header, main, footer) p:hover {<br>color: red;<br>cursor: pointer;<br>}</p>\n<p>:-moz-any(header, main, footer) p:hover {<br>color: red;<br>cursor: pointer;<br>}</p>\n<h3 id=\"选择器列表简化\"><a href=\"#选择器列表简化\" class=\"headerlink\" title=\"选择器列表简化\"></a>选择器列表简化</h3><p><code>:matches()</code> 伪类可以大大简化CSS选择器。例如，下面的CSS:</p>\n<p>/* 多层无须列表 */<br>ol ol ul, ol ul ul, ol menu ul, ol dir ul,<br>ol ol menu, ol ul menu, ol menu menu, ol dir menu,<br>ol ol dir, ol ul dir, ol menu dir, ol dir dir,<br>ul ol ul, ul ul ul, ul menu ul, ul dir ul,<br>ul ol menu, ul ul menu, ul menu menu, ul dir menu,<br>ul ol dir, ul ul dir, ul menu dir, ul dir dir,<br>menu ol ul, menu ul ul, menu menu ul, menu dir ul,<br>menu ol menu, menu ul menu, menu menu menu, menu dir menu,<br>menu ol dir, menu ul dir, menu menu dir, menu dir dir,<br>dir ol ul, dir ul ul, dir menu ul, dir dir ul,<br>dir ol menu, dir ul menu, dir menu menu, dir dir menu,<br>dir ol dir, dir ul dir, dir menu dir, dir dir dir {<br>list-style-type: square;<br>}</p>\n<p>可以被替换为：</p>\n<p>:matches(ol, ul, menu, dir) :matches(ol, ul, menu, dir) ul,<br>:matches(ol, ul, menu, dir) :matches(ol, ul, menu, dir) menu,<br>:matches(ol, ul, menu, dir) :matches(ol, ul, menu, dir) dir {<br>list-style-type: square;<br>}</p>\n<p>但是，不要像下面那么做: (参见 the section on performance 。)</p>\n<p>:matches(ol, ul, menu, dir) :matches(ol, ul, menu, dir) :matches(ul, menu, dir) {<br>list-style-type: square;<br>}</p>\n<h3 id=\"简化部分选择器\"><a href=\"#简化部分选择器\" class=\"headerlink\" title=\"简化部分选择器\"></a>简化部分选择器</h3><p><code>:matches</code> 伪类在处理HTML5 <a href=\"https://developer.mozilla.org/en-US/docs/Sections_and_Outlines_of_an_HTML5_document\">sections and headings</a>特别有用。 由于 <code>&lt;section&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;aside&gt;</code>, <code>&lt;nav&gt;</code> 经常嵌套在一起, 没有 <code>:matches()</code>的话匹配其他元素将会很棘手。 例如, 在没有 :matches()的情况下, 在不同深度对所有<h1> 素进行样式化可能非常复杂:</p>\n<p>/* Level 0 */<br>h1 {<br>font-size: 30px;<br>}<br>/* Level 1 */<br>section h1, article h1, aside h1, nav h1 {<br>font-size: 25px;<br>}<br>/* Level 2 */<br>section section h1, section article h1, section aside h1, section nav h1,<br>article section h1, article article h1, article aside h1, article nav h1,<br>aside section h1, aside article h1, aside aside h1, aside nav h1,<br>nav section h1, nav article h1, nav aside h1, nav nav h1, {<br>font-size: 20px;<br>}<br>/* Level 3 */<br>/* … */</p>\n<p>使用 :matches()之后,它变的非常简单:</p>\n<p>/* Level 0 */<br>h1 {<br>font-size: 30px;<br>}<br>/* Level 1 */<br>:matches(section, article, aside, nav) h1 {<br>font-size: 25px;<br>}<br>/* Level 2 */<br>:matches(section, article, aside, nav)<br>:matches(section, article, aside, nav) h1 {<br>font-size: 20px;<br>}<br>/* Level 3 */<br>:matches(section, article, aside, nav)<br>:matches(section, article, aside, nav)<br>:matches(section, article, aside, nav) h1 {<br>font-size: 15px;<br>}</p>\n<p>这个函数暂时还不被完全支持，相信不久的将来一定会被完美支持</p>\n","categories":["HTML/CSS"],"tags":["css3","css函数",":matches()"]},{"title":"Notyf – 响应式的 JavaScript 通知插件","url":"/2019/04/20/notyf-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84-javascript-%E9%80%9A%E7%9F%A5%E6%8F%92%E4%BB%B6/","content":"<h2 id=\"简要教程\"><a href=\"#简要教程\" class=\"headerlink\" title=\"简要教程\"></a>简要教程</h2><p>notyf.js是一款超级简单的响应式纯js消息通知插件。它使用纯javascript来制作，没有任何外部依赖，通过简单的设置，即可生成漂亮的消息通知效果。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>可以通过npm来安装notyf.js消息通知插件。</p>\n<p>npm i notyf</p>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><p>在页面中引入notyf.min.css和notyf.min.js文件。</p>\n<html>\n<head>\n    ...\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"/path/to/notyf.min.css\">\n</head>\n<body>\n    ...\n    <script src=\"/path/to/notyf.min.js\" type=\"text/javascript\"></script>\n</body>\n</html>\n\n<h2 id=\"初始化插件\"><a href=\"#初始化插件\" class=\"headerlink\" title=\"初始化插件\"></a>初始化插件</h2><p>notyf.js消息通知插件的使用方法如下：</p>\n<p>//创建一个Notyf实例对象<br>var notyf = new Notyf();<br>//显示一条警告消息<br>notyf.error(‘You must fill out the form before moving forward’);<br>//显示一条成功消息<br>notyf.success(‘Your changes have been successfully saved!’);</p>\n<h2 id=\"配置参数\"><a href=\"#配置参数\" class=\"headerlink\" title=\"配置参数\"></a>配置参数</h2><p>notyf.js消息通知插件的可用配置参数如下：</p>\n<p>参数</p>\n<p>类型</p>\n<p>默认值</p>\n<p>描述</p>\n<p>delay</p>\n<p>Number</p>\n<p>2000</p>\n<p>消息通知显示的延迟时间，单位毫秒</p>\n<p>alertIcon</p>\n<p>String</p>\n<p>预定义图标</p>\n<p>警告消息显示的图标的class类</p>\n<p>confirmIcon</p>\n<p>String</p>\n<p>预定义图标</p>\n<p>成功消息显示的图标的class类</p>\n<p>下面的例子是消息在用户点击按钮后1秒钟显示，并使用FontAwesome字体图标作为警告框和成功消息框的图标。</p>\n<p>var notyf = new Notyf({<br>    delay: 1000,<br>    alertIcon: ‘icon icon-exclamation-circle’,<br>    confirmIcon: ‘icon icon-check-circle’<br>})</p>\n<p>演示地址：<a href=\"https://carlosroso.com/notyf/\">https://carlosroso.com/notyf/</a> github地址：<a href=\"https://github.com/caroso1222/notyf\">https://github.com/caroso1222/notyf</a></p>\n","categories":["资源","JavaScript"],"tags":["js对话框","js消息通知","对话框","消息通知"]},{"title":"Js 中的 window.parent ,window.top, window.self 详解","url":"/2017/07/13/window.parent%20,window.top,window.self%20%E8%AF%A6%E8%A7%A3/","content":"<p>在应用有 frameset 或者 iframe 的页面时，parent 是父窗口，top 是最顶级父窗口（有的窗口中套了好几层 frameset 或者 iframe），self 是当前窗口， opener 是用 open 方法打开当前窗口的那个窗口。</p>\n<h3 id=\"window-self\"><a href=\"#window-self\" class=\"headerlink\" title=\"window.self\"></a>window.self</h3><p>功能：是对当前窗口自身的引用。它和 window 属性是等价的。</p>\n<p>语法：window.self</p>\n<p>注：window、self、window.self 是等价的。</p>\n<h3 id=\"window-top\"><a href=\"#window-top\" class=\"headerlink\" title=\"window.top\"></a>window.top</h3><p>功能：返回顶层窗口，即浏览器窗口。</p>\n<p>语法：window.top</p>\n<p>注：如果窗口本身就是顶层窗口，top 属性返回的是对自身的引用。</p>\n<h3 id=\"window-parent\"><a href=\"#window-parent\" class=\"headerlink\" title=\"window.parent\"></a>window.parent</h3><p>功能：返回父窗口。</p>\n<p>语法：window.parent</p>\n<p>注：如果窗口本身是顶层窗口，parent 属性返回的是对自身的引用。</p>\n<p>在框架网页中，一般父窗口就是顶层窗口，但如果框架中还有框架，父窗口和顶层窗口就不一定相同了。</p>\n<p>判断当前窗口是否在一个框架中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class=\"line\">var b &#x3D; window.top!&#x3D;window.self;</span><br><span class=\"line\">document.write( &quot;当前窗口是否在一个框架中：&quot;+b );</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n<p>你应当将框架视为窗口中的不同区域，框架是浏览器窗口中特定的部分。一个浏览器窗口可以根据你的需要分成任意多的框架，一个单个的框架也可以分成其它多个框架，即所谓的嵌套框架。</p>\n<p>举个栗子：</p>\n<p>parent.html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">　  &lt;iframe src&#x3D;&quot;child.html&quot; frameborder&#x3D;&quot;0&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">          window.methods &#x3D; &#123;</span><br><span class=\"line\">              workOrderCallback() &#123;</span><br><span class=\"line\">                  console.log(arguments);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">     &lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n\n<p>child.html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    window.parent.methods.workOrderCallback(111);</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><pre><code>首先要保证同域\n这里用的 window.parent 找的是父级 window,区别于 window.top\n</code></pre>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/parent\" target=\"_blank\" rel=\"noopener\">window.parent</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/top\" target=\"_blank\" rel=\"noopener\">window.top</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/self\" target=\"_blank\" rel=\"noopener\">window.self</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/frameElement\" target=\"_blank\" rel=\"noopener\">window.frameElement</a></p>\n","tags":["window.parent","window.top","window.self"]},{"title":"windows下 sublime text3 安装babel编译es6插件","url":"/2018/10/24/windows%E4%B8%8B-sublime-text3-%E5%AE%89%E8%A3%85babel%E7%BC%96%E8%AF%91es6%E6%8F%92%E4%BB%B6/","content":"<h4 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h4><p>先安装babel-cli</p>\n<p>npm install –save-dev babel-cli</p>\n<h4 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h4><p>在sublime text 中<a href=\"https://packagecontrol.io/packages/Babel\">安装babel插件</a> 插件如何安装这里就不多解释，不过记住一定是babel</p>\n<h4 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h4><p>安装好后来配置一下安装的babel插件 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/10/babel-cil.jpg\"> <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/10/babel-cil-url.jpg\"> 这里的地址要配置好，<strong>也就是你安装的babel-cli的目录地址</strong>，让插件可以在此寻找 babel或babel-core 命令，否则就会报错 <a href=\"https://github.com/babel/babel-sublime/issues/171\">Couldn’t find babel or babel-core</a></p>\n<h4 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h4><p>在当前目录配置好.babelrc文件，定义转码规则，在当前目录放置好依赖包（因为这里找不到全局的）</p>\n<p>npm install –save babel-preset-es2015</p>\n<p>比如我只用了babel编译es5，就在.babelrc文件里添加</p>\n<p>{<br>“presets”: [<br>“es2015”<br>]<br>}</p>\n<p>然后在js文件里编写es6的代码，按下快捷键Ctrl+Shift+P，输入babel，选择 babel transform 执行即可，如果顺利的话，就能看到es6文件已经转换为es5语法，然而有一个很大的缺陷就是只能生成匿名文件，具体如何解决还没找到方法。 其他一些<a href=\"https://www.babeljs.cn/docs/editors.html\">编辑器的安装方法</a></p>\n","categories":["资源","JavaScript"],"tags":["babel","es6","sublime"]},{"title":"wordpress 输出 wp_nav_menu()菜单函数","url":"/2019/05/29/wordpress-%E8%BE%93%E5%87%BA-wp-nav-menu%E8%8F%9C%E5%8D%95%E5%87%BD%E6%95%B0/","content":"<p>wp_nav_menu()函数主要用途是通过该方法，实现后台的生成菜单调用。使用该功能之前，必须激活主题3.0+菜单功能。 激活方法如下： 在<strong>functions.php</strong>文件中加入</p>\n<p>if (function_exists(‘register_nav_menus’)) {<br>  register_nav_menus(<br>    array(<br>      ‘header-menu’ =&gt; __(‘导航菜单’),<br>      ‘footer-menu’ =&gt; __(‘页脚菜单’),<br>      ‘side-menu’ =&gt; __(‘侧边栏菜单’)<br>    )<br>  );<br>}</p>\n<p>上面这些，只是菜单的位置，并不是菜单的内容。菜单的内容，得在后台添加。</p>\n<h2 id=\"简单调用如下：\"><a href=\"#简单调用如下：\" class=\"headerlink\" title=\"简单调用如下：\"></a>简单调用如下：</h2><?php wp\\_nav\\_menu(\n  array(\n    'theme\\_location' => '' //指定显示的导航名，如果没有设置，则显示第一个\n    'menu' => 'header-menu', //后台设置的菜单的名称\n    'container' => 'nav', //最外层容器标签名\n    'container\\_class' => 'primary', //最外层容器class名\n    'container\\_id' => '', //最外层容器id值\n    'menu\\_class' => 'sf-menu', //ul标签class\n    'menu\\_id' => 'topnav', //ul标签id\n    'echo' => true, //是否打印，默认是true，如果想将导航的代码作为赋值使用，可设置为false\n    'fallback\\_cb' => 'wp\\_page\\_menu', //备用的导航菜单函数，用于没有在后台设置导航时调用\n    'before' => '', //显示在导航a标签之前\n    'after' => '', //显示在导航a标签之后\n    'link\\_before' => '', //显示在导航链接名之后\n    'link\\_after' => '', //显示在导航链接名之前\n    'items\\_wrap' => '<ul id=\"%1$s\">%3$s</ul>',\n    'depth' => 0, ////显示的菜单层数，默认0，0是显示所有层\n    'walker' => '' // //调用一个对象定义显示导航菜单\n  ));\n?>\n\n<h2 id=\"根据是否登录生成不同该菜单栏\"><a href=\"#根据是否登录生成不同该菜单栏\" class=\"headerlink\" title=\"根据是否登录生成不同该菜单栏\"></a>根据是否登录生成不同该菜单栏</h2><?php\nif ( is\\_user\\_logged\\_in() ) {\n     wp\\_nav\\_menu( array( 'theme\\_location' => 'logged-in-menu' ) );\n} else {\n     wp\\_nav\\_menu( array( 'theme\\_location' => 'logged-out-menu' ) );\n}\n?>\n\n<p><strong>移除菜单栏</strong></p>\n<p>function my_wp_nav_menu_args($args = ‘’) {<br>  $args[‘container’] = false;<br>  return $args;<br>} // function<br>add_filter(‘wp_nav_menu_args’, ‘my_wp_nav_menu_args’); ?&gt;</p>\n<p>或者</p>\n<?php wp\\_nav\\_menu(array('container' => '')); ?>\n\n<p> </p>\n<h2 id=\"将“active”类添加到wp-nav-menu（）\"><a href=\"#将“active”类添加到wp-nav-menu（）\" class=\"headerlink\" title=\"将“active”类添加到wp_nav_menu（）\"></a>将“active”类添加到wp_nav_menu（）</h2><p>要在其中一个子页面处于活动状态时突出显示该菜单项，还请检查其他类（<code>current-page-ancestor</code>），如下所示：</p>\n<p>function special_nav_class($classes, $item) {<br>  if (in_array(‘current-page-ancestor’, $classes)  in_array(‘current-menu-item’, $classes)) {<br>    $classes[] = ‘active ‘;<br>  }<br>  return $classes;<br>}</p>\n<p>add_filter(‘nav_menu_css_class’, ‘special_nav_class’, 10, 2);</p>\n<p>  <a href=\"https://developer.wordpress.org/reference/functions/wp/_nav/_menu/\">https://developer.wordpress.org/reference/functions/wp\\_nav\\_menu/</a></p>\n","categories":["wordpress"],"tags":["wordpress","wp_nav_menu()"]},{"title":"wordpress主题get_the_category()函数使用详解","url":"/2019/05/20/wordpress%E4%B8%BB%E9%A2%98get-the-category%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/","content":"<p>函数 get_the_category() 是获取与查询参数相匹配的类别对象，用法如下：</p>\n<?php get\\_the\\_category($id) ?>\n\n<p>显示第一个类别的名称</p>\n<?php\n    $category = get\\_the\\_category();\n    echo $category\\[0\\]->cat\\_name;\n?>\n\n<p>显示第一个类别的连接</p>\n<?php\n    $category = get\\_the\\_category();\n        if($category\\[0\\]){\n        echo '<a href=\"'.get\\_category\\_link($category\\[0\\]->term\\_id ).'\">'.$category\\[0\\]->cat\\_name.'</a>';\n    }\n?>\n\n<p>获取指定文章编号的类别信息</p>\n<?php\n    global $post;\n    $categories = get\\_the\\_category($post->ID);\n    var\\_dump($categories);\n?>\n\n<p>显示类别的图片</p>\n<?php\n    foreach((get\\_the\\_category()) as $category) {\n        echo '<img src=\"http://www.w3cbest.com/images/' . $category->cat\\_ID . '.jpg\" alt=\"' . $category->cat\\_name . '\" />';\n    }\n?>\n\n<p>返回对象的成员：</p>\n<ul>\n<li>  cat_ID：类别编号，存储在term_id字段;</li>\n<li>  cat_name：类别名称，存储在name字段;</li>\n<li>  category_nicename：别名，存储在slug字段;</li>\n<li>  category_description：类别描述，存储在description字段;</li>\n<li>  category_parent：父类别编号，没有父类的为0，存储在parent字段;</li>\n<li>  category_count：类别使用的数量，存储在count字段.</li>\n</ul>\n<p>文件：</p>\n<blockquote>\n<p>wp-includes/category-template.php</p>\n</blockquote>\n<p>参考： <a href=\"https://developer.wordpress.org/reference/functions/get/_the/_category/\">https://developer.wordpress.org/reference/functions/get\\_the\\_category/</a></p>\n","categories":["wordpress"],"tags":["get_the_category()","wordpress get_the_category()","wordpress主题"]},{"title":"wordpress禁用5.0.2版本自带的Gutenberg编辑器","url":"/2018/12/28/wordpress%E7%A6%81%E7%94%A85-0-2%E7%89%88%E6%9C%AC%E8%87%AA%E5%B8%A6%E7%BC%96%E8%BE%91%E5%99%A8/","content":"<p>禁用方法，在function.php文件里面加入这句就可以禁用新版编辑器</p>\n<p>add_filter(‘use_block_editor_for_post’, ‘__return_false’);</p>\n<p>后台禁用block editor编辑器后，前端还是会加载相关的的样式文件，还需要加上一句：</p>\n<p>remove_action( ‘wp_enqueue_scripts’, ‘wp_common_block_scripts_and_styles’ );</p>\n<p>禁止前端加载样式文件。</p>\n","categories":["资源"],"tags":["wordpress","Gutenberg","古腾堡","古腾堡编辑器","编辑器"]},{"title":"wordpress引用脚本js文件的最佳函数wp_enqueue_script()","url":"/2018/11/16/wordpress%E5%BC%95%E7%94%A8%E8%84%9A%E6%9C%ACjs%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E4%BD%B3%E5%87%BD%E6%95%B0wp-enqueue-script/","content":"<p>相信大部分人在制作wordpress主题引用js文件时，会直接在header.php或footer.php文件中或通过<code>bloginfo()</code>函数调用js文件，其实wordpress主题最佳引用js文件的方法是使用wordpress内置的<code>wp_enqueue_script()</code>函数，通过该函数可以安全地将javascript代码加入到WordPress创建的页面中，不仅可以最大限度地保证兼容性，还是提高wordpress性能效率的一个方法。</p>\n<h2 id=\"函数代码：\"><a href=\"#函数代码：\" class=\"headerlink\" title=\"函数代码：\"></a>函数代码：</h2><?php wp\\_enqueue\\_script( string $handle, string $src = '', array $deps = array(), stringboolnull $ver = false, bool $in\\_footer = false ) ?>\n\n<h3 id=\"参数说明：\"><a href=\"#参数说明：\" class=\"headerlink\" title=\"参数说明：\"></a>参数说明：</h3><ul>\n<li>  <code>$handle</code> (string)(必需) 调用的脚本名称，用于区分其它脚本js，因此不能和其它脚本js文件命名相同；</li>\n<li>  <code>$src</code> (字符串)(可选) 脚本的完整路径，或脚本相对于WordPress根目录的路径。 默认值: ‘’；</li>\n<li>  <code>$deps</code> 依赖关系，加载的js文件所依存的其它js的标识字串数组（array:string），即需要在本代码之前加载的代码的名称（如js脚本依赖jquery库，那么这里要用数组的形式写上jquery），非必需;</li>\n<li>  <code>$ver</code> 加载js文件的版本号，作为查询字串附加在路径的末尾，作用是确保正确的版本信息传递给了客户端，以免受到缓存的影响（如js脚本发生变化时，通过更改版本号可以强制客户浏览器更新缓存），默认为false，调用当前wordpress程序的版本号，如果不想显示，则设置为NULL（不推荐）;</li>\n<li>  <code>$in_footer</code> boolean类型，设置调用js文件放置的位置，设置为ture则放在</body>之前，设置为false则放置在head部分;</li>\n</ul>\n<h3 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h3><p>通过<code>wp_enqueue_script</code>函数加载js文件时，应该将它分配给一个钩子，如只在前台调用，使用钩子<code>wp_enqueue_script</code>；只在后台调用，使用<code>admin_enqueue_scripts</code>。</p>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><p>只在前台调用</p>\n<?php\nfunction dui\\_theme\\_scripts() {  \nwp\\_enqueue\\_script( 'dui', get\\_template\\_directory\\_uri() . '/assets/js/dui.js', array(), '1.0.0', true );\n}\nadd\\_action( 'wp\\_enqueue\\_scripts', 'dui\\_theme\\_scripts' );\n?>\n\n<p>只在后台调用</p>\n<?php\nfunction dui\\_theme\\_scripts() {  \nwp\\_enqueue\\_script( 'dui', get\\_template\\_directory\\_uri() . '/assets/js/dui.js', array(), '1.0.0', true );\n}\nadd\\_action( 'admin\\_enqueue\\_scripts', 'dui\\_theme\\_scripts' );\n?>\n\n<p>附：函数位置wp-includes/functions.wp-scripts.php文件</p>\n","categories":["资源"],"tags":["wordpress","add_action()","get_template_directory_uri()","wp_enqueue_script()"]},{"title":"一些很酷的chorem开发工具的提示和技巧的列表","url":"/2019/01/03/%E4%B8%80%E4%B8%AA%E5%BE%88%E9%85%B7%E7%9A%84chrome%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7%E7%9A%84%E5%88%97%E8%A1%A8/","content":"<p>Chrome开发工具提供了一套非常棒的工具，可以帮助您在Web平台上进行开发。以下是一些你可能还不知道的建议</p>\n<h3 id=\"在ELEMENTS面板中拖放\"><a href=\"#在ELEMENTS面板中拖放\" class=\"headerlink\" title=\"在ELEMENTS面板中拖放\"></a>在ELEMENTS面板中拖放</h3><p>在Elements面板中，您可以拖放任何HTML元素并更改其在页面上的位置 <img src=\"http://file.w3cbest.com/file/images/reference-elements.gif\"></p>\n<h3 id=\"引用控制台中当前选择的元素\"><a href=\"#引用控制台中当前选择的元素\" class=\"headerlink\" title=\"引用控制台中当前选择的元素\"></a>引用控制台中当前选择的元素</h3><p>在Elements面板中选择一个节点，并在控制台中键入$0来引用它。 <img src=\"http://file.w3cbest.com/file/images/drag-and-drop.gif\"></p>\n<blockquote>\n<p>提示:如果使用jQuery，可以输入$($0)来访问这个元素上的jQuery API。</p>\n</blockquote>\n<h3 id=\"使用控制台中最后一个操作的值\"><a href=\"#使用控制台中最后一个操作的值\" class=\"headerlink\" title=\"使用控制台中最后一个操作的值\"></a>使用控制台中最后一个操作的值</h3><p>使用$_引用在控制台中执行的前一个操作的返回值 <img src=\"http://file.w3cbest.com/file/images/use-last-result.gif\"></p>\n<h3 id=\"添加CSS并编辑元素状态\"><a href=\"#添加CSS并编辑元素状态\" class=\"headerlink\" title=\"添加CSS并编辑元素状态\"></a>添加CSS并编辑元素状态</h3><p>在元素面板中有两个超级有用的按钮。 第一个选项允许您添加一个新的CSS属性，使用您想要的任何选择器，但要预先填充当前选定的元素: <img src=\"http://file.w3cbest.com/file/images/add-css.gif\"> 第二个选项允许您为所选元素触发一个状态，这样您就可以看到当它处于活动状态、悬停状态、焦点状态时应用的样式。 <img src=\"http://file.w3cbest.com/file/images/element-state.png\"></p>\n<h3 id=\"找到定义CSS属性的位置\"><a href=\"#找到定义CSS属性的位置\" class=\"headerlink\" title=\"找到定义CSS属性的位置\"></a>找到定义CSS属性的位置</h3><p>在元素面板中的CSS属性，DevTools将指向定义该属性的地方，即源面板</p>\n<p><img src=\"http://file.w3cbest.com/file/images/find-where-css-defined.gif\">  </p>\n<h3 id=\"保存并归档修改后的CSS\"><a href=\"#保存并归档修改后的CSS\" class=\"headerlink\" title=\"保存并归档修改后的CSS\"></a>保存并归档修改后的CSS</h3><p>单击您编辑的CSS文件的名称。检查器将它打开到Sources窗格中，然后您可以在应用的实时编辑中保存它。 这个技巧不适用于使用+或元素添加的新选择器。样式属性，但仅适用于已修改的现有属性。 <img src=\"http://file.w3cbest.com/file/images/save-modified-css.gif\"></p>\n<h3 id=\"屏幕截图一个元素\"><a href=\"#屏幕截图一个元素\" class=\"headerlink\" title=\"屏幕截图一个元素\"></a>屏幕截图一个元素</h3><p>选择一个元素并按下cmd-shift-p(或在Windows中按ctrl-shift-p)打开命令菜单，然后选择Capture node截图 <img src=\"http://file.w3cbest.com/file/images/screenshot-node.gif\"></p>\n<h3 id=\"使用CSS选择器查找元素\"><a href=\"#使用CSS选择器查找元素\" class=\"headerlink\" title=\"使用CSS选择器查找元素\"></a>使用CSS选择器查找元素</h3><p>按下cmd-f(在Windows中ctrl-f)将在Elements面板中打开搜索框。 你可以在里面输入任何字符串来匹配源代码，或者你也可以使用CSS选择器让Chrome为你生成一个图像: <img src=\"http://file.w3cbest.com/file/images/find-elements-css-selectors.gif\"></p>\n<h3 id=\"在控制台中SHIFT-ENTER\"><a href=\"#在控制台中SHIFT-ENTER\" class=\"headerlink\" title=\"在控制台中SHIFT-ENTER\"></a>在控制台中SHIFT-ENTER</h3><p>要在控制台中编写跨越多行代码的命令，请按shift-enter。 一旦你准备好了，按下回车在脚本的最后，以执行它: <img src=\"http://file.w3cbest.com/file/images/multiple-lines-commands.gif\"></p>\n<h3 id=\"清除控制台\"><a href=\"#清除控制台\" class=\"headerlink\" title=\"清除控制台\"></a>清除控制台</h3><p>您可以使用控制台左上角的clear按钮清除控制台，或者按ctrl-l或cmd-k。</p>\n<h3 id=\"GO-TO…\"><a href=\"#GO-TO…\" class=\"headerlink\" title=\"GO TO…\"></a>GO TO…</h3><p>在资源面板:</p>\n<ul>\n<li>  显示页面加载的所有文件。</li>\n<li>  显示当前文件中的符号(属性、函数、类)。</li>\n<li>  ctrl-g转到特定的行。</li>\n</ul>\n<p><img src=\"http://file.w3cbest.com/file/images/files-list.png\"></p>\n<h3 id=\"监视表达式\"><a href=\"#监视表达式\" class=\"headerlink\" title=\"监视表达式\"></a>监视表达式</h3><p>在调试过程中，您将多次检查变量名或表达式，而不是一次又一次地编写变量名或表达式，而是将其添加到监视表达式列表中。 <img src=\"http://file.w3cbest.com/file/images/watch-expressions.gif\"></p>\n<h3 id=\"XHR-获取调试\"><a href=\"#XHR-获取调试\" class=\"headerlink\" title=\"XHR /获取调试\"></a>XHR /获取调试</h3><p>从调试器中打开XHR/Fetch断点面板。 您可以将它设置为在发送XHR / Fetch调用时断开，或者仅在特定的调用上: <img src=\"http://file.w3cbest.com/file/images/xhr-fetch-breakpoints.png\"></p>\n<h3 id=\"对DOM修改的调试\"><a href=\"#对DOM修改的调试\" class=\"headerlink\" title=\"对DOM修改的调试\"></a>对DOM修改的调试</h3><p>右键单击元素并在子树修改上启用Break:每当脚本遍历该元素的子元素并修改它们时，调试器都会自动停止，以便让您检查发生了什么。 <img src=\"http://file.w3cbest.com/file/images/break-subtree-modifications.png\"></p>\n","categories":["资源","JavaScript"],"tags":["Chrome","Elements","浏览器"]},{"title":"什么是防抖和节流？有什么区别？如何实现？","url":"/2020/08/14/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/","content":"<h2 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h2><p>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间</p>\n<p>思路：</p>\n<p>每次触发事件时都取消之前的延时调用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function debounce(fn) &#123;</span><br><span class=\"line\">    let timeout &#x3D; null; &#x2F;&#x2F; 创建一个标记用来存放定时器的返回值</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">    clearTimeout(timeout); &#x2F;&#x2F; 每当用户输入的时候把前一个 setTimeout clear 掉</span><br><span class=\"line\">    timeout &#x3D; setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span><br><span class=\"line\">        fn.apply(this, arguments);</span><br><span class=\"line\">    &#125;, 500);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function sayHi() &#123;</span><br><span class=\"line\">    console.log(&#39;防抖成功&#39;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var inp &#x3D; document.getElementById(&#39;inp&#39;);</span><br><span class=\"line\">inp.addEventListener(&#39;input&#39;, debounce(sayHi)); &#x2F;&#x2F; 防抖</span><br></pre></td></tr></table></figure>\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率</p>\n<p>思路：<br>每次触发事件时都判断当前是否有等待执行的延时函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function throttle(fn) &#123;</span><br><span class=\"line\">    let canRun &#x3D; true; &#x2F;&#x2F; 通过闭包保存一个标记</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">    if (!canRun) return; &#x2F;&#x2F; 在函数开头判断标记是否为true，不为true则return</span><br><span class=\"line\">    canRun &#x3D; false; &#x2F;&#x2F; 立即设置为false</span><br><span class=\"line\">    setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 将外部传入的函数的执行放在setTimeout中</span><br><span class=\"line\">        fn.apply(this, arguments);</span><br><span class=\"line\">        &#x2F;&#x2F; 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span><br><span class=\"line\">        canRun &#x3D; true;</span><br><span class=\"line\">    &#125;, 500);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function sayHi(e) &#123;</span><br><span class=\"line\">    console.log(e.target.innerWidth, e.target.innerHeight);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.addEventListener(&#39;resize&#39;, throttle(sayHi));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","tags":["防抖","节流"]},{"title":"CSS形状入门--自定义路径周围的内容包装（CSS Shapes）","url":"/2019/01/03/%E4%BB%8B%E7%BB%8Dcss%E5%BD%A2%E7%8A%B6-css-shapes/","content":"<h2 id=\"CSS-Shapes-简介\"><a href=\"#CSS-Shapes-简介\" class=\"headerlink\" title=\"CSS Shapes 简介\"></a>CSS Shapes 简介</h2><p>CSS Shapes 允许我们通过定义文本内容可以环绕的几何形状、图像和渐变，来创建有趣且独特的布局。本次教程会教你如何使用它们。 在 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes\">CSS Shapes</a> 问世之前，为网页设计文本自由环绕的杂志式布局几乎是不可能的。相反，网页设计布局传统上一直用网格、盒子和直线构造。 CSS Shapes 允许我们定义文本环绕的几何形状。这些形状可以是圆、椭圆、简单或复杂的多边形，甚至图像和渐变。Shapes 的一些实际设计应用可能是圆形头像周围显示圆形环绕文本，全屏背景图片的简单部位上面展示文本，以及在文章中显示首字下沉。 现在 CSS Shapes 已经获得了现代浏览器的广泛支持，值得一看的是它们提供的灵活性和功能，以确定它们在你的下一个设计项目中是否能派上用场。</p>\n<blockquote>\n<p>注意：截至攥写本文时，CSS Shapes 支持 Firefox、Chrome、Safari 和 Opera，以及 iOS Safari 和 Chrome for Android 等移动浏览器。Shapes 不支持 IE，对 Microsoft Edge 的支持<a href=\"https://developer.microsoft.com/en-us/microsoft-edge/platform/status/shapes/\">正在考虑中</a>。</p>\n</blockquote>\n<h2 id=\"CSS-Shapes-初探\"><a href=\"#CSS-Shapes-初探\" class=\"headerlink\" title=\"CSS Shapes 初探\"></a>CSS Shapes 初探</h2><p>CSS Shapes 的当前实现是 <a href=\"https://drafts.csswg.org/css-shapes/\">CSS Shapes Module Level 1</a>，它主要包含 [shape-outside]属性。<a href=\"https://tympanus.net/codrops/css_reference/shape-outside/\">shape-outside</a> 定义了文本环绕的形状。 考虑到有 shape-outside 属性，你可能会想到还有一个相应的 shape-inside 属性，它包含形状内的文本。shape-inside 属性可能会在将来实现，目前它只是 <a href=\"https://drafts.csswg.org/css-shapes-2/\">CSS Shapes Module Level 2</a>里面的一个草案，并没有被任何浏览器实现。 在本文中，我们将演示如何使用&lt;<a href=\"https://tympanus.net/codrops/css_reference/basic-shape/\">basic-shape</a>&gt;数据类型并使用形状函数值设置它，以及使用半透明URL或渐变设置形状。  </p>\n<h3 id=\"基本形状函数\"><a href=\"#基本形状函数\" class=\"headerlink\" title=\"基本形状函数\"></a>基本形状函数</h3><p>我们可以通过对shape-outside属性应用以下函数值来定义CSS中的各种基本形状:</p>\n<ul>\n<li>  circle()</li>\n<li>  ellipse()</li>\n<li>  inset()</li>\n<li>  polygon()</li>\n</ul>\n<p>为了将shape-outside属性应用到元素上，元素必须是浮动的，并且具有定义的高度和宽度。让我们逐一介绍这四个基本形状，并演示如何使用它们。</p>\n<h2 id=\"circle\"><a href=\"#circle\" class=\"headerlink\" title=\"circle\"></a>circle</h2><p>我们将从 circle() 函数开始。设想如下场景，有一个圆形的作者头像，我们想让头像左浮动并且作者的描述文本环绕它。仅对头像元素使用 border-radius: 50% 不足以使文本呈圆形；文本仍将把头像当成矩形元素。 通过圆形，我们可以演示文本如何按圆形环绕。 首先我们在一个普通的 div 上创建 circle 样式，并且写几段文字（我使用 Bob Ross 语录作为 Lorem Ipsum 文本）。</p>\n<div class=\"circle\"></div>\n<p>Example text...</p>\n\n<p>在circle 样式中，我们将元素浮动到左边，给它一个相等的高度和宽度，并将shape-outside设置为circle()。</p>\n<p>.circle {<br>    float: left;<br>    height: 200px;<br>    width: 200px;<br>    shape-outside: circle();<br>}</p>\n<p>如果我们访问页面，会看到如下场景。 <img src=\"http://file.w3cbest.com/file/images/cssshapes_circle1.jpg\"> 正如你所看到的，文字围绕着圆形流动，但我们实际上看不到任何形状。将鼠标悬停在Developer Tools中的元素上，将向我们显示正在设置的实际形状。 <img src=\"http://file.w3cbest.com/file/images/cssshapes_circle2.jpg\"> 此时，你可能会认为可以给元素 background 设置颜色或者图片就能看到形状了。我们来试一下。</p>\n<p>.circle {<br>    float: left;<br>    height: 200px;<br>    width: 200px;<br>    shape-outside: circle();<br>    background: linear-gradient(to top right, #FDB171, #FD987D);<br>}</p>\n<p>不幸的是，给 circle 设置 background 后会显示一个矩形，这是我们一直试图避免的事情。 <img src=\"http://file.w3cbest.com/file/images/cssshapes_circle3.jpg\"> 我们可以清晰地看到文本在它周围环绕，但是元素本身并没有形状。如果我们想要真实地显示形状函数，就必须使用 clip-path 属性。clip-path 采用许多和 shape-outside 相同的值，所以我们可以给它相同的circle()值。</p>\n<p>.circle {<br>    float: left;<br>    height: 200px;<br>    width: 200px;<br>    shape-outside: circle();<br>    clip-path: circle();<br>    background: linear-gradient(to top right, #FDB171, #FD987D);<br>}</p>\n<p>  <img src=\"http://file.w3cbest.com/file/images/cssshapes_circle4.jpg\"></p>\n<blockquote>\n<p>在本文剩下的部分，我将使用 clip-path 帮助我们辨认形状。</p>\n</blockquote>\n<p>circle() 函数接收可选的 radius 参数。在我们的例子中，默认 radius 是 50% 或者 100px。使用 circle(50%) 或者 circle(100px) 都将产生和我们已经完成样例的同样结果。 你可能会注意到文本刚好和形状贴合。我们可以使用 shape-margin 属性给形状添加 margin，它可以设置为px、em、% 和任何其他标准的 CSS 测量单位。</p>\n<p>.circle {<br>    float: left;<br>    height: 200px;<br>    width: 200px;<br>    shape-outside: circle(25%);<br>    shape-margin: 1rem;<br>    clip-path: circle(25%);<br>    background: linear-gradient(to top right, #FDB171, #FD987D);<br>}</p>\n<p>下面是一个circle radius 设置 25% 并且使用 shape-margin 的例子。 <img src=\"http://file.w3cbest.com/file/images/cssshapes_circle5.jpg\"> 除了 radius，形状函数可以使用 at 定位。默认位置是圆的中心，因此 circle() 也可以被显式设置为 circle(50% at 50% 50%) 或 circle(100px at 100px 100px)，这两个值分别是水平和垂直位置。 为了搞清楚 position 的作用，我们可以设置水平位置值为 0 来创造一个完美的半圆。</p>\n<p>circle(50% at 0 50%);</p>\n<p>这种坐标定位系统称为参考框。</p>\n<p><img src=\"http://file.w3cbest.com/file/images/cssshapes_circle6.jpg\"></p>\n<p>稍后我们将学习如何使用图像代替形状或者渐变。现在我们将继续进行下一个形状函数。</p>\n<h2 id=\"Ellipse\"><a href=\"#Ellipse\" class=\"headerlink\" title=\"Ellipse\"></a>Ellipse</h2><p>ellipse() 和 circle() 函数类似，只是它会创造椭圆。为了演示，我们创建一个 ellipse 元素和样式。</p>\n<div class=\"ellipse\"></div>\n<p>Example text...</p>\n\n<p>.ellipse {<br>    float: left;<br>    shape-outside: ellipse();<br>    clip-path: ellipse();<br>    width: 150px;<br>    height: 300px;<br>    background: linear-gradient(to top right, #F17BB7, #AD84E3);<br>}</p>\n<p>这次，我们设置不同的 height 和 width 创建一个垂直拉长的椭圆。 <img src=\"http://file.w3cbest.com/file/images/cssshapes_ellipse1.jpg\"> ellipse() 和 circle()的区别在于，ellipse有两个半径rx和ry，即x轴半径和y轴半径。因此，上述例子也可以写成:</p>\n<p>ellipse(75px 150px);</p>\n<p>circles 和 ellipses 的位置参数是一样的。除了是测量单位，半径也包括 farthest-side 和 closest-side 的选项。 closest-side 是指从参考框的中心到最近边的长度，相反，farthest-side 是指从参考框的中心到最远边的长度。这意味着如果未设置默认值以外的位置，这两个值将无效。 下面演示了在 ellipse() 上翻转 closest-side 和 farthest-side 的区别，在X轴和Y轴上偏移25%。</p>\n<p>ellipse(farthest-side closest-side at 25% 25%)</p>\n<p><img src=\"http://file.w3cbest.com/file/images/cssshapes_ellipse2.jpg\"></p>\n<p>ellipse(farthest-side closest-side at 25% 25%)</p>\n<p><img src=\"http://file.w3cbest.com/file/images/cssshapes_ellipse3.jpg\">  </p>\n<h2 id=\"Inset\"><a href=\"#Inset\" class=\"headerlink\" title=\"Inset\"></a>Inset</h2><p>到目前为止我们只处理了圆形的形状，但是我们可以使用 inset() 函数定义内嵌矩形。</p>\n<div class=\"inset\"></div>\n<p>Example text...</p>\n\n<p>.inset {<br>    float: left;<br>    shape-outside: inset(75px);<br>    clip-path: inset(75px);<br>    width: 300px;<br>    height: 300px;<br>    background: linear-gradient(#58C2ED, #1B85DC);<br>}</p>\n<p>在本例中，我们将创建一个300px×300px的矩形，并在所有边内嵌75px。这样我们就得到了150px×150px的图像周围有75px的空间。 <img src=\"http://file.w3cbest.com/file/images/cssshapes_inset1.jpg\"> 我们可以看到矩形是内嵌的，文本忽略了内嵌区域。 <img src=\"http://file.w3cbest.com/file/images/cssshapes_inset2.jpg\"> inset() 形状也可以使用 round 参数接收 border-radius，并且文本会识别圆角，就像本例中所有边都是 25px 内嵌和 75px 圆角。</p>\n<p>inset(25px round 75px)</p>\n<p><img src=\"http://file.w3cbest.com/file/images/cssshapes_inset3.jpg\"> 像 padding 或 margin 简写，inset 值以顺时针方式（inset(25px 25px 25px 25px)）接收 top right bottom left，并且只传一个值将使四条边都相同（inset(25px)）。  </p>\n<h2 id=\"Polygon\"><a href=\"#Polygon\" class=\"headerlink\" title=\"Polygon\"></a>Polygon</h2><p>形状函数中最有趣和最灵活的是 polygon()，它可以采用一系列 x 和 y 点来制作任何复杂形状。数组里的每个元素代表 _x_i _y_i，将被写成 polygon(x1 y1, x2 y2, x3 y3…) 等等。 我们可以为多边形设置的点集数量最少为 3，这将创建一个三角形。</p>\n<div class=\"polygon\"></div>\n<p>Example text...</p>\n\n<p>.polygon {<br>    float: left;<br>    shape-outside: polygon(0 0, 0 300px, 200px 300px);<br>    clip-path: polygon(0 0, 0 300px, 200px 300px);<br>    height: 300px;<br>    width: 300px;<br>    background: linear-gradient(to top right, #86F7CC, #67D7F5);<br>}</p>\n<p>  在这个形状中，第一个点是 0 0，div 中最左上角的点。第二个点是 0 300px，它是 div 中最左下角的点。第三个也就是最后一个点是 200px 300px，它在 X 轴的 2/3 处并且也在底部。最终的形状是这样： <img src=\"http://file.w3cbest.com/file/images/cssshapes_polygon1.jpg\"> polygon() 形状函数的一个有趣用法是文本内容可以在两个或以上形状中环绕。因为 polygon() 形状是如此灵活和动态，这给我们制作真正独特的杂志式布局提供了一个最好机会。在本例中，我们将把文本放在两个多边形中。</p>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n<p>Example text...</p>\n\n<p>.left {<br>    float: left;<br>    shape-outside: polygon(0 0, 0 300px, 200px 300px);<br>    clip-path: polygon(0 0, 0 300px, 200px 300px);<br>    background: linear-gradient(to top right, #67D7F5, #86F7CC);<br>    height: 300px;<br>    width: 300px;<br>}<br>.right {<br>    float: right;<br>    shape-outside: polygon(200px 300px, 300px 300px, 300px 0, 0 0);<br>    clip-path: polygon(200px 300px, 300px 300px, 300px 0, 0 0);<br>    background: linear-gradient(to bottom left, #67D7F5, #86F7CC);<br>    height: 300px;<br>    width: 300px;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/cssshapes_polygon2.jpg\"> 显然，想要手动创造你自己的复杂形状是非常困难的。幸运的是，你可以用一些工具来创建多边形。Firefox 有一个内置的形状编辑器，你可以在 Inspector 中通过点击多边形使用。 <img src=\"http://file.w3cbest.com/file/images/cssshapes_polygon3.jpg\"> 目前，Chrome有一些可以使用的扩展，比如<a href=\"https://chrome.google.com/webstore/detail/css-shapes-editor/nenndldnbcncjmeacmnondmkkfedmgmp?hl=en-US\">CSS shape Editor</a>。 多边形可以用来剪切图像或其他元素周围的形状。在另一个例子中，我们可以通过在大字母周围绘制多边形来创建首字下沉。</p>\n<div class=\"letter\">R</div>\n<p>Example text...</p>\n\n<p>.letter {<br>    float: left;<br>    font-size: 400px;<br>    font-family: Georgia;<br>    line-height: .8;<br>    margin-top: 20px;<br>    margin-right: 20px;<br>    shape-outside: polygon(5px 14px, 233px 20px, 246px 133px, 189px 167px, 308px 304px, 0px 306px) content-box;<br>    clip-path: polygon(5px 14px, 233px 20px, 246px 133px, 189px 167px, 308px 304px, 0px 306px);<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/cssshapes_polygon4.jpg\"></p>\n<h3 id=\"URLs\"><a href=\"#URLs\" class=\"headerlink\" title=\"URLs\"></a>URLs</h3><p>CSS Shapes 一个令人激动的特性是你不必每次都通过形状函数明确定义；你也可以使用半透明图像的 url 来定义形状，这样文本就会自动环绕它。 需要注意的是，所使用的图像必须与CORS兼容，否则您将得到如下所示的错误。</p>\n<p>Access to image at ‘file:///users/tania/star.png’ from origin ‘null’<br>has been blocked by CORS policy: The response is invalid.</p>\n<p>  在同一个服务器上提供图像将会保证你不会遇到上面的错误。 与其他示例不同，我们将使用 img 代替 div。这次的 CSS 很简单——只需将url()放到shape-outside属性中，就像使用 background-image 一样。</p>\n<img src=\"./star.png\" class=\"star\">\n<p>Example text...</p>\n\n<p>.star {<br>float: left;<br>height: 350px;<br>width: 350px;<br>shape-outside: url(‘./star.png’)<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/cssshapes_image1.jpg\"> 因为我使用了透明背景的星星图像，所以文本知道哪些区域是透明的，哪些区域是不透明的，并相应地对自己进行自适应布局。</p>\n<h3 id=\"Gradients\"><a href=\"#Gradients\" class=\"headerlink\" title=\"Gradients\"></a>Gradients</h3><p>最后，渐变也可以用来当成形状。渐变和图像一样，就像我们上面使用的图像示例一样，文本也将知道在透明部分环绕。 我们将使用渐变的一个新属性 —— shape-image-threshold。shape-image-threshold 定义形状的 alpha 通道阈值，或者图像透明的百分比值。 我们将制作一个渐变例子，它是 50％/50％ 的颜色和透明分割，并且设置 shape-image-threshold 为 .5，意味着超过 50％ 不透明的所有像素都应被视为图像的一部分。</p>\n<div class=\"gradient\"></div>\n<p>Example text...</p>\n\n<p>.gradient {<br>    float: left;<br>    height: 300px;<br>    width: 100%;<br>    background: linear-gradient(to bottom right, #86F7CC, transparent);<br>    shape-outside: linear-gradient(to bottom right, #86F7CC, transparent);<br>    shape-image-threshold: .5;<br>}</p>\n<p>  <img src=\"http://file.w3cbest.com/file/images/cssshapes_gradient1.jpg\"> 我们可以看到渐变在不透明和透明的中心完美地对角线分割。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在这篇文章中，我们学习了 CSS Shapes 的三个属性 shape-outside、shape-margin 和 shape-image-threshold。我们也了解到如何使用函数值创建可供文本环绕的圆、椭圆、内嵌矩形以及复杂的多边形，并且演示了形状如何检测图像和渐变的透明部分。 <strong>你可以在如下 <a href=\"http://tympanus.net/Tutorials/CSSShapes/\">demo</a> 中找到本文中用到的所有例子，也可以<a href=\"http://tympanus.net/Tutorials/CSSShapes/CSSShapes.zip\">下载源文件</a>。</strong></p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/JwpjzM/\">CSS Shapes Examples</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>文章来源： <a href=\"https://tympanus.net/codrops/2018/11/29/an-introduction-to-css-shapes/\">https://tympanus.net/codrops/2018/11/29/an-introduction-to-css-shapes/</a> 相关阅读参考：<a href=\"https://alistapart.com/article/css-shapes-101\">https://alistapart.com/article/css-shapes-101</a> 相关阅读参考：<a href=\"https://www.html5rocks.com/en/tutorials/shapes/getting-started/#toc-manual-shapes\">https://www.html5rocks.com/en/tutorials/shapes/getting-started/#toc-manual-shapes</a></p>\n","categories":["HTML/CSS","资源"],"tags":["basic-shape","circle","css shapes","CSS形状","polygon","shape-outside"]},{"title":"从数组中删除重复的对象","url":"/2019/05/01/%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AF%B9%E8%B1%A1/","content":"<p>假设我们有一个对象数组，如下所示：</p>\n<p>const books = [<br>    {<br>        name: “My Sister the Serial Killer”,<br>        author: “Oyinkan Braithwaite”<br>    },<br>    {<br>        name: “Educated”,<br>        author: “Tara Westover”<br>    },<br>    {<br>        name: “My Sister the Serial Killer”,<br>        author: “Oyinkan Braithwaite”<br>    }<br>];</p>\n<p>数组中的第一个和最后一个对象是相同的。那么如果我们想从数组中删除这些重复的对象呢？令人惊讶的是，这是一个非常难以解决的问题。为了理解原因，让我们看一下如何从平面项目数组中删除重复项，例如字符串。</p>\n<h2 id=\"从数组中删除重复的项\"><a href=\"#从数组中删除重复的项\" class=\"headerlink\" title=\"从数组中删除重复的项\"></a>从数组中删除重复的项</h2><p>假设我们有一个字符串数组，如下所示：</p>\n<p>const strings = [<br>    “My Sister the Serial Killer”,<br>    “Educated”,<br>    “My Sister the Serial Killer”<br>];</p>\n<p>如果我们想从这个数组中删除任何重复项，我们可以使用该<code>filter()</code>方法以及<code>indexOf()</code>方法来检查任何给定项是否重复。</p>\n<p>const filteredStrings = strings.filter((item, index) =&gt; {<br>    // Return to new array if the index of the current item is the same<br>    // as the first occurence of the item<br>    return strings.indexOf(item) === index;<br>});</p>\n<p>由于<code>strings.indexOf(item)</code>将始终返回第一次出现的索引<code>item</code>，我们可以判断过滤器循环中的当前项是否重复。如果是，我们不会将其返回到由该<code>filter()</code>方法创建的新数组</p>\n<h2 id=\"对象的工作方式不同\"><a href=\"#对象的工作方式不同\" class=\"headerlink\" title=\"对象的工作方式不同\"></a>对象的工作方式不同</h2><p>这个方法不适用于对象的原因是因为任何具有相同属性和值的2个对象实际上并不相同。</p>\n<p>const a = {<br>    name: “My Sister the Serial Killer”,<br>    author: “Oyinkan Braithwaite”<br>};<br>const b = {<br>    name: “My Sister the Serial Killer”,<br>    author: “Oyinkan Braithwaite”<br>};</p>\n<p>a === b // false</p>\n<p>这是因为基于参考而不是结构来比较对象。在比较两个对象时，不考虑两个对象具有相同的orperties和value的事实。因此，即使存在具有完全相同属性和值的另一个对象<code>indexOf(object)</code>，对象数组内也将始终返回精确<code>object</code>传递的索引。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>给定此信息，检查两个对象是否具有相同属性和值的唯一方法是实际检查每个对象的属性和值。我提出的解决方案涉及进行此手动检查，但有一些改进性能并减少不必要的嵌套循环。 需要注意3点：</p>\n<ol>\n<li> 仅检查数组中的每个项目与其后的每个其他项目，以避免多次比较相同的对象</li>\n<li> 仅检查未找到与任何其他项目重复的项目</li>\n<li> 在检查每个属性的值是否相同之前，请检查两个对象是否具有相同的键</li>\n</ol>\n<p>这是最后的功能：</p>\n<p>function removeDuplicates(arr) {</p>\n<pre><code>const result = \\[\\];\nconst duplicatesIndices = \\[\\];\n\n// Loop through each item in the original array\narr.forEach((current, index) =&gt; &#123;\n\n    if (duplicatesIndices.includes(index)) return;\n\n    result.push(current);\n\n    // Loop through each other item on array after the current one\n    for (let comparisonIndex = index + 1; comparisonIndex &lt; arr.length; comparisonIndex++) &#123;\n    \n        const comparison = arr\\[comparisonIndex\\];\n        const currentKeys = Object.keys(current);\n        const comparisonKeys = Object.keys(comparison);\n        \n        // Check number of keys in objects\n        if (currentKeys.length !== comparisonKeys.length) continue;\n        \n        // Check key names\n        const currentKeysString = currentKeys.sort().join(&quot;&quot;).toLowerCase();\n        const comparisonKeysString = comparisonKeys.sort().join(&quot;&quot;).toLowerCase();\n        if (currentKeysString !== comparisonKeysString) continue;\n        \n        // Check values\n        let valuesEqual = true;\n        for (let i = 0; i &lt; currentKeys.length; i++) &#123;\n            const key = currentKeys\\[i\\];\n            if ( current\\[key\\] !== comparison\\[key\\] ) &#123;\n                valuesEqual = false;\n                break;\n            &#125;\n        &#125;\n        if (valuesEqual) duplicatesIndices.push(comparisonIndex);\n        \n    &#125; // end for loop\n\n&#125;); // end arr.forEach()\nreturn result;\n</code></pre>\n<p>}</p>\n","categories":["JavaScript"],"tags":["javascript","Array.filter","Array.includes","Array.indexOf","javascript教程"]},{"title":"从网站发送HTTP，你可能会忽略的一个安全问题","url":"/2019/01/03/%E4%BB%8E%E7%BD%91%E7%AB%99%E5%8F%91%E9%80%81http%EF%BC%8C%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","content":"<p>在一个新窗口中打开链接是前端开发中一个很常见的逻辑，它可以将用户引导到一个新的域名。我们可以用 target=”_blank”来实现这个功能。我敢肯定，每个人都会在他的某个项目中使用过 target=”_blank”，但是我不确定是否每个人都知道这种用法的缺陷。 当一个外部链接使用了 target=”_blank”的方式，这个外部链接会打开一个新的浏览器tab。此时，新页面会打开，并且和原始页面占用同一个进程。这也意味着，如果这个新页面有任何性能上的问题，比如有一个很长的加载时间，这也将会影响到原始页面的表现。如果你打开的是一个同域的页面，那么你将可以在新页面访问到原始页面的所有内容，包括 document对象( window.opener.document)。如果你打开的是一个跨域的页面，你虽然无法访问到 document，但是你依然可以访问到 location对象。 这意味着，如果你在你的站点或者文章中，嵌入了通过新窗口打开一个新页面的链接，这个新页面可以使用 window.opener，在一定程度上来修改原始页面。</p>\n<blockquote>\n<p>可以参考这个例子，请导航到此<a href=\"https://s.codepen.io/adamlaki/debug/dd4475e9a73052ad37d3e5f19f4bcb92\">链接</a></p>\n</blockquote>\n<p><img src=\"http://file.w3cbest.com/file/images/640.gif\"> 我们来看看上面例子发生了什么？当你点击了链接(在打开的 document中)，浏览器会打开这个页面。而这个页面中运行了一段 JavaScript代码：通过 window.opener来修改原始页面(你来自的那个页面)。有点乏味但是这可能是有害的。 那么问题来了：我们如何阻止这种情况的发生呢？在所有使用 target=”_blank”打开新页面的链接上，加上 rel=”noopener”。</p>\n<p> <a href=\"https://niteshsoni.info\" rel=\"noopener\"></a></p>\n<p>使用了 rel=”noreferrer”以后，当一个新页面通过一个链接打开后，新页面中的恶意 JavaScript代码将无法通过 window.opener 来访问到原始页面。这将保证新页面运行在一个单独的进程里。 在老浏览器中，你可以使用 rel=”noreferrer”属性，具有同样的效果。但是，这样也会阻止 Refererheader被发送到新页面。</p>\n<p><a href=\"https://niteshsoni.info\" rel=\"noopener noreferrer\"></a></p>\n<p>在上面的例子中，使用了 rel=”noreferrer” ，当一个用户点击了这个超链接进入到新页面后，新页面拿不到 referrer信息。这将意味着，新页面不知道用户是从哪里来的。 如果你通过 JavaScript中的 window.open打开一个页面的话，上文所说的都适用，因为你也是打开了一个新的窗口。在这种情况下，你不得不清楚掉 opener对象：</p>\n<p>var newWindow = window.open();<br>newWindow.opener = null;</p>\n<p>在我看来，使用第一种解决方案(在每一个 target=”_blank”的链接中加上 rel=”noopener”)是没有什么明显的坏处的。这个问题表明，在你的网页安全性中找到漏洞是多么的容易。 本文主要介绍了在使用 &lt;atarget=”_blank”&gt;标签打开一个新窗口过程中的安全问题。新页面中可以使用 window.opener来控制原始页面。如果新老页面同域，那么在新页面中可以任意操作原始页面。如果是不同域，新页面中依然可以通过 window.opener.location，访问到原始页面的 location对象。 试想一下，你在自己的a页面中，通过 <a target=\"\\_blank\" href=\"http://b.com\">打开新窗口，跳转到了b页面，此刻b页面中有一段代码 window.opener.location=”http://c.com”。这是，a页面就会自动跳转到c页面。如果这个c页面是一个和a页面长得一样的钓鱼网站，那么用户可能就中招了。 解决方法就是：在带有 target=”_blank”的 标签中，加上 rel=”noopener”属性。如果使用 window.open的方式打开页面，将 opener对象置为空。这样的副作用是：在某些低版本浏览器中，新页面中拿不到 referer信息。 原文地址：<a href=\"https://medium.com/front-end-weekly/prevent-sending-http-referer-headers-from-your-website-e30eecfe813a\">https://medium.com/front-end-weekly/prevent-sending-http-referer-headers-from-your-website-e30eecfe813a</a></p>\n","categories":["JavaScript"],"tags":["html","javascript","html5","网络安全","钓鱼网站"]},{"title":"你真的需要了解一下CSS变量 var()","url":"/2018/11/14/%E4%BD%A0%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8Bcss%E5%8F%98%E9%87%8F-var/","content":"<p>当Web项目变得越来越大时，他的CSS会变得像天文数字那么大而且还变得混乱。为了帮助我们解决这个问题，新的CSS变量很快就会出现在主流浏览器中，它让开发人员能够重用并轻松编辑重复出现的CSS属性。用过SASS或Less的人应该知道他的变量功能有多棒，但这些变量是预处理器，需要在使用前进行编译。现在变量在vanilla CSS中可用，您可以立即在浏览器中使用它们！</p>\n<h3 id=\"定义和使用CSS变量\"><a href=\"#定义和使用CSS变量\" class=\"headerlink\" title=\"定义和使用CSS变量\"></a>定义和使用CSS变量</h3><p>与任何其他CSS定义一样，变量遵循相同的范围和继承规则。使用它们的最简单方法是通过将声明添加到:root伪类来使它们全局可用，以便所有其他选择器都可以继承它。</p>\n<p>:root {<br>  –awesome-blue：＃2196F3;<br>}</p>\n<p>要访问变量中的值，我们可以使用var(…)语法。请注意，名称区分大小写，因此–foo != –FOO。</p>\n<p>.element {<br>background-color:var(–awesome-blue);<br>}</p>\n<h3 id=\"浏览器支持\"><a href=\"#浏览器支持\" class=\"headerlink\" title=\"浏览器支持\"></a>浏览器支持</h3><p>常用的浏览器除了IE都完美支持，您可以在此处获取更多详细信息 - <a href=\"https://caniuse.com/#search=var()\">我可以使用CSS变量</a>。下面是几个例子，展示了CSS变量的典型用法。为确保它们正常工作，请尝试在我们上面提到的其中一个浏览器上查看它们。</p>\n<h3 id=\"示例1-主题颜色\"><a href=\"#示例1-主题颜色\" class=\"headerlink\" title=\"示例1 - 主题颜色\"></a>示例1 - 主题颜色</h3><p>当我们需要对多个元素一遍又一遍地应用相同的规则时，CSS中的变量是最有用的，例如主题中的重复颜色。我们不是每次想要重复使用相同颜色时进行复制和粘贴，而是将其放在变量中并从那里访问它。 现在，如果我们的客户不喜欢我们选择的蓝色阴影，我们可以在一个地方（变量的定义）改变样式来改变整个主题的颜色。没有变量，我们必须手动搜索和替换每一次出现。 可将代码复制下来在你的编辑器里面测试</p>\n<p>* {margin: 0;padding: 0;box-sizing: border-box;}html {padding: 30px;font: normal 13px/1.5 sans-serif;color: #546567;background-color: var(–primary-color);}.container {background: #fff;padding: 20px;}h3 {padding-bottom: 10px;margin-bottom: 15px;}p {background-color: #fff;margin: 15px 0;}button {font-size: 13px;padding: 8px 12px;background-color: #fff;border-radius: 3px;box-shadow: none;text-transform: uppercase;font-weight: bold;cursor: pointer;opacity: 0.8;outline: 0;}button:hover {opacity: 1;}</p>\n<!-- 分割线 -->:root {\n<pre><code>--primary-color: #B1D7DC;\n--accent-color: #FF3F90;\n</code></pre>\n<p>}<br>html {<br>    background-color: var(–primary-color);<br>}<br>h3 {<br>    border-bottom: 2px solid var(–primary-color);<br>}<br>button {<br>    color: var(–accent-color);<br>    border: 1px solid var(–accent-color);<br>}</p>\n<div class=\"container\">\n<h3>对话框窗口</h3>\n<p>过放荡不羁的生活，容易得像顺水推舟，但是要结识良朋益友，却难如登天。</p>\n<button>确认</button>\n</div>\n\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/xmLvoV/\">示例1 – 主题颜色</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h3 id=\"示例2-属性类名可读性\"><a href=\"#示例2-属性类名可读性\" class=\"headerlink\" title=\"示例2 - 属性类名可读性\"></a>示例2 - 属性类名可读性</h3><p>变量的另一个重要用途是当我们想要保存更复杂的属性值时，我们不必记住它。最好的例子就是有多个参数，如CSS规则box-shadow，transform和font。 通过将属性放在变量中，我们可以使用语义可读的名称来访问它。</p>\n<p>html{background-color: #F9F9F9;}<br>ul{padding: 20px;list-style: none;width: 300px;}<br>li{font: normal 18px sans-serif;padding: 20px;transition: 0.4s;margin: 10px;color: #444;background-color: #fff;cursor: pointer;}</p>\n<!-- 分割线 -->\n<p>:root{<br>–tiny-shadow: 0 2px 1px 0 rgba(0, 0, 0, 0.2);<br>–animate-right: translateX(20px);<br>}<br>li{<br>box-shadow: var(–tiny-shadow);<br>}<br>li:hover{<br>transform: var(–animate-right);<br>}</p>\n<ul>\n<li>我在这里!</li>\n<li>我在这里!</li>\n<li>我在这里!</li>\n</ul>\n\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/LMjwKb/\">示例2 – 属性类名可读性</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h3 id=\"示例3-动态更改变量\"><a href=\"#示例3-动态更改变量\" class=\"headerlink\" title=\"示例3 - 动态更改变量\"></a>示例3 - 动态更改变量</h3><p>当多次声明自定义属性时，标准规则有助于解决冲突，样式表中最后定义的会覆盖上面定义的。 下面的示例演示了用户动态操作改变属性是多么容易，同时仍然保持代码清晰简洁。</p>\n<p>*{margin: 0;padding: 0;box-sizing: border-box;}<br>html{background: #eee;padding: 30px;font: 500 14px sans-serif;color: #333;line-height: 1.5;}<br>.blue-container{background: #64B5F6;padding-left: 50px;}<br>.green-container{background: #AED581;padding-left: 50px;}<br>.container{background: #fff;padding: 20px;}<br>p{transition: 0.4s;}<br>.title{font-weight: bold;}</p>\n<!-- 分割线 -->\n<p>.blue-container{<br>–title-text: 18px;<br>–main-text: 14px;<br>}<br>.blue-container:hover{<br>–title-text: 24px;<br>–main-text: 16px;<br>}<br>.green-container:hover{<br>–title-text: 30px;<br>–main-text: 18px;<br>}<br>.title{<br>font-size: var(–title-text);<br>}<br>.content{<br>font-size: var(–main-text);<br>}</p>\n<div class=\"blue-container\">\n<div class=\"green-container\">\n<div class=\"container\">\n<p class=\"title\">这是个标题</p>\n<p class=\"content\">将鼠标悬停在不同的颜色区域上可以更改此文本和标题的大小。</p>\n</div>\n</div>\n</div>\n\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/OrxLLE/\">示例3 – 动态更改变量</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>正如您所看到的，CSS变量非常简单易用，开发人员不必花费太多时间在各处开始应用它们。以下是扩展内容：</p>\n<ul>\n<li>  var()函数有两个参数，如果自定义属性失败，它可用于提供回退值： width: var(–custom-width, 20%);</li>\n<li>  可以嵌套自定义属性： –base-color: #f93ce9; –background-gradient: linear-gradient(to top, var(–base-color), #444);</li>\n<li>  变量可以与CSS的另一个新增功能- calc() 函数结合使用。 –container-width: 1000px; max-width: calc(var(–container-width) / 2);</li>\n</ul>\n","categories":["HTML/CSS"],"tags":["css3","calc()","html5","var()"]},{"title":"使用CSS content的attr实现鼠标悬浮提示（tooltip）效果","url":"/2018/09/30/%E4%BD%BF%E7%94%A8css-content%E7%9A%84attr%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE%E6%8F%90%E7%A4%BA%EF%BC%88tooltip%EF%BC%89%E6%95%88%E6%9E%9C/","content":"<p>当你的用户需要漂亮的图标给出额外的文字信息时，亦或是当他们在点击了按钮之后需要确认自己没点错时，又或是带图片和字幕的复活节彩蛋，提示框是用来增强用户界面的绝佳手段。现在，让我们来做几个动画提示框，没有别的，只有HTML和CSS。 样例 这是我们之后要做的：</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/BGRKEE/\">CSS Tooltip Magic</a> by xianzhiding (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>在我们沉浸在写代码的过程中之前，让我们先来看看我们的意图是什么。主要目的是为了获得一种简单的添加提示框的方法，这样一来，我们之后就能够通过增加一个自定义的 tooltip 属性来做到这一点。</p>\n<p><span tooltip=\"message\">visible text or icon, etc.</span></p>\n<h2 id=\"让我们设定几个预期\"><a href=\"#让我们设定几个预期\" class=\"headerlink\" title=\"让我们设定几个预期\"></a>让我们设定几个预期</h2><ul>\n<li>  不需要JavaScript</li>\n<li>  我们将会使用属性选择器（而不是类名），以及CSS内建的模式匹配</li>\n<li>  加到现有的DOM元素（你的标签中不需要新的元素）</li>\n<li>  代码例子中是没有前缀的（如有需要，为你的目标浏览器加上供应商前缀）</li>\n<li>  假设通过 mouseover/hover 来触发提示框</li>\n<li>  仅仅是纯文本提示框（HTML，图片等等都不支持）</li>\n<li>  当唤起提示框时，有巧妙的动画</li>\n</ul>\n<h2 id=\"好了，老司机要开车了！\"><a href=\"#好了，老司机要开车了！\" class=\"headerlink\" title=\"好了，老司机要开车了！\"></a>好了，老司机要开车了！</h2><p>哦，等等。我们还要先处理一个问题，是关于”不需要额外标签”的。毕竟，这很巧妙。 我们的提示框真的不需要额外的DOM元素，因为它们完全是基于伪元素的（::before 和 ::after），我们可以通过CSS来控制。 如果你已经在其它样式集中使用了一个元素的伪元素，又希望在这个元素是加一个提示框，那么你可能需要稍稍做一些重构。 没什么比得上来一场提示框盛会了！ 等等。小坏蛋！还有一个警告：CSS定位。为了提示框正常运作，它们的父元素（我们把提示框添加在它后面）需要是</p>\n<ul>\n<li>  <code>position: relative</code>，或者</li>\n<li>  <code>position: absolute</code>，或</li>\n<li>  <code>position: fixed</code></li>\n</ul>\n<p>基本上，什么都行，只要不是 position: static — 这是浏览器赋给几乎所有元素的默认定位模式。提示框是绝对定位的，所以它们需要知道它们的绝对值在什么边界内是有意义的。 默认的定位指令 static 不会声明它的边界，也不会给我们的提示框以上下文来进行相对定位。所以提示框会使用之后，最近的，有声明边界的父元素。 你还需要根据你如何使用提示框来决定哪个定位指令最为合适。这篇教程假设父元素是 postion: relative 如果你的UI依靠一个绝对定位的元素，那么在那个元素上部署一个提示框，也会需要一些重构（额外的标签）。 让我们开始吧。</p>\n<h2 id=\"属性选择器：快速回顾\"><a href=\"#属性选择器：快速回顾\" class=\"headerlink\" title=\"属性选择器：快速回顾\"></a>属性选择器：快速回顾</h2><p>大多数CSS规则印象中都是用类名写的，比如 .this-thing ,但是CSS有几个类型的选择器。我们巧妙的提示框打算使用属性选择器——也就是方括号表示法。</p>\n<p>[foo] {<br>background: rgba(0, 0, 0, 0.8);<br>color: #fff;<br>}</p>\n<p>当浏览器看到诸如此类的东西时：</p>\n<p><span foo>Check it out!</span></p>\n<p>浏览器会知道，它需要应用 [foo] 规则了，因为 <span> 标签有一个叫做 foo 的属性。在这个例子中，span自身会有一个半透明的黑色背景，以及白色文字。 HTML元素有着各种各样的内置属性，但是我们也可以给出我们自己的属性。比如 foo ，又或者是 tooltip 。默认情况下，HTML不知道这些东西是什么意思，但是有了CSS，我们可以告诉HTML这些自定义属性是什么意思。</p>\n<h2 id=\"为什么用属性选择器？\"><a href=\"#为什么用属性选择器？\" class=\"headerlink\" title=\"为什么用属性选择器？\"></a>为什么用属性选择器？</h2><p>我们后面会使用属性选择器，主要是出于侧重分离的目的。使用属性而不是类名，并不会让我们在详细程度上获得更多益处，类和属性在详细程度上是相同的。 然而，通过使用属性，我们可以把我们的内容放在一块儿，因为HTML属性可以有值，而类名没有值。 在这个例子的代码中，来权衡一下类名 .tooltip 对比属性 [tooltip] 。类名是 [class] 属性的值中的一个，而tooltip属性可以存放一个值，它就是我们要显示的文字。</p>\n<p><span class=\"tooltip another-classname\">lorem ipsum</span><br><span tooltip=\"sit dolar amet\">lorem ipsum</span></p>\n<h2 id=\"现在让我们来看看提示框炼金术\"><a href=\"#现在让我们来看看提示框炼金术\" class=\"headerlink\" title=\"现在让我们来看看提示框炼金术\"></a>现在让我们来看看提示框炼金术</h2><p>我们的提示框会使用两种不同的属性：</p>\n<ul>\n<li>  tooltip: 这个属性存放了提示框的内容（一个纯文本字符串）</li>\n<li>  flow: 可选；这个属性允许我们控制如何显示提示框。我们可以支持很多方位，但是我们会覆盖4各常用方位： 上，左，右，下</li>\n</ul>\n<p>现在，让我们为所有的提示框做好准备工作。步骤1-5的规则会应用到所有的提示框上，无论我们给 flow 属性什么值。步骤6-7对于不同的 flow 值会有所区分。</p>\n<h3 id=\"1-相对性\"><a href=\"#1-相对性\" class=\"headerlink\" title=\"1. 相对性\"></a>1. 相对性</h3><p>这是用在提示框的父元素上的。让我们来给定一个定位指令，这样提示框的组成部分（即::before 和 ::after 伪元素）的绝对定位就可以以父元素做参照进行定位，而不是以整个页面或祖父元素或DOM树上方的其它外围元素作为参照进行定位。</p>\n<p>[tooltip] {<br>position: relative;<br>}</p>\n<h3 id=\"2-伪元素准备时间\"><a href=\"#2-伪元素准备时间\" class=\"headerlink\" title=\"2. 伪元素准备时间\"></a>2. 伪元素准备时间</h3><p>是时候准备伪元素了。在这里，我们要对 ::before 和 ::after 设置常用属性。content 属性是真正让伪元素工作的属性，不过我们稍后再讨论它。</p>\n<p>[tooltip]::before,<br>[tooltip]::after {<br>line-height: 1;<br>user-select: none;<br>pointer-events: none;<br>position: absolute;<br>display: none;<br>opacity: 0;</p>\n<p>/* opinions */<br>text-transform: none;<br>font-size: .9em;<br>}</p>\n<h3 id=\"3-丁克帽\"><a href=\"#3-丁克帽\" class=\"headerlink\" title=\"3. 丁克帽\"></a>3. 丁克帽</h3><p>我不知道丁克帽是不是说得通，我只是一直这么叫它。它是一个尖尖的小三角形，通过指向它的调用者，为提示框提供对话气泡的感觉。 注意到我们在边界颜色这一块，使用了 tranparent ；由于上色要根据提示框的 flow 值来，所以之后再加上颜色。</p>\n<p>[tooltip]::before {<br>content: ‘’;<br>z-index: 1001;<br>border: 5px solid transparent;<br>}</p>\n<p>content: ‘’;声明中的值是一个空字符串，这并不是笔误。字符串里面，我们不想要任何东西，但是我们需要这个属性，使得伪元素得以存在。 为了生成一个三角形，我们定义了一个实现边框，在空的盒子（没有内容）上加了一些厚度，而不设定盒子的宽度和高度，仅仅对盒子的每一条边都给一个边框颜色。</p>\n<h3 id=\"4-气泡！\"><a href=\"#4-气泡！\" class=\"headerlink\" title=\"4. 气泡！\"></a>4. 气泡！</h3><p>这里是重点了。注意到 content: attr(tooltip) 这一部分是说：“这个伪类应该使用 tooltip 属性的值作为这个伪类的内容。”这也是为什么使用属性而不是类名会这么赞的原因。</p>\n<p>[tooltip]::after {<br>content: attr(tooltip); /* magic! */<br>z-index: 1000;</p>\n<p>/* most of the rest of this is opinion */<br>font-family: Helvetica, sans-serif;<br>text-align: center;</p>\n<p>/*<br>Let the content set the size of the tooltips<br>but this will also keep them from being obnoxious<br>*/<br>min-width: 3em;<br>max-width: 21em;<br>white-space: nowrap;<br>overflow: hidden;<br>text-overflow: ellipsis;</p>\n<p>/* visible design of the tooltip bubbles */<br>padding: 1ch 1.5ch;<br>border-radius: .3ch;<br>box-shadow: 0 1em 2em -.5em rgba(0, 0, 0, 0.35);<br>background: #333;<br>color: #fff;<br>}</p>\n<p>注意看丁克帽和气泡的 z-index 值。这些值可以是任意的。但是要记住，z-index 值是相对的。 解释：一个z-index值为1001的元素，在一个z-index为3的元素内部。仅仅意味着，z-index: 3 容器内部，1001元素是最顶层的元素。 气泡的z-index应该至少比丁克帽的z-index低一档。如果它和丁克的一样高，或更高的话，如果你提示框使用了 box-shadow 的话，结果在丁克帽上回得到不一致的颜色效果。</p>\n<h3 id=\"5-交互动作\"><a href=\"#5-交互动作\" class=\"headerlink\" title=\"5. 交互动作\"></a>5. 交互动作</h3><p>我们的提示框是通过把鼠标移动到带提示框的元素上面，来激活的。差不多是这样。</p>\n<p>[tooltip]:hover::before,<br>[tooltip]:hover::after {<br>display: block;<br>}</p>\n<p>如果你回顾在第2不中的样式部分，你会看到我们对提示框的组成部分，使用了 opacity: 0; 以及 display: none; 。我们这么做是为了当提示框显示和隐藏时，可以使用CSS动画效果。 display属性是不能做成动画的，但是opacity属性可以！我们留到最后来处理动画的问题。如果你对动画提示框没兴趣，只要把第2步中的 opacity: 0; 删掉，无视第7步即可。 最后一件要应用到所有提示框上的是，如果提示框没有内容，能有一个方法来抑制提示框。如果你使用某种动态系统（Vue.js, Angular, 或者 React, PHP等等）来生成提示框的话，我们就不需要笨笨的空白气泡了！</p>\n<p>/* don’t show empty tooltips */<br>[tooltip=’’]::before,<br>[tooltip=’’]::after {<br>display: none !important;<br>}</p>\n<h3 id=\"6-流控制\"><a href=\"#6-流控制\" class=\"headerlink\" title=\"6. 流控制\"></a>6. 流控制</h3><p>这一步会变得更加复杂，因为我们会使用一些不那么常见的选择器，来帮助我们的提示框基于 flow 值（或没有flow属性）来确定位置。 在我们写样式之前，让我们看看将要用到一些选择器模式。</p>\n<p>[tooltip]:not([flow])::before,<br>[tooltip][flow^=”up”]::before {<br>/* …<br>properties: values<br>… */<br>}</p>\n<p>这是在告诉浏览器：“对于所有带有 tooltip 属性来说，其中没有 flow 属性的元素，或者有flow元素，但它的值是以’up’开头的：将这些样式套用到这类元素的::before伪元素上。” 我们在这里使用了一个模式，这样一来，这些东西可以扩展到其它流上，而步需要重复这么多的CSS。这个模式 flow^=”up” 使用了 ^= （开头）匹配符。 如果你想增加其它流控制的话，通过这个模式，也可以将样式应用在 up-right 和 up-left 方向上（代码中）。我们在这里不会讨论这些流控制，不过你可以在CodePen上，我原来的提示框演示中看到如何使用它们。 以下是教程中所讲到的4个流所对应的CSS代码块。 上（这是默认的方向）</p>\n<p>/* ONLY the ::before */<br>[tooltip]:not([flow])::before,<br>[tooltip][flow^=”up”]::before {<br>bottom: 100%;<br>border-bottom-width: 0;<br>border-top-color: #333;<br>}</p>\n<p>/* ONLY the ::after */<br>[tooltip]:not([flow])::after,<br>[tooltip][flow^=”up”]::after {<br>bottom: calc(100% + 5px);<br>}</p>\n<p>/* Both ::before &amp; ::after */<br>[tooltip]:not([flow])::before,<br>[tooltip]:not([flow])::after,<br>[tooltip][flow^=”up”]::before,<br>[tooltip][flow^=”up”]::after {<br>left: 50%;<br>transform: translate(-50%, -.5em);<br>}</p>\n<h4 id=\"下\"><a href=\"#下\" class=\"headerlink\" title=\"下:\"></a>下:</h4><p>[tooltip][flow^=”down”]::before {<br>top: 100%;<br>border-top-width: 0;<br>border-bottom-color: #333;<br>}</p>\n<p>[tooltip][flow^=”down”]::after {<br>top: calc(100% + 5px);<br>}</p>\n<p>[tooltip][flow^=”down”]::before,<br>[tooltip][flow^=”down”]::after {<br>left: 50%;<br>transform: translate(-50%, .5em);<br>}</p>\n<h4 id=\"左\"><a href=\"#左\" class=\"headerlink\" title=\"左:\"></a>左:</h4><p>[tooltip][flow^=”left”]::before {<br>top: 50%;<br>border-right-width: 0;<br>border-left-color: #333;<br>left: calc(0em - 5px);<br>transform: translate(-.5em, -50%);<br>}</p>\n<p>[tooltip][flow^=”left”]::after {<br>top: 50%;<br>right: calc(100% + 5px);<br>transform: translate(-.5em, -50%);<br>}</p>\n<h4 id=\"右\"><a href=\"#右\" class=\"headerlink\" title=\"右:\"></a>右:</h4><p>[tooltip][flow^=”right”]::before {<br>top: 50%;<br>border-left-width: 0;<br>border-right-color: #333;<br>right: calc(0em - 5px);<br>transform: translate(.5em, -50%);<br>}</p>\n<p>[tooltip][flow^=”right”]::after {<br>top: 50%;<br>left: calc(100% + 5px);<br>transform: translate(.5em, -50%);<br>}</p>\n<h3 id=\"7-让一切都动起来\"><a href=\"#7-让一切都动起来\" class=\"headerlink\" title=\"7. 让一切都动起来\"></a>7. 让一切都动起来</h3><p>动画是很神奇的。动画可以做到： 让用户感觉舒服 让用户感受到你的用户界面的空间感 注意到该看到的东西 让用户界面中本来非黑即白的生硬效果变得柔和 我们的提示框属于最后那一种。如果仅仅是让一个文字泡泡出现然后突然消失，效果是不令人满意的，我们可以让它更柔和一些。 关键帧 (@keyframes) 我们需要两个关键帧 (@keyframe) 动画。向上/向下提示框要用到tooltips-vert关键帧，而向左/向右提示框使用tooltips-horz关键帧。 注意，在这些关键帧中，我们只定义了提示框所需的终止状态。我们并不需要知道它们从何处来 (提示框本身就有状态信息)。我们只想控制它们要到哪儿去。</p>\n<p>@keyframes tooltips-vert {<br>to {<br>opacity: .9;<br>transform: translate(-50%, 0);<br>}<br>}</p>\n<p>@keyframes tooltips-horz {<br>to {<br>opacity: .9;<br>transform: translate(0, -50%);<br>}<br>}</p>\n<p>现在，当一个用户的鼠标移到触发元素 (具有[tooltip]属性的元素) 上时，我们需要将这些关键帧应用到提示框上。因为我们采用了不同的流来控制提示框的显示方式，我们需要在样式中对它们进行定义。 使用:hover将控制传递给动画</p>\n<p>[tooltip]:not([flow]):hover::before,<br>[tooltip]:not([flow]):hover::after,<br>[tooltip][flow^=”up”]:hover::before,<br>[tooltip][flow^=”up”]:hover::after,<br>[tooltip][flow^=”down”]:hover::before,<br>[tooltip][flow^=”down”]:hover::after {<br>animation:<br>tooltips-vert<br>300ms<br>ease-out<br>forwards;<br>}</p>\n<p>[tooltip][flow^=”left”]:hover::before,<br>[tooltip][flow^=”left”]:hover::after,<br>[tooltip][flow^=”right”]:hover::before,<br>[tooltip][flow^=”right”]:hover::after {<br>animation:<br>tooltips-horz<br>300ms<br>ease-out<br>forwards;<br>}</p>\n<p>我们不能对display属性进行动画，但是可以通过操作opacity属性，在提示框上加上淡入效果。我们也可以动画transform属性，它可以给提示框加上微妙的动作，触发的元素就像飞入某点的一样。 主要forward关键词在动画的声明中，这告诉动画当完成时不重置，而是继续停留在结束。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>棒极了！我们在这个教程里已经覆盖了很多，一堆提示框效果。 我们仅仅摸索了用css做提示框的表面。好好享受它们，继续试验，调制出你自己的方子！</p>\n","categories":["HTML/CSS"],"tags":["css","css3",":after",":before","Bootstrap","content","tooltip"]},{"title":"使用CSS Grid轻松搞定响应式布局","url":"/2019/11/18/%E4%BD%BF%E7%94%A8css-grid%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9A%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/","content":"<p>在这篇文章中，我将教你如何使用 CSS Grid 来创建一个超酷的图像网格图，它将根据屏幕的宽度来改变列的数量。最精彩的地方在于：所有的响应特性被添加到了一行 css 代码中。这意味着我们不必将 HTML 与丑陋的类名(如col-sm-4, col-md-8)混杂在一起，也不必为每个屏幕创建媒体查询。ok，让我们发车吧。</p>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><p>在本文中，我将继续使用我在第一篇 <a href=\"https://www.freecodecamp.org/news/learn-css-grid-in-5-minutes-f582e87b1228/\">CSS Grid 布局教程文章</a>中的网格布局。然后，我们将在文章末尾添加图片。下面是我们初始化网格的外观： <img src=\"http://file.w3cbest.com/file/images/1_fJNIdDiScjhI9CZjdxv3Eg.png\"> HTML 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class=\"line\">  &lt;div&gt;1&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;div&gt;2&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;div&gt;3&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;div&gt;4&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;div&gt;5&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;div&gt;6&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>CSS 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.container &#123;</span><br><span class=\"line\">display: grid;</span><br><span class=\"line\">grid-template-columns: 100px 100px 100px;</span><br><span class=\"line\">grid-template-rows: 50px 50px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意: 示例中有一些基础的样式，但我在这里没有写出来，因为这对 CSS 网格布局没有任何影响 如果这段代码让你感到困惑，我建议你去好好读下我的这篇文章<a href=\"https://www.freecodecamp.org/news/learn-css-grid-in-5-minutes-f582e87b1228/\">Learn CSS Grid in 5 minutes</a>，其中就详细的解释了布局的基础知识。 让我们让列开始具有自适应特性吧。 基础响应单位: fraction CSS 栅格布局带来了一个全新的值:fraction单位，fraction单位通常简写为fr，它允许你根据需要将容器拆分为多个块。 让我们将每一列更改为一个 fraction 单位宽:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.container &#123;</span><br><span class=\"line\">display: grid;</span><br><span class=\"line\">grid-template-columns: 1fr 1fr 1fr;</span><br><span class=\"line\">grid-template-rows: 50px 50px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果是栅格布局将会把整个宽度分成三个 fraction，每列占据一个 fraction 单位，效果如下： <img src=\"http://file.w3cbest.com/file/images/1_JgGPqT2AfFNDD8DhG2wPdQ.gif\"> 如果我们将grid-template-columns的值更改为1fr 2fr 1fr，第二列的宽度将会是其它两列的两倍。总宽现在是四个 fraction 单位，第二列占据两个 fraction 单位，其它列各占一个 fraction。效果如下： <img src=\"http://file.w3cbest.com/file/images/1_cpfokc1HBgCwOTNhRU9SHg.gif\"> 总的来说，fraction 单位值将使你可以很容易的更改列的宽度。 高级响应 然而，上面列子并没有给出我们想要的响应性，因为网格总是三列宽。我们希望网格能根据容器的宽度改变列的数量。要做到这一点，你必须学习如下三个概念：</p>\n<h2 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat()\"></a>repeat()</h2><p>首先我们学习repeat()函数。这是一个强大的指定列和行的方法。让我们使用repeat()函数来更改网格:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.container &#123;</span><br><span class=\"line\">  display: grid;</span><br><span class=\"line\">  grid-template-columns: repeat(3, 100px);</span><br><span class=\"line\">  grid-template-rows: repeat(2, 50px);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面代码中，repeat(3, 100px)等于100px 100px 100px。第一个参数指定行与列的数量，第二个参数指定它们的宽度，因此它将为我们提供与开始时完全相同的布局： <img src=\"http://file.w3cbest.com/file/images/1_fJNIdDiScjhI9CZjdxv3Eg.png\"></p>\n<h2 id=\"auto-fit\"><a href=\"#auto-fit\" class=\"headerlink\" title=\"auto-fit\"></a>auto-fit</h2><p>然后是auto-fit。让我们跳过固定数量的列，将3替换为自适应数量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.container &#123;</span><br><span class=\"line\">display: grid;</span><br><span class=\"line\">grid-gap: 5px;</span><br><span class=\"line\">grid-template-columns: repeat(auto-fit, 100px);</span><br><span class=\"line\">grid-template-rows: repeat(2, 100px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果如下: <img src=\"http://file.w3cbest.com/file/images/v2-e9df20fc5a27960605959ba296042ffa_b.webp\"> 现在，栅格将会根据容器的宽度调整其数量。它会尝试在容器中容纳尽可能多的 100px 宽的列。但如果我们将所有列硬写为 100px，我们将永远没法获得所需的弹性，因为它们很难填充整个宽度。正如你在上图看到的，网格通常在右侧留有空白。</p>\n<h2 id=\"minmax\"><a href=\"#minmax\" class=\"headerlink\" title=\"minmax()\"></a>minmax()</h2><p>为了解决上述问题，我们需要minmax()。我们将 100px 替换为 minmax(100px, 1fr)，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.container &#123;</span><br><span class=\"line\">display: grid;</span><br><span class=\"line\">grid-gap: 5px;</span><br><span class=\"line\">grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));</span><br><span class=\"line\">grid-template-rows: repeat(2, 100px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，所有响应都发生在一行 css 代码中 效果如下： <img src=\"http://file.w3cbest.com/file/images/v2-4c968663383dbf14b08e22c45c1ddbd8_b.webp\"> 正如你所见，效果完美。minmax()函数定义的范围大于或等于 min， 小于或等于 max。 因此，现在每列将至少为 100px。但如果有更多的可用空间，栅格布局将简单地将其均分给每列，因为这些列变成了 fraction 单位，而不是 100px。</p>\n<h2 id=\"添加图片\"><a href=\"#添加图片\" class=\"headerlink\" title=\"添加图片\"></a>添加图片</h2><p>最后一步是添加图片。这与 <a href=\"http://www.w3cbest.com/494.html\">CSS Grid</a> 布局无关，但让我们看下代码。 我们在每个网格中添加一个图片标签：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&lt;img src&#x3D;&quot;img&#x2F;forest.jpg&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>为了使图片适应于每个条目，我们将其宽、高设置为与条目本身一样，我们使用object-fit:cover。这将使图片覆盖它的整个容器，根据需要，浏览器将会对其进行裁剪。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.container &gt; div &gt; img &#123;</span><br><span class=\"line\">width: 100%;</span><br><span class=\"line\">height: 100%;</span><br><span class=\"line\">object-fit: cover;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果如下： <img src=\"http://file.w3cbest.com/file/images/v2-5589cdec01ac4734366b7d38ebac182a_b.webp\"> ok！现在你已经了解了 <a href=\"http://www.w3cbest.com/494.html\">CSS Grid</a> 布局中最复杂的概念之一了，请给自己一个赞吧。</p>\n<h2 id=\"浏览器兼容性\"><a href=\"#浏览器兼容性\" class=\"headerlink\" title=\"浏览器兼容性\"></a>浏览器兼容性</h2><p>在结束本文前，我提下浏览器支持情况，在撰写本文时，全球77%的网站将支持 CSS Grid，而且比例还在逐步攀升。 2018将是 CSS 网格布局的元年。它将获得突破，并成为前端开发者的必备技能，就像过去几年 <a href=\"http://www.w3cbest.com/490.html\">CSS Flexbox</a> 布局发生的情况一样。</p>\n","categories":["HTML/CSS"],"tags":["css","css 布局","css grid"]},{"title":"使用CSS3 选择器:target制作一个可伸缩的导航菜单","url":"/2018/10/05/%E4%BD%BF%E7%94%A8css3-%E9%80%89%E6%8B%A9%E5%99%A8target%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BC%B8%E7%BC%A9%E7%9A%84%E5%AF%BC%E8%88%AA%E8%8F%9C%E5%8D%95/","content":"<p>我们使用CSS3 选择器:target制作一个可伸缩的导航菜单。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target\">先理解一下:target</a></p>\n<h4 id=\"定义和用法\"><a href=\"#定义和用法\" class=\"headerlink\" title=\"定义和用法\"></a>定义和用法</h4><p>URL 带有后面跟有锚名称 #，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)。 :target 选择器可用于选取当前活动的目标元素。 那么我就看一下代码如何做可伸缩的导航菜单</p>\n<nav id=\"menu\">\n<ul id=\"menu-closed\">\n<li><a href=\"#\">首页</a></li>\n<li><a href=\"#\">html/css</a></li>\n<li><a href=\"#\">javascript</a></li>\n<li><a href=\"#\">vue</a></li>\n<li><a href=\"#\">anjular</a></li>\n<li><a href=\"#\">react</a></li>\n<li><a href=\"#\">php</a></li>\n<li><a href=\"#\">python</a></li>\n<li><a href=\"#\">highcharts</a></li>\n<li><a href=\"#\">echarts</a></li>\n<li><a href=\"#menu-closed\">&#215;</a></li>\n<li><a href=\"#menu\">&#9776;</a></li>\n</ul>\n</nav>\n\n<p>CSS代码</p>\n<p>nav {<br>font-size: 12px;<br>background-color: rgb(19, 51, 61);<br>box-shadow: 0 1px 2px rgba(19, 51, 61, 0.5);<br>margin: 3em 0 6em;<br>padding: 0 1em;<br>height: 44px;<br>overflow: hidden;<br>}</p>\n<p>nav ul {<br>margin: 0;<br>padding: 0;<br>list-style-type: none;<br>max-height: 88px;<br>position: relative;<br>}</p>\n<p>nav li {<br>display: inline-block;<br>}</p>\n<p>nav a {<br>display: inline-block;<br>padding: 0 1em;<br>color: rgb(236, 236, 236);<br>font-weight: 700;<br>letter-spacing: 0.1em;<br>text-decoration: none;<br>text-transform: uppercase;<br>white-space: nowrap;<br>line-height: 44px;<br>height: 44px;<br>}</p>\n<p>nav a:hover {<br>background-color: rgba(255, 255, 255, 0.08);<br>}</p>\n<p>nav li:last-child {<br>/* 菜单按钮 */<br>position: absolute;<br>right: 0;<br>bottom: 44px;<br>background-image: linear-gradient(to right, rgba(19, 51, 61, 0) 0, rgba(19, 51, 61, 1) 2em);<br>padding-left: 3em;<br>}</p>\n<p>nav li:nth-last-child(2) {<br>/* 先关闭按钮 */<br>display: none;<br>}</p>\n<p>nav#menu:target {<br>height: auto;<br>padding: 0;<br>}</p>\n<p>nav#menu:target ul {<br>max-height: none;<br>}</p>\n<p>nav#menu:target li {<br>display: block;<br>}</p>\n<p>nav#menu:target a {<br>display: block;<br>padding: 0 2em;<br>background-color: rgba(255, 255, 255, 0.05);<br>}</p>\n<p>nav#menu:target a:hover {<br>background-color: rgba(255, 255, 255, 0.08);<br>}</p>\n<p>nav#menu:target li:not(:first-child) {<br>margin-top: 2px;<br>}</p>\n<p>nav#menu:target li:last-child {<br>display: none;<br>}</p>\n<p>nav#menu:target li:nth-last-child(2) {<br>display: inline-block;<br>position: absolute;<br>top: 0;<br>right: 0;<br>margin: 0;<br>border-left: 2px solid rgb(19, 51, 61);<br>}</p>\n<p><a href=\"https://jshare.com.cn/temp/HpJ1bg/share/pure\">查看demo</a></p>\n","categories":["HTML/CSS"],"tags":["css","css3","导航","导航菜单",":target","菜单"]},{"title":"使用CSS属性选择器拼接html","url":"/2018/11/08/%E4%BD%BF%E7%94%A8css%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8%E6%8B%BC%E6%8E%A5html/","content":"<blockquote>\n<p>属性选择器非常神奇。它们可以使你摆脱棘手的问题，帮助你避免添加类，并指出代码中的一些问题。但是不要担心，虽然属性选择器非常复杂和强大，但是它们很容易学习和使用。在本文中，我们将讨论它们是如何运行的，并给出一些如何使用它们的想法。</p>\n</blockquote>\n<p>通常将 HTML 属性放在方括号中，称为属性选择器，如下：</p>\n<p>[href] {<br>    color: red;<br>}</p>\n<p>这样任何具有href属性的且没有更特定选择器的元素的文本颜色都会是红色的。属性选择器的特性与类相同。 <strong>注:更多关于笼匹配的CSS特异性，你可以阅读<a href=\"https://link.juejin.im/?target=https://www.smashingmagazine.com/2007/07/css-specificity-things-you-should-know/\">CSS特性:你应该知道的事情</a>，或者如果你喜欢星球大战:<a href=\"https://link.juejin.im/?target=http://www.stuffandnonsense.co.uk/archives/css_specificity_wars.html\">CSS特性战争</a>。</strong> 但是你可以使用属性选择器做得更多。就像你的 DNA 一样，它们有内在的逻辑来帮助你选择各种属性组合和值。它们可以匹配属性中的任何属性，甚至字符串值，而不是像标签、类或id选择器那样精确匹配。</p>\n<h2 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h2><p>属性选择器可以独立存在，更具体地说，如果需要选择所有具有title属性的div标签，可以这么做：</p>\n<p>div[title]</p>\n<p>但你也可以通过以下操作选择具有 title 属性的 div 的子元素</p>\n<p>div [title]</p>\n<p>需要说明的是，它们之间没有空格意味着属性位于相同的元素上(就像元素和类之间没有空格一样)，而它们之间的空格意味着后代选择器，即选择具有该属性的元素的子元素。 你可以更精细地选择具体属性值的属性。</p>\n<p>div[title=”dna”]</p>\n<p>上面选择了所有具有确切名称dna的div,虽然有选择器算法可以处理每种情况（以及更多），但这里不会选择**“dna is awesome”或“dnamutation”**的标题。 **注意:**在大多数情况下，属性选择器中不需要引号，但是我使用它们，因为我相信它可以提高清代码的可读性，并确保边界用例能够正常工作。 如果你想选择 title 包含 dna的元素，如 “my beautiful dna” 或者 “mutating dna is fun!” ，可以使用波浪号（~）。</p>\n<p>div[title~=”dna”]</p>\n<p>如果你想匹配以 dna 结尾的 title,如  “dontblamemeblamemydna” 或 “his-stupidity-is-from-upbringing-not-dna” ，刚可以使用$标志符：</p>\n<p>[title$=”dna”]</p>\n<p>如果你想匹配以 dna 开头的 title,如  “dnamutants” 或 “dna-splicing-for-all” ，刚可以使用^标志符：</p>\n<p>[title^=”dna”]</p>\n<p>虽然精确匹配是有帮助的，但它可能选择太紧，并且^符号匹配可能太宽而无法满足你的需要。 例如，可能不想选择 “genealogy” 的标题，但仍然选择“gene”和“gene-data”。 管道特征()就是这样，属性中必须是完整且唯一的单词，或者以-分隔开。</p>\n<p>[title=”gene”]</p>\n<p>最后，还有一个匹配任何子字符串的模糊搜索属性操作符，属性中做字符串拆分，只要能拆出来dna这个词就行:</p>\n<p>[title*=”dna”]</p>\n<p>使这些属性选择器更加强大的是，它们是可堆叠的，允许你选择具有多个匹配因子的元素。 如果你需要找到一个a 标签，它有一个 title ，并且有一个以“genes” 结尾的 class,可以使用如下方式：</p>\n<p>a[title][class$=”genes”]</p>\n<p>你不仅可以选择 HTML 元素的属性，还可以使用伪类型元素来打印出文本：</p>\n<p><span class=\"joke\" title=\"Gene Editing!\">What’s the first thing a biotech journalist does after finishing the first draft of an article?</span></p>\n<p>.joke:hover:after {<br>    content: “Answer:”attr(title);<br>    display: block;<br>}</p>\n<p>上面的代码在鼠标悬停时将显示一串自定义的字符串。 最后要知道的是，您可以添加一个标志，让属性搜索不区分大小写。 在结束方括号之前添加i：</p>\n<p>[title*=”DNA” i]</p>\n<p>因此它会匹配dna, DNA, dnA等。 现在我们已经看到了如何使用属性选择器进行选择，让我们看看一些用例。 我将它们分为两类：一般用途和诊断。</p>\n<h2 id=\"一般用途\"><a href=\"#一般用途\" class=\"headerlink\" title=\"一般用途\"></a>一般用途</h2><h3 id=\"输入类型样式的设置\"><a href=\"#输入类型样式的设置\" class=\"headerlink\" title=\"输入类型样式的设置\"></a>输入类型样式的设置</h3><p>你可以对输入类型使用不同的样式，例如电子邮件和电话。</p>\n<p>input[type=”email”] {<br>    color: papayawhip;<br>}<br>input[type=”tel”] {<br>    color: thistle;<br>}</p>\n<h3 id=\"显示电话链接\"><a href=\"#显示电话链接\" class=\"headerlink\" title=\"显示电话链接\"></a>显示电话链接</h3><p>你可以隐藏特定尺寸的电话号码并显示电话链接，以便在手机上轻松拨打电话。</p>\n<p>span.phone {<br>    display: none;<br>}<br>a[href^=”tel”] {<br>    display: block;<br>}</p>\n<h3 id=\"内部链接-vs-外部链接，安全链接-vs-非安全链接\"><a href=\"#内部链接-vs-外部链接，安全链接-vs-非安全链接\" class=\"headerlink\" title=\"内部链接 vs 外部链接，安全链接 vs 非安全链接\"></a>内部链接 vs 外部链接，安全链接 vs 非安全链接</h3><p>你可以区别对待内部和外部链接，并将安全链接设置为与不安全链接不同：</p>\n<p>a[href^=”http”] {<br>    color: bisque;<br>}<br>a:not([href^=”http”]) {<br>    color: darksalmon;<br>}</p>\n<p>a[href^=”http://“]:after {<br>    content: url(unlock-icon.svg);<br>}<br>a[href^=”https://“]:after {<br>    content: url(lock-icon.svg);<br>}</p>\n<h3 id=\"下载图标\"><a href=\"#下载图标\" class=\"headerlink\" title=\"下载图标\"></a>下载图标</h3><p>HTML5 给我们的一个属性是“下载”，它告诉浏览器，你猜对了，下载该文件而不是试图打开它。这对于你希望人们访问但不希望它们立即打开的 PDF 和 DOC 非常有用。它还使得连续下载大量文件的工作流程更加容易。下载属性的缺点是没有默认的视觉效果将其与更传统的链接区分开来。通常这是你想要的，但如果不是，你可以做类似下面的事情：</p>\n<p>a[download]:after {<br>    content: url(download-arrow.svg);<br>}</p>\n<p>还可以使用不同的图标（如PDF与DOCX与ODF等）来表示文件类型，等等。</p>\n<p>a[href$=”pdf”]:after {<br>    content: url(pdf-icon.svg);<br>}<br>a[href$=”docx”]:after {<br>    content: url(docx-icon.svg);<br>}<br>a[href$=”odf”]:after {<br>    content: url(open-office-icon.svg);<br>}</p>\n<p>你还可以通过叠加属性选择器来确保这些图标只出现在可下载链接上。</p>\n<p>a[download][href$=”pdf”]:after {<br>    content: url(pdf-icon.svg);<br>}</p>\n<h3 id=\"覆盖或重新使用已废弃-弃用的代码\"><a href=\"#覆盖或重新使用已废弃-弃用的代码\" class=\"headerlink\" title=\"覆盖或重新使用已废弃/弃用的代码\"></a>覆盖或重新使用已废弃/弃用的代码</h3><p>我们都遇到过时代码过时的旧网站，在 HTML5 之前，你可能需要覆盖甚至重新应用作为属性实现的样式。</p>\n<div bgcolor=\"#000000\"color=\"#FFFFFF\">Old,holey genes</div>\n\n<p>div[bgcolor=”#000000”] {<br>    /*override*/<br>    background-color: #222222 !important;<br>}<br>div[color=”#FFFFFF”] {<br>    /*reapply*/<br>    color: #FFFFFF;<br>}</p>\n<h3 id=\"重写特定的内联样式\"><a href=\"#重写特定的内联样式\" class=\"headerlink\" title=\"重写特定的内联样式\"></a>重写特定的内联样式</h3><p>有时候你会遇到一些内联样式，这些样式会影响布局，但这些内联样式我们又没修改。那么以下是一种方法。 如果你道要覆盖的确切属性和值，并且希望在它出现的任何地方覆盖它，那么这种方法的效果最好。 对于此示例，元素的边距以像素为单位设置，但需要在 em 中进行扩展和设置，以便在用户更改默认字体大小时可以正确地重新调整元素。</p>\n<div style=\"color: #222222; margin: 8px; background-color: #EFEFEF;\"Teenage Mutant Ninja Myrtle</div>\n\n<p>div[style*=”margin: 8px”] {<br>    margin: 1em !important;<br>}</p>\n<h3 id=\"显示文件类型\"><a href=\"#显示文件类型\" class=\"headerlink\" title=\"显示文件类型\"></a>显示文件类型</h3><p>默认情况下，文件输入的可接受文件列表是不可见的。 通常，我们使用伪元素来暴露它们：</p>\n<p>&lt;input type=”file”accept=”pdf,doc,docx”&gt;</p>\n<p>[accept]:after {<br>    content: “Acceptable file types: “attr(accept);<br>}</p>\n<h3 id=\"html-手风琴菜单\"><a href=\"#html-手风琴菜单\" class=\"headerlink\" title=\"html 手风琴菜单\"></a>html 手风琴菜单</h3><p>details和summary标签是一种只用HTML做扩展/手风琴菜单的方法，details 包括了summary标签和手风琴打开时要展示的内容。点击summary会展开details标签并添加open属性，我们可以通过open属性轻松地为打开的details标签设置样式：</p>\n<p>details[open] {<br>    background-color: hotpink;<br>}</p>\n<h3 id=\"打印链接\"><a href=\"#打印链接\" class=\"headerlink\" title=\"打印链接\"></a>打印链接</h3><p>在打印样式中显示URL使我走上了理解属性选择器的道路。 你现在应该知道如何自己构建它， 你只需选择带有href的所有标签，添加伪元素，然后使用attr()和content打印它们。</p>\n<p>a[href]:after {<br>    content: “ (“attr(href) “) “;<br>}</p>\n<h3 id=\"自定义提示\"><a href=\"#自定义提示\" class=\"headerlink\" title=\"自定义提示\"></a>自定义提示</h3><p>使用属性选择器创建自定义工具提示既有趣又简单：</p>\n<p>[title] {<br>    position: relative;<br>    display: block;<br>}<br>[title]:hover:after {<br>    content: attr(title);<br>    color: hotpink;<br>    background-color: slateblue;<br>    display: block;<br>    padding: .225em .35em;<br>    position: absolute;<br>    right: -5px;<br>    bottom: -5px;<br>}</p>\n<h3 id=\"便捷键\"><a href=\"#便捷键\" class=\"headerlink\" title=\"便捷键\"></a>便捷键</h3><p>web 的一大优点是它提供了许多不同的信息访问选项。一个很少使用的属性是设置accesskey的能力，这样就可以通过键组合和accesskey设置的字母直接访问该项目(确切的键组合取决于浏览器)。但是要想知道网站上设置了哪些键并不是件容易的事下面的代码将显示这些键:focus。我不使用鼠标悬停，因为大多数时候需要accesskey的人是那些使用鼠标有困难的人。你可以将其添加为第二个选项，但要确保它不是惟一的选项。</p>\n<p>a[accesskey]:focus:after {<br>    content: “ AccessKey: “attr(accesskey);<br>}</p>\n<h2 id=\"诊断\"><a href=\"#诊断\" class=\"headerlink\" title=\"诊断\"></a>诊断</h2><p>这些选项用于帮助我们在构建过程中或在尝试修复问题时在本地识别问题。将这些内容放在我们的生产网站上会使用户产生错误。</p>\n<h3 id=\"没有-controls-属性的-audio\"><a href=\"#没有-controls-属性的-audio\" class=\"headerlink\" title=\"没有 controls 属性的 audio\"></a>没有 controls 属性的 audio</h3><p>我不经常使用audio标签，但是当我使用它时，我经常忘记包含controls属性。 结果：没有显示任何内容。 如果你在 Firefox，如果隐藏了音频元素，或者语法或其他一些问题阻止它出现（仅适用于Firefox），此代码可以帮助你解决问题：</p>\n<p>audio:not([controls]) {<br>    width: 100px;<br>    height: 20px;<br>    background-color: chartreuse;<br>    display: block;<br>}</p>\n<h3 id=\"没有-alt-文本\"><a href=\"#没有-alt-文本\" class=\"headerlink\" title=\"没有 alt 文本\"></a><strong>没有</strong> alt <strong>文本</strong></h3><p>没有 alt 文本的图像是可访问性的噩梦。只需查看页面就很难找到它们，但如果添加它们，它们就会弹出来（当页面图片加载失败时，alt文字可以更好的解释图片的作用）：</p>\n<p>img:not([alt]) {<br>    /* no alt attribute */<br>    outline: 2em solid chartreuse;<br>}<br>img[alt=””] {<br>    /* alt attribute is blank */<br>    outline: 2em solid cadetblue;<br>}</p>\n<h3 id=\"异步-Javascript-文件\"><a href=\"#异步-Javascript-文件\" class=\"headerlink\" title=\"异步 Javascript 文件\"></a>异步 Javascript 文件</h3><p>网页可以是内容管理系统和插件，框架和代码的集合，确定哪些JavaScript异步加载以及哪些不加载可以帮助你专注于提高页面性能。</p>\n<p>script[src]:not([async]) {<br>    display: block;<br>    width: 100%;<br>    height: 1em;<br>    background-color: red;<br>}<br>script:after {<br>    content: attr(src);<br>}</p>\n<h3 id=\"JavaScript-事件元素\"><a href=\"#JavaScript-事件元素\" class=\"headerlink\" title=\"JavaScript 事件元素\"></a>JavaScript 事件元素</h3><p>你可以突出显示具有JavaScript事件属性的元素，以便将它们重构到JavaScript文件中。这里我主要关注OnMouseOver属性，但是它适用于任何JavaScript事件属性。</p>\n<p>[OnMouseOver] {<br>    color: burlywood;<br>}<br>[OnMouseOver]:after {<br>    content: “JS: “attr(OnMouseOver);<br>}</p>\n<h3 id=\"隐藏项\"><a href=\"#隐藏项\" class=\"headerlink\" title=\"隐藏项\"></a>隐藏项</h3><p>如果需要查看隐藏元素或隐藏输入的位置，可以使用它们来显示</p>\n<p>[hidden], [type=”hidden”] {<br>    display: block;<br>}</p>\n<p>  文章来源：<a href=\"https://www.smashingmagazine.com/2018/10/attribute-selectors-splicing-html-dna-css\">https://www.smashingmagazine.com/2018/10/attribute-selectors-splicing-html-dna-css</a></p>\n","categories":["HTML/CSS"],"tags":["html","css3","css3教程","css函数","css 布局","html5","html教程","前端开发","前端教程","伪类选择器","属性选择器"]},{"title":"使用JavaScript 进行对象拷贝","url":"/2019/04/26/%E4%BD%BF%E7%94%A8javascript-%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/","content":"<p>对象是 JavaScript 的基本块。对象是属性的集合，属性是键值对。JavaScript 中的几乎所有对象都是位于原型链顶部 <code>Object</code> 的实例。</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>如你所知，赋值运算符不会创建一个对象的副本，它只分配一个引用，我们来看下面的代码：</p>\n<p>let obj = {<br>    a: 1,<br>    b: 2,<br>};<br>let copy = obj;<br>obj.a = 5;<br>console.log(copy.a);<br>// Result<br>// a = 5;</p>\n<p><code>obj</code> 变量是一个新对象初始化的容器。<code>copy</code> 变量指向同一个对象，是对该对象的引用。所以现在有两种方式可以访问这个 <code>&#123; a: 1, b: 2, &#125;</code> 对象。你必须通过 <code>obj</code> 变量或 <code>copy</code> 变量，无论你是通过何种方式对这个对象进行的任何操作都会影响该对象。 不变性（Immutability）最近被广泛地谈论，这个很重要！上面示例的方法消除了任何形式的不变性，如果原始对象被你的代码的另一部分使用，则可能导致bug。</p>\n<h2 id=\"复制对象的原始方式\"><a href=\"#复制对象的原始方式\" class=\"headerlink\" title=\"复制对象的原始方式\"></a>复制对象的原始方式</h2><p>复制对象的原始方法是循环遍历原始对象，然后一个接一个地复制每个属性。我们来看看这段代码：</p>\n<p>function copy(mainObj) {<br>    let objCopy = {}; // objCopy will store a copy of the mainObj<br>    let key;</p>\n<pre><code>for (key in mainObj) &#123;\n    objCopy\\[key\\] = mainObj\\[key\\]; // copies each property to the objCopy object\n&#125;\nreturn objCopy;\n</code></pre>\n<p>}</p>\n<p>const mainObj = {<br>    a: 2,<br>    b: 5,<br>    c: {<br>        x: 7,<br>        y: 4,<br>    },<br>}</p>\n<p>console.log(copy(mainObj));</p>\n<h3 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h3><ol>\n<li> <code>objCopy</code> 对象具有一个新的 <code>Object.prototype</code>方法，这与 <code>mainObj</code> 对象的原型方法不同，这不是我们想要的。我们需要精确的拷贝原始对象。</li>\n<li> 属性描述符不能被复制。值为 <code>false</code> 的 “可写(<code>writable</code>)” 描述符在 <code>objCopy</code> 对象中为 <code>true</code> 。</li>\n<li> 上面的代码只复制了 <code>mainObj</code> 的可枚举属性。</li>\n<li> 如果原始对象中的一个属性本身就是一个对象，那么副本和原始对象之间将共享这个对象，从而使其各自的属性指向同一个对象。</li>\n</ol>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>当 <code>writable</code> 设置为<code>false</code>时，表示不可写，也就是说属性不能被修改。</p>\n<p>var o = {}; // Creates a new object</p>\n<p>Object.defineProperty(o, ‘a’, {<br>    value: 37,<br>    writable: false<br>});</p>\n<p>console.log(o.a); // logs 37<br>o.a = 25; // No error thrown<br>// (it would throw in strict mode,<br>// even if the value had been the same)<br>console.log(o.a); // logs 37. The assignment didn’t work.</p>\n<p>// strict mode<br>(function() {<br>    ‘use strict’;<br>    var o = {};<br>    Object.defineProperty(o, ‘b’, {<br>        value: 2,<br>        writable: false<br>    });<br>    o.b = 3; // throws TypeError: “b” is read-only<br>    return o.b; // returns 2 without the line above<br>}());</p>\n<p>正如上例中看到的，修改一个 non-writable 的属性不会改变属性的值，同时也不会报异常。</p>\n<h2 id=\"浅拷贝对象\"><a href=\"#浅拷贝对象\" class=\"headerlink\" title=\"浅拷贝对象\"></a>浅拷贝对象</h2><p>当拷贝源对象的顶级属性被复制而没有任何引用，并且拷贝源对象存在一个值为对象的属性，被复制为一个引用时，那么我说这个对象被浅拷贝。如果拷贝源对象的属性值是对象的引用，则只将该引用值复制到目标对象。 浅层复制将复制顶级属性，但是嵌套对象将在原始（源）对象和副本（目标）对象之间是共享。</p>\n<h3 id=\"使用-Object-assign-方法\"><a href=\"#使用-Object-assign-方法\" class=\"headerlink\" title=\"使用 Object.assign() 方法\"></a>使用 Object.assign() 方法</h3><p>Object.assign() 方法用于将从一个或多个源对象中的所有可枚举的属性值复制到目标对象。</p>\n<p>let obj = {<br>    a: 1,<br>    b: 2,<br>};<br>let objCopy = Object.assign({}, obj);<br>console.log(objCopy);<br>// Result - { a: 1, b: 2 }</p>\n<p>到目前为止。我们创建了一个 <code>obj</code> 的副本。让我们看看是否存在不变性：</p>\n<p>let obj = {<br>    a: 1,<br>    b: 2,<br>};<br>let objCopy = Object.assign({}, obj);</p>\n<p>console.log(objCopy); // result - { a: 1, b: 2 }<br>objCopy.b = 89;<br>console.log(objCopy); // result - { a: 1, b: 89 }<br>console.log(obj); // result - { a: 1, b: 2 }</p>\n<p>在上面的代码中，我们将 <code>objCopy</code> 对象中的属性 <code>b</code> 的值更改为 <code>89</code> ，并且当我们在控制台中 log 修改后的 <code>objCopy</code> 对象时，这些更改仅应用于 <code>objCopy</code> 。我们可以看到最后一行代码检查 <code>obj</code> 对象并没有被修改。这意味着我们已经成功地创建了拷贝源对象的副本，而且它没有引用。</p>\n<h3 id=\"Object-assign-的陷阱\"><a href=\"#Object-assign-的陷阱\" class=\"headerlink\" title=\"Object.assign()的陷阱\"></a>Object.assign()的陷阱</h3><p>不要高兴的太早！ 虽然我们成功地创建了一个副本，一切似乎都正常工作，记得我们讨论了浅拷贝？ 我们来看看这个例子：</p>\n<p>let obj = {<br>    a: 1,<br>    b: {<br>        c: 2,<br>    },<br>}<br>let newObj = Object.assign({}, obj);<br>console.log(newObj); // { a: 1, b: { c: 2} }</p>\n<p>obj.a = 10;<br>console.log(obj); // { a: 10, b: { c: 2} }<br>console.log(newObj); // { a: 1, b: { c: 2} }</p>\n<p>newObj.a = 20;<br>console.log(obj); // { a: 10, b: { c: 2} }<br>console.log(newObj); // { a: 20, b: { c: 2} }</p>\n<p>newObj.b.c = 30;<br>console.log(obj); // { a: 10, b: { c: 30} }<br>console.log(newObj); // { a: 20, b: { c: 30} }</p>\n<p>// Note: newObj.b.c = 30; Read why..</p>\n<h3 id=\"obj-b-c-30\"><a href=\"#obj-b-c-30\" class=\"headerlink\" title=\"obj.b.c = 30 ?\"></a>obj.b.c = 30 ?</h3><p>这就是 <code>Object.assign()</code> 的陷阱。<code>Object.assign</code> 只是浅拷贝。 <code>newObj.b</code> 和 <code>obj.b</code> 都引用同一个对象，没有单独拷贝，而是复制了对该对象的引用。任何对对象属性的更改都适用于使用该对象的所有引用。我们如何解决这个问题？继续阅读…我们会在下一节给出修复方案。 注意：原型链上的属性和不可枚举的属性不能复制。 看这里：</p>\n<p>let someObj = {<br>    a: 2,<br>}</p>\n<p>let obj = Object.create(someObj, {<br>    b: {<br>        value: 2,<br>    },<br>    c: {<br>        value: 3,<br>        enumerable: true,<br>    },<br>});</p>\n<p>let objCopy = Object.assign({}, obj);<br>console.log(objCopy); // { c: 3 }</p>\n<ul>\n<li>  <code>someObj</code> 是在 <code>obj</code> 的原型链，所以它不会被复制。</li>\n<li>  <code>property b</code> 是不可枚举属性。</li>\n<li>  <code>property c</code> 具有 可枚举(enumerable) 属性描述符，所以它可以枚举。 这就是为什么它会被复制。</li>\n</ul>\n<h2 id=\"深度拷贝对象\"><a href=\"#深度拷贝对象\" class=\"headerlink\" title=\"深度拷贝对象\"></a>深度拷贝对象</h2><p>深度拷贝将拷贝遇到的每个对象。副本和原始对象不会共享任何东西，所以它将是原件的副本。以下是使用 <code>Object.assign()</code> 遇到问题的修复方案。让我们探索一下。</p>\n<h3 id=\"使用-JSON-parse-JSON-stringify-object\"><a href=\"#使用-JSON-parse-JSON-stringify-object\" class=\"headerlink\" title=\"使用 JSON.parse(JSON.stringify(object));\"></a>使用 JSON.parse(JSON.stringify(object));</h3><p>这可以修复了我们之前提出的问题。现在 <code>newObj.b</code> 有一个副本而不是一个引用！这是深度拷贝对象的一种方式。 这里有一个例子：</p>\n<p>let obj = {<br>    a: 1,<br>    b: {<br>        c: 2,<br>    },<br>}</p>\n<p>let newObj = JSON.parse(JSON.stringify(obj));</p>\n<p>obj.b.c = 20;<br>console.log(obj); // { a: 1, b: { c: 20 } }<br>console.log(newObj); // { a: 1, b: { c: 2 } } (New Object Intact!)</p>\n<p>不可变性: ?</p>\n<h3 id=\"陷阱\"><a href=\"#陷阱\" class=\"headerlink\" title=\"陷阱\"></a>陷阱</h3><p>不幸的是，此方法不能用于复制用户定义的对象方法。 见下文。</p>\n<h2 id=\"复制对象方法\"><a href=\"#复制对象方法\" class=\"headerlink\" title=\"复制对象方法\"></a>复制对象方法</h2><p>方法是一个对象的属性，它是一个函数。在以上的示例中，我们还没有复制对象的方法。现在让我们尝试一下，使用我们学过的方法来创建副本。</p>\n<p>let obj = {<br>    name: ‘scotch.io’,<br>    exec: function exec() {<br>        return true;<br>    },<br>}</p>\n<p>let method1 = Object.assign({}, obj);<br>let method2 = JSON.parse(JSON.stringify(obj));</p>\n<p>console.log(method1); //Object.assign({}, obj)<br>/* result<br>{<br>  exec: function exec() {<br>    return true;<br>  },<br>  name: “scotch.io”<br>}<br>*/</p>\n<p>console.log(method2); // JSON.parse(JSON.stringify(obj))<br>/* result<br>{<br>  name: “scotch.io”<br>}<br>*/</p>\n<p>结果表明，<code>Object.assign()</code> 可以用于复制对象的方法，而使用 <code>JSON.parse(JSON.stringify(obj))</code> 则不行。</p>\n<h2 id=\"复制循环引用对象\"><a href=\"#复制循环引用对象\" class=\"headerlink\" title=\"复制循环引用对象\"></a>复制循环引用对象</h2><p>循环引用对象是具有引用自身属性的对象。让我们使用已学的复制对象的方法来复制一个循环引用对象的副本，看看它是否有效。</p>\n<h3 id=\"使用-JSON-parse-JSON-stringify-object-1\"><a href=\"#使用-JSON-parse-JSON-stringify-object-1\" class=\"headerlink\" title=\"使用 JSON.parse(JSON.stringify(object))\"></a>使用 JSON.parse(JSON.stringify(object))</h3><p>让我们尝试使用 <code>JSON.parse(JSON.stringify(object))</code>：</p>\n<p>// circular object<br>let obj = {<br>    a: ‘a’,<br>    b: {<br>        c: ‘c’,<br>        d: ‘d’,<br>    },<br>}</p>\n<p>obj.c = obj.b;<br>obj.e = obj.a;<br>obj.b.c = obj.c;<br>obj.b.d = obj.b;<br>obj.b.e = obj.b.c;</p>\n<p>let newObj = JSON.parse(JSON.stringify(obj));</p>\n<p>console.log(newObj);</p>\n<p>结果是： <img src=\"http://file.w3cbest.com/file/images/circular-object.jpg\"> 很明显，<code>JSON.parse(JSON.stringify(object))</code> 不能用于复制循环引用对象。</p>\n<h3 id=\"使用-Object-assign\"><a href=\"#使用-Object-assign\" class=\"headerlink\" title=\"使用 Object.assign()\"></a>使用 Object.assign()</h3><p>让我们尝试使用 <code>Object.assign()</code>：</p>\n<p>// circular object<br>let obj = {<br>    a: ‘a’,<br>    b: {<br>        c: ‘c’,<br>        d: ‘d’,<br>    },<br>}</p>\n<p>obj.c = obj.b;<br>obj.e = obj.a;<br>obj.b.c = obj.c;<br>obj.b.d = obj.b;<br>obj.b.e = obj.b.c;</p>\n<p>let newObj2 = Object.assign({}, obj);</p>\n<p>console.log(newObj2);</p>\n<p>结果是： <img src=\"http://file.w3cbest.com/file/images/circular-object-tree.jpg\"> <code>Object.assign()</code> 适用于浅拷贝循环引用对象，但不适用于深度拷贝。随意浏览浏览器控制台上的循环引用对象树。我相信你会发现很多有趣的工作在那里。</p>\n<h2 id=\"使用展开操作符-…\"><a href=\"#使用展开操作符-…\" class=\"headerlink\" title=\"使用展开操作符(…)\"></a>使用展开操作符(…)</h2><p>ES6已经有了用于数组解构赋值的 rest 元素，和实现的数组字面展开的操作符。看一看这里的数组的展开操作符的实现：</p>\n<p>const array = [<br>    “a”,<br>    “c”,<br>    “d”, {<br>        four: 4<br>    },<br>];<br>const newArray = […array];<br>console.log(newArray);<br>// Result<br>// [“a”, “c”, “d”, { four: 4 }]</p>\n<p>对象字面量的展开操作符目前是<a href=\"https://jsbin.com/denadeg/edit?js,console\">ECMAScript 的第 3 阶段提案</a>。对象字面量的展开操作符能将源对象中的可枚举的属性复制到目标对象上。下面的例子展示了在提案被接受后复制一个对象是多么的容易。</p>\n<p>let obj = {<br>    one: 1,<br>    two: 2,<br>}</p>\n<p>let newObj = { …z };</p>\n<p>// { one: 1, two: 2 }</p>\n<p>注意：这将只对浅拷贝有效</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>在 JavaScript 中复制对象可能是相当艰巨的，特别是如果您刚开始使用 JavaScript 并且不了解该语言的方式。希望本文帮助您了解并避免您可能遇到复制对象的陷阱。如果您有任何库或一段代码可以获得更好的结果，欢迎与社区分享。 文章来源：<a href=\"https://scotch.io/bar-talk/copying-objects-in-javascript\">https://scotch.io</a></p>\n","categories":["JavaScript"],"tags":["JSON.parse()","JSON.stringify(object)","Object.assign","writable","不变性","复制循环引用对象","对象拷贝","深度拷贝","解构赋值"]},{"title":"使用JavaScript更新CSS变量","url":"/2018/09/13/%E4%BD%BF%E7%94%A8javascript%E6%9B%B4%E6%96%B0css%E5%8F%98%E9%87%8F/","content":"<p>这是一个CSS变量（正式称为“ CSS自定义属性 ”） html</p>\n<div class=\"mover\"></div>\n\n<p>css</p>\n<p>:root {<br>    –mouse-x: 0px;<br>    –mouse-y: 0px;<br>}</p>\n<p>你可以用它们来设定一个位置： css</p>\n<p>.mover {<br>    left: var(–mouse-x);<br>    top: var(–mouse-y);<br>}</p>\n<p>如果要从JavaScript更新这些值，您需要： js</p>\n<p>let root = document.documentElement;<br>root.addEventListener(“mousemove”, e =&gt; {<br>    root.style.setProperty(‘–mouse-x’, e.clientX + “px”);<br>    root.style.setProperty(‘–mouse-y’, e.clientY + “px”);<br>});</p>\n","categories":["HTML/CSS","JavaScript"],"tags":["javascript","css3"]},{"title":"使用微信开发工具配置SCSS编译","url":"/2020/04/21/%E4%BD%BF%E7%94%A8%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AESCSS%E7%BC%96%E8%AF%91/","content":"<p>使用微信开发工具手写css真的每次都很浪费时间；现在终于可以用scss在微信开发者工具上自编译出wxss了</p>\n<h3 id=\"主要配置流程如下\"><a href=\"#主要配置流程如下\" class=\"headerlink\" title=\"主要配置流程如下\"></a>主要配置流程如下</h3><p>1，下载EasySass插件复制到微信开发者工具，可以在vscode扩展里面找，然后安装，安装后可以在C盘 <code>用户目录/.vscode/extensions</code> 找到下载的扩展包</p>\n<p>2，打开微信开发工具 找到菜单栏 <code>设置 &gt; 扩展设置 &gt; 拓展 &gt; 编辑器自定义扩展 </code>打开扩展文件夹， 将vscode安装的扩展包复制到这里，然后重启微信开发工具，然后找到菜单栏 <code>设置 &gt; 扩展设置 &gt; 拓展 &gt; 编辑器自定义扩展</code> 就能看到扩展文件，点击开启</p>\n<img src=\"http://file.w3cbest.com/file/images/20210421105100.png\">\n\n<img src=\"http://file.w3cbest.com/file/images/20210421105148.png\">\n\n<p>3，配置编辑器，找到菜单栏 <code>设置 &gt; 扩展设置 &gt; 编辑器 &gt; 更多及工作区设置</code> 进入设置页面，点击扩展 找到 <code>EasySass configuration</code> 看到 <code>formats</code> 在 <code>setting.json</code> 中编辑进入后就会看到生成的配置信息，将.css改为.wxss,如果不想要压缩版可删除</p>\n<img src=\"http://file.w3cbest.com/file/images/20210421105431.png\">\n\n<img src=\"http://file.w3cbest.com/file/images/20210421105501.png\">\n\n<img src=\"http://file.w3cbest.com/file/images/20210421105528.png\">\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;easysass.formats&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &quot;format&quot;: &quot;expanded&quot;,</span><br><span class=\"line\">    &quot;extension&quot;: &quot;.css&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &quot;format&quot;: &quot;compressed&quot;,</span><br><span class=\"line\">    &quot;extension&quot;: &quot;.min.css&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;easysass.formats&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &quot;format&quot;: &quot;expanded&quot;,</span><br><span class=\"line\">    &quot;extension&quot;: &quot;.wxss&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n","tags":["微信开发工具","SCSS编译"]},{"title":"关于JS 数组的一些骚操作","url":"/2019/03/25/%E5%85%B3%E4%BA%8Ejs-%E6%95%B0%E7%BB%84%E9%AA%9A%E6%93%8D%E4%BD%9C/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文主要从应用来讲数组api的一些骚操作; 如一行代码扁平化n维数组、数组去重、求数组最大值、数组求和、排序、对象和数组的转化等； 上面这些应用场景你可以用一行代码实现？</p>\n<h2 id=\"1-扁平化n维数组\"><a href=\"#1-扁平化n维数组\" class=\"headerlink\" title=\"1.扁平化n维数组\"></a>1.扁平化n维数组</h2><h3 id=\"1-终极篇\"><a href=\"#1-终极篇\" class=\"headerlink\" title=\"1.终极篇\"></a>1.终极篇</h3><p>[1,[2,3]].flat(2) //[1,2,3]<br>[1,[2,3,[4,5]].flat(3) //[1,2,3,4,5]<br>[1,[2,3,[4,5]]].toString() //‘1,2,3,4,5’<br>[1[2,3,[4,5[…]].flat(Infinity) //[1,2,3,4…n]</p>\n<p><code>Array.flat(n)</code>是ES10扁平数组的api,n表示维度,n值为Infinity时维度为无限大</p>\n<h3 id=\"2-开始篇\"><a href=\"#2-开始篇\" class=\"headerlink\" title=\"2.开始篇\"></a>2.开始篇</h3><p>function flatten(arr) {<br>    while (arr.some(item =&gt; Array.isArray(item))) {<br>        arr = [].concat(…arr);<br>    }<br>    return arr;<br>}<br>flatten([1, [2, 3]]) //[1,2,3]<br>flatten([1, [2, 3, [4, 5]]) //[1,2,3,4,5]</p>\n<p>实质是利用递归和数组合并方法concat实现扁平</p>\n<h2 id=\"2-去重\"><a href=\"#2-去重\" class=\"headerlink\" title=\"2.去重\"></a>2.去重</h2><h3 id=\"1-终极篇-1\"><a href=\"#1-终极篇-1\" class=\"headerlink\" title=\"1.终极篇\"></a>1.终极篇</h3><p>Array.from(new Set([1,2,3,3,4,4])) //[1,2,3,4]<br>[…new Set([1,2,3,3,4,4])] //[1,2,3,4]</p>\n<p><code>set</code>是ES6新出来的一种一种定义不重复数组的数据类型 <code>Array.from</code>是将类数组转化为数组 <code>...</code>是扩展运算符,将set里面的值转化为字符串</p>\n<h3 id=\"2-开始篇-1\"><a href=\"#2-开始篇-1\" class=\"headerlink\" title=\"2.开始篇\"></a>2.开始篇</h3><p>Array.prototype.distinct = function() {<br>    var arr = this,<br>        result = [],<br>        i,<br>        j,<br>        len = arr.length;<br>    for (i = 0; i &lt; len; i++) {<br>        for (j = i + 1; j &lt; len; j++) {<br>            if (arr[i] === arr[j]) {<br>                j = ++i;<br>            }<br>        }<br>        result.push(arr[i]);<br>    }<br>    return result;<br>}<br>[1, 2, 3, 3, 4, 4].distinct(); //[1,2,3,4]</p>\n<p>取新数组存值,循环两个数组值相比较</p>\n<h2 id=\"3-排序\"><a href=\"#3-排序\" class=\"headerlink\" title=\"3.排序\"></a>3.排序</h2><h3 id=\"1-终极篇-2\"><a href=\"#1-终极篇-2\" class=\"headerlink\" title=\"1.终极篇\"></a>1.终极篇</h3><p>[1,2,3,4].sort((a, b) =&gt; a - b); // [1, 2,3,4],默认是升序<br>[1,2,3,4].sort((a, b) =&gt; b - a); // [4,3,2,1] 降序</p>\n<p><code>sort</code>是js内置的排序方法,参数为一个函数</p>\n<h3 id=\"2-开始篇-2\"><a href=\"#2-开始篇-2\" class=\"headerlink\" title=\"2.开始篇\"></a>2.开始篇</h3><p>冒泡排序:</p>\n<p>Array.prototype.bubleSort = function() {<br>    let arr = this,<br>        len = arr.length;<br>    for (let outer = len; outer &gt;= 2; outer–) {<br>        for (let inner = 0; inner &lt;= outer - 1; inner++) {<br>            if (arr[inner] &gt; arr[inner + 1]) {<br>                //升序<br>                [arr[inner], arr[inner + 1]] = [arr[inner + 1], arr[inner]];<br>                console.log([arr[inner], arr[inner + 1]]);<br>            }<br>        }<br>    }<br>    return arr;<br>}<br>[1, 2, 3, 4].bubleSort() //[1,2,3,4]</p>\n<p>选择排序</p>\n<p>Array.prototype.selectSort = function() {<br>    let arr = this,<br>        len = arr.length;<br>    for (let i = 0, len = arr.length; i &lt; len; i++) {<br>        for (let j = i, len = arr.length; j &lt; len; j++) {<br>            if (arr[i] &gt; arr[j]) {<br>                [arr[i], arr[j]] = [arr[j], arr[i]];<br>            }<br>        }<br>    }<br>    return arr;<br>}<br>[1, 2, 3, 4].selectSort() //[1,2,3,4]</p>\n<h2 id=\"4-最大值\"><a href=\"#4-最大值\" class=\"headerlink\" title=\"4.最大值\"></a>4.最大值</h2><h3 id=\"1-终极篇-3\"><a href=\"#1-终极篇-3\" class=\"headerlink\" title=\"1.终极篇\"></a>1.终极篇</h3><p>Math.max(…[1, 2, 3, 4]) //4<br>Math.max.apply(this, [1, 2, 3, 4]) //4<br>[1, 2, 3, 4].reduce((prev, cur, curIndex, arr) =&gt; {<br>    return Math.max(prev, cur);<br>}, 0) //4</p>\n<p><code>Math.max()</code>是Math对象内置的方法,参数是字符串; <code>reduce</code>是ES5的数组api,参数有函数和默认初始值; 函数有四个参数</p>\n<ul>\n<li>  <code>pre</code>(上一次的返回值)</li>\n<li>  <code>cur</code>(当前值)</li>\n<li>  <code>curIndex</code>(当前值索引)</li>\n<li>  <code>arr</code>(当前数组)</li>\n</ul>\n<h3 id=\"2-开始篇-3\"><a href=\"#2-开始篇-3\" class=\"headerlink\" title=\"2.开始篇\"></a>2.开始篇</h3><p>先排序再取值</p>\n<h2 id=\"5-求和\"><a href=\"#5-求和\" class=\"headerlink\" title=\"5.求和\"></a>5.求和</h2><h3 id=\"1-终极篇-4\"><a href=\"#1-终极篇-4\" class=\"headerlink\" title=\"1.终极篇\"></a>1.终极篇</h3><p>[1, 2, 3, 4].arr.reduce(function(prev, cur){<br>    return prev + cur;<br>}, 0) //10</p>\n<h3 id=\"2-开始篇-4\"><a href=\"#2-开始篇-4\" class=\"headerlink\" title=\"2.开始篇\"></a>2.开始篇</h3><p>function sum(arr) {<br>    var len = arr.length;<br>    if (len == 0) {<br>        return 0;<br>    } else if (len == 1) {<br>        return arr[0];<br>    } else {<br>        return arr[0] + sum(arr.slice(1));<br>    }<br>}<br>sum([1,2,3,4]) //10</p>\n<p>利用slice截取改变数组,再利用递归求和</p>\n<h2 id=\"6-合并\"><a href=\"#6-合并\" class=\"headerlink\" title=\"6.合并\"></a>6.合并</h2><h3 id=\"1-终极篇-5\"><a href=\"#1-终极篇-5\" class=\"headerlink\" title=\"1.终极篇\"></a>1.终极篇</h3><p>[1,2,3,4].concat([5,6]) //[1,2,3,4,5,6]<br>[…[1,2,3,4],…[4,5]] //[1,2,3,4,5,6]<br>[1,2,3,4].push.apply([1,2,3,4],[5,6]) //[1,2,3,4,5,6]</p>\n<h3 id=\"2-开始篇-5\"><a href=\"#2-开始篇-5\" class=\"headerlink\" title=\"2.开始篇\"></a>2.开始篇</h3><p>let arr = [1, 2, 3, 4];<br>[5, 6].map(item =&gt; {<br>    arr.push(item)<br>})<br>//arr值为[1,2,3,4,5,6],注意不能直接return出来,return后只会返回[5,6]</p>\n<h2 id=\"7-判断是否包含值\"><a href=\"#7-判断是否包含值\" class=\"headerlink\" title=\"7.判断是否包含值\"></a>7.判断是否包含值</h2><h3 id=\"1-终极篇-6\"><a href=\"#1-终极篇-6\" class=\"headerlink\" title=\"1.终极篇\"></a>1.终极篇</h3><p>[1,2,3].includes(4) //false<br>[1,2,3].indexOf(4) //-1 如果存在换回索引<br>[1, 2, 3].find((item)=&gt;item===3)) //3 如果数组中无值返回undefined<br>[1, 2, 3].findIndex((item)=&gt;item===3)) //2 如果数组中无值返回-1</p>\n<p><code>includes()</code>,<code>find()</code>,<code>findIndex()</code>是ES6的api</p>\n<h3 id=\"2-开始篇-6\"><a href=\"#2-开始篇-6\" class=\"headerlink\" title=\"2.开始篇\"></a>2.开始篇</h3><p>[1, 2, 3].some(item =&gt;{<br>    return item === 3<br>}) //true 如果不包含返回false</p>\n<h2 id=\"8-类数组转化\"><a href=\"#8-类数组转化\" class=\"headerlink\" title=\"8.类数组转化\"></a>8.类数组转化</h2><h3 id=\"1-终极篇-7\"><a href=\"#1-终极篇-7\" class=\"headerlink\" title=\"1.终极篇\"></a>1.终极篇</h3><p>Array.prototype.slice.call(arguments) //arguments是类数组(伪数组)<br>Array.prototype.slice.apply(arguments)<br>Array.from(arguments)<br>[…arguments]</p>\n<p>类数组:表示有length属性,但是不具备数组的方法 <code>call</code>,<code>apply</code>:是改变<code>slice</code>里面的<code>this</code>指向<code>arguments</code>,所以<code>arguments</code>也可调用数组的方法 <code>Array.from</code>是将类似数组或可迭代对象创建为数组 <code>...</code>是将类数组扩展为字符串,再定义为数组</p>\n<h3 id=\"2-开始篇-7\"><a href=\"#2-开始篇-7\" class=\"headerlink\" title=\"2.开始篇\"></a>2.开始篇</h3><p>Array.prototype.slice = function(start, end) {<br>    var result = new Array();<br>    start = start  0;<br>    end = end  this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键<br>    for (var i = start; i &lt; end; i++) {<br>        result.push(this[i]);<br>    }<br>    return result;<br>}</p>\n<h2 id=\"9-每一项设置值\"><a href=\"#9-每一项设置值\" class=\"headerlink\" title=\"9.每一项设置值\"></a>9.每一项设置值</h2><h3 id=\"1-终极篇-8\"><a href=\"#1-终极篇-8\" class=\"headerlink\" title=\"1.终极篇\"></a>1.终极篇</h3><p>[1,2,3].fill(false) //[false,false,false]</p>\n<p><code>fill</code>是ES6的方法</p>\n<h3 id=\"2-开始篇-8\"><a href=\"#2-开始篇-8\" class=\"headerlink\" title=\"2.开始篇\"></a>2.开始篇</h3><p>[1,2,3].map(() =&gt; 0)</p>\n<h2 id=\"10-每一项是否满足\"><a href=\"#10-每一项是否满足\" class=\"headerlink\" title=\"10.每一项是否满足\"></a>10.每一项是否满足</h2><p>[1,2,3].every(item=&gt;{return item&gt;2}) //false</p>\n<p><code>every</code>是ES5的api,每一项满足返回 true</p>\n<h2 id=\"11-有一项满足\"><a href=\"#11-有一项满足\" class=\"headerlink\" title=\"11.有一项满足\"></a>11.有一项满足</h2><p>[1,2,3].some(item=&gt;{return item&gt;2}) //true</p>\n<p><code>some</code>是ES5的api,有一项满足返回 true</p>\n<h2 id=\"12-过滤数组\"><a href=\"#12-过滤数组\" class=\"headerlink\" title=\"12.过滤数组\"></a>12.过滤数组</h2><p>[1,2,3].filter(item=&gt;{return item&gt;2}) //[3]</p>\n<p><code>filter</code>是ES5的api,返回满足添加的项的数组</p>\n<h2 id=\"13-对象和数组转化\"><a href=\"#13-对象和数组转化\" class=\"headerlink\" title=\"13.对象和数组转化\"></a>13.对象和数组转化</h2><p>Object.keys({name:’张三’,age:14}) //[‘name’,’age’]<br>Object.values({name:’张三’,age:14}) //[‘张三’,14]<br>Object.entries({name:’张三’,age:14}) //[[name,’张三’],[age,14]]<br>Object.fromEntries([name,’张三’],[age,14]) //ES10的api,Chrome不支持 , firebox输出{name:’张三’,age:14}</p>\n<p>文章来源：<a href=\"https://segmentfault.com/a/1190000018549643\">https://segmentfault.com</a></p>\n","categories":["JavaScript"],"tags":["javascript","Array.filter","Array.find","Array.includes","Array.map","javascript教程","Array.some","Array.sort"]},{"title":"写好的JavaScript代码为什么非常重要","url":"/2018/12/07/%E5%86%99%E5%A5%BD%E7%9A%84javascript%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81/","content":"<blockquote>\n<p>本文将通过简单的术语和真实世界的例子解释 JavaScript 中 this 及其用途，并告诉你写出好的代码为何如此重要。</p>\n</blockquote>\n<h3 id=\"this-适合你吗？\"><a href=\"#this-适合你吗？\" class=\"headerlink\" title=\"this 适合你吗？\"></a>this 适合你吗？</h3><p>我看到许多文章在介绍 JavaScript 的 this 时都会假设你学过某种面向对象的编程语言，比如 Java、C++ 或 Python 等。但这篇文章面向的读者是那些不知道 this 是什么的人。我尽量不用任何术语来解释 this 是什么，以及 this 的用法。 也许你一直不敢解开 this 的秘密，因为它看起来挺奇怪也挺吓人的。或许你只在 StackOverflow 说你需要用它的时候（比如在 React 里实现某个功能）才会使用。 在深入介绍 this 之前，我们首先需要理解函数式编程和面向对象编程之间的区别。  </p>\n<h3 id=\"函数式编程-vs-面向对象编程\"><a href=\"#函数式编程-vs-面向对象编程\" class=\"headerlink\" title=\"函数式编程 vs 面向对象编程\"></a>函数式编程 vs 面向对象编程</h3><p>你可能不知道，JavaScript 同时拥有面向对象和函数式的结构，所以你可以自己选择用哪种风格，或者两者都用。 我在很早以前使用 JavaScript 时就喜欢函数式编程，而且会像躲避瘟疫一样避开面向对象编程，因为我不理解面向对象中的关键字，比如 this。我不知道为什么要用 this。似乎没有它我也可以做好所有的工作。 而且我是对的。 在某种意义上 。也许你可以只专注于一种结构并且完全忽略另一种，但这样你只能是一个 JavaScript 开发者。为了解释函数式和面向对象之间的区别，下面我们通过一个数组来举例说明，数组的内容是 Facebook 的好友列表。 假设你要做一个 Web 应用，当用户使用 Facebook 登录你的 Web 应用时，需要显示他们的 Facebook 的好友信息。你需要访问 Facebook 并获得用户的好友数据。这些数据可能是 firstName、lastName、username、numFriends、friendData、birthday 和 lastTenPosts 等信息。</p>\n<p>const data = [<br>{<br>firstName: ‘Bob’,<br>lastName: ‘Ross’,<br>username: ‘bob.ross’,<br>numFriends: 125,<br>birthday: ‘2/23/1985’,<br>lastTenPosts: [‘What a nice day’, ‘I love Kanye West’, …],<br>},<br>…<br>]</p>\n<p>假设上述数据是你通过 Facebook API 获得的。现在需要将其转换成方便你的项目使用的格式。我们假设你想显示的好友信息如下：</p>\n<ul>\n<li>  姓名，格式为`${firstName} ${lastName}`</li>\n<li>  三篇随机文章</li>\n<li>  距离生日的天数</li>\n</ul>\n<p> </p>\n<h3 id=\"函数式方式\"><a href=\"#函数式方式\" class=\"headerlink\" title=\"函数式方式\"></a>函数式方式</h3><p>函数式的方式就是将整个数组或者数组中的某个元素传递给某个函数，然后返回你需要的信息：</p>\n<p>const fullNames = getFullNames(data)<br>// [‘Ross, Bob’, ‘Smith, Joanna’, …]</p>\n<p>首先我们有 Facebook API 返回的原始数据。为了将其转换成需要的格式，首先要将数据传递给一个函数，函数的输出是（或者包含）经过修改的数据，这些数据可以在应用中向用户展示。 我们可以用类似的方法获得随机三篇文章，并且计算距离好友生日的天数。 函数式的方式是：将原始数据传递给一个函数或者多个函数，获得对你的项目有用的数据格式。  </p>\n<h3 id=\"面向对象的方式\"><a href=\"#面向对象的方式\" class=\"headerlink\" title=\"面向对象的方式\"></a>面向对象的方式</h3><p>对于编程初学者和 JavaScript 初学者，面向对象的概念可能有点难以理解。其思想是，我们要将每个好友变成一个对象，这个对象能够生成你一切开发者需要的东西。 你可以创建一个对象，这个对象对应于某个好友，它有 fullName 属性，还有两个函数 getThreeRandomPosts 和 getDaysUntilBirthday。</p>\n<p>function initializeFriend(data) {<br>return {<br>fullName: `${data.firstName} ${data.lastName}`,<br>getThreeRandomPosts: function() {<br>// get three random posts from data.lastTenPosts<br>},<br>getDaysUntilBirthday: function() {<br>// use data.birthday to get the num days until birthday<br>}<br>};<br>}<br>const objectFriends = data.map(initializeFriend)<br>objectFriends[0].getThreeRandomPosts()<br>// Gets three of Bob Ross’s posts</p>\n<p>面向对象的方式就是为数据创建对象，每个对象都有自己的状态，并且包含必要的信息，能够生成需要的数据。  </p>\n<h3 id=\"这跟-this-有什么关系？\"><a href=\"#这跟-this-有什么关系？\" class=\"headerlink\" title=\"这跟 this 有什么关系？\"></a>这跟 this 有什么关系？</h3><p>你也许从来没想过要写上面的 initializeFriend 代码，而且你也许认为，这种代码可能会很有用。但你也注意到，这并不是真正的面向对象。 其原因就是，上面例子中的 getThreeRandomPosts 或 getdaysUntilBirtyday 能够正常工作的原因其实是闭包。因为使用了闭包，它们在 initializeFriend 返回之后依然能访问 data。关于闭包的更多信息可以看看这篇文章：作用域和闭包（<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch5.md%EF%BC%89%E3%80%82\">https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch5.md）。</a> 还有一个方法该怎么处理？我们假设这个方法叫做 greeting。注意方法（与 JavaScript 的对象有关的方法）其实只是一个属性，只不过属性值是函数而已。我们想在 greeting 中实现以下功能：</p>\n<p>function initializeFriend(data) {<br>return {<br>fullName: `${data.firstName} ${data.lastName}`,<br>getThreeRandomPosts: function() {<br>// get three random posts from data.lastTenPosts<br>},<br>getDaysUntilBirthday: function() {<br>// use data.birthday to get the num days until birthday<br>},<br>greeting: function() {<br>return `Hello, this is ${fullName}’s data!`<br>}<br>};<br>}</p>\n<p>这样能正常工作吗？ 不能！ 我们新建的对象能够访问 initializeFriend 中的一切变量，但不能访问这个对象本身的属性或方法。当然你会问，</p>\n<blockquote>\n<p>难道不能在 greeting 中直接用 data.firstName 和 data.lastName 吗？</p>\n</blockquote>\n<p>当然可以。但要是想在 greeting 中加入距离好友生日的天数怎么办？我们最好还是有办法在 greeting 中调用 getDaysUntilBirthday。 这时轮到 this 出场了！  </p>\n<h3 id=\"终于——this-是什么\"><a href=\"#终于——this-是什么\" class=\"headerlink\" title=\"终于——this 是什么\"></a>终于——this 是什么</h3><p>this 在不同的环境中可以指代不同的东西。默认的全局环境中 this 指代的是全局对象（在浏览器中 this 是 window 对象），这没什么太大的用途。而在 this 的规则中具有实用性的是这一条： 如果在对象的方法中使用 this，而该方法在该对象的上下文中调用，那么 this 指代该对象本身。</p>\n<blockquote>\n<p>你会说“在该对象的上下文中调用”……是啥意思？</p>\n</blockquote>\n<p>别着急，我们一会儿就说。 所以，如果我们想从 greeting 中调用 getDaysUntilBirtyday 我们只需要写 this.getDaysUntilBirthday，因为此时的 this 就是对象本身。 附注：不要在全局作用域的普通函数或另一个函数的作用域中使用 this！this 是个面向对象的东西，它只在对象的上下文（或类的上下文）中有意义。 我们利用 this 来重写 initializeFriend：</p>\n<p>function initializeFriend(data) {<br>return {<br>lastTenPosts: data.lastTenPosts,<br>birthday: data.birthday,<br>fullName: `${data.firstName} ${data.lastName}`,<br>getThreeRandomPosts: function() {<br>// get three random posts from this.lastTenPosts<br>},<br>getDaysUntilBirthday: function() {<br>// use this.birthday to get the num days until birthday<br>},<br>greeting: function() {<br>const numDays = this.getDaysUntilBirthday()<br>return `Hello, this is ${this.fullName}’s data! It is ${numDays} until ${this.fullName}’s birthday!`<br>}<br>};<br>}</p>\n<p>现在，在 initializeFriend 执行结束后，该对象需要的一切都位于对象本身的作用域之内了。我们的方法不需要再依赖于闭包，它们只会用到对象本身包含的信息。 好吧，这是 this 的用法之一，但你说过 this 在不同的上下文中有不同的含义。那是什么意思？为什么不一定会指向对象自己？ 有时候，你需要将 this 指向某个特定的东西。一种情况就是事件处理函数。比如我们希望在用户点击好友时打开好友的 Facebook 首页。我们会给对象添加下面的 onClick 方法：</p>\n<p>function initializeFriend(data) {<br>return {<br>lastTenPosts: data.lastTenPosts,<br>birthday: data.birthday,<br>username: data.username,<br>fullName: `${data.firstName} ${data.lastName}`,<br>getThreeRandomPosts: function() {<br>// get three random posts from this.lastTenPosts<br>},<br>getDaysUntilBirthday: function() {<br>// use this.birthday to get the num days until birthday<br>},<br>greeting: function() {<br>const numDays = this.getDaysUntilBirthday()<br>return `Hello, this is ${this.fullName}’s data! It is ${numDays} until ${this.fullName}’s birthday!`<br>},<br>onFriendClick: function() {<br>window.open(`<a href=\"https://facebook.com/$%7Bthis.username%7D/%60\">https://facebook.com/${this.username}\\`</a>)<br>}<br>};<br>}</p>\n<p>注意我们在对象中添加了 username 属性，这样 onFriendClick 就能访问它，从而在新窗口中打开该好友的 Facebook 首页。现在只需要编写 HTML：</p>\n<button id=\"Bob\\_Ross\">\n<!-- A bunch of info associated with Bob Ross -->\n</button>\n\n<p>还有 JavaScript：</p>\n<p>const bobRossObj = initializeFriend(data[0])<br>const bobRossDOMEl = document.getElementById(‘Bob_Ross’)<br>bobRossDOMEl.addEventListener(“onclick”, bobRossObj.onFriendClick)</p>\n<p>在上述代码中，我们给 Bob Ross 创建了一个对象。然后我们拿到了 Bob Ross 对应的 DOM 元素。然后执行 onFriendClick 方法来打开 Bob 的 Facebook 主页。似乎没问题，对吧？ 有问题！ 哪里出错了？ 注意我们调用 onclick 处理程序的代码是 bobRossObj.onFriendClick。看到问题了吗？要是写成这样的话能看出来吗？</p>\n<p>bobRossDOMEl.addEventListener(“onclick”, function() {<br>window.open(`<a href=\"https://facebook.com/$%7Bthis.username%7D/%60\">https://facebook.com/${this.username}\\`</a>)<br>})</p>\n<p>现在看到问题了吗？如果把事件处理程序写成 bobRossObj.onFriendClick，实际上是把 bobRossObj.onFriendClick 上保存的函数拿出来，然后作为参数传递。它不再“依附”在 bobRossObj 上，也就是说，this 不再指向 bobRossObj。它实际指向全局对象，也就是说 this.username 不存在。似乎我们没什么办法了。 轮到绑定上场了！  </p>\n<h3 id=\"明确绑定-this\"><a href=\"#明确绑定-this\" class=\"headerlink\" title=\"明确绑定 this\"></a>明确绑定 this</h3><p>我们需要明确地将 this 绑定到 bobRossObj 上。我们可以通过 bind 实现：</p>\n<p>const bobRossObj = initializeFriend(data[0])<br>const bobRossDOMEl = document.getElementById(‘Bob_Ross’)<br>bobRossObj.onFriendClick = bobRossObj.onFriendClick.bind(bobRossObj)<br>bobRossDOMEl.addEventListener(“onclick”, bobRossObj.onFriendClick)</p>\n<p>之前，this 是按照默认的规则设置的。但使用 bind 之后，我们明确地将 bobRossObj.onFriendClick 中的 this 的值设置为 bobRossObj 对象本身。 到此为止，我们看到了为什么要使用 this，以及为什么要明确地绑定 this。最后我们来介绍一下，this 实际上是箭头函数。  </p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>你也许注意到了箭头函数最近很流行。人们喜欢箭头函数，因为很简洁、很优雅。而且你还知道箭头函数和普通函数有点区别，尽管不太清楚具体区别是什么。 简而言之，两者的区别在于： <strong>在定义箭头函数时，不管 this 指向谁，箭头函数内部的 this 永远指向同一个东西。</strong></p>\n<blockquote>\n<p>嗯……这貌似没什么用……似乎跟普通函数的行为一样啊？</p>\n</blockquote>\n<p>我们通过 initializeFriend 举例说明。假设我们想添加一个名为 greeting 的函数：</p>\n<p>function initializeFriend(data) {<br>return {<br>lastTenPosts: data.lastTenPosts,<br>birthday: data.birthday,<br>username: data.username,<br>fullName: `${data.firstName} ${data.lastName}`,<br>getThreeRandomPosts: function() {<br>// get three random posts from this.lastTenPosts<br>},<br>getDaysUntilBirthday: function() {<br>// use this.birthday to get the num days until birthday<br>},<br>greeting: function() {<br>function getLastPost() {<br>return this.lastTenPosts[0]<br>}<br>const lastPost = getLastPost()<br>return `Hello, this is ${this.fullName}’s data!<br>${this.fullName}’s last post was ${lastPost}.`<br>},<br>onFriendClick: function() {<br>window.open(`<a href=\"https://facebook.com/$%7Bthis.username%7D/%60\">https://facebook.com/${this.username}\\`</a>)<br>}<br>};<br>}</p>\n<p>这样能运行吗？如果不能，怎样修改才能运行？ 答案是不能。因为 getLastPost 没有在对象的上下文中调用，因此getLastPost 中的 this 按照默认规则指向了全局对象。</p>\n<blockquote>\n<p>你说没有“在对象的上下文中调用”……难道它不是从 initializeFriend 返回的内部调用的吗？如果这还不叫“在对象的上下文中调用”，那我就不知道什么才算了。</p>\n</blockquote>\n<p>  我知道“在对象的上下文中调用”这个术语很模糊。也许，判断函数是否“在对象的上下文中调用”的好方法就是检查一遍函数的调用过程，看看是否有个对象“依附”到了函数上。 我们来检查下执行 bobRossObj.onFriendClick() 时的情况。“给我对象 bobRossObj，找到其中的 onFriendClick 然后调用该属性对应的函数”。 我们同样检查下执行 getLastPost() 时的情况。“给我名为 getLastPost 的函数然后执行。”看到了吗？我们根本没有提到对象。 好了，这里有个难题来测试你的理解程度。假设有个函数名为 functionCaller，它的功能就是调用一个函数： functionCaller(fn) { fn() } 如果调用 functionCaller(bobRossObj.onFriendClick) 会怎样？你会认为 onFriendClick 是“在对象的上下文中调用”的吗？this.username有定义吗？ 我们来检查一遍：“给我 bobRosObj 对象然后查找其属性 onFriendClick。取出其中的值（这个值碰巧是个函数），然后将它传递给 functionCaller，取名为 fn。然后，执行名为 fn 的函数。”注意该函数在调用之前已经从 bobRossObj 对象上“脱离”了，因此并不是“在对象的上下文中调用”的，所以 this.username 没有定义。 这时可以用箭头函数解决这个问题：</p>\n<p>function initializeFriend(data) {<br>return {<br>lastTenPosts: data.lastTenPosts,<br>birthday: data.birthday,<br>username: data.username,<br>fullName: `${data.firstName} ${data.lastName}`,<br>getThreeRandomPosts: function() {<br>// get three random posts from this.lastTenPosts<br>},<br>getDaysUntilBirthday: function() {<br>// use this.birthday to get the num days until birthday<br>},<br>greeting: function() {<br>const getLastPost = () =&gt; {<br>return this.lastTenPosts[0]<br>}<br>const lastPost = getLastPost()<br>return `Hello, this is ${this.fullName}’s data!<br>${this.fullName}’s last post was ${lastPost}.`<br>},<br>onFriendClick: function() {<br>window.open(`<a href=\"https://facebook.com/$%7Bthis.username%7D/%60\">https://facebook.com/${this.username}\\`</a>)<br>}<br>};<br>}</p>\n<p>上述代码的规则是： <strong>在定义箭头函数时，不管 this 指向谁，箭头函数内部的 this 永远指向同一个东西。</strong> 箭头函数是在 greeting 中定义的。我们知道，在 greeting 内部的 this 指向对象本身。因此，箭头函数内部的 this 也指向对象本身，这正是我们需要的结果。  </p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>this 有时很不好理解，但它对于开发 JavaScript 应用非常有用。本文当然没能介绍 this 的所有方面。一些没有涉及到的话题包括：</p>\n<ul>\n<li>  call 和 apply；</li>\n<li>  使用 new 时 this 会怎样；</li>\n<li>  在 ES6 的 class 中 this 会怎样。</li>\n</ul>\n<p>我建议你首先问问自己在这些情况下的 this，然后在浏览器中执行代码来检验你的结果。   想学习更多关 于this 的内容，可参考《你不知道的 JS：this 和对象原型》： <a href=\"https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes\">https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes</a> 如果你想测试自己的知识，可参考《你不知道的JS练习：this和对象原型》： <a href=\"https://ydkjs-exercises.com/this-object-prototypes\">https://ydkjs-exercises.com/this-object-prototypes</a> 原文：<a href=\"https://medium.freecodecamp.org/a-deep-dive-into-this-in-javascript-why-its-critical-to-writing-good-code-7dca7eb489e7\">https://medium.freecodecamp.org/a-deep-dive-into-this-in-javascript-why-its-critical-to-writing-good-code-7dca7eb489e7</a></p>\n","categories":["资源","JavaScript"],"tags":["javascript","jquery","this"]},{"title":"分享一款jquery hover3d超酷鼠标滑过动效插件","url":"/2018/10/12/%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%BEjquery-hover3d%E8%B6%85%E9%85%B7%E9%BC%A0%E6%A0%87%E6%BB%91%E8%BF%87%E5%8A%A8%E6%95%88%E6%8F%92%E4%BB%B6/","content":"<p>hover3d.js是一款效果超酷的鼠标滑过图片呈现类似3D效果的jQuery插件。通过该插件可以制作出鼠标滑过图片时图片3D倾斜，旋转的效果，非常有层次感。</p>\n<p>See the Pen <a href=\"https://codepen.io/xianzhiding/pen/dgREab/\">dgREab</a> by xianzhiding (<a href=\"https://codepen.io/xianzhiding\">@xianzhiding</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p><a href=\"https://github.com/ariona/hover3d\">Demo</a></p>\n","categories":["HTML/CSS","资源","JavaScript"],"tags":["css","javascript","css3","jquery","hover3d"]},{"title":"创建CSS Grid 图像库(具有模糊效果和媒体查询)","url":"/2018/12/03/%E5%88%9B%E5%BB%BAcss-grid-%E5%9B%BE%E5%83%8F%E5%BA%93%E5%85%B7%E6%9C%89%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C%E5%92%8C%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/","content":"<p>我们将用一组图片缩略图列表将它们转换为具有模糊悬停效果的响应式CSS Grid图库。我们还将使用一个很棒的CSS技巧来确保触摸屏用户也能体验到这种效果！ 我们将执行以下操作：</p>\n<ul>\n<li>  使用CSS Grid排列缩略图，为我们提供响应式图库。</li>\n<li>  使用CSS filter和transitions创建悬停效果。</li>\n<li>  使用漂亮的CSS媒体查询来确保触摸屏用户仍然可以看到每个缩略图标题，即使没有悬停。</li>\n</ul>\n<h2 id=\"首先要把列表的结构罗列出来\"><a href=\"#首先要把列表的结构罗列出来\" class=\"headerlink\" title=\"首先要把列表的结构罗列出来\"></a>首先要把列表的结构罗列出来</h2><div class=\"grid-container\">\n  <article class=\"location-listing\">\n    <a class=\"location-title\" href=\"#\"></a>\n    <a class=\"location-image\" href=\"#\">\n        <img src=\"\">\n    </a>\n  </article>\n</div>\n\n<h2 id=\"响应式CSS网格\"><a href=\"#响应式CSS网格\" class=\"headerlink\" title=\"响应式CSS网格\"></a>响应式CSS网格</h2><p>只要有几个规则，我们就可以把缩略图变成网格：</p>\n<p>.grid-container {<br>  display: grid;<br>  grid-gap: 1em;<br>  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));<br>}</p>\n<p>这里的简单线条是display:grid;（它将所有子项转换成网格项并加以布局）和grid-gap:1em;（它定义了模块之间的间隔）。 稍微的复杂的是我们定义的grid-template-columns属性的值，它定义了我们的列。你平常可能看到的是类似repeat(3,200px)的内容，它将定义的是三列200px。在这种情况下，我们将使用auto-fill来填充关键字repeat()，然后使用了一些值。这给了我们尽可能多的列，最小为300px，最大为1fr，将适合网格容器。 调整浏览器窗口大小，看看它是如何运行的！</p>\n<h3 id=\"你需要补充的一个细节：\"><a href=\"#你需要补充的一个细节：\" class=\"headerlink\" title=\"你需要补充的一个细节：\"></a>你需要补充的一个细节：</h3><p>img {<br>  width: 100%;<br>  height: auto;<br>  vertical-align: middle;<br>}</p>\n<h3 id=\"悬停效果\"><a href=\"#悬停效果\" class=\"headerlink\" title=\"悬停效果\"></a>悬停效果</h3><p>我们将使用标题作为缩略图的叠加层，在悬停时显示它们。我们还将为悬停的图像提供红色效果，并使其略微模糊，以帮助覆盖文本的可读性。</p>\n<h3 id=\"覆盖标题\"><a href=\"#覆盖标题\" class=\"headerlink\" title=\"覆盖标题\"></a>覆盖标题</h3><p>要叠加标题，我们需要定位它，所以我们首先要将<article>设置position: relative;和标题position: absolute;。我们将其背景填充为红色背景：</p>\n<p>.location-listing {<br>  position: relative;<br>}</p>\n<p>.location-title {<br>  position: absolute;<br>  top: 0;<br>  left: 0;<br>  height: 100%;<br>  width: 100%;<br>  background: rgba(90, 0, 10, 0.4);<br>}</p>\n<p>已经很好的显示了<img src=\"http://file.w3cbest.com/file/images/columns.gif\"></p>\n<h3 id=\"标题的风格\"><a href=\"#标题的风格\" class=\"headerlink\" title=\"标题的风格\"></a>标题的风格</h3><p>一些印刷样式将改善我们的标题的外观，并且三行flexbox魔术将集中为我们对齐：</p>\n<p>.location-title {<br>  position: absolute;<br>  top: 0;<br>  left: 0;<br>  height: 100%;<br>  width: 100%;<br>  background: rgba(90, 0, 10, 0.4);</p>\n<p>  color: white;<br>  font-size: 1.5em;<br>  font-weight: bold;<br>  text-decoration: none;</p>\n<p>  display: flex;<br>  align-items: center;<br>  justify-content: center;<br>}</p>\n<p>好多了： <img src=\"http://file.w3cbest.com/file/images/align-items.gif\"></p>\n<h3 id=\"隐藏标题\"><a href=\"#隐藏标题\" class=\"headerlink\" title=\"隐藏标题\"></a>隐藏标题</h3><p>现在让我们通过设置它的不透明度隐藏标题，这样我们可以在悬停时看到它。.location-title应该这样做：</p>\n<p>opacity: 0;<br>transition: opacity .5s;</p>\n<p>在这里，我们还设置了一个transition规则，以便当我们将不透明度恢复时，它将有0.5秒的延时过程。我们现在将hover悬停时不透明度设置为1</p>\n<p>.location-listing:hover .location-title {<br>  opacity: 1;<br>}</p>\n<p>到这里我们标题悬停效果已经完美实现了： <img src=\"http://file.w3cbest.com/file/images/transition.jpg\"></p>\n<h3 id=\"模糊效果\"><a href=\"#模糊效果\" class=\"headerlink\" title=\"模糊效果\"></a>模糊效果</h3><p>我们已经创造了一个漂亮的悬停效果，接下来为图像添加模糊滤镜。首先将模糊滤镜设置为正常状态，以便为我们提供一些过渡。然后我们会为悬停状态模糊设置为2px（这里你可以根据你的意愿设置，但我认为2px是一个很棒的视觉效果）：</p>\n<p>.location-image img {<br>  filter: blur(0px);<br>  transition: filter 0.3s ease-in;<br>}</p>\n<p>.location-listing:hover .location-image img {<br>  filter: blur(2px);<br>}</p>\n<p>这就是效果了： <img src=\"http://file.w3cbest.com/file/images/filter.jpg\"></p>\n<h3 id=\"需要注意的两件事：\"><a href=\"#需要注意的两件事：\" class=\"headerlink\" title=\"需要注意的两件事：\"></a>需要注意的两件事：</h3><ul>\n<li>  标题已经消失，因为浏览器现在正在顶部呈现模糊的图形。</li>\n<li>  模糊效果看起来不错，但它也有边缘模糊效果。(可以把它去掉)</li>\n</ul>\n<p>因为层级的关系标题被遮住了把.location-title设置z-index:1 把边缘模糊去掉，首先我们对图像进行缩放，使其稍微大一些，然后对图像容器（.location-list）设置overflow: hidden;以便当较大的图像模糊时，有效地裁剪其边缘。下面是两个元素已设置的属性：</p>\n<p>.location-image img {<br>  filter: blur(0px);<br>  transition: filter 0.3s ease-in;<br>  transform: scale(1.1);<br>}</p>\n<p>.location-listing {<br>  position: relative;<br>  overflow: hidden;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/transform-scale.jpg\"></p>\n<h2 id=\"触摸屏问题\"><a href=\"#触摸屏问题\" class=\"headerlink\" title=\"触摸屏问题\"></a>触摸屏问题</h2><p>有些网页应用都有很多悬停效果，而且是都被隐藏，在不触发的时候是看不到的(大量的平板电脑和智能手机不能模仿悬停“按下”动作)，这是不容易访问的。 幸运的是，CSS有一些非常有用的交互媒体查询可以帮助我们（他们也享受相当不错的浏览器支持）。这些查询将检测浏览器的输入机制 - 指针设备质量，悬停能力以及一些其他特殊定义 - 因此我们可以相当准确地确定是否在触摸屏设备上查看我们的缩略图。 以此媒体查询为例（它完全符合我们的预期）</p>\n<p>@media (hover: none) { }</p>\n<p>在这些花括号中，我们将我们想要应用的任何样式应用于无法处理的浏览器:hover。我们将声明对于悬停不可能或至少不方便的设备，缩略图图像将始终模糊，标题将始终可见：</p>\n<p>@media (hover: none) {<br>  .location-title {<br>     opacity: 1;<br>  }<br>  .location-image img {<br>    filter: blur(2px);<br>  }<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/screen-devices.jpg\"> 注意：如上所述，对此的支持非常合理，但有关交互媒体查询实施的讨论仍在进行中。这个规范很可能会改变或删除部分。</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/oQVGaa/\">创建CSS Grid 图像库</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n","categories":["HTML/CSS"],"tags":["filter","css3","transforms","translate","grid-template-columns","grid-gap"]},{"title":"利用JavaScript实现密码可见性切换（显示和隐藏）","url":"/2018/10/03/%E5%88%A9%E7%94%A8javascript%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%87%E6%8D%A2%EF%BC%88%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F%EF%BC%89/","content":"<p>对于密码的可见性切换经常会在移动端见到，由于移动端输入体验不是很好，经常会输入密码的时候出现错误，反正我是有这样的体验，所以衍生出了密码的显示和隐藏的切换，那么在pc端会出现这种问题吗？答案是会的，特别是在重置密码的时候要输入两次，就会出现输入错误的问题，我是程序员我的解决方法是查看源码。把input的type类型的password改变成text或置空，就显示密码了，这是我经常使用的惯例，所以你在使用浏览器的时候千万不要让浏览器记住密码，很危险的。</p>\n<p>那么我们的用户是否也可以看到密码呢，答案是有的，实现原理就是通过js将input 标签 type=”password”改变为type=”text”，在 Chrome、FireFox 等浏览器中通过修改 input 标签的 type 属性轻松实现该效果，但是 IE 下就会报错。如果你需要兼容IE，就必须考虑其他方案。下面看例子：</p>\n<h2 id=\"例子一：用复选框作为介质来切换显示隐藏\"><a href=\"#例子一：用复选框作为介质来切换显示隐藏\" class=\"headerlink\" title=\"例子一：用复选框作为介质来切换显示隐藏\"></a>例子一：用复选框作为介质来切换显示隐藏</h2><p>最常见的实现是位于密码输入框下的复选框和标签。切换复选框后，密码变为可见。</p>\n<iframe src=\"https://code.hcharts.cn/temp/ZBh1b7/share/result,js,html,css\" width=\"100%\" height=\"450\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe>\n\n<p>对于上面提到的安全问题，我已经在密码输入上禁用了自动完成功能。交互非常简单，JavaScript将监听复选框输入的更改。切换后，密码字段将从type属性更改password为text。</p>\n<p>在功能方面，这种实现很好。但是有个问题是，“显示密码”复选框文本乍一看就像登录表单更常见的“记住我”选项，不可取。</p>\n<h2 id=\"例子二：用一个按钮实现\"><a href=\"#例子二：用一个按钮实现\" class=\"headerlink\" title=\"例子二：用一个按钮实现\"></a>例子二：用一个按钮实现</h2><p>实现密码可见性切换的另一种方法是在密码字段本身上设置一个按钮。你也可以用图标来表示。</p>\n<iframe src=\"https://code.hcharts.cn/temp/FeMwrG/share/result,js,html,css\" width=\"100%\" height=\"450\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe>\n\n<p>实现与复选框示例没有太大差别，主要区别在于文本根据密码字段的状态而变化。</p>\n<p>我更喜欢这种方法的原因是因为像按钮的作用，至少它看起来不像是“记住我”复选框，它仍然有相同的安全问题。</p>\n","categories":["HTML/CSS","资源","JavaScript"],"tags":["javascript","password","密码可见性","显示隐藏"]},{"title":"利用jQuery实现简单的数据双向绑定","url":"/2018/09/14/%E5%88%A9%E7%94%A8jquery%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/","content":"<p>在软件开发中，MVC或者MVVM是经常被用到的设计模式。在web前端开发中，之前我们需要自己写许多代码来完成这项功能。而现在有许多优秀的类库可以帮我们实现这个功能。 许多优秀的前端框架都提供了强大的数据双向绑定的功能。比如 Vue.js， Angular.js， KnockoutJS。 如果我们在一些小型的项目中，只是希望某个功能区域有数据双向绑定的功能，是不是就非得使用这么重的框架呢？事实上，我们可以用jQuery来实现一个简单的数据双向绑定的功能。 从头开始做一个数据双向绑定并不是那么复杂。简单来说，需要实现下面三点： 我们需要指定View中的UI元素和数据中的属性对应关系。 我们需要监听View中的UI元素内容以及数据的变化。 最后就是我们需要把变化通知到所有与之绑定的数据或者UI元素。 Javascript Code</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function DataBinder (objectId) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 使用jQuery空对象作为监听对象</span><br><span class=\"line\">  var pubSub &#x3D; jQuery(&#123;&#125;);</span><br><span class=\"line\">  &#x2F;&#x2F;</span><br><span class=\"line\">  var dataAttr &#x3D; &#39;bind-&#39; + objectId;</span><br><span class=\"line\">  var message &#x3D; objectId + &#39;:change&#39;;</span><br><span class=\"line\">  &#x2F;&#x2F; 监听dom中所有元素的 data-binding 属性变化。并由pubSub来处理。</span><br><span class=\"line\">  $(document).on(&#39;input change&#39;, &#39;[data-&#39; + dataAttr + &#39;]&#39;, function (event) &#123;</span><br><span class=\"line\">    var $ele &#x3D; $(this);</span><br><span class=\"line\">    console.log(&#39;$ele&#39;, $ele);</span><br><span class=\"line\">    pubSub.trigger(message, [$ele.data(dataAttr), $ele.val()]);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  &#x2F;&#x2F; pubSub把数据变化推送给所有与之绑定的页面元素</span><br><span class=\"line\">  pubSub.on(message, function (event, proName, newValue) &#123;</span><br><span class=\"line\">    $(&#39;[data-&#39; + dataAttr + &#39;&#x3D;&#39; + proName + &#39;]&#39;).each(function () &#123;</span><br><span class=\"line\">      var $ele &#x3D; $(this);</span><br><span class=\"line\">      if($ele.is(&#39;input, textarea, select&#39;)) &#123;</span><br><span class=\"line\">        $ele.val(newValue);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        $ele.html(newValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return pubSub;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function User(uid) &#123;</span><br><span class=\"line\">    var binder &#x3D; new DataBinder(uid);</span><br><span class=\"line\">    var user &#x3D; &#123;</span><br><span class=\"line\">      attributes: &#123;&#125;,</span><br><span class=\"line\">      set: function (attrName, val) &#123;</span><br><span class=\"line\">        this.attributes[attrName] &#x3D; val;</span><br><span class=\"line\">        binder.trigger(uid + &#39;:change&#39;, [attrName, val, this]);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      get: function (attrName) &#123;</span><br><span class=\"line\">        return this.attributes[attrName];</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      _binder: binder</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  return user;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用的时候，用uid与之关联。 Javascript Code</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var user &#x3D; new User(&#39;user&#39;);</span><br><span class=\"line\">$(&#39;#btnSet&#39;).bind(&#39;click&#39;, function (event) &#123;</span><br><span class=\"line\">  user.set(&#39;name&#39;, &#39;Liuyuan211&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class=\"line\">&lt;label&gt;用户名：&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;text&quot; data-bind-user&#x3D;&quot;name&quot; &#x2F;&gt;&lt;span data-bind-user&#x3D;&quot;name&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class=\"line\">&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btnSet&quot; value&#x3D;&quot;Set&quot; &#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>该例子中，uid就是 data-bind-user=”name” 中的 user ，绑定的页面元素会自动与user对应的属性关联。</p>\n","categories":["JavaScript"],"tags":["javascript","jquery","数据双向绑定"]},{"title":"前端缓存技术","url":"/2021/08/25/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/","content":"<p>思路：</p>\n<p>1、当页面第一次加载先判断本地储存中有没有旧数据  //储存数据格式{time:Date.now(), data}<br>2、没有旧数据直接发送请求，并将数据储存本地<br>3、有旧数据并且数据没有过期，就使用本地储存的旧数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">init()&#123;</span><br><span class=\"line\">    &lt;!-- 1,获取本地数据 --&gt;</span><br><span class=\"line\">    const getData &#x3D; sessionStorage.getItem(&#39;key&#39;);</span><br><span class=\"line\">    &lt;!-- 2,判断数据是否存在 --&gt;</span><br><span class=\"line\">    if(!getData)&#123;</span><br><span class=\"line\">        this.getData()</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        &lt;!-- 定义过期时间 (如:10s) --&gt;</span><br><span class=\"line\">        if(Date.new() - getData.time &gt; 1000*10)&#123;</span><br><span class=\"line\">            &lt;!-- 如果时间超过过期时间 重新发送请求 --&gt;</span><br><span class=\"line\">            this.getData()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            &lt;!-- 如果时间未超过过期时间 使用本地储存数据 --&gt;</span><br><span class=\"line\">            this.render(getData.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">getData()&#123;</span><br><span class=\"line\">    &lt;!-- 没有旧数据直接发送请求 --&gt;</span><br><span class=\"line\">    request(&#39;url&#39;).then(data&#x3D;&gt;&#123;</span><br><span class=\"line\">        &lt;!-- 并将数据储存本地 --&gt;</span><br><span class=\"line\">        sessionStorage.setItem(&#39;key&#39;,&#123;time: Date.new(), data&#125;);</span><br><span class=\"line\">        this.render(data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">render(data)&#123;</span><br><span class=\"line\">    &lt;!-- 这里是数据展示 --&gt;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","tags":["缓存"]},{"title":"表单验证的最简单方法","url":"/2018/09/13/%E5%90%91%E8%A1%A8%E5%8D%95%E6%B7%BB%E5%8A%A0%E9%AA%8C%E8%AF%81%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/","content":"<p>向HTML表单添加验证将确保用户以正确的格式准确地输入数据。在过去，验证表单输入需要使用JavaScript插件，但是现在大多数浏览器都有可以处理大部分验证的内置解决方案。 在本教程中，我们将向您展示如何仅使用本地HTML输入属性向表单添加验证规则。 项目概览 为了演示创建验证规则的过程，我们准备了一个简单的HTML注册表单Bootstrap 4。你可以点击下面的图片来打开一个现场演示。 布局 HTML 我们的设计包括一个带有两个输入字段和一个提交按钮的引导表单。在本例中，我们使用了3种不同类型的输入字段-文本输入、密码输入和电子邮件输入。</p>\n<div class=\"registration-form\">\n<form>\n<h3 class=\"text-center\">Create your account</h3>\n<div class=\"form-group\">\n<input class=\"form-control item\" type=\"text\" name=\"username\" maxlength=\"15\" minlength=\"4\" pattern=\"^\\[a-zA-Z0-9\\_.-\\]\\*$\" id=\"username\" placeholder=\"Username\" required>\n</div>\n<div class=\"form-group\">\n<input class=\"form-control item\" type=\"password\" name=\"password\" minlength=\"6\" id=\"password\" placeholder=\"Password\" required>\n</div>\n<div class=\"form-group\">\n<input class=\"form-control item\" type=\"email\" name=\"email\" id=\"email\" placeholder=\"Email\" required>\n</div>\n<div class=\"form-group\">\n<button class=\"btn btn-primary btn-block create-account\" type=\"submit\">Create Account</button>\n</div>\n</form>\n</div>\n\n<p>CSS 我们还添加了一些基本的CSS样式，以使表单更加简单。</p>\n<p>html {<br>background-color:#214c84;<br>background-blend-mode:overlay;<br>display:flex;<br>align-items:center;<br>justify-content:center;<br>height:100%;<br>}</p>\n<p>body {<br>background-color:transparent;<br>}</p>\n<p>.registration-form {<br>padding:50px 0;<br>}</p>\n<p>.registration-form form {<br>max-width:800px;<br>padding:50px 70px;<br>border-radius:10px;<br>box-shadow:4px 4px 15px rgba(0, 0, 0, 0.2);<br>background-color:#fff;<br>}</p>\n<p>.registration-form form h3 {<br>font-weight:bold;<br>margin-bottom:30px;<br>}</p>\n<p>.registration-form .item {<br>border-radius:10px;<br>margin-bottom:25px;<br>padding:10px 20px;<br>}</p>\n<p>.registration-form .create-account {<br>border-radius:30px;<br>padding:10px 20px;<br>font-size:18px;<br>font-weight:bold;<br>background-color:#3f93ff;<br>border:none;<br>color:white;<br>margin-top:20px;<br>}</p>\n<p>@media (max-width: 576px) {<br>.registration-form form {<br>padding:50px 20px;<br>}<br>}</p>\n<p>验证类型 HTML 5提供了一种使用输入属性进行内联验证的好方法。有大量的属性可用，我们将只看一些最常见的。要获得完整的列表，您可以访问这个优秀的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input\">MDN指南</a>. required 此属性指定输入字段不能为空。它要求用户在提交表单之前输入一些内容。</p>\n<input class=\"form-control item\" type=\"email\" name=\"email\" id=\"email\" placeholder=\"Email\" required>\n\n<p>maxlength 和 minlength 指定用户可以在输入字段中输入的最大/最小符号数。这在密码字段中尤其有用，因为更长的密码意味着更安全的密码。</p>\n<input class=\"form-control item\" type=\"password\" name=\"password\" minlength=\"6\" id=\"password\" placeholder=\"Password\" required>\n\n<p>pattern 指定必须匹配以传递输入数据的正则表达式。它可以与以下输入类型一起使用：文本、搜索、url、电子邮件和密码。</p>\n<input class=\"form-control item\" type=\"text\" name=\"username\" maxlength=\"15\" minlength=\"4\" pattern=\"^\\[a-zA-Z0-9\\_.-\\]\\*$\" id=\"username\" placeholder=\"Username\" required>","categories":["HTML/CSS"],"tags":["css3","html5","表单验证"]},{"title":"大部分教程不会告诉你的12个JS技巧","url":"/2019/04/16/%E5%A4%A7%E9%83%A8%E5%88%86%E6%95%99%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%91%8A%E8%AF%89%E4%BD%A0%E7%9A%8412%E4%B8%AAJS%E6%8A%80%E5%B7%A7/","content":"<h2 id=\"1-过滤唯一值\"><a href=\"#1-过滤唯一值\" class=\"headerlink\" title=\"1. 过滤唯一值\"></a>1. 过滤唯一值</h2><p>ES6 引入了 Set 对象和延展（spread）语法…，我们可以用它们来创建一个只包含唯一值的数组。</p>\n<p>const array = [1, 1, 2, 3, 5, 5, 1]<br>const uniqueArray = […new Set(array)];<br>console.log(uniqueArray); // Result: [1, 2, 3, 5]</p>\n<p>在 ES6 之前，获得同样的数组需要更多的代码！ 这个技巧可以支持包含原始类型的数组：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>string</code> 和 number</p>\n<span id=\"more\"></span>\n<p>。但如果你的数组包含了对象、函数或其他嵌套数组，就不能使用这种方法了。</p>\n<h2 id=\"2-在循环中缓存数组长度\"><a href=\"#2-在循环中缓存数组长度\" class=\"headerlink\" title=\"2. 在循环中缓存数组长度\"></a>2. 在循环中缓存数组长度</h2><p>在我们学习使用 for 循环时，一般建议使用这种结构：</p>\n<p>for (let i = 0; i &lt; array.length; i++) {<br>    console.log(i);<br>}</p>\n<p>在使用这种方式时，<code>for</code> 循环的每次迭代都会重复计算数组长度。 有时候这个会很有用，但在大多数情况下，如果能够缓存数组的长度会更好，这样只需要计算一次就够了。我们可以把数组长度复制给一个叫作 <code>length</code> 的变量，例如：</p>\n<p>for (let i = 0, length = array.length; i &lt; length; i++) {<br>    console.log(i);<br>}</p>\n<p>这段代码和上面的差不多，但从性能方面来看，即使数组变得很大，也不需要花费额外的运行时重复计算 <code>array.length</code>。</p>\n<h2 id=\"3-短路求值\"><a href=\"#3-短路求值\" class=\"headerlink\" title=\"3. 短路求值\"></a>3. 短路求值</h2><p>使用三元运算符可以很快地写出条件语句，例如：</p>\n<p>x &gt; 100 ? ‘Above 100’ : ‘Below 100’;<br>x &gt; 100 ? (x &gt; 200 ? ‘Above 200’ : ‘Between 100-200’) : ‘Below 100’;</p>\n<p>但有时候三元运算符仍然很复杂，我们可以使用逻辑运算符 <code>&amp;&amp;</code> 和来替代，让代码更简洁一些。这种技巧通常被称为“短路求值”。 假设我们想要返回两个或多个选项中的一个，使用 <code>&amp;&amp;</code> 可以返回第一个 <code>false</code>。如果所有操作数的值都是 <code>true</code>，将返回最后一个表达式的值。</p>\n<p>let one = 1, two = 2, three = 3;<br>console.log(one &amp;&amp; two &amp;&amp; three); // Result: 3<br>console.log(0 &amp;&amp; null); // Result: 0</p>\n<p>使用可以返回第一个 <code>true</code>。如果所有操作数的值都是 <code>false</code>，将返回最后一个表达式的值。</p>\n<p>let one = 1, two = 2, three = 3;<br>console.log(one  two  three); // Result: 1<br>console.log(0  null); // Result: null</p>\n<p><strong>示例</strong> 1 假设我们想要返回一个变量的 <code>length</code>，但又不知道变量的类型。 我们可以使用 <code>if/else</code> 来检查 <code>foo</code> 是否是一个可接受的类型，但这样会让代码变得很长。这个时候可以使用短路求值：</p>\n<p>return (foo  []).length;</p>\n<p>对于上述两种情况，如果变量 foo 具有 <code>length</code> 属性，这个属性的值将被返回，否则将返回 0。 <strong>示例</strong> 2 你是否曾经在访问嵌套对象属性时遇到过问题？你可能不知道对象或某个子属性是否存在，所以经常会碰到让你头疼的错误。 假设我们想要访问 <code>this.state</code> 中的一个叫作 data 的属性，但 data 却是 <code>undefined</code> 的。在某些情况下调用 <code>this.state.data</code> 会导致 App 无法运行。为了解决这个问题，我们可以使用条件语句：</p>\n<p>if (this.state.data) {<br>    return this.state.data;<br>} else {<br>    return ‘Fetching Data’;<br>}</p>\n<p>但这样似乎有点啰嗦，而提供了更简洁的解决方案：</p>\n<p>return (this.state.data  ‘Fetching Data’);</p>\n<h2 id=\"4-转换成布尔值\"><a href=\"#4-转换成布尔值\" class=\"headerlink\" title=\"4. 转换成布尔值\"></a>4. 转换成布尔值</h2><p>除了标准的布尔值 true 和 false，在 JavaScript 中，所有的值要么是“真值”要么是“假值”。 在 JavaScript 中，除了 <code>0</code>、<code>“”</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code> 和 <code>false</code> 是假值之外，其他的都是真值。 我们可以使用! 云算法来切换 <code>true</code> 和 <code>false</code>。</p>\n<p>const isTrue = !0;<br>const isFalse = !1;<br>const alsoFalse = !!0;<br>console.log(true); // Result: true<br>console.log(typeof true); // Result: “boolean”</p>\n<h2 id=\"5-转换成字符串\"><a href=\"#5-转换成字符串\" class=\"headerlink\" title=\"5. 转换成字符串\"></a>5. 转换成字符串</h2><p>要快速将数字转换成字符串，我们可以使用 + 运算符，然后在后面跟上一个空字符串。</p>\n<p>const val = 1 + “”;<br>console.log(val); // Result: “1”<br>console.log(typeof val); // Result: “string”</p>\n<h2 id=\"6-转换成数字\"><a href=\"#6-转换成数字\" class=\"headerlink\" title=\"6. 转换成数字\"></a>6. 转换成数字</h2><p>要把字符串转成数字，也可以使用 + 运算符。</p>\n<p>let int = “15”;<br>int = +int;<br>console.log(int); // Result: 15<br>console.log(typeof int); Result: “number”</p>\n<p>也可以使用这种方式将布尔值转成数字，例如：</p>\n<p>console.log(+true); // Return: 1<br>console.log(+false); // Return: 0</p>\n<p>在某些情况下，<code>+</code> 运算符会被解析成连接操作，而不是加法操作。对于这种情况，可以使用两个波浪号：<code>~~</code>。 一个波浪号表示按位取反操作，例如，<code>~15</code> 等于 <code>-16</code>。</p>\n<p>const int = ~~”15”<br>console.log(int); // Result: 15<br>console.log(typeof int); Result: “number”</p>\n<p>使用两个波浪号可以再次取反，因为 <code>-(-n-1)=n+1-1=n</code>，所以<code>~-16</code> 等于 <code>15</code>。</p>\n<h2 id=\"7-快速幂运算\"><a href=\"#7-快速幂运算\" class=\"headerlink\" title=\"7. 快速幂运算\"></a>7. 快速幂运算</h2><p>从 ES7 开始，可以使用 ** 进行幂运算，比使用 <code>Math.power(2,3)</code> 要快得多。</p>\n<p>console.log(2 ** 3); // Result: 8</p>\n<p>但要注意不要把这个运算符于 <code>^</code> 混淆在一起了，<code>^</code> 通常用来表示指数运算，但在 JavaScript 中，<code>^</code> 表示位异或运算。 在 ES7 之前，可以使用位左移运算符<code>&lt;&lt;</code>来表示以 2 为底的幂运算：</p>\n<p>// 以下表达式是等效的:<br>Math.pow(2, n);<br>2 &lt;&lt; (n - 1);<br>2**n;</p>\n<p>例如，<code>2 &lt;&lt; 3 = 16</code> 等同于 <code>2 ** 4 = 16</code>。</p>\n<h2 id=\"8-快速取整\"><a href=\"#8-快速取整\" class=\"headerlink\" title=\"8. 快速取整\"></a>8. 快速取整</h2><p>我们可以使用 <code>Math.floor()</code>、<code>Math.ceil()</code> 或 <code>Math.round()</code> 将浮点数转换成整数，但有另一种更快的方式，即使用位或运算符 。</p>\n<p>console.log(23.9  0); // Result: 23<br>console.log(-23.9  0); // Result: -23</p>\n<p>的实际行为取决于操作数是正数还是负数，所以在使用这个运算符时要确保你知道操作数是正是负。 如果 n 是正数，那么 n0 向下取整，否则就是向上取整。它会移除小数部分，也可以使用~~ 达到同样的效果。 <strong>移除整数尾部数字</strong> 运算符也可以用来移除整数的尾部数字，这样就不需要像下面这样：</p>\n<p>let str = “1553”;<br>Number(str.substring(0, str.length - 1));</p>\n<p>相反，我们可以这样：</p>\n<p>console.log(1553 / 10  0) // Result: 155<br>console.log(1553 / 100  0) // Result: 15<br>console.log(1553 / 1000  0) // Result: 1</p>\n<h2 id=\"9-自动类绑定\"><a href=\"#9-自动类绑定\" class=\"headerlink\" title=\"9. 自动类绑定\"></a>9. 自动类绑定</h2><p>在 ES6 中，我们可以使用箭头进行隐式绑定，这样可以为类的构造器省下一些代码，并跟一些重复出现的表达式说再见，比如 <code>this.myMethod = this.myMethod.bind(this)</code>。</p>\n<p>import React, { Component } from React;<br>export default class App extends Compononent {<br>    constructor(props) {<br>        super(props);<br>        this.state = {};<br>    }<br>    myMethod = () =&gt; {<br>        // This method is bound implicitly!<br>    }<br>    render() {<br>        return (<br>            &lt;&gt;<br>            <div><br>              {this.myMethod()}<br>            </div><br>            &lt;/&gt;<br>        )<br>    }<br>};</p>\n<h2 id=\"10-截取数组\"><a href=\"#10-截取数组\" class=\"headerlink\" title=\"10. 截取数组\"></a>10. 截取数组</h2><p>如果你想从一个数组尾部移除某些元素，可以使用一种比 <code>splice()</code> 更快的方法。 例如，如果你知道初始数组的大小，可以像下面这样重新定义它的 <code>length</code> 属性：</p>\n<p>let array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];<br>array.length = 4;<br>console.log(array); // Result: [0, 1, 2, 3]</p>\n<p>这显然是一种更简洁的解决方案。不过，我发现 <code>slice()</code> 的运行速度更快，所以，如果你更看重速度，可以像下面这样：</p>\n<p>let array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];<br>array = array.slice(0, 4);<br>console.log(array); // Result: [0, 1, 2, 3]</p>\n<h2 id=\"11-获取数组最后的元素\"><a href=\"#11-获取数组最后的元素\" class=\"headerlink\" title=\"11. 获取数组最后的元素\"></a>11. 获取数组最后的元素</h2><p>数组的 <code>slice()</code> 方法可以接受负整数，并从数组的尾部开始获取元素。</p>\n<p>let array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];<br>console.log(array.slice(-1)); // Result: [9]<br>console.log(array.slice(-2)); // Result: [8, 9]<br>console.log(array.slice(-3)); // Result: [7, 8, 9]</p>\n<h2 id=\"12-格式化-JSON\"><a href=\"#12-格式化-JSON\" class=\"headerlink\" title=\"12. 格式化 JSON\"></a>12. 格式化 JSON</h2><p>你之前可能使用过 <code>JSON.stringify</code>，但你是否知道它还可以用来给 JSON 添加缩进？ <code>stringify()</code> 方法可以接受两个额外的参数，一个是函数（形参为 replacer），用于过滤要显示的 JSON，另一个是空格个数（形参为 space）。 space 可以是一个整数，表示空格的个数，也可以是一个字符串（比如’\\t’表示制表符），这样得到的 JSON 更容易阅读。</p>\n<p>console.log(JSON.stringify({ alpha: ‘A’, beta: ‘B’ }, null, ‘\\t’));<br>// Result:<br>// ‘{<br>// “alpha”: A,<br>// “beta”: B<br>// }’</p>\n<p>  英文原文： <a href=\"https://medium.com/@bretcameron/12-javascript-tricks-you-wont-find-in-most-tutorials-a9c9331f169d\">https://medium.com/</a></p>\n","categories":["JavaScript"],"tags":["splice()","ECMAScript教程","Math.ceil()","Math.floor()","JSON.parse()","ECMAScript","JSON.stringify()","Math.round()"]},{"title":"如何为团队定义CSS标准","url":"/2018/12/18/%E5%A6%82%E4%BD%95%E4%B8%BA%E5%9B%A2%E9%98%9F%E5%AE%9A%E4%B9%89css%E6%A0%87%E5%87%86/","content":"<p>“我们都经历过重构app,将每个页面分配给团队中的一个人，实现协同开发，但是页面的结构和样式，每个人都会按照自己的方式来实现，这样就很不方便团队的管理，每个人写的都不一样，代码管理困难，您是否有用于创建和实施SASS项目的建议，或者技巧，博客之类的？”</p>\n<p>我曾经也有过这样的苦恼，试图让一大群开发人员在没有现有代码标准或风格指南的情况下达成共识，现在我觉得你最好的选择就是先构建标准框架。但是这样可能和应用程序的当前部分之间存在巨大差异，但是在后续的开发中，无论是修复错误还是重构，你都可以问“这符合我们的CSS标准吗？”</p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>我们必须了解什么是模块化CSS,以及他的好处是什么？不是自己吹嘘。我的这篇演讲可以有助于开发人员更好的理解它的概念。除此之外，我还会向团队推荐SMACSS书籍。 我很幸运能让一位经理开办一个强制性的读书俱乐部，团队中的每个人都必须阅读一本书并参加会议讨论。</p>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>一旦围绕模块化CSS的优势达成某种程度的共识，就可以将您团队的代码标准整合在一起。您既可以自己编写，也可以采用其他团队的。 我强烈推荐Harry Robert的CSS指南，或许补充了Hugo Giraudel的Sass指南。<br>我一直在为Tempest制作CSS标准文档，我对此感到非常满意。 这是一个很不情愿的工作，试图记录和标准化几年的现有代码实践。 如果我从头开始，我可能会很难切换到BEM命名约定和StyleLint默认格式规则。 不是因为它们是最好的标准，而是因为它们是既定标准，更容易达成一致。</p>\n<h3 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>创建模式库，记录您的模式并将其列在中心位置有两个原因：首先，它可以帮助您的设计人员查看已存在的模式并避免重复。 其次，它可以帮助您的开发人员开始考虑可重用模块与独特页面。</p>\n<p><strong>关于通用的Sass技巧：</strong></p>\n<ul>\n<li>  多使用mixins,【Use mixing instead】;</li>\n<li>  尽可能的使用变量，理想情况下，您几乎没有在Sass文件中看到硬编码的数字。 这样可以更容易地避免幻数，并且在代码审查提供方便。</li>\n<li>  将变量保存在中央_variables.scss文件中，以便于查找，并帮助团队记住Sass中的变量是全局变量。</li>\n<li>  使用main.css文件来负责加载其他Sass文件， 这有助于鼓励您的团队编写更小，更好的范围Sass文件并避免膨胀。</li>\n<li>  理性情况下，每个模块都应该独立，不受其他模块的影响。 如果每个模块都有自己的Sass partial，那么强制执行此操作的一种方法是随机更改部分加载的顺序。如果这个规则被打破，那么你模块是有漏洞的。</li>\n</ul>\n<p>这是一个非常广泛的主题，有许多截然不同的观点。 最重要的是让您的团队同意标准，无论标准是什么。 在一天结束时，你不能阻止一个开发者去做一些非团队标准的事，但是团队有了统一的标准后管理团队的代码规范就容易多了。</p>\n<p>译文：<a href=\"https://spaceninja.com/2017/02/01/team-css-standards/\">How to Define CSS Standards for a Team</a></p>\n","categories":["HTML/CSS","资源"],"tags":["css","css3","mixins","Sass"]},{"title":"如何使用 JavaScript 解析 URL","url":"/2019/02/26/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-javascript-%E8%A7%A3%E6%9E%90-url/","content":"<p>在 Web 开发中，有许多情况需要解析 URL,这篇主要学习如何使用 URL 对象实现这一点。 入门 创建一个以下内容的 HTML 文件，并在浏览器中打开。</p>\n<html>\n    <head>\n        <title>JavaScript URL parsing</title>\n    </head>\n    <body>\n        <script>\n            // Exciting code coming soon!\n        </script>\n    </body>\n</html>\n\n<p>如果你想尝试本文中的任何内容，可以将其放在 <script> 标记中，保存，重新加载页面，看看会发生什么！ 在本教程中，将使用 console.log 来打印所需要的内容，你可以打开开发都工具，来查看内容。</p>\n<h2 id=\"什么是-URL\"><a href=\"#什么是-URL\" class=\"headerlink\" title=\"什么是 URL\"></a>什么是 URL</h2><p>这应该是相当简单的，但让我们说清楚。 URL 是网页的地址，可以在浏览器中输入以获取该网页的唯一内容。 可以在地址栏中看到它： <img src=\"http://file.w3cbest.com/file/images/url-annotated.png\"> URL 是统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 此外，如果你不熟悉基本 URL 路径的工作方式，可以查看<a href=\"https://codetheweb.blog/2017/10/14/links-images-about-file-paths/\">此文</a>学习。 <strong>URL 不都长的一样的</strong></p>\n<blockquote>\n<p>这是一个快速提醒 - 有时 URL 可能非常奇怪，如下： <a href=\"https://example.com:1234/page/?a=b\">https://example.com:1234/page/?a=b</a> <a href=\"http://localhost/page.html\">http://localhost/page.html</a> <a href=\"https://154.23.54.156/page?x=\">https://154.23.54.156/page?x=</a>… file:///Users/username/folder/file.png</p>\n</blockquote>\n<h2 id=\"获取当前URL\"><a href=\"#获取当前URL\" class=\"headerlink\" title=\"获取当前URL\"></a>获取当前URL</h2><p>获取当前页面的 URL 非常简单 - 我们可以使用 <code>window.location</code>。 试着把这个添加到我们形如写的的脚本中:</p>\n<p>console.log(window.location);</p>\n<p>查看浏览器的控制台： <img src=\"http://file.w3cbest.com/file/images/console-log-window-location.png\"> 不是你想要的?这是因为它不返回你在浏览器中看到的实际 URL 地址——它返回的是一个 URL 对象。使用这个 URL 对象，我们可以解析 URL 的不同部分，接下来就会讲到。</p>\n<h2 id=\"创建-URL-对象\"><a href=\"#创建-URL-对象\" class=\"headerlink\" title=\"创建 URL 对象\"></a>创建 URL 对象</h2><p>很快就会看到，可以使用 URL 对象来了解 URL 的不同部分。如果你想对任何 URL 执行此操作，而不仅仅是当前页面的 URL，该怎么办？ 我们可以通过创建一个新的 URL 对象来实现。 以下是如何创建一个：</p>\n<p>var myURL = new URL(‘<a href=\"https://example.com&/#39;\">https://example.com&#39;</a>);</p>\n<p>就这么简单！ 可以打印 <code>myURL</code> 来查看 <code>myURL</code> 的内容：</p>\n<p>console.log(myURL);</p>\n<p><img src=\"http://file.w3cbest.com/file/images/console-log-myurl.png\"> 出于本文的目的，将 myURL 设置为这个值：</p>\n<p>var myURL = new URL(‘<a href=\"https://example.com:4000/folder/page.html?x=y&amp;a=b#section-2&#39;\">https://example.com:4000/folder/page.html?x=y&amp;a=b#section-2&#39;</a>)</p>\n<p>将其复制并粘贴到 <code>&lt;script&gt;</code> 元素中，以便你可以继续操作！ 这个 <code>URL</code> 的某些部分可能不熟悉，因为它们并不总是被使用 - 但你将在下面了解它们，所以不要担心！</p>\n<h2 id=\"URL-对象的结构\"><a href=\"#URL-对象的结构\" class=\"headerlink\" title=\"URL 对象的结构\"></a>URL 对象的结构</h2><p>使用 URL 对象，可以非常轻松地获取 URL 的不同部分。 以下是你可以从 URL 对象获得的所有内容。 对于这些示例，我们将使用上面设置的 <code>myURL</code>。</p>\n<h4 id=\"href\"><a href=\"#href\" class=\"headerlink\" title=\"href\"></a><strong>href</strong></h4><p>URL 的 <code>href</code> 基本上是作为字符串(文本)的整个 URL。如果你想把页面的 URL 作为字符串而不是 URL 对象，你可以写 <code>window.location.href</code>。</p>\n<p>console.log(myURL.href);<br>// Output: “<a href=\"https://example.com:4000/folder/page.html?x=y&amp;a=b#section-2&quot;\">https://example.com:4000/folder/page.html?x=y&amp;a=b#section-2&quot;</a></p>\n<h4 id=\"协议-protocol\"><a href=\"#协议-protocol\" class=\"headerlink\" title=\"协议 (protocol)\"></a><strong>协议 (protocol)</strong></h4><p>URL的协议是一开始的部分。这告诉浏览器如何访问该页面，例如通过 HTTP 或 HTTPS。 但是还有很多其他协议，比如 <strong>ftp</strong>（文件传输协议）和 <strong>ws</strong>（WebSocket）。通常，网站将使用 HTTP 或 HTTPS。 虽然如果你的计算机上打开了文件，你可能正在使用文件协议！ URL对象的协议部分包括<code>：</code>，但不包括 <code>//</code>。 让我们看看 <code>myURL</code> 吧！</p>\n<p>console.log(myURL.protocol);<br>// Output: “https:”</p>\n<h4 id=\"主机名（hostname）\"><a href=\"#主机名（hostname）\" class=\"headerlink\" title=\"主机名（hostname）\"></a><strong>主机名（hostname）</strong></h4><p>主机名是站点的域名。 如果你不熟悉域名，则它是在浏览器中看到的URL的主要部分 - 例如 <code>google.com</code> 或<code>codetheweb.blog</code>。</p>\n<p>console.log(myURL.hostname);<br>// Output: “example.com”</p>\n<h4 id=\"端口（port）\"><a href=\"#端口（port）\" class=\"headerlink\" title=\"端口（port）\"></a><strong>端口（port）</strong></h4><p>URL 的端口号位于域名后面，用冒号分隔（例如 <code>example.com:1234</code>）。 大多数网址都没有端口号，这种情况非常罕见。 端口号是服务器上用于获取数据的特定“通道” - 因此，如果我拥有 <code>example.com</code>，我可以在多个不同的端口上发送不同的数据。 但通常域名默认为一个特定端口，因此不需要端口号。 来看看 <code>myURL</code> 的端口号：</p>\n<p>console.log(myURL.port);<br>// Output: “4000”</p>\n<h4 id=\"主机（host）\"><a href=\"#主机（host）\" class=\"headerlink\" title=\"主机（host）\"></a><strong>主机（host）</strong></h4><p>主机只是<code>主机名</code>和<code>端口</code>放在一起，尝试获取 <code>myURL</code> 的主机：</p>\n<p>console.log(myURL.host);<br>// Output: “example.com:4000”</p>\n<h4 id=\"来源（origin）\"><a href=\"#来源（origin）\" class=\"headerlink\" title=\"来源（origin）\"></a><strong>来源（origin）</strong></h4><p>origin 由 URL 的协议，主机名和端口组成。 它基本上是整个 URL，直到端口号结束，如果没有端口号，到主机名结束。</p>\n<p>console.log(myURL.origin);<br>// Output: “<a href=\"https://example.com:4000&quot;\">https://example.com:4000&quot;</a></p>\n<h4 id=\"pathname（文件名）\"><a href=\"#pathname（文件名）\" class=\"headerlink\" title=\"pathname（文件名）\"></a><strong>pathname（文件名）</strong></h4><p><code>pathname</code> 从域名的最后一个 “/” 开始到 “?” 为止,是文件名部分,如果没有 “?” ,则是从域名最后的一个 “/” 开始到 “#” 为止 , 是文件部分, 如果没有 “?” 和 “#” , 那么从域名后的最后一个 “/” 开始到结束 , 都是文件名部分。</p>\n<p>console.log(myURL.pathname);<br>// Output: “/folder/page.html”</p>\n<h4 id=\"锚点（hash）\"><a href=\"#锚点（hash）\" class=\"headerlink\" title=\"锚点（hash）\"></a>锚点（hash）</h4><p>从 <strong>“#”</strong> 开始到最后，都是锚部分。可以将哈希值添加到 URL 以直接滚动到具有 ID 为该值的哈希值 的元素。 例如，如果你有一个 <code>id</code> 为 <code>hello</code> 的元素，则可以在 URL 中添加 <code>#hello</code> 就可以直接滚动到这个元素的位置上。通过以下方式可以在 URL 获取 <strong>“#”</strong> 后面的值:</p>\n<p>console.log(myURL.hash);<br>// Output: “#section-2”</p>\n<h4 id=\"查询参数-search\"><a href=\"#查询参数-search\" class=\"headerlink\" title=\"查询参数 (search)\"></a><strong>查询参数 (search)</strong></h4><p>你还可以向 URL 添加查询参数。它们是键值对，意味着将特定的<strong>“变量”</strong>设置为特定值。 查询参数的形式为 <code>key=value</code>。 以下是一些 URL 查询参数的示例：</p>\n<p>?key1=value1&amp;key2=value2&amp;key3=value3</p>\n<p>请注意，如果 URL 也有 <strong>锚点（hash</strong>），则查询参数位于 锚点（hash）(也就是 <strong>‘#’</strong>)之前，如我们的示例 URL 中所示：</p>\n<p><a href=\"https://example.com:4000/folder/page.html?x=y&amp;a=b#section-2\">https://example.com:4000/folder/page.html?x=y&amp;a=b#section-2</a></p>\n<p>要将查询参数作为字符串，我们只需使用myURL.search：</p>\n<p>console.log(myURL.search);<br>// Output: “?x=y&amp;a=b”</p>\n<p>但是，如果我们想要拆分它们并获取它们的值，那就有点复杂了。</p>\n<h2 id=\"使用-URLSearchParams-解析查询参数\"><a href=\"#使用-URLSearchParams-解析查询参数\" class=\"headerlink\" title=\"使用 URLSearchParams 解析查询参数\"></a>使用 URLSearchParams 解析查询参数</h2><p>要解析查询参数，我们需要创建一个 <strong>URLSearchParams</strong> 对象，如下所示：</p>\n<p>var searchParams = new URLSearchParams(myURL.search);</p>\n<p>然后可以通过调用 <code>searchParams.get（&#39;key&#39;）</code>来获取特定键的值。 使用我们的示例网址 - 这是原始搜索参数：</p>\n<p>?x=y&amp;a=b</p>\n<p>因此，如果我们调用 <code>searchParams.get（&#39;x&#39;</code>），那么它应该返回 <code>y</code>，而 <code>searchParams.get（&#39;a&#39;）</code>应该返回 <code>b</code>，我们来试试吧！</p>\n<p>console.log(searchParams.get(‘x’));<br>// Output: “y”<br>console.log(searchParams.get(‘a’));<br>// Output: “b”</p>\n","categories":["JavaScript"],"tags":["javascript","javascript教程","url解析"]},{"title":"如何使用JAVASCRIPT初始化一个新数组","url":"/2018/10/10/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8javascript%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E6%96%B0%E6%95%B0%E7%BB%84/","content":"<p>简单解决方案</p>\n<p>new Array(12).fill(0);</p>\n<p><code>fill()</code> 是ES6中引入的一种新方法。</p>\n","categories":["JavaScript"],"tags":["javascript","array()","fill()","数组"]},{"title":"如何在CSS中使用2D Transformation功能","url":"/2018/09/28/%E5%A6%82%E4%BD%95%E5%9C%A8css%E4%B8%AD%E4%BD%BF%E7%94%A82d-transformation%E5%8A%9F%E8%83%BD/","content":"<p>Transforms允许我们创建不可能的效果和交互。与过渡和动画结合使用时，我们可以创建旋转，dance和zoom的元素和界面。特别是三维变换使得模仿物体成为可能。在本文中，我们将介绍2D变换函数（此处介绍了3D函数）。 有四种主要的二维变换函数：rotate，scale，skew，和translate。其他六个函数让我们在一个维度上转换元素：scaleX和scaleY; skewX和skewY; 和translateX和translateY。</p>\n<h2 id=\"rotate\"><a href=\"#rotate\" class=\"headerlink\" title=\"rotate()\"></a>rotate()</h2><p>旋转变换围绕该transform-origin点围绕指定的角度旋转元素。使用rotate()顺时针（正角度值）或逆时针（负角度值）倾斜元素。它的效果很像风车或风车，如下所示。 紫色框从其起始位置旋转了55度，如虚线所示 <img src=\"http://file.w3cbest.com/file/images/1TransformRotate.png\"> 该rotate()函数接受角度单位的值。角度单位由CSS值和单位模块级别3定义。这些可以是deg（度），rad（弧度），grad（梯度）或turn单位。一个完整旋转等于360deg，6.28rad，400grad，或1turn。 超过一个旋转（例如，540deg或1.5turn）的旋转值将根据其剩余值进行渲染，除非设置为动画或过渡。换句话说，540deg渲染与180deg（540度减去360度）相同，并且渲染与（1.5-1）1.5turn相同.5turn。但是，从一个过渡或动画0deg来540deg或1turn以1.5turn将旋转元素一个和倍半。</p>\n<h2 id=\"2D缩放功能：scale，scaleX，和scaleY\"><a href=\"#2D缩放功能：scale，scaleX，和scaleY\" class=\"headerlink\" title=\"2D缩放功能：scale，scaleX，和scaleY\"></a>2D缩放功能：scale，scaleX，和scaleY</h2><p>使用缩放功能，我们可以在X维度（scaleX），Y维度（scaleY）或两者（scale）中增加或减少元素的渲染大小。缩放如下图所示，其中边框表示框的原始边界，+标记其中心点。 一个方框（左）缩放2倍（右） <img src=\"http://file.w3cbest.com/file/images/2TransformScale.png\"> 每个比例函数都接受乘数或因子作为其参数。这个乘数可以是任何正数或负数。不支持百分比值。正乘数大于1增加元素的大小。例如，scale(1.5)将元素在X和Y方向上的尺寸增加1.5倍。之间的正乘数0和1将降低元素的大小。 小于的值0也会导致元素向上或向下缩放并创建反射（翻转）变换。 警告：使用scale(0)将导致元素消失，因为将数字乘以零会产生零。 使用scale(1)创建标识转换，这意味着它被绘制到屏幕，就像没有应用缩放转换一样。使用scale(-1)不会更改元素的绘制大小，但负值将导致元素被反射。即使元素没有出现变换，它仍会触发新的堆叠上下文并包含块。 可以使用该scale功能分别缩放X和Y尺寸。只需传递两个参数：scale(1.5, 2)。第一个参数缩放X维度; 第二个缩放Y维度。例如，我们可以单独使用X轴反射物体scale(-1, 1)。传递单个参数可以按相同因子缩放两个维度。</p>\n<h2 id=\"2D转换功能：translateX，translateY，和translate\"><a href=\"#2D转换功能：translateX，translateY，和translate\" class=\"headerlink\" title=\"2D转换功能：translateX，translateY，和translate\"></a>2D转换功能：translateX，translateY，和translate</h2><p>平移元素会将其绘制位置与布局位置偏移指定的距离。如同其它变换，平移一个元件不改变其offsetLeft或offsetTop位置。但是，它会影响它在屏幕上的可视位置。 每个2D平移函数translateX- translateY，和 - translate接受参数的长度或百分比。长度单位包括像素（px）， ，em，rem和视口单元（vw和vh）。 该translateX函数更改元素的水平渲染位置。如果元素位于左侧零像素处，则将transform: transitionX(50px)其渲染位置移动50个像素到其起始位置的右侧。同样，translateY更改元素的垂直渲染位置。transform: transitionY(50px)将元素垂直偏移50个像素的变换。 使用translate()，我们可以使用单个函数垂直和水平移动元素。它最多接受两个参数：X转换值和Y转换值。下图显示了一个元件与效果transform的值translate(120%, -50px)，其中，所述左绿色正方形是在原来的位置，而右侧绿色正方形水平平移120％，并从它的含有元素（虚线框）垂直-50px。 <img src=\"http://file.w3cbest.com/file/images/3Translate.png\"> 具有转换值为translate的元素的效果（120％， - 50px） 传递单个参数translate相当于使用translateX; Y转换值将设置为0。使用translate()是更简洁的选择。申请translate(100px, 200px)相当于translateX(100px) translateY(200px)。 正转换值将元素向右移动（for translateX）或向下移动（for translateY）。负值将元素移动到左（translateX）或向上（translateY）。 翻译对于向左，向右，向上或向下移动项目特别有用。更新的值left，right，top，和bottom属性强制浏览器重新计算整个文档布局信息。但是在计算布局之后计算变换。它们影响其中的元素出现在屏幕上，而不是他们的实际尺寸。是的，将文档布局和渲染视为单独的概念是很奇怪的，但就浏览器而言，它们是。 转换属性可能会到达您附近的浏览器 在CSS的最新版本来变换规范增加translate，rotate以及scale 性能的CSS。变换属性的工作方式与其对应的变换函数非常相似，但值是以空格分隔的，而不是以逗号分隔的。例如，我们可以transform: rotate3d(1, 1, 1, 45deg)使用该rotate属性表达：rotate: 1 1 1 45deg。同样，translate: 15% 10% 300px在视觉上与之相同transform: translate3d(15%, 10%, 300px)并且scale: 1.5 1.5 3相同transform: scale3d(1.5, 1.5, 3)。通过这些属性，我们可以与其他转换分开管理旋转，平移或缩放转换。 在撰写本文时，浏览器对转换属性的支持仍然非常稀少。Chrome和三星互联网支持开箱即用。在Firefox 60及更高版本中，支持隐藏在标志后面; 访问about: config并设置layout.css.individual-transform.enabled为true。</p>\n<h2 id=\"skew，skewX和skewY\"><a href=\"#skew，skewX和skewY\" class=\"headerlink\" title=\"skew，skewX和skewY\"></a>skew，skewX和skewY</h2><p>歪斜变换会使点之间的角度和距离发生偏移，同时将它们保持在同一平面内。歪斜变换也称为剪切变换，它们会扭曲元素的形状，如下所示，其中虚线表示元素的原始边界框。 矩形沿其X维度倾斜45度 <img src=\"http://file.w3cbest.com/file/images/4TransformSkew.png\"> 偏斜函数skew- skewX，和 - skewY接受大多数角度单位作为参数。度，渐变和弧度是倾斜函数的有效角度单位，而转弯单位可能显然不是。 该skewX功能在X或水平方向上剪切元素（参见下面的图像）。它接受一个参数，该参数也必须是一个角度单位。正值将元素向左移动，负值将元素向右移动。 左图像未被变换，而右图像显示变换的效果：skewX（30deg） <img src=\"http://file.w3cbest.com/file/images/5skewX.png\"> 同样，skewY剪切Y或垂直方向的元素。下图显示了效果transform: skewY(30deg)。原点右侧的点向下移动，带有正值。负值将这些点向上移动。 同样，左图像保持未变换，右图像垂直偏斜30度 <img src=\"http://file.w3cbest.com/file/images/6skewY.png\"> 这带给我们的skew功能。该skew函数需要一个参数，但最多可接受两个参数。第一个参数在X方向上扭曲一个元素，第二个参数在Y方向上扭曲它。如果只提供一个参数，则假定第二个值为零，使其相当于单独在X方向上的倾斜。换句话说，skew(45deg)渲染相同skewX(45deg)。</p>\n<h2 id=\"当前变换矩阵\"><a href=\"#当前变换矩阵\" class=\"headerlink\" title=\"当前变换矩阵\"></a>当前变换矩阵</h2><p>到目前为止，我们已经分别讨论了变换函数，但它们也可以组合在一起。想要缩放和旋转对象？没问题：使用转换列表。例如：</p>\n<p>.rotatescale {<br>transform: rotate(45deg) scale(2);<br>}</p>\n<p>这将产生您在下面看到的结果。 <img src=\"http://file.w3cbest.com/file/images/7ScaleAndRotate.png\"> 应用原始元素（左）和组合旋转和缩放变换后（右） 使用转换函数时，顺序很重要。这是一个比谈论更好的一点，所以让我们看一个例子来说明。以下CSS倾斜并旋转元素：</p>\n<p>.transformEl {<br>transform: skew(10deg, 15deg) rotate(45deg);<br>}</p>\n<p>它为我们提供了您在下面看到的结果。 <img src=\"http://file.w3cbest.com/file/images/8SkewAndRotate.png\"> 歪斜变换后的元素（10度，15度）旋转（45度） 如果首先旋转元素然后将其倾斜会发生什么？</p>\n<p>.transformEl {<br>transform: rotate(45deg) skew(10deg, 15deg);<br>}</p>\n<p>如下所示，效果完全不同。 <img src=\"http://file.w3cbest.com/file/images/9RotateThenSkew.png\"> 旋转后然后倾斜的元素 这些变换中的每一个具有由其变换函数的顺序创建的不同的当前变换矩阵。为了完全理解为什么这样，我们需要学习一点矩阵乘法。这也有助于我们理解matrix和matrix3d功能。 矩阵乘法和矩阵函数 甲矩阵是排列成行和列的矩形号码或表达式的阵列。所有变换可以使用4×4矩阵表示，如下所示。 <img src=\"http://file.w3cbest.com/file/images/1536071956matrix4x4.png\"> 用于3D变换的4×4矩阵 该矩阵对应于matrix3d函数，该函数接受16个参数，每个参数用于4×4矩阵的每个值。二维变换也可以使用3×3矩阵表示，如下所示。 <img src=\"http://file.w3cbest.com/file/images/1536071982matrix.png\"> 用于2D变换的3×3矩阵 该3×3矩阵对应于matrix变换函数。该matrix()函数接受六个参数，每个参数对应于值a到f。 可以使用矩阵和/ matrix或matrix3d函数来描述每个变换函数。下图显示了scale3d函数的4×4矩阵，其中sx，sy和sz分别是X，Y和Z维度的缩放因子。 <img src=\"http://file.w3cbest.com/file/images/1536072012scalingmatrix4x4.png\"> 当我们组合变换时 - 例如transform: scale(2) translate(30px, 50px)- 浏览器将每个函数的矩阵相乘以创建新矩阵。这个新矩阵是应用于元素的。 但这是关于矩阵乘法的事情：它不是可交换的。使用简单值，3×2的乘积与2×3相同。但是，对于矩阵，A × B的乘积不一定与B × A的乘积相同。我们来看一个例子。我们将计算出的矩阵乘积transform: scale(2) translate(30px, 50px)。 <img src=\"http://file.w3cbest.com/file/images/1536072046ScaleAndTranslate.png\"> 我们的元素按比例缩放了两倍，然后水平翻译60像素，垂直翻译100像素。我们也可以使用以下matrix功能表达此产品：transform: matrix(2, 0, 0, 2, 60, 100)。现在让我们切换这些变换的顺序 - 即transform: translate(30px, 50px) scale(2)。结果如下所示。 <img src=\"http://file.w3cbest.com/file/images/1536072076TranslateAndScale.png\"> 用于平移（30px，50px）和刻度（2）的矩阵的乘积 请注意，我们的对象仍然按比例缩放了两倍，但在这里它被水平翻译了30个像素而垂直翻译了50个像素。使用该matrix函数表示，这是transform: matrix(2, 0, 0, 2, 30, 50)。 值得注意的是，继承转换的功能与转换列表类似。每个子变换乘以应用于其父变换的任何变换。例如，请使用以下代码：</p>\n<div style=\"transform: skewX(25deg)\">\n<p style=\"transform: rotate(-15deg)\"></p>\n</div>\n\n<p>这与以下内容相同：</p>\n<div>\n<p style=\"transform: skewX(25deg) rotate(-15deg)\"></p>\n</div>\n\n<p>p在两种情况下，元素的当前变换矩阵都是相同的。虽然到目前为止我们专注于2D变换，但上述内容也适用于3D变换。第三个维度增加了深度的幻觉。它还以新功能和属性的形式带来了一些额外的复杂性。</p>\n","categories":["HTML/CSS"],"tags":["css3","transforms","css 布局","css教程","translate","html教程","前端教程","rotate","skew"]},{"title":"如何在JavaScript中获取CSS值","url":"/2019/02/18/%E5%A6%82%E4%BD%95%E5%9C%A8javascript%E4%B8%AD%E8%8E%B7%E5%8F%96css%E5%80%BC/","content":"<p>有时候单独的使用CSS是不够的。您可能需要使用JavaScript控制CSS值。但是你如何在JavaScript中获得CSS值？ 有两种可能的方式，取决于您是尝试获取内联样式还是计算样式。</p>\n<h2 id=\"获取内联样式\"><a href=\"#获取内联样式\" class=\"headerlink\" title=\"获取内联样式\"></a>获取内联样式</h2><p>内联样式是存在于 HTML style 属性(attribute)中的样式。</p>\n<div class=\"element\" style=\"font-size: 2em; color: red;\">Red hot chili pepper!</div>\n\n<p>要获取内联样式，可以使用 style 属性(property)。</p>\n<p>const element = document.querySelector(‘.element’)</p>\n<p>const fontSize = element.style.fontSize<br>console.log(fontSize) // 2em</p>\n<p>const color = element.style.color<br>console.log(color) // red</p>\n<h2 id=\"获取计算样式\"><a href=\"#获取计算样式\" class=\"headerlink\" title=\"获取计算样式\"></a>获取计算样式</h2><p>如果您的样式是在CSS文件中编写的，则需要获取计算出的样式。为此，您可以使用 getComputedStyle 。 它有两个值：</p>\n<p>const style = getComputedStyle(Element, );</p>\n<p>这里的Element是指您使用 querySelector 选择的元素。 这里的 pseudoElement 指的是你想要获取的伪类元素的字符串（如果有的话）。如果您没有选择伪元素，则可以省略这个值。 让我们通过一个例子来帮助理解。假设您有以下HTML和CSS：</p>\n<div class=\"element\"> This is my element </div>\n.element { background-color: red }\n\n<p>首先，您需要使用 querySelector 选择元素。然后，使用 getComputedStyle 获取元素的样式。</p>\n<p>const element = document.querySelector(‘.element’)<br>const style = getComputedStyle(element)</p>\n<p>如果你用 console.log(style) 打印，您应该看到一个包含每个CSS属性及其各自值的对象。 <img src=\"http://file.w3cbest.com/file/images/all-properties.png\"></p>\n<p>图注：getComputedStyle 返回一个包含每个CSS属性及其各自值的对象</p>\n<p>您还可以在Chrome和Firefox的开发工具中看到此对象。 对于Firefox开发工具，请查看 “Inspector”，“Computed”。 <img src=\"http://file.w3cbest.com/file/images/firefox.png\"></p>\n<p>图注：Firefox dev工具计算样式选项卡</p>\n<p>对于Chrome开发工具，请查看“Elements” 面板。 如果开发工具窗口很大，您可以在右侧面板上看到计算出的样式。 如果开发工具窗口很小，您可以在“Computed”选项卡下查看。 <img src=\"http://file.w3cbest.com/file/images/chrome.png\"></p>\n<p>图注：Chrome dev工具计算样式选项卡</p>\n<p>要获取CSS属性的值，请以驼峰形式编写属性。</p>\n<p>const style = getComputedStyle(element)</p>\n<p>const backgroundColor = style.backgroundColor<br>console.log(backgroundColor) // rgb(0, 0, 0)</p>\n<p>注意：getComputedStyle 是只读的。您无法使用 getComputedStyle 设置CSS值。 注意2：getComputedStyle 获取计算出的CSS值。你将从 getComputedStyle 获得 px 单位值，而不是像 em 和 rem 这样的相对单位。</p>\n<h3 id=\"从伪类元素中获取样式\"><a href=\"#从伪类元素中获取样式\" class=\"headerlink\" title=\"从伪类元素中获取样式\"></a>从伪类元素中获取样式</h3><p>要从伪类元素获取样式，您需要将伪类元素的字符串作为第二个参数传递给 getComputedStyle 。</p>\n<div class=\"element\"> This is my element </div>\n\n<p>element { background-color: red }<br>.element::before { content: “Before pseudo element”; }</p>\n<p>const element = document.querySelector(‘.element’)<br>pseudoElementStyle = getComputedStyle(element, ‘::before’)</p>\n<p>console.log(pseudoElementStyle.content) // Before pseudo element</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>您可以通过两种方法在JavaScript中获取CSS值：</p>\n<ul>\n<li>  style 属性(property)</li>\n<li>  getComputedStyle 。</li>\n</ul>\n<p>style 属性仅检索内联CSS值，而 getComputedStyle 样式检索计算的CSS值。</p>\n","categories":["JavaScript"],"tags":["javascript","css3教程","javascript教程","css教程","ECMAScript教程","js教程"]},{"title":"如何正确判断this的指向？","url":"/2019/09/03/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%88%A4%E6%96%ADthis%E7%9A%84%E6%8C%87%E5%90%91%EF%BC%9F/","content":"<p>如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。 但是仅通过这句话，我们很多时候并不能准确判断 this 的指向。因此我们需要借助一些规则去帮助自己： this 的指向可以按照以下顺序判断:</p>\n<h2 id=\"1-全局环境中的-this\"><a href=\"#1-全局环境中的-this\" class=\"headerlink\" title=\"1. 全局环境中的 this\"></a>1. 全局环境中的 this</h2><p>浏览器环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象 window; node 环境：无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 {};</p>\n<h2 id=\"2-是否是-new-绑定\"><a href=\"#2-是否是-new-绑定\" class=\"headerlink\" title=\"2. 是否是 new 绑定\"></a>2. 是否是 new 绑定</h2><p>如果是 new 绑定，并且构造函数中没有返回 function 或者是 object，那么 this 指向这个新对象。如下: 构造函数返回值不是 function 或 object。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function Super(age) &#123;</span><br><span class=\"line\">    this.age &#x3D; age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let instance &#x3D; new Super(&#39;26&#39;);</span><br><span class=\"line\">console.log(instance.age); &#x2F;&#x2F;26</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>构造函数返回值是 function 或 object，这种情况下 this 指向的是返回的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function Super(age) &#123;</span><br><span class=\"line\">    this.age &#x3D; age;</span><br><span class=\"line\">    let obj &#x3D; &#123;a: &#39;2&#39;&#125;;</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let instance &#x3D; new Super(&#39;hello&#39;);</span><br><span class=\"line\">console.log(instance.age); &#x2F;&#x2F;undefined</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>你可以想知道为什么会这样？我们来看一下 new 的实现原理:</p>\n<ol>\n<li> 创建一个新对象。</li>\n<li> 这个新对象会被执行 <code>[原型]</code> 连接。</li>\n<li> 属性和方法被加入到 this 引用的对象中。并执行了构造函数中的方法.</li>\n<li> 如果函数没有返回其他对象，那么 this 指向这个新对象，否则 this 指向构造函数中返回的对象。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function new(func) &#123;</span><br><span class=\"line\">    let target &#x3D; &#123;&#125;;</span><br><span class=\"line\">    target.__proto__ &#x3D; func.prototype;</span><br><span class=\"line\">    let res &#x3D; func.call(target);</span><br><span class=\"line\">    &#x2F;&#x2F;排除 null 的情况</span><br><span class=\"line\">    if (res &amp;&amp; typeof(res) &#x3D;&#x3D; &quot;object&quot;  typeof(res) &#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return target;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-函数是否通过-call-apply-调用，或者使用了-bind-绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。\"><a href=\"#3-函数是否通过-call-apply-调用，或者使用了-bind-绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。\" class=\"headerlink\" title=\"3. 函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。\"></a>3. 函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function info()&#123;</span><br><span class=\"line\">    console.log(this.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person &#x3D; &#123;</span><br><span class=\"line\">    age: 20,</span><br><span class=\"line\">    info</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var age &#x3D; 28;</span><br><span class=\"line\">var info &#x3D; person.info;</span><br><span class=\"line\">info.call(person);   &#x2F;&#x2F;20</span><br><span class=\"line\">info.apply(person);  &#x2F;&#x2F;20</span><br><span class=\"line\">info.bind(person)(); &#x2F;&#x2F;20</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里同样需要注意一种特殊情况，如果 call,apply 或者 bind 传入的第一个参数值是 undefined 或者 null，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function info()&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;node环境中:非严格模式 global，严格模式为null</span><br><span class=\"line\">    &#x2F;&#x2F;浏览器环境中:非严格模式 window，严格模式为null</span><br><span class=\"line\">    console.log(this);</span><br><span class=\"line\">    console.log(this.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person &#x3D; &#123;</span><br><span class=\"line\">    age: 20,</span><br><span class=\"line\">    info</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var age &#x3D; 28;</span><br><span class=\"line\">var info &#x3D; person.info;</span><br><span class=\"line\">&#x2F;&#x2F;严格模式抛出错误；</span><br><span class=\"line\">&#x2F;&#x2F;非严格模式，node下输出undefined（因为全局的age不会挂在 global 上）</span><br><span class=\"line\">&#x2F;&#x2F;非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）</span><br><span class=\"line\">info.call(null);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为-xxx-fn\"><a href=\"#4-隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为-xxx-fn\" class=\"headerlink\" title=\"4. 隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn()\"></a>4. 隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn()</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function info()&#123;</span><br><span class=\"line\">    console.log(this.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person &#x3D; &#123;</span><br><span class=\"line\">    age: 20,</span><br><span class=\"line\">    info</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var age &#x3D; 28;</span><br><span class=\"line\">person.info(); &#x2F;&#x2F;20;执行的是隐式绑定</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。\"><a href=\"#5-默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。\" class=\"headerlink\" title=\"5. 默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。\"></a>5. 默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">非严格模式： node环境，执行全局对象 global，浏览器环境，执行全局对象 window。 严格模式：执行 undefined</span><br><span class=\"line\"></span><br><span class=\"line\">function info()&#123;</span><br><span class=\"line\">    console.log(this.age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var age &#x3D; 28;</span><br><span class=\"line\">&#x2F;&#x2F;严格模式；抛错</span><br><span class=\"line\">&#x2F;&#x2F;非严格模式，node下输出 undefined（因为全局的age不会挂在 global 上）</span><br><span class=\"line\">&#x2F;&#x2F;非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）</span><br><span class=\"line\">&#x2F;&#x2F;严格模式抛出，因为 this 此时是 undefined</span><br><span class=\"line\">info();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-箭头函数的情况：\"><a href=\"#6-箭头函数的情况：\" class=\"headerlink\" title=\"6. 箭头函数的情况：\"></a>6. 箭头函数的情况：</h2><p>箭头函数没有自己的this，继承外层上下文绑定的this。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    age: 20,</span><br><span class=\"line\">    info: function() &#123;</span><br><span class=\"line\">        return () &#x3D;&gt; &#123;</span><br><span class=\"line\">            console.log(this.age); &#x2F;&#x2F;this继承的是外层上下文绑定的this</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let person &#x3D; &#123;age: 28&#125;;</span><br><span class=\"line\">let info &#x3D; obj.info();</span><br><span class=\"line\">info(); &#x2F;&#x2F;20</span><br><span class=\"line\"></span><br><span class=\"line\">let info2 &#x3D; obj.info.call(person);</span><br><span class=\"line\">info2(); &#x2F;&#x2F;28</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","categories":["JavaScript"],"tags":["Object","this","function","this的指向","window","对象字面量"]},{"title":"如何用JavaScript（ES6）标准语法，取代jQuery的一些主要功能","url":"/2018/10/08/%E5%A6%82%E4%BD%95%E7%94%A8javascript%EF%BC%88es6%EF%BC%89%E6%A0%87%E5%87%86%E8%AF%AD%E6%B3%95%EF%BC%8C%E5%8F%96%E4%BB%A3jquery%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/","content":"<p>常用的 class、id、属性 选择器都可以使用 <code>document.querySelector</code> 或 <code>document.querySelectorAll</code> 替代。区别是</p>\n<ul>\n<li>  <code>document.querySelector</code> 返回第一个匹配的 <code>Element</code></li>\n<li>  <code>document.querySelectorAll</code> 返回所有匹配的 <code>Element</code> 组成的 <code>NodeList</code>。它可以通过 <code>[].slice.call()</code> 把它转成 <code>Array</code></li>\n<li>  如果匹配不到任何 <code>Element，jQuery</code> 返回空数组 <code>[]</code>，但 <code>document.querySelector</code> 返回 null，注意空指针异常。当找不到时，也可以使用 设置默认的值，如 document.querySelectorAll(selector) []</li>\n</ul>\n<blockquote>\n<p>注意：<code>document.querySelector</code> 和 <code>document.querySelectorAll</code> 性能很<strong>差</strong>。如果想提高性能，尽量使用 <code>document.getElementById</code>、<code>document.getElementsByClassName</code> 或 <code>document.getElementsByTagName</code>。</p>\n</blockquote>\n<p>探讨一下如果不需要支持过于陈旧的浏览器版本，如何用JavaScript（ES6）标准语法，取代jQuery的一些主要功能</p>\n<h3 id=\"选取元素\"><a href=\"#选取元素\" class=\"headerlink\" title=\"选取元素\"></a>选取元素</h3><h4 id=\"选择器查询\"><a href=\"#选择器查询\" class=\"headerlink\" title=\"选择器查询\"></a>选择器查询</h4><p>常用的 class、id、属性 选择器都可以使用 document.querySelector 或 document.querySelectorAll 替代。</p>\n<ul>\n<li>  document.querySelector 返回第一个匹配的 Element</li>\n<li>  document.querySelectorAll 返回所有匹配的 Element 组成的 NodeList。</li>\n</ul>\n<p>jQuery：</p>\n<p>var $ele = $(“selector”);</p>\n<p>Native:</p>\n<p>let ele = document.querySelectorAll(“selector”);</p>\n<h4 id=\"选择器模式\"><a href=\"#选择器模式\" class=\"headerlink\" title=\"选择器模式\"></a>选择器模式</h4><p>选择器</p>\n<p>示例</p>\n<p>示例说明</p>\n<p>.class</p>\n<p>.intro</p>\n<p>选择所有class=”intro”的元素</p>\n<p>#id</p>\n<p>#firstname</p>\n<p>选择所有id=”firstname”的元素</p>\n<p>*</p>\n<p>*</p>\n<p>选择所有元素</p>\n<p>element</p>\n<p>p</p>\n<p>选择所有<p>元素</p>\n<p>element,element</p>\n<p>div,p</p>\n<p>选择所有<div>元素和<p>元素</p>\n<p>element element</p>\n<p>div p</p>\n<p>选择<div>元素内的所有<p>元素</p>\n<p>element&gt;element</p>\n<p>div&gt;p</p>\n<p>选择所有父级是<div>元素的 <p>元素</p>\n<p>element+element</p>\n<p>div+p</p>\n<p>选择所有紧接着<div>元素之后的<p>元素</p>\n<p>[attribute=value]</p>\n<p>a[target=_blank]</p>\n<p>选择所有使用target=”_blank”的<a>元素</p>\n<p>[attribute^=value]</p>\n<p>a[src^=”http”]</p>\n<p>选择每一个src属性的值以”http”开头的<a>元素</p>\n<p>[attribute$=value]</p>\n<p>a[src$=”.jpg”]</p>\n<p>选择每一个src属性的值以”.jpg”结尾的<a>元素</p>\n<p>:first-child</p>\n<p>ul li:first-child</p>\n<p>选择<ul>元素下的首个<li>元素</p>\n<p>:nth-child(n)</p>\n<p>ul li:nth-child(3)</p>\n<p>选择<ul>元素下的第三个<li>元素</p>\n<p>:last-child</p>\n<p>ul li:last-child</p>\n<p>选择<ul>元素下的最后一个<li>元素</p>\n<p> </p>\n<h4 id=\"DOM-树查询\"><a href=\"#DOM-树查询\" class=\"headerlink\" title=\"DOM 树查询\"></a>DOM 树查询</h4><p>jQuery</p>\n<p>Native</p>\n<p>方法说明</p>\n<p><code>$ele.parent()</code></p>\n<p><code>ele.parentNode</code></p>\n<p>元素的直接父元素</p>\n<p><code>$ele.children()</code></p>\n<p><code>ele.childNodes</code></p>\n<p>元素的所有直接子元素</p>\n<p><code>$ele.find(&quot;a&quot;)</code></p>\n<p><code>ele.querySelectorAll(&quot;a&quot;)</code></p>\n<p>元素的后代元素</p>\n<p><code>$ele.prev()</code></p>\n<p><code>ele.previousElementSibling</code></p>\n<p>元素的上一个同胞元素</p>\n<p><code>$ele.next()</code></p>\n<p><code>ele.nextElementSibling</code></p>\n<p>元素的下一个同胞元素</p>\n<h3 id=\"DOM-操作\"><a href=\"#DOM-操作\" class=\"headerlink\" title=\"DOM 操作\"></a>DOM 操作</h3><p>DOM本身就具有很丰富的操作方法，可以取代jQuery提供的操作方法。</p>\n<h4 id=\"内容和属性\"><a href=\"#内容和属性\" class=\"headerlink\" title=\"内容和属性\"></a>内容和属性</h4><p>jQuery</p>\n<p>Native</p>\n<p>方法说明</p>\n<p><code>var text = $ele.text()</code></p>\n<p><code>let text = ele.innerText</code></p>\n<p>获取所选元素的文本内容</p>\n<p><code>$ele.text(&quot;text&quot;)</code></p>\n<p><code>ele.innerText = &quot;text&quot;</code></p>\n<p>设置所选元素的文本内容</p>\n<p><code>var html = $ele.html()</code></p>\n<p><code>let html = ele.innerHTML</code></p>\n<p>获取所选元素的HTML内容</p>\n<p><code>$ele.html(&quot;&lt;div&gt;html&lt;/div&gt;&quot;)</code></p>\n<p><code>ele.innerHTML = &quot;&lt;div&gt;html&lt;/div&gt;&quot;</code></p>\n<p>设置所选元素的HTML内容</p>\n<p><code>var input = $ele.val()</code></p>\n<p><code>let input = ele.value</code></p>\n<p>获取表单字段的值</p>\n<p><code>$ele.val(&quot;input&quot;)</code></p>\n<p><code>ele.value = &quot;input&quot;</code></p>\n<p>设置表单字段的值</p>\n<p><code>var href = $ele.attr(&quot;href&quot;)</code></p>\n<p><code>let href = ele.getAttribute(&quot;href&quot;)</code></p>\n<p>获取元素的属性值</p>\n<p><code>$ele.attr(&quot;href&quot;, &quot;/&quot;)</code></p>\n<p><code>ele.setAttribute(&quot;href&quot;, &quot;/&quot;)</code></p>\n<p>设置元素的属性值</p>\n<h4 id=\"修改-DOM-树\"><a href=\"#修改-DOM-树\" class=\"headerlink\" title=\"修改 DOM 树\"></a>修改 DOM 树</h4><p>jQuery</p>\n<p>Native</p>\n<p>方法说明</p>\n<p><code>$parent.append($ele)</code></p>\n<p><code>parent.appendChild(ele)</code></p>\n<p>在被选元素的结尾插入内容</p>\n<p><code>$parent.prepend($ele)</code></p>\n<p><code>parent.insertBefore(ele, parent.firstChild)</code></p>\n<p>在被选元素的开头插入内容</p>\n<p><code>$ele.after(html)</code></p>\n<p><code>ele.insertAdjacentHTML(&quot;afterend&quot;, html)</code></p>\n<p>在被选元素之后插入内容</p>\n<p><code>$ele.before(html)</code></p>\n<p><code>ele.insertAdjacentHTML(&quot;beforebegin&quot;, html)</code></p>\n<p>在被选元素之前插入内容</p>\n<p><code>$ele.remove()</code></p>\n<p><code>ele.parentNode.removeChild(ele)</code></p>\n<p>删除被选元素及其子元素</p>\n<p><code>$ele.empty()</code></p>\n<p><code>ele.innerHTML = null</code></p>\n<p>从被选元素中删除子元素</p>\n<p><code>$ele.clone()</code></p>\n<p><code>ele.cloneNode(true)</code></p>\n<p>拷贝被选元素</p>\n<p><code>$ele.replaceWith(html)</code></p>\n<p><code>ele.outerHTML = html</code></p>\n<p>指定HTML替换被选元素</p>\n<h3 id=\"CSS-样式\"><a href=\"#CSS-样式\" class=\"headerlink\" title=\"CSS 样式\"></a>CSS 样式</h3><p> </p>\n<h4 id=\"设置-Style\"><a href=\"#设置-Style\" class=\"headerlink\" title=\"设置 Style\"></a>设置 Style</h4><p>HTML DOM 允许 JavaScript 改变 HTML 元素的样式，Native API 提供了如下几种方式：</p>\n<ul>\n<li>  ele.setAttribute 直接修改 DOM style 属性改变样式</li>\n<li>  ele.style.cssText 通过 cssText 修改 Style 属性</li>\n<li>  ele.style.property 通过 style 对象读写行内 CSS 样式</li>\n</ul>\n<p>jQuery：</p>\n<p>var size = $ele.css(“font-size”); // 返回第一个匹配元素的 CSS 属性值<br>$ele.css(“font-size”, “2rem”); // 为所有元素设置指定的 CSS 属性值</p>\n<p>Native:</p>\n<p>let size = getComputedStyle(ele)[“font-size”]; // 获取当前元素计算后的 CSS 属性值<br>ele.style.setProperty(“font-size”, “2rem”); // 设置当前元素的某个内联样式<br>ele.style.removeProperty(“font-size”); // 移除当前元素的某个内联样式</p>\n<h4 id=\"设置-Class\"><a href=\"#设置-Class\" class=\"headerlink\" title=\"设置 Class\"></a>设置 Class</h4><p>jQuery</p>\n<p>Native</p>\n<p>方法说明</p>\n<p><code>$ele.hasClass(className)</code></p>\n<p><code>ele.classList.contains(className)</code></p>\n<p>检查元素是否包含指定的类名</p>\n<p><code>$ele.addClass(className)</code></p>\n<p><code>ele.classList.add(className)</code></p>\n<p>向元素增加一个或多个类名</p>\n<p><code>$ele.removeClass(className)</code></p>\n<p><code>ele.classList.remove(className)</code></p>\n<p>从元素中移除一个或多个类</p>\n<p><code>$ele.toggleClass(className)</code></p>\n<p><code>ele.classList.toggle(className)</code></p>\n<p>对元素的一个或多个类进行切换</p>\n<h3 id=\"事件方法\"><a href=\"#事件方法\" class=\"headerlink\" title=\"事件方法\"></a>事件方法</h3><h4 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h4><p>jQuery：</p>\n<p>$ele.on(“click”, function (evt) {<br>console.log(evt.target);<br>});</p>\n<p>Native:</p>\n<p>ele.addEventListener(“click”, evt =&gt; {<br>console.log(evt.target);<br>});</p>\n<p>解除绑定 jQuery：</p>\n<p>$ele.off(“click”);</p>\n<p>Native:</p>\n<p>ele.removeEventListener(“click”, func);</p>\n<p>如果要移除事件，addEventListener 必须使用外部函数，绑定匿名函数的事件是无法移除的。</p>\n<h4 id=\"模拟触发\"><a href=\"#模拟触发\" class=\"headerlink\" title=\"模拟触发\"></a>模拟触发</h4><p>jQuery：</p>\n<p>$ele.trigger(“click”);</p>\n<p>Native:</p>\n<p>let event = document.createEvent(“MouseEvents”);<br>event.initMouseEvent(“click”);<br>ele.dispatchEvent(event);</p>\n<p>模拟事件：</p>\n<ul>\n<li>  首先通过 document.createEvent 方法创建 Event 对象。</li>\n<li>  然后利用 Event 对象的 init 方法对其进行初始化。</li>\n<li>  最后使用 dispatchEvent 方法触发 Event 对象。</li>\n</ul>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><h4 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h4><p>jQuery</p>\n<p>Native</p>\n<p>方法说明</p>\n<p><code>$.isArray(array)</code></p>\n<p><code>Array.isArray(array)</code></p>\n<p>判断参数是否为一个数组</p>\n<p><code>$.inArray(item, array)</code></p>\n<p><code>array.includes(item)</code></p>\n<p>判断值是否在指定数组中</p>\n<p><code>$.makeArray(objlist)</code></p>\n<p><code>Array.from(objlist)</code></p>\n<p>将类数组对象转换为数组</p>\n<p><code>$.merge(array1, array2)</code></p>\n<p><code>array1.concat(array2)</code></p>\n<p>合并两个数组（有区别）</p>\n<p><code>$.each(array, function (i, item) &#123;&#125;</code></p>\n<p><code>array.forEach((item, i) =&gt; &#123;&#125;)</code></p>\n<p>遍历指定的对象和数组</p>\n<p>合并数组时，merge 会改变原数组的内容，而 concat 不会修改原数组，只会返回合并后的数组</p>\n<h4 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h4><p>jQuery</p>\n<p>Native</p>\n<p>方法说明</p>\n<p><code>$.now()</code></p>\n<p><code>Date.now()</code></p>\n<p>返回当前时间戳</p>\n<p><code>$.trim(string)</code></p>\n<p><code>string.trim();</code></p>\n<p>移除字符串头尾空白</p>\n<p><code>$.type(obj);</code></p>\n<p><code>Object.prototype.toString.call(obj).replace(/^\\[object (.+)\\]$/, &#39;$1&#39;).toLowerCase();</code></p>\n<p>检测参数的内部类型</p>\n<p><code>$.parseJSON(string)</code></p>\n<p><code>JSON.parse(string)</code></p>\n<p>将JSON转换为JS对象</p>\n<p><code>$ele.data(&quot;key&quot;, &quot;value&quot;)</code></p>\n<p><code>ele.dataset.key = &quot;value&quot;</code></p>\n<p>在指定的元素上存储数据</p>\n<p><code>$.map(array, function(value, index)&#123; &#125;);</code></p>\n<p><code>array.map(function(value, index)&#123; &#125;);</code></p>\n<p>将数组转化为处理后的新数组</p>\n<p>参考：<a href=\"https://github.com/nefe/You-Dont-Need-jQuery/blob/master/README.zh-CN.md\">https://github.com/nefe/You-Dont-Need-jQuery</a></p>\n","categories":["资源","JavaScript"],"tags":["javascript","es6","jquery","document","querySelector"]},{"title":"如何给ECharts柱状图设置一个高亮色","url":"/2018/10/07/%E5%A6%82%E4%BD%95%E7%BB%99echarts%E6%9F%B1%E7%8A%B6%E5%9B%BE%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E9%AB%98%E4%BA%AE%E8%89%B2/","content":"<p>在项目开发中用到echarts有这样的需求，比如要给一个星期的某个一天设置一个高亮色与其他天不同的颜色来区分开，那么我来演示一下如何达到这样的需求， 我知道的方法有两种，也可能有其他方法，欢迎来吐槽</p>\n<h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>也是在<a href=\"http://www.echartsjs.com/option.html#series-bar.data\">官网</a>上看到的，就是直接在data数据的数组上设置颜色，也就是说在数组的某一段需要添加对象值来达到这种效果</p>\n<p>option = {<br>……<br>series: [{<br>data: [120, {<br>value: 200,<br>itemStyle:{<br>color: ‘#f00’<br>}<br>}, 150, 80, 70, 110, 130],<br>……<br>}]<br>};</p>\n<p>这种方法在处理数据的太麻烦，我不喜欢这种方法</p>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>设置itemStyle图形样式属性的color，这种方法是在formatter的启发下得到的，因为在文档上没有看到color有回调函数，首先要设置一个变量也就是高亮色的位置，这个变量的值可以后端给，也可以前端给（前端给的必定是死值）， data数组我们不动，</p>\n<p>const curInt = 2;<br>option = {<br>series:[{<br>data:[…],</p>\n<!-- 在这里设置 -->\n<p>itemStyle:{<br>color: function(params){<br>const key = params.dataIndex;<br>if(key === curInt){<br>return ‘#E062AE’;<br>}else{<br>return ‘#37A2DA’<br>}<br>}<br>}<br>}]<br>};</p>\n<p>好了，我知道的就这，方法是否对你有用，我就不知道了。 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/11/echarts-img.jpg\"></p>\n","categories":["JavaScript","ECharts"],"tags":["javascript","echarts","可视化","插件"]},{"title":"如何让你的 JS 写得更漂亮","url":"/2019/09/17/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84-js-%E5%86%99%E5%BE%97%E6%9B%B4%E6%BC%82%E4%BA%AE/","content":"<h2 id=\"1-按强类型风格写代码\"><a href=\"#1-按强类型风格写代码\" class=\"headerlink\" title=\"1. 按强类型风格写代码\"></a>1. 按强类型风格写代码</h2><p>JS是弱类型的，但是写代码的时候不能太随意，写得太随意也体现了编码风格不好。下面分点说明：</p>\n<h3 id=\"（1）定义变量的时候要指明类型，告诉JS解释器这个变量是什么数据类型的，而不要让解释器去猜，例如不好的写法：\"><a href=\"#（1）定义变量的时候要指明类型，告诉JS解释器这个变量是什么数据类型的，而不要让解释器去猜，例如不好的写法：\" class=\"headerlink\" title=\"（1）定义变量的时候要指明类型，告诉JS解释器这个变量是什么数据类型的，而不要让解释器去猜，例如不好的写法：\"></a>（1）定义变量的时候要指明类型，告诉JS解释器这个变量是什么数据类型的，而不要让解释器去猜，例如不好的写法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var num,</span><br><span class=\"line\">    str,</span><br><span class=\"line\">    obj;</span><br></pre></td></tr></table></figure>\n\n<p>声明了三个变量，但其实没什么用，因为解释器不知道它们是什么类型的，好的写法应该是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var num &#x3D; 0,</span><br><span class=\"line\">    str &#x3D; &#39;&#39;,</span><br><span class=\"line\">    obj &#x3D; null;</span><br></pre></td></tr></table></figure>\n\n<p>定义变量的时候就给他一个默认值，这样不仅方便了解释器，也方便了阅读代码的人，他会在心里有数——知道这些变量可能会当作什么用。</p>\n<h3 id=\"（2）不要随意地改变变量的类型，例如下面代码：\"><a href=\"#（2）不要随意地改变变量的类型，例如下面代码：\" class=\"headerlink\" title=\"（2）不要随意地改变变量的类型，例如下面代码：\"></a>（2）不要随意地改变变量的类型，例如下面代码：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var num &#x3D; 5; </span><br><span class=\"line\">    num &#x3D; &quot;-&quot; + num;</span><br></pre></td></tr></table></figure>\n<p>第1行它是一个整型，第2行它变成了一个字符串。因为JS最终都会被解释成汇编的语言，汇编语言变量的类型肯定是要确定的，你把一个整型的改成了字符串，那解释器就得做一些额外的处理。并且这种编码风格是不提倡的，有一个变量第1行是一个整型，第10行变成了一个字符串，第20行又变成了一个object，这样就让阅读代码的人比较困惑，上面明明是一个整数，怎么突然又变成一个字符串了。好的写法应该是再定义一个字符串的变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var num &#x3D; 5;</span><br><span class=\"line\">var sign &#x3D; &quot;-&quot; + num;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（3）函数的返回类型应该是要确定的，例如下面不确定的写法：\"><a href=\"#（3）函数的返回类型应该是要确定的，例如下面不确定的写法：\" class=\"headerlink\" title=\"（3）函数的返回类型应该是要确定的，例如下面不确定的写法：\"></a>（3）函数的返回类型应该是要确定的，例如下面不确定的写法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getPrice(count)&#123;</span><br><span class=\"line\">    if(count &lt; 0) return &quot;&quot;;</span><br><span class=\"line\">    else return count \\* 100;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>getPrice这个函数有可能返回一个整数，也有可能返回一个空的字符串。这样写也不太好，虽然它是符合JS语法的，但这种编码风格是不好的。使用你这个函数的人会有点无所适从，不敢直接进行加减乘除，因为如果返回字符串进行运算的话值就是NaN了。函数的返回类型应该是要确定的，如下面是返回整型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getPrice(count)&#123;</span><br><span class=\"line\">    if(count &lt; 0) return -1;</span><br><span class=\"line\">    else return count \\* 100;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后告诉使用者，如果返回-1就表示不合法。如果类型确定，解释器也不用去做一些额外的工作，可以加快运行速度。</p>\n<h2 id=\"2-减少作用域查找\"><a href=\"#2-减少作用域查找\" class=\"headerlink\" title=\"2. 减少作用域查找\"></a>2. 减少作用域查找</h2><h3 id=\"（1）不要让代码暴露在全局作用域下\"><a href=\"#（1）不要让代码暴露在全局作用域下\" class=\"headerlink\" title=\"（1）不要让代码暴露在全局作用域下\"></a>（1）不要让代码暴露在全局作用域下</h3><p>例如以下运行在全局作用域的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var map &#x3D; document.querySelector(&quot;#my-map&quot;);</span><br><span class=\"line\">    map.style.height &#x3D; &quot;600px&quot;;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>有时候你需要在页面直接写一个script，要注意在一个script标签里面，代码的上下文都是全局作用域的，由于全局作用域比较复杂，查找比较慢。例如上面的map变量，第二行在使用的时候，需要在全局作用域查找一下这个变量，假设map是在一个循环里面使用，那可能就会有效率问题了。所以应该要把它搞成一个局部的作用域：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">!function()&#123;</span><br><span class=\"line\">    var map &#x3D; document.querySelector(&quot;#my-map&quot;);</span><br><span class=\"line\">    map.style.height &#x3D; &quot;600px&quot;;</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面用了一个function制造一个局部作用域，也可以用ES6的块级作用域。由于map这个变量直接在当前的局部作用域命中了，所以就不用再往上一级的作用域（这里是全局作用域）查找了，而局部作用域的查找是很快的。同时直接在全局作用域定义变量，会污染window对象。</p>\n<h3 id=\"（2）不要滥用闭包\"><a href=\"#（2）不要滥用闭包\" class=\"headerlink\" title=\"（2）不要滥用闭包\"></a>（2）不要滥用闭包</h3><p>闭包的作用在于可以让子级作用域使用它父级作用域的变量，同时这些变量在不同的闭包是不可见的。这样就导致了在查找某个变量的时候，如果当前作用域找不到，就得往它的父级作用域查找，一级一级地往上直到找到了，或者到了全局作用域还没找到。因此如果闭包嵌套得越深，那么变量查找的时间就越长。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getResult(count)&#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    function process()&#123;</span><br><span class=\"line\">        var factor &#x3D; 2;</span><br><span class=\"line\">        return count \\* factor - 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return process();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码定义了一个process函数，在这个函数里面count变量的查找时间要高于局部的factor变量。其实这里不太适合用闭包，可以直接把count传给process：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getResult(count)&#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    function process(count)&#123;</span><br><span class=\"line\">        var factor &#x3D; 2;</span><br><span class=\"line\">        return count \\* factor - 5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return process(count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样count的查找时间就和factor一样，都是在当前作用域直接命中。这个就启示我们如果某个全局变量需要频繁地被使用的时候，可以用一个局部变量缓存一下，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var url &#x3D; &quot;&quot;;</span><br><span class=\"line\">if(window.location.protocal &#x3D;&#x3D;&#x3D; &quot;https:&quot;)&#123;</span><br><span class=\"line\">    url &#x3D; &quot;wss:&#x2F;&#x2F;xxx.com&quot; + window.location.pathname + window.location.search;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>频繁地使用了window.location对象，所以可以先把它缓存一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var url &#x3D; &quot;&quot;;</span><br><span class=\"line\">var location &#x3D; window.location;</span><br><span class=\"line\">if(location.protocal &#x3D;&#x3D;&#x3D; &quot;https:&quot;)&#123;</span><br><span class=\"line\">    url &#x3D; &quot;wss:&#x2F;&#x2F;xxx.com&quot; + location.pathname + location.search;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>搞成了一个局变变量，这样查找就会明显快于全局的查找，代码也可以写少一点。</p>\n<h2 id=\"3-避免-的使用\"><a href=\"#3-避免-的使用\" class=\"headerlink\" title=\"3. 避免==的使用\"></a>3. 避免==的使用</h2><p>这里你可能会有疑问了，有些人喜欢用==，有些人喜欢用===，大家的风格不一样，你为什么要强制别人用===呢？习惯用==的人，不能仅仅是因为==比===少敲了一次键盘。为什么不提倡用==呢？</p>\n<h3 id=\"（1）如果你确定了变量的类型，那么就没必要使用-了，如下：\"><a href=\"#（1）如果你确定了变量的类型，那么就没必要使用-了，如下：\" class=\"headerlink\" title=\"（1）如果你确定了变量的类型，那么就没必要使用==了，如下：\"></a>（1）如果你确定了变量的类型，那么就没必要使用==了，如下：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if(typeof num !&#x3D; &quot;undefined&quot;)&#123; &#125; </span><br><span class=\"line\">var num &#x3D; parseInt(value);</span><br><span class=\"line\">if(num &#x3D;&#x3D; 10)&#123; &#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>上面的两个例子都是确定类型的，一个是字符串，一个是整数。就没必要使用==了，直接用===就可以了。</p>\n<h3 id=\"（2）如果类型不确定，那么应该手动做一下类型转换，而不是让别人或者以后的你去猜这里面有类型转换，如下：\"><a href=\"#（2）如果类型不确定，那么应该手动做一下类型转换，而不是让别人或者以后的你去猜这里面有类型转换，如下：\" class=\"headerlink\" title=\"（2）如果类型不确定，那么应该手动做一下类型转换，而不是让别人或者以后的你去猜这里面有类型转换，如下：\"></a>（2）如果类型不确定，那么应该手动做一下类型转换，而不是让别人或者以后的你去猜这里面有类型转换，如下：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var totalPage &#x3D; &quot;5&quot;;</span><br><span class=\"line\">if(parseInt(totalPage) &#x3D;&#x3D;&#x3D; 1)&#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（3）使用-在JSLint检查的时候是不通过的：\"><a href=\"#（3）使用-在JSLint检查的时候是不通过的：\" class=\"headerlink\" title=\"（3）使用==在JSLint检查的时候是不通过的：\"></a>（3）使用==在JSLint检查的时候是不通过的：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if(a &#x3D;&#x3D; b)&#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如下JSLint的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Expected ‘&#x3D;&#x3D;&#x3D;’ and instead saw ‘&#x3D;&#x3D;’. </span><br><span class=\"line\">if(a &#x3D;&#x3D; b)&#123; &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"（4）并且使用-可能会出现一些奇怪的现象，这些奇怪的现象可能会给代码埋入隐患：\"><a href=\"#（4）并且使用-可能会出现一些奇怪的现象，这些奇怪的现象可能会给代码埋入隐患：\" class=\"headerlink\" title=\"（4）并且使用==可能会出现一些奇怪的现象，这些奇怪的现象可能会给代码埋入隐患：\"></a>（4）并且使用==可能会出现一些奇怪的现象，这些奇怪的现象可能会给代码埋入隐患：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">null &#x3D;&#x3D; undefined        &#x2F;&#x2F;true</span><br><span class=\"line\">&#39;&#39; &#x3D;&#x3D; &#39;0&#39;&#x2F;&#x2F;false</span><br><span class=\"line\">0  &#x3D;&#x3D; &#39;&#39;&#x2F;&#x2F;true</span><br><span class=\"line\">0  &#x3D;&#x3D; &#39;0&#39;&#x2F;&#x2F;true</span><br><span class=\"line\">&#39;&#39; &#x3D;&#x3D; 0&#x2F;&#x2F;true</span><br><span class=\"line\">new String(&quot;abc&quot;) &#x3D;&#x3D; &quot;abc&quot;                      &#x2F;&#x2F;true</span><br><span class=\"line\">new Boolean(true) &#x3D;&#x3D; true                       &#x2F;&#x2F;true</span><br><span class=\"line\">true &#x3D;&#x3D; 1&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<p>上面的比较在用===的时候都是false，这样才是比较合理的。例如第一点null居然会等于undefined，就特别地奇怪，因为null和undefined是两个毫无关系的值，null应该是作为初始化空值使用，而undefined是用于检验某个变量是否未定义。 这和第1点介绍强类型的思想是相通的。</p>\n<h2 id=\"4-合并表达式\"><a href=\"#4-合并表达式\" class=\"headerlink\" title=\"4. 合并表达式\"></a>4. 合并表达式</h2><p>如果用1句代码就可以实现5句代码的功能，那往往1句代码的执行效率会比较高，并且可读性可能会更好</p>\n<h3 id=\"（1）用三目运算符取代简单的if-else\"><a href=\"#（1）用三目运算符取代简单的if-else\" class=\"headerlink\" title=\"（1）用三目运算符取代简单的if-else\"></a>（1）用三目运算符取代简单的if-else</h3><p>如上面的getPrice函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getPrice(count)&#123;</span><br><span class=\"line\">    if(count &lt; 0) return -1;</span><br><span class=\"line\">    else return count \\* 100;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以改成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getPrice(count)&#123;</span><br><span class=\"line\">    return count &lt; 0 ? return -1 : count \\* 100;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个比写一个if-else看起来清爽多了。当然，如果你写了if-else，压缩工具也会帮你把它改三目运算符的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getPrice(e)&#123;return 0&gt;e?-1:100\\*e&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（2）连等\"><a href=\"#（2）连等\" class=\"headerlink\" title=\"（2）连等\"></a>（2）连等</h3><p>连等是利用赋值运算表达式会返回所赋的值，并且执行顺序是从右到左的，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">overtime &#x3D; favhouse &#x3D; listingDetail &#x3D; &#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有时候你会看到有人这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var age &#x3D; 0;</span><br><span class=\"line\">if((age &#x3D; +form.age.value) &gt;&#x3D; 18)&#123;</span><br><span class=\"line\">    console.log(&quot;你是成年人&quot;);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    consoe.log(&quot;小朋友，你还有&quot; + (18 - age) + &quot;就成年了&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也是利用了赋值表达式会返回一个值，在if里面赋值的同时用它的返回值做判断，然后else里面就已经有值了。上面的+号把字符串转成了整数。</p>\n<h3 id=\"（3）自增\"><a href=\"#（3）自增\" class=\"headerlink\" title=\"（3）自增\"></a>（3）自增</h3><p>利用自增也可以简化代码。如下，每发出一条消息，localMsgId就自增1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">chatService.sendMessage(localMsgId++, msgContent);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-减少魔数\"><a href=\"#5-减少魔数\" class=\"headerlink\" title=\"5. 减少魔数\"></a>5. 减少魔数</h2><p>例如，在某个文件的第800行，冒出来了一句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dialogHandler.showQuestionNaire（&quot;seller&quot;, &quot;sell&quot;, 5, true);</span><br></pre></td></tr></table></figure>\n\n<p>就会让人很困惑了，上面的四个常量分别代表什么呢，如果我不去查一个那个函数的变量说明就不能够很快地意会到这些常量分别有什么用。这些意义不明的常量就叫“魔数”。 所以最好还是给这些常量取一个名字，特别是在一些比较关键的地方。例如上面的代码可改成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var naireType &#x3D; &quot;seller&quot;,</span><br><span class=\"line\">dialogType &#x3D; &quot;sell&quot;,</span><br><span class=\"line\">questionsCount &#x3D; 5,</span><br><span class=\"line\">reloadWindow &#x3D; true;</span><br><span class=\"line\"></span><br><span class=\"line\">naireHandler.showNaire(naireType, dialogType, questionsCount, reloadWindow);</span><br></pre></td></tr></table></figure>\n\n<p>这样意义就很明显了。</p>\n<h2 id=\"6-使用ES6简化代码\"><a href=\"#6-使用ES6简化代码\" class=\"headerlink\" title=\"6. 使用ES6简化代码\"></a>6. 使用ES6简化代码</h2><p>ES6已经发展很多年了，兼容性也已经很好了。恰当地使用，可以让代码更加地简洁优雅。</p>\n<h3 id=\"（1）使用箭头函数取代小函数\"><a href=\"#（1）使用箭头函数取代小函数\" class=\"headerlink\" title=\"（1）使用箭头函数取代小函数\"></a>（1）使用箭头函数取代小函数</h3><p>有很多使用小函数的场景，如果写个function，代码起码得写3行，但是用箭头函数一行就搞定了，例如实现数组从大到小排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var nums &#x3D; [4, 8, 1, 9, 0];</span><br><span class=\"line\">nums.sort(function(a, b)&#123;</span><br><span class=\"line\">    return b - a;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#x2F;&#x2F;输出[9, 8, 4, 1, 0]</span><br></pre></td></tr></table></figure>\n\n<p>如果用箭头函数，排序只要一行就搞定了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var nums &#x3D; [4, 8, 1, 9, 0];</span><br><span class=\"line\"></span><br><span class=\"line\">nums.sort(a, b &#x3D;&gt; b - a);</span><br></pre></td></tr></table></figure>\n\n<p>代码看起来简洁多了，还有setTimeout里面经常会遇到只要执行一行代码就好了，写个function总感觉有点麻烦，用字符串的方式又不太好，所以这种情况用箭头函数也很方便：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">setTimeout(() &#x3D;&gt; console.log(&quot;hi&quot;), 3000)</span><br></pre></td></tr></table></figure>\n\n<p>箭头函数在C++/Java等其它语言里面叫做Lambda表达式，Ruby比较早就有这种语法形式了，后来C++/Java也实现了这种语法。 当然箭头函数或者Lambda表达式不仅适用于这种一行的，多行代码也可以，不过在一行的时候它的优点才比较明显。</p>\n<h3 id=\"（2）使用ES6的class\"><a href=\"#（2）使用ES6的class\" class=\"headerlink\" title=\"（2）使用ES6的class\"></a>（2）使用ES6的class</h3><p>虽然ES6的class和使用function的prototype本质上是一样的，都是用的原型。但是用class可以减少代码量，同时让代码看起来更加地高大上，使用function要写这么多：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Person(name, age)&#123;</span><br><span class=\"line\">    this.name &#x3D; name;</span><br><span class=\"line\">    this.age &#x3D; age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.addAge &#x3D; function()&#123;</span><br><span class=\"line\">    this.age++;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.setName &#x3D; function(name)&#123;</span><br><span class=\"line\">    this.name &#x3D; name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>使用class代码看加地简洁易懂：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    constructor(name, age)&#123;</span><br><span class=\"line\">        this.name &#x3D; name;</span><br><span class=\"line\">        this.age &#x3D; age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addAge()&#123;</span><br><span class=\"line\">        this.age++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setName(name)&#123;</span><br><span class=\"line\">        this.name &#x3D; name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且class还可以很方便地实现继承、静态的成员函数，就不需要自己再去通过一些技巧去实现了。</p>\n<h3 id=\"（3）字符串拼接\"><a href=\"#（3）字符串拼接\" class=\"headerlink\" title=\"（3）字符串拼接\"></a>（3）字符串拼接</h3><p>以前要用+号拼接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var tpl &#x3D; </span><br><span class=\"line\">    &#39;&lt;div&gt;&#39; + </span><br><span class=\"line\">    &#39;    &lt;span&gt;1&lt;&#x2F;span&gt;&#39; +</span><br><span class=\"line\">    &#39;&lt;&#x2F;div&gt;&#39;;</span><br></pre></td></tr></table></figure>\n\n<p>现在只要用两个反引号“`”就可以了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var tpl &#x3D; </span><br><span class=\"line\">    &#96;&lt;div&gt;</span><br><span class=\"line\">        &lt;span&gt;1&lt;&#x2F;span&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &#96;;</span><br></pre></td></tr></table></figure>\n\n<p>另外反引号还支持占位替换，原本你需要：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var page &#x3D; 5,</span><br><span class=\"line\">type &#x3D; encodeURIComponet(&quot;#js&quot;);</span><br><span class=\"line\">var url &#x3D; &quot;&#x2F;list?page&#x3D;&quot; + page + &quot;&amp;type&#x3D;&quot; + type;</span><br></pre></td></tr></table></figure>\n\n<p>现在只需要： <code>var url = `/list?page=$&#123;page&#125;&amp;type=$&#123;type&#125;`;</code> 就不用使用+号把字符串拆散了。</p>\n<h3 id=\"（4）块级作用域变量\"><a href=\"#（4）块级作用域变量\" class=\"headerlink\" title=\"（4）块级作用域变量\"></a>（4）块级作用域变量</h3><p>块级作用域变量也是ES6的一个特色，下面的代码是一个任务队列的模型抽象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var tasks &#x3D; [];</span><br><span class=\"line\">for(var i &#x3D; 0; i &lt; 4; i++)&#123;</span><br><span class=\"line\">    tasks.push(function()&#123;</span><br><span class=\"line\">        console.log(&quot;i is &quot; + i);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for(var j &#x3D; 0; j &lt; tasks.length; j++)&#123;</span><br><span class=\"line\">    tasks[j]();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是上面代码的执行输出是4，4，4，4，并且不是想要输出：0，1，2，3，所以每个task就不能取到它的index了，这是因为闭包都是用的同一个i变量，i已经变成4了，所以执行闭包的时候就都是4了。那怎么办呢？可以这样解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var tasks &#x3D; [];</span><br><span class=\"line\">for(var i &#x3D; 0; i &lt; 4; i++)&#123;</span><br><span class=\"line\">    !function(k)&#123;</span><br><span class=\"line\">        tasks.push(function()&#123;</span><br><span class=\"line\">            console.log(&quot;i is &quot; + k);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for(var j &#x3D; 0; j &lt; tasks.length; j++)&#123;</span><br><span class=\"line\">    tasks[j]();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把i赋值给了k，由于k它是一个function的一个参数，每次执行函数的时候，肯定会实例化新的k，所以每次的k都是不同的变量，这样就输出就正常了。 但是代码看起来有点别扭，如果用ES6，只要把var改成let就可以了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var tasks &#x3D; [];</span><br><span class=\"line\">for(let i &#x3D; 0; i &lt;&#x3D; 4; i++)&#123;</span><br><span class=\"line\">    tasks.push(function()&#123;</span><br><span class=\"line\">        console.log(&quot;i is &quot; + i);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for(var j &#x3D; 0; j &lt; tasks.length; j++)&#123;</span><br><span class=\"line\">    tasks[j]();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只改动了3个字符就达到了目的。因为for循环里面有个大括号，大括号就是一个独立的作用域，let定义的变量在独立的作用域里面它的值也是独立的。当然即使没写大括号for循环执行也是独立的。 除了以上几点，ES6还有其它一些比较好用的功能，如Object的assign，Promise等，也是可以帮助写出简洁高效的代码。</p>\n","categories":["JavaScript"],"tags":["javascript","javascript教程","前端开发","前端教程"]},{"title":"学习了解CSS逻辑属性和值（CSS Logical Properties and Values）","url":"/2019/01/19/%E5%AD%A6%E4%B9%A0%E4%BA%86%E8%A7%A3css%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E5%92%8C%E5%80%BC/","content":"<p>在了解本文时可先查看本博客就是使用的新的语法样式搭建的， 2017年5月18日，W3C的 <a href=\"https://www.w3.org/Stlye/CSS/Members/\">CSS工作组（CSS Working Group）</a> 发布了 <a href=\"https://www.w3.org/TR/2017/WD-css-logical-1-20170518/\">CSS逻辑属性和值（CSS Logical Properties and Values Level 1）</a> 的首份工作草案（First Public Working Draft）。不同的书写模式（writing mode）中，可以抽取出共性的抽象概念（如开始位置，或行），这些逻辑抽象概念需要在不同书写模式下映射到左或右、上或下等物理的概念上。一些CSS布局可能依赖这些共性的逻辑概念。该 CSS 模块给出了用于通过逻辑方式（而不是基于物理坐标、书写方向和维映射等）控制布局的逻辑属性和取值（logical properties and values）。这个模块来源于CSS21中关于逻辑属性和值的特性。 在过去，CSS属性运用于物理维度（尺寸）和方向，将元素的位置映射到<code>left</code>、<code>right</code>、<code>top</code>或<code>bottom</code>。使用<code>float</code>可以让一个元素向左或向右浮动，可以使用<code>position</code>的<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>定位元素的偏移量。使用比如<code>margin-top</code>或<code>padding-top</code>来设置<code>margin</code>、<code>padding</code>和<code>border</code>的值。这些特理属性和值在<code>top</code>、<code>right</code>、<code>bottom</code>和left 和书写模式有很大的关系，书写模式可以直接改变其方向。比如： 当书写模式<code>direction</code>是<code>rtl</code>（从右向左）时，<code>margin-left</code>不再是让该元素距其侧元素有多少间距了，而是变成了该元素距右侧元素之间有多少间距 如果你使用垂直书写模式，无论是在整个布局中还是在某些元素中，都没有什么意义。这篇文章中接下来将解释CSS如何改变这些，并且可以支持书写模式。在这个过程中，可以解释清楚一些关于Flexbox和Grid布局中一些令人感到困惑的一些事情。 当第一次开始使用CSS Grid并向大家解释其规范时，我注意到<code>grid-area</code>属性被用于<code>grid-row-start</code>、<code>grid-row-end</code>、<code>grid-column-start</code>和<code>grid-column-end</code>四个属性的简写属性。因此，下面三种书写方式，其达到的效果都是相同的：</p>\n<p>.item {<br>    grid-row-start: 1;<br>    grid-column-start: 2;<br>    grid-row-end: 3;<br>    grid-column-end: 4;<br>}</p>\n<p>.item {<br>    grid-row: 1 / 3;<br>    grid-column: 2 / 4;<br>}</p>\n<p>.item {<br>    grid-area: 1 / 2 / 3 / 4;<br>}</p>\n<p>grid-area对应的顺序如下：</p>\n<ul>\n<li>  grid-row-start</li>\n<li>  grid-column-start</li>\n<li>  grid-row-end</li>\n<li>  grid-column-end</li>\n</ul>\n<p>这里有两个关键词<code>*-start</code>和<code>*-end</code>，而我们以前接触的CSS属性，比如<code>margin</code>、<code>padding</code>和<code>border</code>之类的都是以<code>*-top</code>、<code>*-right</code>、<code>*-bottom</code>和<code>*-left</code>。那么为什么会是如此呢？如果仔细观察，它们实际上是按照相反的顺序排列的：<code>top</code>、<code>left</code>、<code>bottom</code>和<code>right</code>。这样一来，CSS工作组不是把事情变得更为困难了？ 答案是，这些值 已经偏离了一个基本的假设，即Web上的内容映射到屏幕的物理尺寸，一个句子的第一个单词位于其所在框的左上角。如果你从未遇到过我们用简写的属性设置这些值，那么<code>grid-area</code>中的行顺序就变得完全有意义了。我们先设置了两个起始位置（行和列的起始位置），然后设置两个结束位置（行和列的结束位置）。 这意味着，如果书写模式改为垂直模式，那么块的位置仍然相对于文档的书写模式，而不是屏幕的物理属性。这样理解可能有点困惑。咱们来看看@Rachel Andrew在Codepen上给我们提供的一个示例：</p>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/yvGEbZ/\">Grid and writing-mode</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>了解了书写模式的这个事实，也就解释清楚了为什么Flexbox和Grid是指开始和结束行，而不是将网格映射到top、right、bottom和left的物理维度上。 了解写入模式的这一事实也解释了为什么CSS Grid和Flexbox引用<code>start</code>和<code>end</code>排列而不是将网格映射到<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>的物理维度上，就像我们使用绝对定位一样。在上面的示例中，第一个项目使用<code>grid-area</code>基于行的定位定位。</p>\n<p>grid-area: 1 / 2 / 3 / 4;</p>\n<p>如果我们使用的是手写是这样的：</p>\n<p>grid-row-start: 1;<br>grid-column-start: 2;<br>grid-row-end: 3;<br>grid-column-end: 4;</p>\n<p>我们设置两个起始行，首先是阻塞轴，然后是第二个内联轴，然后按照相同的模式设置每个维度中的结束行。无论网格布局如何，起始线和结束线都保持相对于网格和文档的写入模式。</p>\n<h2 id=\"块和内联维度\"><a href=\"#块和内联维度\" class=\"headerlink\" title=\"块和内联维度\"></a>块和内联维度</h2><p>我已经提到了一些对于理解新布局，块和内联维度的概念至关重要的东西。当你使用新的CSS时，这些术语将不断涌现。这两个维度在网格布局的上下文中相当容易理解，因为我们在网格布局中工作时总是使用块和内联轴，所以我将使用网格演示来解释。 块维度对应于在页面上布置块的顺序。比如你d的页面中有一大段文本内容。每个段落都是一个在另一段下面排列，这些排列的方向是块的维度，所以在网格布局中，这是块轴。 在CSS网格布局中，块轴也称为行轴，这就是块轴属性为<code>grid-row-start</code>和的原因<code>grid-row-end</code>。 <img src=\"http://file.w3cbest.com/file/images/block-row-axis.png\"> 因此，内联轴将会穿过块轴，沿着词在句子中的方向分布。在英文语句中，这个轴从左到右。在网格布局中，内联轴属性是<code>grid-column-start</code>和<code>grid-column-end</code>。 <img src=\"http://file.w3cbest.com/file/images/inline-column-axis.png\"> 如果我们把书写模式改变<code>vertical-lr</code>（垂直模式），这意味着块轴垂直运行，而内联轴沿着直线从上到下。 <img src=\"http://file.w3cbest.com/file/images/block-inline-vertical-column-axis.png\"> 因此，如果我们谈论块维度，其实对应的是描述文本段落在普通文档流中布局的方向，内联维度是句子运行的方向。</p>\n<h2 id=\"逻辑属性\"><a href=\"#逻辑属性\" class=\"headerlink\" title=\"逻辑属性\"></a>逻辑属性</h2><p>所谓CSS逻辑属性，指的是<code>*-start</code>，<code>*-end</code>以及<code>*-inline-start</code>，<code>*-inline-end</code>，<code>*-block-start</code>，<code>*-block-start</code>这类CSS属性，其最终渲染的方向是有逻辑性在里面的。 例如<code>margin-left</code>方向是固定的，就左侧间距，没有逻辑；但是，<code>margin-start</code>有可能是左间距，也有可能是右间距，例如，对于内联元素，如果<code>direction</code>属性值是<code>rtl</code>，则<code>margin-start</code>的表现等同于<code>margin-right</code>，如果属性值是<code>ltr</code>，则<code>margin-start</code>的表现等同于<code>margin-left</code>，就表现出了逻辑判断在里面，因此，成为CSS逻辑属性。</p>\n<h2 id=\"逻辑维度\"><a href=\"#逻辑维度\" class=\"headerlink\" title=\"逻辑维度\"></a>逻辑维度</h2><p>逻辑属性定义块和内联维度的开始和结束属性。对于高度和宽度属性，我们改为使用<code>block-size</code>和<code>inline-size</code>。我们还可以设置<code>max-block-size</code>、<code>min-block-size</code>、<code>max-inline-size</code>和<code>min-inline-size</code>。如果您使用的是英语，则从上到下的横向语言<code>block-size</code>是指<code>height</code>屏幕上块<code>inline-size</code>的物理特性<code>width</code>，即物品的物理特性。如果您使用的是垂直运行的语言，那么当您查看屏幕时，<code>block-size</code>将会出现控制<code>width</code>和<code>inline-size</code>高度的情况。 您可以在下面的演示中看到这一点。我的块是<code>block-size: 150px</code>和<code>inline-size: 250px</code>组成。更改<code>writing-mode</code>属性以查看布局如何调整。</p>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/paqZvz/\">Block and Inline Size demo</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>逻辑边界(border) 我们来回忆一下物理属性边界的工作方式，边界(border)的物理属性是：</p>\n<ul>\n<li>  border-top</li>\n<li>  border-top-width</li>\n<li>  border-top-style</li>\n<li>  border-top-color</li>\n<li>  border-right</li>\n<li>  border-right-width</li>\n<li>  border-right-style</li>\n<li>  border-right-color</li>\n<li>  border-bottom</li>\n<li>  border-bottom-width</li>\n<li>  border-bottom-style</li>\n<li>  border-bottom-color</li>\n<li>  border-left</li>\n<li>  border-left-width</li>\n<li>  border-left-style</li>\n<li>  border-left-color</li>\n</ul>\n<p>现在它们具有逻辑映射，这些映射变得有点冗余：</p>\n<ul>\n<li>  border-block-start</li>\n<li>  border-block-start-width</li>\n<li>  border-block-start-style</li>\n<li>  border-block-start-color</li>\n<li>  border-inline-start</li>\n<li>  border-inline-start-width</li>\n<li>  border-inline-start-style</li>\n<li>  border-inline-start-color</li>\n<li>  border-block-end</li>\n<li>  border-block-end-width</li>\n<li>  border-block-end-style</li>\n<li>  border-block-end-color</li>\n<li>  border-inline-end</li>\n<li>  border-inline-end-width</li>\n<li>  border-inline-end-style</li>\n<li>  border-inline-end-color</li>\n</ul>\n<p>在以下示例中，有两个访客，第一个使用逻辑属性来设置<code>border-block-start-color: green</code>和<code>border-inline-end-style:dotted</code>。第二个使用物理属性<code>border-top-color: green</code>和<code>border-right-style:dotted</code>。我们通过改变<code>write-mode</code>的属性值，来看一下<code>border</code>的物理属性和逻辑属性之间的差异：</p>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/RQEYbm/\">Logical borders</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"margin和padding\"><a href=\"#margin和padding\" class=\"headerlink\" title=\"margin和padding\"></a>margin和padding</h2><p>margin和padding和border属性一样，其物理属性为：</p>\n<ul>\n<li>  margin-top</li>\n<li>  margin-left</li>\n<li>  margin-bottom</li>\n<li>  margin-right</li>\n<li>  padding-top</li>\n<li>  padding-right</li>\n<li>  padding-bottom</li>\n<li>  padding-left</li>\n</ul>\n<p>它们具有如下逻辑属性：</p>\n<ul>\n<li>  margin-block-start</li>\n<li>  margin-inline-start</li>\n<li>  margin-inline-start</li>\n<li>  margin-inline-end</li>\n<li>  padding-block-start</li>\n<li>  padding-inline-start</li>\n<li>  padding-inline-start</li>\n<li>  padding-inline-end</li>\n</ul>\n<p>在下一个示例中，我已设置<code>padding-block-start</code>第一个块，而<code>padding-top</code>在第二个块中，我们通过改变<code>write-mode</code>的属性值，来看一下物理属性和逻辑属性之间的差异：</p>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/OQrorW/\">Logical properties - padding</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"position的位移属性\"><a href=\"#position的位移属性\" class=\"headerlink\" title=\"position的位移属性\"></a>position的位移属性</h2><p>使用物理属性的另一个地方是使用属性定位事物<code>position</code>。在设置<code>position: absolute</code>或<code>position</code>除<code>static</code>我们的默认值之外的其他值之后，可以使用偏移来定位项目，无论是来自视口还是来自已创建新定位上下文的父项。 偏移物理属性是：</p>\n<ul>\n<li>  top</li>\n<li>  right</li>\n<li>  bottom</li>\n<li>  left</li>\n</ul>\n<p>按照我们其他逻辑属性的模式，我们得到：</p>\n<ul>\n<li>  offset-block-start</li>\n<li>  offset-inline-start</li>\n<li>  offset-block-end</li>\n<li>  offset-inline-end</li>\n</ul>\n<p>请在下面的示例中尝试这些。带边框的盒子<code>position: relative</code>和小紫色方块<code>position: absolute</code>。在物理示例的正方形被定位<code>top: 50px</code>和<code>right: 20px</code>。逻辑版本有<code>offset-block-start: 50px</code>和<code>offset-inline-end: 20px</code>。</p>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/QQzZwm/\">Logical offsets</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>逻辑值 我们习惯使用物理尺寸的另一个地方是我们漂浮或清理东西。因为<code>float</code>，<code>clear</code> 我们有一些left和right值的逻辑版本。</p>\n<ul>\n<li>  inline-start</li>\n<li>  inline-end</li>\n</ul>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/XZoOGb/\">floating with logical values</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>在演示中，我将紫色块浮动到逻辑版本中<code>inline-start</code>。我也使用逻辑属性作为保证金; 这样可以确保边距始终位于块之后，并且在包围它的内容之前。通过选择<code>vertical-rl</code>下拉列表中的值，您可以看到物理示例中的边距如何在块的右侧结束，而不是在<code>-end</code>方向上应用。 <img src=\"http://file.w3cbest.com/file/images/float-margins-side.png\"> 还有<code>start</code>和<code>end</code>值<code>text-align</code>。对齐要启动的内容将使其与内联轴的起点对齐，直到内联轴<code>end</code>的末端，无论写入模式是水平还是垂直。</p>\n<h2 id=\"今天使用逻辑属性和值\"><a href=\"#今天使用逻辑属性和值\" class=\"headerlink\" title=\"今天使用逻辑属性和值\"></a>今天使用逻辑属性和值</h2><p><a href=\"http://caniuse.com/#feat=css-logical-props\">Can I Use css-logical-props?</a> Data on support for the css-logical-props feature across the major browsers from caniuse.com.</p>\n<p>如前所述，目前逻辑属性和值的浏览器支持很少。但是，如果您现在想要开始使用它们，并且选项是使用它们编写CSS，然后使用PostCSS插件将逻辑属性和值转换为它们的物理对应物。<a href=\"https://github.com/jonathantneal/postcss-logical-properties\">Jonathan Neal的这个插件</a>涵盖了我在本文中描述的所有属性和值。 即使您现在决定不使用这些属性，了解它们的工作方式也是使用新布局的关键理解。将Grid或Flex布局描述为具有起始和结束线，考虑块和内联维度，这些将使得更容易理解布局的工作原理。 进一步阅读</p>\n<ul>\n<li>  MDN Web Docs具有列出的<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties\">所有逻辑属性和值</a>以及其他示例。</li>\n<li>  <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/CSS_Grid,_Logical_Values_and_Writing_Modes\">CSS网格，逻辑值和写入模式</a>，MDN</li>\n<li>  <a href=\"https://24ways.org/2016/css-writing-modes/\">CSS写作模式</a>，Jen Simmons，24种方式</li>\n</ul>\n<p>文章来源：<a href=\"https://www.smashingmagazine.com/2018/03/understanding-logical-properties-values/\">https://www.smashingmagazine.com</a></p>\n","categories":["HTML/CSS"],"tags":["*-block-end","*-block-start","*-inline-end","*-inline-start","CSS Logical","css逻辑","wrioting-mode"]},{"title":"学习如何用CSS变量创建网页响应布局 — css var()","url":"/2019/01/14/%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E7%94%A8css%E5%8F%98%E9%87%8F%E5%88%9B%E5%BB%BA%E7%BD%91%E9%A1%B5%E5%93%8D%E5%BA%94%E5%B8%83%E5%B1%80/","content":"<p>在创新的2018年已经过去，在2019年看看如何简单做成响应性的网站 如果你未曾听说过<a href=\"http://www.w3cbest.com/?p=240\">CSS变量</a>，那么我告诉你，它就是CSS的一种新功能，可以让你拥有在样式表中使用变量的能力，这样做时并不需要什么特别的设置呦。 从本质上讲，<a href=\"http://www.w3cbest.com/?p=240\">CSS变量</a>可以让你摆脱老式的样式设置：</p>\n<p>h1 {<br>    font-size: 30px;<br>}</p>\n<p>navbar&gt;a {<br>    font-size: 30px;<br>}</p>\n<p>…而是主张这样写：</p>\n<p>:root {<br>    –base-font-size: 30px;<br>}<br>h1 {<br>    font-size: var(–base-font-size);<br>}<br>navbar&gt;a {<br>    font-size: var(–base-font-size);<br>}</p>\n<p>这样的语法看起来的确有点怪怪的，但有没有觉得它和less、sass中的变量有点类似呢，但如此一来，只要更改–base-font-size 变量，就能在整个应用中改变字号了。 如果你想把<a href=\"http://www.w3cbest.com/?p=240\">CSS变量</a>学明白，可以在Scrimba网站 这里有<a href=\"https://scrimba.com/g/gcssvariables\">免费互动CSS变量课程</a>，该课程包含8个互动截屏。</p>\n<h2 id=\"今天来讲一下如何用CSS变量创建响应布局\"><a href=\"#今天来讲一下如何用CSS变量创建响应布局\" class=\"headerlink\" title=\"今天来讲一下如何用CSS变量创建响应布局\"></a>今天来讲一下如何用CSS变量创建响应布局</h2><p>这是一段html</p>\n<ul class=\"item\">\n    <li>item 1</li>\n    <li>item 2</li>\n    <li>item 3</li>\n    <li>item 4</li>\n</ul>\n\n<p> </p>\n<h3 id=\"老方法：\"><a href=\"#老方法：\" class=\"headerlink\" title=\"老方法：\"></a>老方法：</h3><p>在以前即使不使用CSS变量也可以把这些事情搞定。只是需要把要改变的属性在重新重置一下，需要在媒体查询中拥有自己的选择器，但会招致额外的大量代码，像下面这样：</p>\n<p>.item {<br>    display: flex;<br>    flex-direction: column;<br>    flex-wrap: wrap;<br>    justify-content: space-around;<br>    padding: 10px;</p>\n<pre><code>li &#123;\n    background-color: #ff6f69;\n    border: 1px solid #fff;\n    font-size: 20px;\n    height: 200px;\n    list-style-type: none;\n    width: 100%;\n&#125;\n</code></pre>\n<p>}</p>\n<p>@media (min-width: 768px) {<br>    .item {<br>        flex-direction: row;<br>        li {<br>            background-color: #ffcc5c;<br>            font-size: 50px;<br>            height: 300px;<br>            width: 50%;<br>        }<br>    }<br>}</p>\n<p>@media (min-width: 992px) {<br>    .item {<br>        flex-wrap: nowrap;<br>        li {<br>            background-color: #ffeead;<br>            font-size: 100px;<br>            height: 500px;<br>            width: calc(100% / 4);<br>        }<br>    }<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/roovdK/\">CSS media</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p> </p>\n<h3 id=\"新方法\"><a href=\"#新方法\" class=\"headerlink\" title=\"新方法\"></a>新方法</h3><p>下面让我们来看如何使用<a href=\"http://www.w3cbest.com/?p=240\">CSS变量</a>来解决这个问题。首先，要把我们将重复利用和更改的数值存储在变量的内部：</p>\n<p>:root {<br>–base-color: #ff6f69;<br>–base-font-size: 20px;<br>–direction: column;<br>–width: 100%;<br>–height: 200px;<br>}</p>\n<p>然后，在整个页面中简单地使用这些变量就行了：</p>\n<p>.item {<br>  display: flex;<br>  padding: 10px;<br>  justify-content: space-around;<br>  flex-direction: var(–direction);<br>  flex-wrap: var(–wrap);<br>  li{<br>    list-style-type: none;<br>    border: 1px solid #fff;<br>    height: var(–height);<br>    width: var(–width);<br>    background-color: var(–base-color);<br>    font-size: var(–base-font-size);<br>  }<br>}</p>\n<p>一旦进行了这样的设置之后，我们只要在媒体查询中简单地更改变量值就行了：</p>\n<p>@media (min-width: 768px) {<br>  :root {<br>    –base-font-size: 60px;<br>    –base-color: #ffcc5c;<br>    –direction: row;<br>    –height: 300px;<br>    –width: 50%;<br>    –wrap:wrap;<br>  }<br>}<br>@media (min-width: 992px) {<br>  :root {<br>    –base-font-size: 100px;<br>    –base-color: #ffeead;<br>    –direction: row;<br>    –height: 500px;<br>    –width: calc(100% / 4);<br>    –wrap:nowrap;<br>  }<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/NeeYYK/\">CSS Variables</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>  这比我们以往的方法简便多了。只需盯住 :root，而不必为所有的选择器指定值了。 这只是一个简单的例子。设想成熟的网站会是什么样子吧，例如，用 –base-margin 来控制APP四周的多数自由空间。想翻转其值也是很容易的事情，不必用复杂的选择器来填充媒体查询了。 总之，CSS变量绝对是提高响应速度时，所代表的未来。</p>\n","categories":["HTML/CSS"],"tags":["css var()","CSS Variables","css函数","css 布局","布局","相应布局"]},{"title":"实现深拷贝的几种方法来区别深拷贝与浅拷贝","url":"/2019/01/16/%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%9D%A5%E5%8C%BA%E5%88%AB%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","content":"<p>以前面试的时候面试官总是会问深拷贝与浅拷贝，那个时候回答不上来，其实是在工作中没涉及到这个问题，基本上都是拿到数据修改一下有还给后端了，没有在本地做过处理停留。 经过时间的积累工作年份的增加，这个深拷贝与浅拷贝问题也就开始涉及到了，如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，如果B没变，那就是深拷贝。 我们来举一个例子</p>\n<p>var a = [0,1,2,3,4],<br>b = a;<br>a[0] = 6<br>console.log(a, b)</p>\n<p><img src=\"http://file.w3cbest.com/file/images/deepclone20190116163428.jpg\"> 然后看打印结果b复制了a，可是修改了a后b也跟着变化了，为什么呢？那么这里，就得引入基本数据类型与引用数据类型的概念了。</p>\n<h2 id=\"基本数据类型（存放在栈中）\"><a href=\"#基本数据类型（存放在栈中）\" class=\"headerlink\" title=\"基本数据类型（存放在栈中）\"></a>基本数据类型（存放在栈中）</h2><p>基本数据类型(值类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。 基本数据类型是指存放在栈中的简单数据段，数据大小确定，内存空间大小可以分配，它们是直接按值存放的，所以可以直接按值访问</p>\n<p>var a = 10,<br>b = a,<br>b = 20;<br>console.log(a); // 10值<br>console.log(b); // 20值</p>\n<p>下图演示了这种基本数据类型赋值的过程： <img src=\"http://file.w3cbest.com/file/images/deepclone20190116163429.jpg\">  </p>\n<h2 id=\"引用数据类型（存放在堆内存中的对象，每个空间大小不一样，要根据情况进行特定的配置）\"><a href=\"#引用数据类型（存放在堆内存中的对象，每个空间大小不一样，要根据情况进行特定的配置）\" class=\"headerlink\" title=\"引用数据类型（存放在堆内存中的对象，每个空间大小不一样，要根据情况进行特定的配置）\"></a>引用数据类型（存放在堆内存中的对象，每个空间大小不一样，要根据情况进行特定的配置）</h2><p>引用数据类型：对象(Object)、数组(Array)、函数(Function)。 引用类型是存放在堆内存中的对象，变量其实是保存的在栈内存中的一个指针（保存的是堆内存中的引用地址），这个指针指向堆内存。 引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象</p>\n<p>var obj1 = new Object();<br>var obj2 = obj1;<br>obj2.name = “我有名字了”;<br>console.log(obj1.name); // 我有名字了</p>\n<p>说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给obj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，但是实际上他们共同指向了同一个堆内存对象，所以修改obj2其实就是修改那个对象，所以通过obj1访问也能访问的到。 <img src=\"http://file.w3cbest.com/file/images/deepclone20190116163430.jpg\"></p>\n<p>var a = [1,2,3,4,5];<br>var b = a;//传址 ,对象中传给变量的数据是引用类型的，会存储在堆中；<br>var c = a[0];//传值，把对象中的属性/数组中的数组项赋值给变量，这时变量C是基本数据类型，存储在栈内存中；改变栈中的数据不会影响堆中的数据<br>alert(b);//1,2,3,4,5<br>alert(c);//1<br>//改变数值<br>b[4] = 6;<br>c = 7;<br>alert(a[4]);//6<br>alert(a[0]);//1</p>\n<p>从上面我们可以得知，当我改变b中的数据时，a中数据也发生了变化；但是当我改变c的数据值时，a却没有发生改变。 这就是传值与传址的区别。因为a是数组，属于引用类型，所以它赋予给b的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象。而c仅仅是从a堆内存中获取的一个数据值，并保存在栈中。所以b修改的时候，会根据地址回到a堆中修改，c则直接在栈中修改，并且不能指向a堆内存中。 <img src=\"http://file.w3cbest.com/file/images/deepclone20190116163435.jpg\"></p>\n<h2 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h2><h3 id=\"通过slice方法\"><a href=\"#通过slice方法\" class=\"headerlink\" title=\"通过slice方法\"></a>通过slice方法</h3><p>var a = [1,2,3,4],<br>    b = a.slice(0);<br>a[0] = 2;<br>console.log(a,b);</p>\n<p><img src=\"http://file.w3cbest.com/file/images/deepclone20190116163441.jpg\"> 看到打印结果说明slice方法已经进行拷贝了，毕竟b没有受a的影响，我们把a改一下</p>\n<p>var a = [0,1,[2,3],4],<br>    b = a.slice(0);<br>a[0] = 1;<br>a[2][0] = 1;<br>console.log(a,b);</p>\n<p><img src=\"http://file.w3cbest.com/file/images/deepclone20190116163442.jpg\"> 看到打印结果说明拷贝的不彻底，b对象的一级属性没有受到影响，但是二级属性还是没能拷贝成功，没有脱离a的控制，说明slice()只能进行浅拷贝。 这里引用知乎问答里面的一张图 <img src=\"http://file.w3cbest.com/file/images/deepclone20190116163450.jpg\"> 第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。 同理，concat()方法与slice()也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。</p>\n<h2 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h2><p>我们怎么去实现深拷贝呢，这里可以利用递归去复制所有层级属性。我们封装一个深拷贝的函数</p>\n<p>function deepClone(obj){<br>    var objClone = Array.isArray(obj)?[]:{};<br>    if(obj &amp;&amp; typeof obj===”object”){<br>        for(key in obj){<br>            if(obj.hasOwnProperty(key)){<br>                //判断ojb子元素是否为对象，如果是，递归复制<br>                if(obj[key]&amp;&amp;typeof obj[key] ===”object”){<br>                    objClone[key] = deepClone(obj[key]);<br>                }else{<br>                    //如果不是，简单复制<br>                    objClone[key] = obj[key];<br>                }<br>            }<br>        }<br>    }<br>    return objClone;<br>}<br>var a = [1,2,3,4],<br>b = deepClone(a);<br>a[0] = 2;<br>console.log(a,b);</p>\n<p>var a = [0,1,[2,3],4],<br>    b = deepClone(a);<br>a[0] = 1;<br>a[2][0] = 1;<br>console.log(a,b);</p>\n<p>可以看到 <img src=\"http://file.w3cbest.com/file/images/deepclone20190116163440.jpg\"> 跟之前想象的一样，现在b脱离了a的控制，不受a影响了。所以说深拷贝就是拷贝对象各个层级的属性</p>\n<h3 id=\"借用JSON对象的parse和stringify\"><a href=\"#借用JSON对象的parse和stringify\" class=\"headerlink\" title=\"借用JSON对象的parse和stringify\"></a>借用JSON对象的parse和stringify</h3><p>function deepClone(obj){<br>    return JSON.parse(JSON.stringify(obj));<br>}<br>var a = [0,1,[2,3],4],<br>    b = deepClone(a);<br>a[0] = 1;<br>a[2][0] = 1;<br>console.log(a,b);</p>\n<p><img src=\"http://file.w3cbest.com/file/images/deepclone20190116163442.jpg\"> 可以看到，这下b是完全不受a的影响了。 有可能还不太明白JSON.stringify() 和 JSON.parse() 拷贝的时候是怎么样的一个原理，其实首先得明白JSON.stringify()与JSON.parse()的作用，我们可以这样理解，前者能将一个对象转为json字符串(基本类型)，后者能将json字符串还原成一个对象(引用类型)。 基本类型拷贝是直接在栈内存新开空间，直接复制一份名-值，两者互不影响。 而引用数据类型，比如对象，变量名在栈内存，值在堆内存，拷贝只是拷贝了堆内存提供的指向值的地址，而JSON.stringify()巧就巧在能将一个对象转换成字符串，也就是基本类型，那这里的原理就是先利用JSON.stringify()将对象转变成基本数据类型，然后使用了基本类型的拷贝方式，再利用JSON.parse()将这个字符串还原成一个对象，达到了深拷贝的目的。</p>\n<h3 id=\"借用JQ的extend方法\"><a href=\"#借用JQ的extend方法\" class=\"headerlink\" title=\"借用JQ的extend方法\"></a>借用JQ的extend方法</h3><p>$.extend( [deep ], target, object1 [, objectN ] )</p>\n<p>deep表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝 target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。 object1 objectN可选。 Object类型 第一个以及第N个被合并的对象。</p>\n<p>let a = [0,1,[2,3],4],<br>    b = $.extend(true,[],a);<br>a[0] = 1;<br>a[2][0] = 1;<br>console.log(a,b);</p>\n<p>可以看到，效果与上面方法一样，只是需要依赖JQ库。 <img src=\"http://file.w3cbest.com/file/images/deepclone20190116163442.jpg\">   在实际开发中也是非常有用的。例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝，大概就是这个意思。</p>\n","categories":["JavaScript"],"tags":["JSON.parse()","JSON.stringify()","$.extend()","js递归","浅拷贝","深拷贝"]},{"title":"封装Promise请求","url":"/2021/07/12/%E5%B0%81%E8%A3%85Promise%E8%AF%B7%E6%B1%82request/","content":"<p>思路：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let url &#x3D; &#39;http:&#x2F;&#x2F;localhost:8080&#39;;</span><br><span class=\"line\">let requestTotal &#x3D; 0;</span><br><span class=\"line\">const request &#x3D; (params) &#x3D;&gt;&#123;</span><br><span class=\"line\">  requestTotal++;</span><br><span class=\"line\">  wx.showLoading(&#123;</span><br><span class=\"line\">   title: &#39;加载中...&#39;,</span><br><span class=\"line\">   mask: true</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  return new Promise((resolve, reject) &#x3D;&gt;&#123;</span><br><span class=\"line\">    wx.request(&#123;</span><br><span class=\"line\">      url: url + params.url,</span><br><span class=\"line\">      data: params.data || &#123;&#125;,</span><br><span class=\"line\">      method: params.method || &#39;GET&#39;,</span><br><span class=\"line\">      header: &#123;&#39;content-type&#39;: &#39;application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8&#39;&#125;,</span><br><span class=\"line\">      success:(result)&#x3D;&gt;&#123;</span><br><span class=\"line\">        resolve(result.data)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      fail:(error)&#x3D;&gt;&#123;</span><br><span class=\"line\">        console.log(error);</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      complete:()&#x3D;&gt;&#123;</span><br><span class=\"line\">        requestTotal--;</span><br><span class=\"line\">        if(requestTotal&#x3D;&#x3D;&#x3D;0)&#123;</span><br><span class=\"line\">         wx.hideLoading()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","tags":["Promise"]},{"title":"常用正则表达式","url":"/2019/05/04/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"<p>说明：正则表达式通常用于两种任务：1.验证，2.搜索/替换。用于验证时，通常需要在前后分别加上<code>^</code>和<code>$</code>，以匹配整个待验证字符串；搜索/替换时是否加上此限定则根据搜索的要求而定，此外，也有可能要在前后加上<code>\\b</code>而不是<code>^</code>和<code>$</code>。此表所列的常用正则表达式，除个别外均未在前后加上任何限定，请根据需要，自行处理。</p>\n<p>说明</p>\n<p>正则表达式</p>\n<p>网址（URL）</p>\n<p><code>[a-zA-z]+://[^\\s]*</code></p>\n<p>IP地址(IP Address)</p>\n<p><code>((2[0-4]\\d25[0-5][01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d25[0-5][01]?\\d\\d?)</code></p>\n<p>电子邮件(Email)</p>\n<p><code>\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*</code></p>\n<p>QQ号码</p>\n<p><code>[1-9]\\d&#123;4,&#125;</code></p>\n<p>HTML标记(包含内容或自闭合)</p>\n<p><code>&lt;(.*)(.*)&gt;.*&lt;\\/\\1&gt;&lt;(.*) \\/&gt;</code></p>\n<p>密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上)</p>\n<p><code>(?=^.&#123;8,&#125;$)(?=.*\\d)(?=.*\\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\\n).*$</code></p>\n<p>日期(年-月-日)</p>\n<p><code>(\\d&#123;4&#125;\\d&#123;2&#125;)-((1[0-2])(0?[1-9]))-(([12][0-9])(3[01])(0?[1-9]))</code></p>\n<p>日期(月/日/年)</p>\n<p><code>((1[0-2])(0?[1-9]))/(([12][0-9])(3[01])(0?[1-9]))/(\\d&#123;4&#125;\\d&#123;2&#125;)</code></p>\n<p>时间(小时:分钟, 24小时制)</p>\n<p><code>((10?)[0-9]2[0-3]):([0-5][0-9])</code></p>\n<p>汉字(字符)</p>\n<p><code>[\\u4e00-\\u9fa5]</code></p>\n<p>中文及全角标点符号(字符)</p>\n<p><code>[\\u3000-\\u301e\\ufe10-\\ufe19\\ufe30-\\ufe44\\ufe50-\\ufe6b\\uff01-\\uffee]</code></p>\n<p>中国大陆固定电话号码</p>\n<p><code>(\\d&#123;4&#125;-\\d&#123;3&#125;-)?(\\d&#123;8&#125;\\d&#123;7&#125;)</code></p>\n<p>中国大陆手机号码</p>\n<p><code>1\\d&#123;10&#125;</code></p>\n<p>中国大陆邮政编码</p>\n<p><code>[1-9]\\d&#123;5&#125;</code></p>\n<p>中国大陆身份证号(15位或18位)</p>\n<p><code>\\d&#123;15&#125;(\\d\\d[0-9xX])?</code></p>\n<p>非负整数(正整数或零)</p>\n<p><code>\\d+</code></p>\n<p>正整数</p>\n<p><code>[0-9]*[1-9][0-9]*</code></p>\n<p>负整数</p>\n<p><code>-[0-9]*[1-9][0-9]*</code></p>\n<p>整数</p>\n<p><code>-?\\d+</code></p>\n<p>小数</p>\n<p><code>(-?\\d+)(\\.\\d+)?</code></p>\n<p>不包含abc的单词</p>\n<p><code>\\b((?!abc)\\w)+\\b</code></p>\n","categories":["JavaScript"],"tags":["regex","正则","正则表达式"]},{"title":"排序算法","url":"/2018/08/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr &#x3D; [23, 3, 24, 67, 21, 60];</span><br></pre></td></tr></table></figure>\n<p>1 冒泡排序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">for (let j &#x3D; arr.length - 1; j &gt; 0; j--) &#123;</span><br><span class=\"line\">    for (let i &#x3D; 0; i &lt; j; i++) &#123;</span><br><span class=\"line\">        if (arr[i] &gt; arr[i + 1]) &#123;</span><br><span class=\"line\">            let temp &#x3D; arr[i];</span><br><span class=\"line\">            arr[i] &#x3D; arr[i + 1];</span><br><span class=\"line\">            arr[i + 1] &#x3D; temp</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(&#39;第&#39;+j+&#39;次循环&#39;,arr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2 选择排序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">for (let j &#x3D; 0; j&lt;arr.length; j++)&#123;</span><br><span class=\"line\">    for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        if(arr[i] &gt; arr[j])&#123;</span><br><span class=\"line\">            let temp &#x3D; arr[i];</span><br><span class=\"line\">            arr[i] &#x3D; arr[j]</span><br><span class=\"line\">            arr[j] &#x3D; temp</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(&#39;第&#39;+(j+1)+&#39;次循环&#39;,arr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","tags":["排序算法"]},{"title":"新的css逻辑布局（CSS Logical Properties and Values）","url":"/2019/01/07/%E6%96%B0%E7%9A%84css%E9%80%BB%E8%BE%91%E5%B8%83%E5%B1%80/","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>我们中的大多数开发人员用来考虑左和右,顶部和底部。这是因为在早期的互联网,它主要用于上传文档,而不是为我们今天知道的复杂的网站结构。 这是原因,没有人认为多语言网站的需求。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>旧的盒子模型告诉我们左右上下这四个方向，但在新的模型中，请记住 inline-start inline-end block-start block-end: <img src=\"http://file.w3cbest.com/file/images/4124437802-5c2c0f3b36e51_articlex.png\"> （LTR）对应关系如下：</p>\n<ul>\n<li>  左: inline-start</li>\n<li>  右: inline-end</li>\n<li>  上: block-start</li>\n<li>  下: block-end</li>\n</ul>\n<p>这些适用于 margin padding border 修饰，比如 margin-left 中，left -&gt; 左 -&gt; inline-start -&gt; margin-inline-start 这有点像把坐标系概念引入了布局，对于不同国家，inline 与 block 的方向是不同的：</p>\n<ul>\n<li>  在东亚绝大多数国家、英美系国家 padding-inline-start = padding-left</li>\n<li>  在阿拉伯国家 padding-inline-start = padding-right</li>\n<li>  在日本 padding-inline-start = padding-top</li>\n</ul>\n<p>以中国和英美系国家的阅读顺序为基准的话，阿拉伯国家等于把左右颠倒了，而日本是把网页沿顺时针旋转 90 度。</p>\n<blockquote>\n<p>为什么 inline 表示从左右，block 表示上下呢？还记得 display: inline 吗？此时排版是从左到右排布的，而 display: block 的排版是从上到下的。</p>\n</blockquote>\n<h2 id=\"宽高\"><a href=\"#宽高\" class=\"headerlink\" title=\"宽高\"></a>宽高</h2><p>width height 也需要换成 inline-size 与 block-size，（LTR）对应关系如下：</p>\n<ul>\n<li>  width: inline-size</li>\n<li>  min-width: min-inline-size</li>\n<li>  max-width: max-inline-size</li>\n<li>  height: block-size</li>\n<li>  min-height: min-inline-size</li>\n<li>  max-height: max-inline-size</li>\n</ul>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/rovGPq/\">width height</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>下图是 Box Model 与 Logical 的对比： <img src=\"http://file.w3cbest.com/file/images/748016906-5c2c0f3b52167_articlex.png\"></p>\n<h2 id=\"CSS-Positions\"><a href=\"#CSS-Positions\" class=\"headerlink\" title=\"CSS Positions\"></a>CSS Positions</h2><p>之前Positions属性的名称，top/right/left/bottom，先在所有名称都带有前缀inset: inset-block-start / inset-inline-end inset-block-end / inset-inline-start。 （LTR）对应关系如下：</p>\n<ul>\n<li>  top = inset-block-start</li>\n<li>  bottom = inset-block-end</li>\n<li>  left = inset-inline-start</li>\n<li>  right = inset-inline-end</li>\n</ul>\n<p>尽管这样描述起来很复杂：</p>\n<p>.popup {<br>position: fixed;<br>inset-block-start: 0; /*top - in English*/<br>inset-block-end: 0; /*bottom - in English*/<br>inset-inline-start: 0; /*left - in English*/<br>inset-inline-end: 0; /*right - in English*/<br>}</p>\n<p>但是这种属性支持聚合写法：</p>\n<p>.popup {<br>position: fixed;<br>inset: 0 0 0 0; /*top, right, bottom, left - in English*/<br>}</p>\n<h2 id=\"Float\"><a href=\"#Float\" class=\"headerlink\" title=\"Float\"></a>Float</h2><p>对于 float 的两个值 left right，可以很容易推测出来，会被 inline-start 与 inline-end 取代，（LTR）对应关系如下：</p>\n<ul>\n<li>  float: left = float: inline-start</li>\n<li>  float: right = float: inline-end</li>\n</ul>\n<h2 id=\"Text-align\"><a href=\"#Text-align\" class=\"headerlink\" title=\"Text-align\"></a>Text-align</h2><p>text-align 也有 left right 属性，分别取代为 start end，（LTR）对应关系如下:</p>\n<ul>\n<li>  text-align :left = text-align: start</li>\n<li>  text-align :right = text-align: end</li>\n</ul>\n<h2 id=\"Css-Grid-与-Flexbox\"><a href=\"#Css-Grid-与-Flexbox\" class=\"headerlink\" title=\"Css Grid 与 Flexbox\"></a>Css Grid 与 Flexbox</h2><p>使用 css grid 与 flexbox 布局方案的网页，将在支持的浏览器上自动享受国际化布局调整，不需要改变语法。</p>\n<h2 id=\"Writing-mode\"><a href=\"#Writing-mode\" class=\"headerlink\" title=\"Writing-mode\"></a>Writing-mode</h2><p>目前为止，看到的是 Css 对排版含义的规范化，Grid 与 Flexbox 由于 API 比较新，定义的较为规范，所以不用变，而旧的 display, position, width, height, float 等 API 需要进行语义化改造。 现在就要聊到最关键的布局国际化部分，我们至今为止遇到的网页都是从上到下的，但其他文化却不同。可以通过配置 writing-mode 让整个网页布局改变：</p>\n<ul>\n<li>  writing-mode: horizontal-tb = 从上到下</li>\n<li>  writing-mode: vertical-rl = 从右到左 比如日本文化</li>\n<li>  writing-mode: vertical-lr = 从左到右 比如蒙古文化</li>\n</ul>\n<p><img src=\"http://file.w3cbest.com/file/images/138420463-5c2c0f3b5204b_articlex.png\"></p>\n<blockquote>\n<p>至今还没有见过从下到上的网页，也许这证明了从下到上是最不合理的阅读方式。</p>\n</blockquote>\n<h2 id=\"Direction\"><a href=\"#Direction\" class=\"headerlink\" title=\"Direction\"></a>Direction</h2><p>这是一个排版属性，writing-mode 是控制网页方向的，而 direction 是控制文字对齐方向的。 目前只有两个配置：rtl 与 ltr:</p>\n<p>html {<br>direction: rtl;<br>}</p>\n<p>其实 writing-mode 与 direction 结合起来也没什么问题，比如网页布局变成 vertical-rl - 从右到左，那么 direction 的 ltr 就等于是从上到下了。 最后还有一些悬而未决的问题，比如如何开启智能布局？一种方式是：</p>\n<p>html {<br>flow-mode: physical;<br>/*or*/<br>flow-mode: logical;<br>}</p>\n<p>另外，像 @meta 配置中的 max-width 也要替换为 max-inline-size, line-height 需要被替换为 line-size，border-width 需要被替换为 border-size 等等。</p>\n<h2 id=\"趋势\"><a href=\"#趋势\" class=\"headerlink\" title=\"趋势\"></a>趋势</h2><p>整个 Logical Properties 规范看下来是个不可逆的趋势，也代表着 W3C 规范在排版方面的全球化工作。</p>\n<h3 id=\"为什么要改造语法\"><a href=\"#为什么要改造语法\" class=\"headerlink\" title=\"为什么要改造语法\"></a>为什么要改造语法</h3><p>第一个问题就是这个，我们习以为常的 left top right bottom 语法都需要改成 inline-start block-end 等略微晦涩的语法，而且你可以发现，新语法与旧语法是完全一对一对等的，也就是完全可以交给某个转换程序去做！ 可以看出，这是一个习惯问题，W3C 希望重塑国际化布局的语义，而原有的 left top 等无法承担这些语义，所以只好换掉。 新版规范要求开发者做出一个抽象，把自己国家的习惯抽象成习惯无关的描述。但对于每个前端从业者来说，left top 等描述估计已经成为肌肉记忆了，想要改变规范还是挺难的，未来前端社区也许会出现三种解决方案：</p>\n<ul>\n<li>  保守派 - 利用 babel 将原有语法与新语法做一对一映射转换，比如 position: left -&gt; position: inset-inline-start。这种方案 成本最小，且不改变开发者习惯，所以最有可能被国内公司率先采用。在商业环境推动一件事情，最大的阻力无非是 成本 与 共识，这次的布局规范同时触及了这两个点，可能让团队倾向于做保守派。</li>\n<li>  兼容派 - 其实就是两面派，利用 babel 工具做映射这一点与保守派相同，但是新代码推荐用新语法编写，如果团队中有人不遵循新规范，也会被工具自动转换为新规范。这种软要求会导致团队布局代码存在两套，但最终效果却没有问题的神奇效果，长远来说不利于维护，但不失为一种较为妥协的策略。</li>\n<li>  改革派 - 利用脚本，将项目里旧规范替换成新规范，并让团队未来的代码遵循新的布局规范编写。很显然，这派抓住了迁移成本小这个优势，但没有考虑到人这个因素的习惯迁移成本，如何说服其他人理解新规范，并做到让 “未来加入的同事” 也能认同并遵循这套新规范，也许是最大的不确定因素。</li>\n</ul>\n<h3 id=\"为什么-Flex-Grid-语法不需改造？\"><a href=\"#为什么-Flex-Grid-语法不需改造？\" class=\"headerlink\" title=\"为什么 Flex Grid 语法不需改造？\"></a>为什么 Flex Grid 语法不需改造？</h3><p>这次改造是冲着 left right width height 等明显带有文化色彩的语法来的。 然而 Flex 语法已经将方向定义转化为抽象的 start 与 end，而 center 是没有歧义的，所以 FlexBox 语法不用改。 而 Grid 是一种拆分单元格的语法，也不涉及具体上下左右的描述，所以也符合国际化语义。</p>\n<h4 id=\"扩展阅读：\"><a href=\"#扩展阅读：\" class=\"headerlink\" title=\"扩展阅读：\"></a>扩展阅读：</h4><ul>\n<li>  <a href=\"https://drafts.csswg.org/css-logical/\">https://drafts.csswg.org/css-logical/</a></li>\n<li>  <a href=\"https://www.w3.org/TR/css-logical-1/\">https://www.w3.org/TR/css-logical-1/</a></li>\n<li>  <a href=\"https://www.w3.org/Style/CSS/all-properties.en.html\">https://www.w3.org/Style/CSS/all-properties.en.html</a></li>\n</ul>\n","categories":["HTML/CSS"],"tags":["css3","css 布局","css 排版","css教程","前端教程","CSS Logical","css 逻辑"]},{"title":"显式网格和隐式网格之间的区别[Grid 网格布局教程]","url":"/2018/08/11/%E6%98%BE%E5%BC%8F%E7%BD%91%E6%A0%BC%E5%92%8C%E9%9A%90%E5%BC%8F%E7%BD%91%E6%A0%BC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%ABgrid-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B/","content":"<p><a href=\"http://www.w3cbest.com/494.html\">Grid(网格)</a> 布局最终使我们能够在CSS中定义网格，并将网格项放置到网格单元格中。这本身就很棒，但事实上我们不需要指定每个网格轨道，也不必手动放置每一个网格项。因为 Grid(网格) 布局足够灵活，可以适应它们的网格项。 这些都由所谓的显式和隐式网格来处理的。 这篇文章中所有代码示例都附有图片，以显示网格线和轨道。 如果你想自己修改代码，我建议你下载<a href=\"https://www.mozilla.org/en-US/firefox/channel/desktop/\">Firefox Nightly</a>，因为它目前有调试网格最好的<a href=\"https://hacks.mozilla.org/2017/06/new-css-grid-layout-panel-in-firefox-nightly/\">DevTools</a>。</p>\n<h2 id=\"显式的-Grid-网格\"><a href=\"#显式的-Grid-网格\" class=\"headerlink\" title=\"显式的 Grid(网格)\"></a>显式的 Grid(网格)</h2><p>我们可以使用 grid-template-rows，grid-template-columns 和 grid-template-areas 属性来定义形成网格的固定数量的网格线和网格轨道。这种手动定义的 Grid 称为显式网格。 <img src=\"http://file.w3cbest.com/file/images/grid1.png\"> 具有4个垂直轨道（列）和2个水平轨道（行）的显式网格。</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/OjMGMY/\">CSS Grid Layout: The explicit grid</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>.grid {<br>  display: grid;<br>  grid-template-columns: 1fr 1fr 1fr 1fr;<br>  grid-template-rows: 100px 100px;<br>  grid-gap: 20px;<br>}</p>\n<h2 id=\"重复轨道\"><a href=\"#重复轨道\" class=\"headerlink\" title=\"重复轨道\"></a>重复轨道</h2><p>当我们定义<code>grid-template-columns: 1fr 1fr 1fr 1fr</code>; 时，我们得到<code>4</code>条垂直轨道，每条轨道的宽度为<code>1fr</code>。 我们可以通过使用<code>repeat()</code>表示法来自动化，如<code>grid-template-columns: repeat(4, 1fr)</code>;。第一个参数指定重复次数，第二个参数指定轨道列表。 轨道列表？ 是的，你实际上可以重复多个轨道。例如和上面代码等价的代码：grid-template-columns: repeat(2, 1fr 1fr);。</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/yoerVa/\">CSS Grid Layout: Repeating track lists</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"自动重复轨道\"><a href=\"#自动重复轨道\" class=\"headerlink\" title=\"自动重复轨道\"></a>自动重复轨道</h2><p><img src=\"http://file.w3cbest.com/file/images/grid6_.png\"> 一个带有4个垂直轨道的显式网格，每个100px宽，由重复表示法生成。</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/VzeNpE/\">CSS Grid Layout: Auto-fitting</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p><code>repeat()</code>函数非常有用，但它可以进一步自动化。我们可以使用<code>auto-fill</code>和<code>auto-fit</code>关键字，来替代设置固定数量的重复。</p>\n<h2 id=\"自动填充轨道（auto-fill）\"><a href=\"#自动填充轨道（auto-fill）\" class=\"headerlink\" title=\"自动填充轨道（auto-fill）\"></a>自动填充轨道（auto-fill）</h2><p>auto-fill 关键字创建适合网格容器的轨道数，而不会导致网格溢出。 <img src=\"http://file.w3cbest.com/file/images/grid7_.png\"> 重复放入宽度为100px的垂直轨道，以适应网格容器。</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/PKZgmr/\">CSS Grid Layout: auto-fill</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>.grid {<br>  display: grid;<br>  grid-template-columns: repeat(auto-fill, 100px);<br>  grid-gap: 20px;<br>}</p>\n<p>注意：<code>repeat(auto-fill, 1fr)</code>; 只会创建一个轨道，因为宽度为<code>1fr</code>的单个轨道已经填满了整个网格容器。</p>\n<h2 id=\"自动调整轨道（auto-fit）\"><a href=\"#自动调整轨道（auto-fit）\" class=\"headerlink\" title=\"自动调整轨道（auto-fit）\"></a>自动调整轨道（auto-fit）</h2><p><code>auto-fit</code>关键字的行为与<code>auto-fill</code>相同，只是在网格项目放置后，它只会根据需要创建任意数量的轨道，并且任何空的重复轨道都会折叠在一起。</p>\n<p>.grid {<br>  display: grid;<br>  grid-template-columns: repeat(auto-fit, 100px);<br>  grid-gap: 20px;<br>}</p>\n<p>上例的代码，使用<code>repeat(auto-fit, 100px)</code>; 和<code>repeat(4, 100px)</code>创建的网格看上去相同。当有超过4个网格项时，就可以看到差异了。 如果有更多网格项，则<code>auto-fit</code>会创建更多列。 <img src=\"http://file.w3cbest.com/file/images/grid8.png\"> 在 repeat() 中使用 auto-fit 关键词可根据需要创建尽可能多的轨道，并将轨道尽可能多地放入网格容器中。</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/RZrOXw/\">CSS Grid Layout: auto-fit</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>另一方面，如果在<code>repeat()</code>中使用固定数量的垂直轨道，并且网格项数超过该值，则添加更多行。您可以在下一节中阅读更多相关内容：<a href=\"#implicit-grids\">隐式网格</a>。 <img src=\"http://file.w3cbest.com/file/images/grid9.png\"> 如果网格项多于垂直轨道，则会添加更多行。</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/ZJQZgr/\">CSS Grid Layout: implicit rows</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>为方便起见，我在上面的示例中使用了<code>grid-template-columns</code>，但所有规则也适用于<code>grid-template-rows</code>。</p>\n<p>.grid {<br>  display: grid;<br>  grid-template-columns: repeat(auto-fill, 100px);<br>  grid-template-rows: repeat(auto-fill, 100px);<br>  grid-gap: 20px;<br>  height: 100%;<br>}</p>\n<p>html, body {<br>  height: 100%;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/grid10.png\"> 在两个轴(行和列)上使用<code>auto-fill</code>关键字重复表示法。</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/prgVmW/\">CSS Grid Layout: auto-fill on both axes</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"隐式的-Grid-网格\"><a href=\"#隐式的-Grid-网格\" class=\"headerlink\" title=\"隐式的 Grid(网格)\"></a>隐式的 Grid(网格)</h2><p>如果网格项的数量多于网格单元格，或者网格项位于显式网格外部，则网格容器会通过向网格添加网格线自动生成网格轨道。 显式网格与这些额外的隐式轨道和网格线线一起形成所谓的隐式网格。 <img src=\"http://file.w3cbest.com/file/images/grid2.png\"> 两个网格项放置在显式网格之外，导致创建隐式网格线条和网格轨道。</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/vJLwNY/\">CSS Grid Layout: implicit tracks</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>.item:first-child {<br>  grid-column-start: -1;<br>}</p>\n<p>.item:nth-child(2) {<br>  grid-row-start: 4;<br>}</p>\n<p>隐式轨道的宽度和高度是自动设置。它们的大小足以适合放置的网格项，但可以更改其默认行为。</p>\n<h2 id=\"调整隐式轨道\"><a href=\"#调整隐式轨道\" class=\"headerlink\" title=\"调整隐式轨道\"></a>调整隐式轨道</h2><p><code>grid-auto-rows</code>和<code>grid-auto-columns</code>属性使我们可以控制隐式轨道的大小。</p>\n<p>.grid {<br>  display: grid;<br>  grid-template-columns: repeat(4, 1fr);<br>  grid-template-rows: 100px 100px;<br>  grid-gap: 20px;<br>  grid-auto-columns: 200px;<br>  grid-auto-rows: 60px;<br>}</p>\n<p>无论网格项是否适合，隐式轨道现在总是具有200px的宽度和60px的高度。 <img src=\"http://file.w3cbest.com/file/images/grid3.png\"> 固定宽度和高度的隐式轨道。</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/KvVLVy/\">CSS Grid Layout: Sizing implicit tracks</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>通过使用 minmax() 函数来指定范围，可以使调整隐式轨道更灵活。</p>\n<p>.grid {<br>  grid-auto-columns: minmax(200px, auto);<br>  grid-auto-rows: minmax(60px, auto);<br>}</p>\n<p>隐式轨道现在至少有200px宽和60px高，但如果内容需要它将会扩展。</p>\n<h2 id=\"将网格扩展到开始\"><a href=\"#将网格扩展到开始\" class=\"headerlink\" title=\"将网格扩展到开始\"></a>将网格扩展到开始</h2><p>隐式轨道可能不仅仅被添加到显式网格的末尾。也可能扩展到显式网格的开始处。 <img src=\"http://file.w3cbest.com/file/images/grid4_.png\"> 一个隐式网格，由一行和一列扩展到开头</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/BdyJWR/\">CSS Grid Layout: Implicit grid</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>.item:first-child {<br>  grid-row-end: 2;<br>  grid-row-start: span 2;<br>}</p>\n<p>.item:nth-child(2) {<br>  grid-column-end: 2;<br>  grid-column-start: span 2;<br>}</p>\n<p>每个网格项在第二行结束，并跨越2个单元格（一个垂直，另一个水平）。 由于在第二行之前只有一个单元，因此在每一侧的开始处将另一个隐式轨道添加到网格中。</p>\n<h2 id=\"自动放置\"><a href=\"#自动放置\" class=\"headerlink\" title=\"自动放置\"></a>自动放置</h2><p>如前所述，如果项目数超过单元格数，也会添加隐式轨道。 默认情况下，自动放置算法通过连续填充每一行来放置网格项，并根据需要添加新行。 我们可以使用 grid-auto-flow 属性来指定如何把网格项自动放置到网格容器。 <img src=\"http://file.w3cbest.com/file/images/grid11.png\"> 如果网格项数超过单元格数量，则添加新列而不是行。</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/JyGqBP/\">CSS Grid Layout: grid-auto-flow</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>.grid {<br>  display: grid;<br>  grid-template-columns: repeat(4, 1fr);<br>  grid-template-rows: 100px 100px;<br>  grid-gap: 20px;<br>  grid-auto-flow: column;<br>}</p>\n<p>使用网格项填充列，不是填充行，并创建其他隐式列。</p>\n<h2 id=\"未定义显式网格\"><a href=\"#未定义显式网格\" class=\"headerlink\" title=\"未定义显式网格\"></a>未定义显式网格</h2><p>由于可以使用<code>grid-auto-rows</code>和<code>grid-auto-columns</code>自动调整单元格大小，因此不必定义显式网格。 <img src=\"http://file.w3cbest.com/file/images/grid5.png\"> 没有显式行和轨道的隐式网格。</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/gxPzeY/\">CSS Grid Layout: Implicit grid only</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>.grid {<br>  display: grid;<br>  grid-auto-columns: minmax(60px, 200px);<br>  grid-auto-rows: 60px;<br>  grid-gap: 20px;<br>}</p>\n<p>.item:first-child {<br>  grid-row: span 2;<br>}</p>\n<p>.item:nth-child(2) {<br>  grid-column: 1 / span 2;<br>}</p>\n<p>.item:nth-child(5) {<br>  grid-column: 3;<br>}</p>\n<p>完全依赖于隐式网格可能会变得混乱和难以理解。我们建议与显式网格相结使用。 在此示例中，第一个网格项自动放置并跨越 2 行，第二个项目显式放置在第一列中，并跨越 2 列创建第二个垂直轨道。 第三和第四网格项实际上都会自动放在第四行，但第五网格项明确地放在先前不存在的第三列中。 这将创建第三个垂直轨道，并且由于网格自动放置，第三个项目向上移动一行以填充空间。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文并未涵盖有关显式和隐式网格的所有内容，它应该为您提供的不仅仅是对该概念的深入理解。 了解创建隐式网格线和隐式轨迹的原因和方式对于使用网格布局至关重要。 你可以在 <a href=\"https://codepen.io/collection/XkLzYO/\">CodePen</a> 集合 中找到本文中使用的所有示例。 文章来源：<a href=\"https://css-tricks.com/difference-explicit-implicit-grids/\">https://css-tricks.com</a></p>\n","categories":["HTML/CSS"],"tags":["css教程","grid-area","grid教程","html教程","前端教程","grid布局"]},{"title":"模拟一个console.log打印代码","url":"/2018/09/05/%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AAconsole-log%E6%89%93%E5%8D%B0%E4%BB%A3%E7%A0%81/","content":"<p>在网站开发中我们时常用console.log来打印我们想要的数据，或返回的一些我们想要知道的结果，在PC端我们可以得心应手的使用，但是在移动端开发的时候，不能用F12了，无法看到代码，哪里出问题了也不知道，其实也可以用alert()，不过呢每刷新一次页面就会弹一次弹框，自我感觉比较麻烦，所以就有下面这段代码，虽然很简单，但是感觉挺实用的，代码如下：</p>\n<p>// log打印<br>Tomd.log = function(s) {<br>  if (typeof s == ‘object’) {<br>    var s1 = ‘’;<br>    for (var a in s) {<br>      s1 += ‘{0}:{1}, ‘.format(a, s[a]);<br>    }<br>    s = s1;<br>  }<br>  var d = $(‘.dui-log’);<br>  if (d.length == 0) {<br>    $(‘body’).append(‘<div class=\"dui-log\"></div>‘);<br>    d = $(‘.dui-log’);<br>  }<br>  d.append(‘<p>‘ + s + ‘</p>‘);<br>}<br>// 调用<br>Tomd.log(obj)</p>\n<p>/*<br>* 格式化字符串<br>* 用法：’my name is {0}, age {1}’.format(‘Tom’, 30)<br>*/<br>String.prototype.format = function() {<br>  var _this = this;<br>  for (var i = 0; i &lt; arguments.length; i++) {<br>    _this = _this.replace(new RegExp(‘\\\\{‘ + i + ‘\\\\}’, ‘g’), arguments[i]);<br>  }<br>  return _this;<br>};</p>\n","categories":["JavaScript"],"tags":["javascript","jquery","alert()","console","console.log"]},{"title":"火狐浏览器table表格th、td填充背景描边后设置position: relative边框失效问题","url":"/2018/12/26/%E7%81%AB%E7%8B%90%E6%B5%8F%E8%A7%88%E5%99%A8table%E8%A1%A8%E6%A0%BCth%E3%80%81td%E5%A1%AB%E5%85%85%E8%83%8C%E6%99%AF%E6%8F%8F%E8%BE%B9%E5%90%8E%E8%AE%BE%E7%BD%AEposition-relative%E8%BE%B9%E6%A1%86/","content":"<p>一般在开发管理系统的时候经常会用到表格，在使用表格式时通常会给thead部分的th或td加上背景色然后还有边框颜色，在这种情况下浏览器基本都显示正常的，但是当给th或td加上position: relative时火狐浏览器就会显示th或td的边框被遮盖，只显示一片背景色没有边框，如下请在火狐浏览器查看，</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/zyzmdz/\">火狐浏览器table边框失效问题1</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>我为什么要在th或td加上position: relative呢，我在开发系统的时候使用bootstrap结合jquery.dataTables，不想使用dataTables自带的图标主题，使用的bootstrap.dataTable 的主题，主题的图标是通过伪类:before和:after实现的，所以加上的position: relative，其实这也是主题的一个小bug，然后导致火狐浏览器只会显示背景色边框完全被遮盖。</p>\n<p>解决方法1：</p>\n<p>去掉th的背景色，把背景色填充在thend 的 tr上，这样就能完全解决这个问题，如下</p>\n<p>.table{<br>    thead{<br>        tr{<br>            background-color: #4587E7;<br>        }<br>        th{<br>            position: relative;<br>            color: #fff;<br>        }<br>    }<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/vvZVeV/\">火狐浏览器table边框失效问题2</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>解决方法2：</p>\n<p>给th设置一个z-index-1属性，这样也能完全解决这个问题，如下</p>\n<p>.table{<br>    thead{<br>        th{<br>            position: relative;<br>            z-index: -1;<br>            color: #fff;<br>            background-color: #4587e7;<br>        }<br>    }<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/gZRBoy/\">火狐浏览器table边框失效问题3</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>扩展阅读：<a href=\"http://www.w3help.org/zh-cn/causes/RE2007\">http://www.w3help.org/zh-cn/causes/RE2007</a></p>\n","categories":["HTML/CSS","资源"],"tags":["Bootstrap","dataTables","firefox","table","火狐浏览器"]},{"title":"理解 CSS 布局和 BFC","url":"/2019/04/09/%E7%90%86%E8%A7%A3-css-%E5%B8%83%E5%B1%80%E5%92%8C-bfc/","content":"<p>CSS布局中有一些概念，一旦你理解了它们，就能真正提高你的 CSS 布局能力。本文是关于块格式化上下文(BFC)的。你可能从未听说过这个术语，但是如果你曾经用CSS做过布局，你可能知道它是什么，理解什么是 BFC，怎么工作以及如何创建 BFC 非常有用，这些可以帮助你理解CSS中的布局是如何工作的。 在本文中，通过熟悉的示例来解释什么是 BFC。然后说明 display 的一个新值，只有当你理解了什么是 BFC 以及为什么需要它时，它才有意义。</p>\n<h2 id=\"什么是-BFC\"><a href=\"#什么是-BFC\" class=\"headerlink\" title=\"什么是 BFC\"></a>什么是 BFC</h2><p>在一个Web页面的CSS渲染中，块级格式化上下文 (Block Fromatting Context)是按照块级盒子布局的。W3C对BFC的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个 BFC 中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 块格式化上下文(BFC)的行为通过一个简单的float示例很容易理解。在下面的示例中，我有一个框，其中包含向左浮动的图像和一些文本。如果我们有足够多的文本，它会环绕浮动的图像和边框，然后环绕整个区域。</p>\n<div class=\"outer\">\n<div class=\"float\">I am a floated element.</div>\nI am text inside the outer box.\n</div>\n\n<p>.outer {<br>    border: 5 px dotted rgb(214, 129, 137);<br>    border - radius: 5 px;<br>    width: 450 px;<br>    padding: 10 px;<br>    margin - bottom: 40 px;<br>}<br>.float {<br>    padding: 10 px;<br>    border: 5 px solid rgba(214, 129, 137, .4);<br>    border - radius: 5 px;<br>    background - color: rgba(233, 78, 119, .4);<br>    color: #fff;<br>    float: left;<br>    width: 200 px;<br>    margin: 0 20 px 0 0;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/floats1-800w-opt.png\"> 如果我删除了一些文本，那么就没有足够的内容来包围图像，而且由于浮动被从文档流中脱离，所以边框会上升，并在图像下方，直到文本的高度。 <img src=\"http://file.w3cbest.com/file/images/floats2-800w-opt.png\"> 这是因为当我们浮动一个元素时，文本所在的框的宽度保持不变，为给浮动元素腾出空间而缩短的是文本的行框。这就是为什么背景和边框会出现在浮动后面的原因。 我们通常有两种方法来解决这个布局问题。一种方法是使用 <a href=\"https://css-tricks.com/snippets/css/clear-fix/\">clearfix hack</a>，它的作用是在文本和图像下面插入一个元素，并将其设置为 clear:both。另一种方法是使用 overflow 属性，其值不是缺省值 visible。</p>\n<p>.outer {<br>    overflow: auto;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/floats3-800w-opt.png\"> overflow 以这种方式工作的原因是，使用 visible 的初值以外的任何值都会创建一个块格式化上下文，而 BFC 的一个特性是它包含浮动。</p>\n<h2 id=\"BFC-是布局中的一个迷你布局\"><a href=\"#BFC-是布局中的一个迷你布局\" class=\"headerlink\" title=\"BFC 是布局中的一个迷你布局\"></a>BFC 是布局中的一个迷你布局</h2><p>你可以将 BFC 看作是页面内的一个迷你布局。一旦一个元素创建了一个 BFC，它就包含了所有的内容。正如我们所看到的，这包括浮动的元素，它们不再从盒子底部伸出来。BFC 还会导致一些其他有用的行为。 <strong>BFC 可以防止 margin 折叠</strong> 了解边距合并是另一个被低估的 CSS 技能。在下一个示例中，假设有一个背景颜色为灰色的 div。 这个 div 包含两个标签 p。外部 <code>div</code> 元素的 <code>margin-bottom</code> 为 40 像素，标签 p 的顶部和底部 margin 都是 20 像素。</p>\n<p>// html</p>\n<div class=\"outer\">\n    <p>I am paragraph one and I have a margin top and bottom of 20px;</p>\n    <p>I am paragraph one and I have a margin top and bottom of 20px;</p>\n</div>\n\n<p>// css<br>.outer {<br>    background-color: #ccc;<br>    margin: 0 0 40px 0;<br>}<br>p {<br>    padding: 0;<br>    margin: 20px 0 20px 0;<br>    background-color: rgb(233, 78, 119);<br>    color: #fff;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/margins1-800w-opt.png\"> 因为 p 元素的 <code>margin</code> 和外部 div 上的 <code>margin</code> 之间没有任何东西，所以两个会折叠，因此 p 最终与 div 的顶部和底部齐平。 我们在 p 的上方和下方看不到任何灰色。 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。折叠的结果按照如下规则计算： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 <strong>产生折叠的必备条件：margin必须是邻接的!</strong> 如果我们把盒子设为 BFC，它现在包含了标签 p 和它们的边距，这样它们就不会折叠，我们可以看到边距后面容器的灰色背景。</p>\n<p>.outer {<br>    background-color: #ccc;<br>    margin: 0 0 40px 0;<br>    overflow: auto;<br>}</p>\n<p>再一次，BFC 的工作是把东西装在盒子里，防止它们从盒子里跑出来。 <strong>BFC 可以阻止元素被浮动元素覆盖</strong> 你将熟悉 BFC 的这种行为，因为使用浮动的任何列类型布局都是这样工作的。如果一个项目创建了一个 BFC，那么该项目将不会包裹任何浮动元素。在下面的例子中，有如下 html 结构：</p>\n<div class=\"outer\">\n    <div class=\"float\">I am a floated element.</div>\n    <div class=\"text\">I am text</div>\n</div>\n\n<p><img src=\"http://file.w3cbest.com/file/images/margins2-800w-opt.png\"> 带有 <code>float</code> 类的项被向左浮动，因此 <code>div</code> 中的文本在它环绕 <code>float</code> 之后。 我可以通过将包裹文本的 div 设置为 BFC 来防止这种包裹行为。</p>\n<p>.text {<br>    overflow: auto;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/wrap2-800w-opt.png\"> 这实际上是我们创建具有多个列的浮动布局的方法。浮动项还为该项创建了一个 BFC，因此，如果右边的列比左边的列高，那么我们的列就不会相互环绕。</p>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/qVKEpJ/\">A BFC preventing wrapping of floats.</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"还有什么能创建-BFC\"><a href=\"#还有什么能创建-BFC\" class=\"headerlink\" title=\"还有什么能创建 BFC?\"></a>还有什么能创建 BFC?</h2><p>除了使用 <code>overflow</code> 创建 BFC 外，其他一些 CSS 属性还创建 <code>BFC</code>。正如我们所看到的，浮动元素创建了 BFC。你的浮动项将包含它里面的任何东西。 使用以下方式都能创建 BFC</p>\n<ul>\n<li>  float 的值不是 none。</li>\n<li>  position 的值不是 static 或者 relative。</li>\n<li>  display 的值是 inline-block、table-cell、flex、table-caption 或者inline-flex</li>\n<li>  overflow 的值不是 visible</li>\n</ul>\n<h2 id=\"创建-BFC-的新方式\"><a href=\"#创建-BFC-的新方式\" class=\"headerlink\" title=\"创建 BFC 的新方式\"></a>创建 BFC 的新方式</h2><p>使用<code>overflow</code>或其他的方法创建BFC时会有两个问题。首先，这些方法本身是有自身的设计目的，所以在使用它们创建BFC时可能会产生副作用。例如，使用<code>overflow</code>创建BFC后在某些情况下可能会看到出现一个滚动条或者元素内容被裁切。 这是由于<code>overflow</code>属性的设计是用来让你告诉浏览器如何定义元素的溢出状态的。浏览器执行了它最基本的定义。 即使在没有任何不想要的副作用的情况下，使用 <code>overflow</code> 也可能会让其他开发人员感到困惑。为什么 overflow 设置为 auto 或 scroll?最初的开发者的意图是什么?他们想要这个组件上的滚动条吗? 最安全的做法应该是创建一个 BFC 时并不会带来任何副作用，它内部的元素都安全的呆在这个迷你布局中，这种方法不会引起任何意想不到的问题，也可以理解开发者的意图。CSS 工作组也十分认同这种想法，所以他们定制了一个新的属性值：display:flow-root。</p>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/WXyvpd/\">Using display: flow-root for common tasks</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p><strong>flow-root 浏览器支持情况</strong> 你可以使用<code>display:flow-root</code>安全的创建BFC，来解决上文中提到的各种问题：包裹浮动元素、阻止外边距叠加和阻止围绕浮动元素。</p>\n<p><a href=\"http://caniuse.com/#feat=flow-root\">Can I Use flow-root?</a> Data on support for the flow-root feature across the major browsers from caniuse.com.</p>\n<p>浏览器对该属性的支持目前还是有限的，如果你觉得这个属性值很方便，请投票去让Edge也支持它。不过无论如何，你现在应该已经理解了什么是 BFC，以及如何使用 <code>overflow</code> 或其他方法来包裹浮动，以及知道了 BFC 可以阻止元素去环绕浮动元素，如果你想使用弹性或网格布局可以在一些不支持他们的浏览器中使用 BFC 的这些特性做降级处理。 理解浏览器如何布置网页是非常基础的。 虽然有时看起来无关紧要，但是这些小知识可以加快创建和调试 CSS 布局所需的时间。</p>\n","categories":["HTML/CSS"],"tags":["css","css3","css3教程","css bfc"]},{"title":"用css3和jquery制作一个带有斜角的选项卡面板","url":"/2018/09/13/%E7%94%A8css3%E5%92%8Cjquery%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E6%96%9C%E8%A7%92%E7%9A%84%E9%80%89%E9%A1%B9%E5%8D%A1%E9%9D%A2%E6%9D%BF/","content":"<p>今天我们将使用CSS 3 gradients技术创建一个好看的带有斜角的选项卡面板。 <img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/tabs1.jpg\"> 下面就直接上代码</p>\n<h4 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h4><ul id=\"tabs\">\n<li><a href=\"#\" title=\"tab1\">tab1</a></li>\n<li><a href=\"#\" title=\"tab2\">tab2</a></li>\n<li><a href=\"#\" title=\"tab3\">tab3</a></li>\n<li><a href=\"#\" title=\"tab4\">tab4</a></li>\n</ul>\n\n<div id=\"content\">\n<div id=\"tab1\">tab1 - content</div>\n<div id=\"tab2\">tab2 - content</div>\n<div id=\"tab3\">tab3 - content</div>\n<div id=\"tab4\">tab4 - content</div>\n</div>\n\n<h4 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h4><p>#tabs {<br>overflow: auto;<br>width: 100%;<br>list-style: none;<br>margin: 0;<br>padding: 0;<br>}</p>\n<p>#tabs li {<br>margin: 0;<br>padding: 0;<br>float: left;<br>}</p>\n<p>#tabs a {<br>box-shadow: -4px 0 0 rgba(0, 0, 0, .2);<br>background: #ad1c1c;<br>background: linear-gradient(225deg, transparent 10px, #ad1c1c 10px);<br>text-shadow: 0 1px 0 rgba(0,0,0,.5);<br>color: #fff;<br>float: left;<br>font: bold 12px/35px ‘Lucida sans’, Arial, Helvetica;<br>height: 35px;<br>padding: 0 30px;<br>text-decoration: none;<br>}</p>\n<p>#tabs a:hover {<br>background: #c93434;<br>background: linear-gradient(225deg, transparent 10px, #c93434 10px);<br>}</p>\n<p>#tabs a:focus {<br>outline: 0;<br>}</p>\n<p>#tabs #current a {<br>background: #fff;<br>background: linear-gradient(225deg, transparent 10px, #fff 10px);<br>text-shadow: none;<br>color: #333;<br>}</p>\n<p>#content {<br>background-color: #fff;<br>background-image: linear-gradient(top, #fff, #ddd);<br>border-radius: 0 2px 2px 2px;<br>box-shadow: 0 2px 2px #000, 0 -1px 0 #fff inset;<br>padding: 30px;<br>}</p>\n<p>/* 这里的高度可随意*/<br>#content div {<br>height: 220px;<br>}</p>\n<h4 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h4><p>下面的代码可能不是最好的，但我认为它相当不错</p>\n<p>$(document).ready(function() {<br>$(“#content div”).hide(); // 最初隐藏所有内容<br>$(“#tabs li:first”).attr(“id”,”current”); // 激活第一个选项卡<br>$(“#content div:first”).fadeIn(); // 显示第一个标签内容</p>\n<p>$(‘#tabs a’).click(function(e) {<br>e.preventDefault();<br>$(“#content div”).hide(); // 隐藏所有内容<br>$(“#tabs li”).attr(“id”,””); // 重置Id<br>$(this).parent().attr(“id”,”current”); // 这里点击后激活<br>$(‘#’ + $(this).attr(‘title’)).fadeIn(); // 显示当前选项卡的内容<br>});<br>})();</p>\n","categories":["HTML/CSS","JavaScript"],"tags":["css3","jquery","tabs"]},{"title":"用CSS3开启硬件加速来提高网站性能","url":"/2018/12/21/%E7%94%A8css3%E5%BC%80%E5%90%AF%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E6%9D%A5%E6%8F%90%E9%AB%98%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD/","content":"<p>你知道我们可以在浏览器中用css开启硬件加速，使GPU (Graphics Processing Unit) 发挥功能，从而提升性能吗？</p>\n<p>现在大多数电脑的显卡都支持硬件加速。鉴于此，我们可以发挥GPU的力量，从而使我们的网站或应用表现的更为流畅。</p>\n<h3 id=\"在桌面端和移动端用CSS3开启硬件加速\"><a href=\"#在桌面端和移动端用CSS3开启硬件加速\" class=\"headerlink\" title=\"在桌面端和移动端用CSS3开启硬件加速\"></a>在桌面端和移动端用CSS3开启硬件加速</h3><p>CSS animations, transforms 以及 transitions 不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行。那我们怎样才可以切换到GPU模式呢，很多浏览器提供了某些触发的CSS规则。</p>\n<p>现在，像Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持硬件加速，当它们检测到页面中某个DOM元素应用了某些CSS规则时就会开启，最显著的特征的元素的3D变换。</p>\n<p>例如：</p>\n<p>.cube {<br>   -webkit-transform: translate3d(250px,250px,250px)<br>   rotate3d(250px,250px,250px,-120deg)<br>   scale3d(0.5, 0.5, 0.5);<br>}</p>\n<p>可是在一些情况下，我们并不需要对元素应用3D变换的效果，那怎么办呢？这时候我们可以使用个小技巧“欺骗”浏览器来开启硬件加速。</p>\n<p>虽然我们可能不想对元素应用3D变换，可我们一样可以开启3D引擎。例如我们可以用transform: translateZ(0); 来开启硬件加速 。</p>\n<p>.cube {<br>   -webkit-transform: translateZ(0);<br>   -moz-transform: translateZ(0);<br>   -ms-transform: translateZ(0);<br>   -o-transform: translateZ(0);<br>   transform: translateZ(0);<br>   /* Other transform properties here */<br>}</p>\n<p>在 Chrome and Safari中，当我们使用CSS transforms 或者 animations时可能会有页面闪烁的效果，下面的代码可以修复此情况：</p>\n<p>.cube {<br>    -webkit-backface-visibility: hidden;<br>    -moz-backface-visibility: hidden;<br>    -ms-backface-visibility: hidden;<br>    backface-visibility: hidden;<br>    -webkit-perspective: 1000;<br>    -moz-perspective: 1000;<br>    -ms-perspective: 1000;<br>    perspective: 1000;<br>    /* Other transform properties here */<br> }</p>\n<p>在webkit内核的浏览器中，另一个行之有效的方法是</p>\n<p>.cube {<br>   -webkit-transform: translate3d(0, 0, 0);<br>   -moz-transform: translate3d(0, 0, 0);<br>   -ms-transform: translate3d(0, 0, 0);<br>   transform: translate3d(0, 0, 0);<br>  /* Other transform properties here */<br>}</p>\n<p>原生的移动端应用(Native mobile applications)总是可以很好的运用GPU，这是为什么它比网页应用(Web apps)表现更好的原因。硬件加速在移动端尤其有用，因为它可以有效的减少资源的利用(麦时注：移动端本身资源有限)。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>只对我们需要实现动画效果的元素应用以上方法，如果仅仅为了开启硬件加速而随便乱用，那是不明智的。</p>\n<p>小心使用这些方法，如果通过你的测试，结果确是提高了性能，你才可以使用这些方法。使用GPU可能会导致严重的性能问题，因为它增加了内存的使用，而且它会减少移动端设备的电池寿命。</p>\n<p>你有在项目中使用过这些方法吗？如果有，请分享你的精彩案例吧。</p>\n<p>转载：<a href=\"https://blog.teamtreehouse.com/increase-your-sites-performance-with-hardware-accelerated-css\">Increase Your Site’s Performance with Hardware-Accelerated CSS</a></p>\n","categories":["HTML/CSS"],"tags":["css3","transforms","animations","translate3d"]},{"title":"用display:flex新属性做个导航排列","url":"/2018/09/06/%E7%94%A8display-flex%E6%96%B0%E5%B1%9E%E6%80%A7%E5%81%9A%E4%B8%AA%E5%AF%BC%E8%88%AA%E6%8E%92%E5%88%97/","content":"<p>现在你得导航还在用float来设置水平排列吗？ 随着css的强大新的属性的增加，浏览器的内核升级，让我们的代码越写越简单，以前我们在写代码设置某一块水平排列用的最多的应该是float了吧，80后的程序员最有感受，深受低版本浏览器的残害(IE6)，乃至现在还会随手敲一个float出来(包括我)。不过现在好了，随着浏览器的内核升级，很多企业也已抛弃低版本浏览器，css的很多新属性就可以用到了，我们今天就用这个新属性flex做个导航水平排列,如下：</p>\n<ul>\n<li>  首页</li>\n<li>  关于我们</li>\n<li>  产品展示</li>\n<li>  客户支持</li>\n<li>  联系我们</li>\n</ul>\n<p>html</p>\n<ul class=\"navbar\">\n  <li><a href=\"/\">首页</a></li>\n  <li><a href=\"/\">关于我们</a></li>\n  <li><a href=\"/\">产品展示</a></li>\n  <li><a href=\"/\">客户支持</a></li>\n  <li><a href=\"/\">联系我们</a></li>\n</ul>\n\n<p>css</p>\n<p>.navbar{<br>  display: flex;<br>  flex-direction: row;<br>  flex-wrap: nowrap;<br>  justify-content: flex-start;<br>  align-items: stretch;<br>  align-content: stretch;<br>}</p>\n<p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 我们来测试一下他的兼容性</p>\n<p>复制代码</p>\n","categories":["HTML/CSS"],"tags":["css3","flex"]},{"title":"经常用到的几个字符串的截取","url":"/2019/08/07/%E7%BB%8F%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%88%AA%E5%8F%96/","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var str&#x3D;&quot;123abc456&quot;;</span><br><span class=\"line\">var i&#x3D;3;</span><br></pre></td></tr></table></figure>\n\n\n<p>1 取字符串的前i个字符：（不操作原字符）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">str&#x3D;str.substring(0,i);</span><br></pre></td></tr></table></figure>\n\n\n<p>2 从右边开始取i个字符：（不操作原字符）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">str&#x3D;str.substring(str.Length-i);</span><br></pre></td></tr></table></figure>\n\n\n<p>3 从右边开始去掉i个字符：（不操作原字符）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">str&#x3D;str.substring(0,str.Length-i);</span><br></pre></td></tr></table></figure>\n\n\n<p>4 如果字符串中有”abc”则替换成”ABC”：（操作原字符）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">str&#x3D;str.replace(&quot;abc&quot;,&quot;ABC&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<p>5 如果想从某一个字符的下标开始：（不操作原字符）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">str&#x3D;str.substr(str.indexOf(&#39;a&#39;),3);&#x2F;&#x2F; 从‘a’下标开始(包括‘a’)截取3个元素，不操作原字符</span><br></pre></td></tr></table></figure>\n","categories":["JavaScript"],"tags":["javascript","javascript教程","substring()"]},{"title":"聊一聊 CSS position sticky是如何工作的","url":"/2019/02/12/%E8%81%8A%E4%B8%80%E8%81%8A-css-position-sticky%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/","content":"<p>CSS position sticky具有非常好的浏览器支持，但大多数开发人员都没有使用它。 究其原因有两个：</p>\n<ul>\n<li>  第一，受到浏览器的良好支持需要漫长的等待：浏览器的支持往往需要很长的时间才能完成，到时候它的功能已经被人们遗忘了。</li>\n<li>  第二个原因是很多开发者并不能完全理解其工作原理背后的逻辑，这就是我的切入点。</li>\n</ul>\n<p>我假设你们都知道什么事CSS定位，不过还是先简单回顾一下比较好： 在3年前，有四种 CSS 定位： <code>static</code>、 <code>relative</code>、 <code>absolute</code>和<code>fixed</code>。 <code>static</code>、 <code>relative</code>、 <code>absolute</code>和<code>fixed</code>之间主要的区别在于它们在DOM流中占用的空间。 <code>static</code>和<code>relative</code>会保留它们在文档流中的自然空间，而<code>absolute</code>和<code>fixed</code>则不会 —— 它们的空间被移除而且具有浮动行为。 正如我下面将要解释的那样，新的粘性定位与所有类型都有相似之处。</p>\n<h2 id=\"我的第一个粘性定位\"><a href=\"#我的第一个粘性定位\" class=\"headerlink\" title=\"我的第一个粘性定位\"></a>我的第一个粘性定位</h2><p>可能很多人都玩过粘性定位。我已经接触过一段时间了，直到我意识到自己并不是完全理解它。 在第一个例子中，大家很容易就能看明白 当视口到达定义的位置时，元素会被粘住。 例：</p>\n<p>.some-component{<br>    position: sticky;<br>    top: 0px;<br>}</p>\n<p>但问题是，它有时候能用，而有时却不起作用。 当它工作时，元素会粘住，但在滚动到其他部分，它会停止粘贴。 作为一个靠 CSS 混饭吃的人，我完全不能接受自己对这个问题是不理解的，所以我决定把粘性位置彻底搞清楚。</p>\n<h2 id=\"探索粘性定位\"><a href=\"#探索粘性定位\" class=\"headerlink\" title=\"探索粘性定位\"></a>探索粘性定位</h2><p>在摆弄它的过程中，我很快就注意到了：当一个具有 <code>position:sticky</code> 样式的元素被包装，且它是包装元素中唯一的元素时，这个被定义为 <code>position:sticky</code> 的元素就不会粘住。</p>\n<style>\n    .sticky{\n        position: sticky;\n        top: 0;\n    }\n</style>\n<div class=\"wrapper\">\n   <div class=\"sticky\">\n        SOME CONTENT\n   </div>\n</div>\n\n<p>当我在包装元素中添加更多元素时，它就能开始正常工作了。</p>\n<h3 id=\"这是为什么？\"><a href=\"#这是为什么？\" class=\"headerlink\" title=\"这是为什么？\"></a>这是为什么？</h3><p>这是因为当一个元素被赋予 <code>position: sticky</code> 样式时，粘性项目的容器是它可以粘贴的唯一区域。 粘性元素没有任何要浮动的元素，因为它只能浮动在同级元素上，作为唯一的子元素，它不能浮动。</p>\n<h2 id=\"怎样才能让-CSS-粘性定位起作用\"><a href=\"#怎样才能让-CSS-粘性定位起作用\" class=\"headerlink\" title=\"怎样才能让 CSS 粘性定位起作用\"></a>怎样才能让 CSS 粘性定位起作用</h2><p>CSS 粘性定位有两个主要部分，粘性元素（<code>sticky item</code>）和 粘性容器（<code>sticky container</code>）。 粘性元素 —— 是我们用位置定义的<code>position: sticky</code>样式。 当视口位置与位置定义匹配时，该元素将会浮动，例如：<code>top: 0px</code> 。 例：</p>\n<p>.some-component{<br>    position: sticky;<br>    top: 0px;<br>}</p>\n<p>粘性容器 —— 是包装粘性元素的 HTML 元素。 这是粘性元素可以浮动的最大区域。 当你定义一个具有<code>position:sticky</code>样式的元素时，父元素会被自动定义为粘性容器！ 记住这一点非常重要！ 容器是粘性元素的范围，并且该元素无法离开其所在的粘性容器。 这就是为什么在前面的例子中，粘性元素没有被粘住的原因：这个粘性元素是粘性容器中唯一的子元素。 CSS 粘性定位的示意图： <img src=\"http://file.w3cbest.com/file/images/342842461-5c601033ed793_articlex.png\"></p>\n<p>See the Pen <a href=\"https://codepen.io/elad2412/pen/QYLEdK/\">Positon Sticky</a> by Elad Shechter (<a href=\"https://codepen.io/elad2412\">@elad2412</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"理解-CSS-的粘性行为\"><a href=\"#理解-CSS-的粘性行为\" class=\"headerlink\" title=\"理解 CSS 的粘性行为\"></a>理解 CSS 的粘性行为</h2><p>正如我前面说过的那样，CSS 粘性定位的行为与所有其他 CSS 定位不一样，但从另一个角度来说，它们也有一些相似之处。我来解释一下：</p>\n<ul>\n<li>  <strong>相对</strong>（或静态）—— 粘性定位元素类似于相对和静态位置，因为它保留了<code>DOM</code>中的自然间隙（留在流中）。</li>\n<li>  <strong>固定</strong> —— 当元素被粘住时，它的行为与<code>position: fixed</code>完全相同，浮动在与视口的相同位置，并从流中移除。</li>\n<li>  <strong>绝对</strong> —— 在粘贴区域的末尾，元素会停止，并堆叠在另一个元素的顶部，就像一个绝对定位的元素被放在一个<code>position: relative</code>容器内的行为。</li>\n</ul>\n<h2 id=\"粘在底部？\"><a href=\"#粘在底部？\" class=\"headerlink\" title=\"粘在底部？\"></a>粘在底部？</h2><p>在大多数情况下，您可以使用粘性定位将元素粘贴到顶部，如下所示：</p>\n<p>.component{<br>    position: sticky;<br>    top: 0;<br>}</p>\n<p>这正是它被设计的初衷，而在此之前，只能使用JavaScript完成这个功能。 但你也可以使用它把元素粘到底部。 这意味着你可以把页脚定义为粘性，并且在向下滚动时使它看起来总是被粘在底部。 当到达粘性容器的末端时，元素会停在它的自然位置。 最好是在以粘性容器底部为自然位置的元素上使用它。 完整示例：</p>\n<main class=\"main-container\">\n  <header class=\"main-header\">HEADER</header>\n  <div class=\"main-content\">MAIN CONTENT</div>\n  <footer class=\"main-footer\">FOOTER</footer>\n</main>\n\n<p>.main-footer{<br>     position: sticky;<br>     bottom: 0;<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/elad2412/pen/MZZVjw/\">Positon Sticky to Bottom</a> by Elad Shechter (<a href=\"https://codepen.io/elad2412\">@elad2412</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>我在开发中常用它来粘贴摘要表，也会用在粘性页脚导航上，这种方法非常适合。</p>\n<h2 id=\"浏览器支持\"><a href=\"#浏览器支持\" class=\"headerlink\" title=\"浏览器支持\"></a>浏览器支持</h2><p>除了老 IE 浏览器外，所有流行的现代浏览器都支持粘性定位。 如果用在 Safari 浏览器上，你需要添加 -webkit 前缀。</p>\n<p>position: -webkit-sticky; /* Safari */<br>position: sticky;</p>\n<p>复制代码</p>\n<p>文章来源<a href=\"https://medium.com/@elad/css-position-sticky-how-it-really-works-54cd01dc2d46\">CSS Position Sticky - How It Really Works!</a></p>\n","categories":["HTML/CSS"],"tags":["css3教程","css 布局","css sticky","css 粘性定位","css粘性布局"]},{"title":"肯定有你不知道的一些CSS小技巧","url":"/2018/12/07/%E8%82%AF%E5%AE%9A%E6%9C%89%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%9Bcss%E5%B0%8F%E6%8A%80%E5%B7%A7/","content":"<h3 id=\"黑白图像\"><a href=\"#黑白图像\" class=\"headerlink\" title=\"黑白图像\"></a>黑白图像</h3><p>这段代码会让你的彩色照片显示为黑白照片，是不是很酷？</p>\n<p>img.desaturate {<br>filter: grayscale(100%);<br>-webkit-filter: grayscale(100%);<br>-moz-filter: grayscale(100%);<br>-ms-filter: grayscale(100%);<br>-o-filter: grayscale(100%);<br>}</p>\n<h3 id=\"使用-not-在菜单上应用-取消应用边框\"><a href=\"#使用-not-在菜单上应用-取消应用边框\" class=\"headerlink\" title=\"使用 :not() 在菜单上应用/取消应用边框\"></a>使用 :not() 在菜单上应用/取消应用边框</h3><p>先给每一个菜单项添加边框</p>\n<p>/* add border */<br>.nav li {<br>border-right: 1px solid #666;<br>}</p>\n<p>……然后再除去最后一个元素……</p>\n<p>// remove border //<br>.nav li:last-child {<br>border-right: none;<br>}</p>\n<p>这样代码就干净，易读，易于理解了。 当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：</p>\n<p>.nav li:first-child ~ li {<br>border-left: 1px solid #666;<br>}</p>\n<h3 id=\"页面顶部阴影\"><a href=\"#页面顶部阴影\" class=\"headerlink\" title=\"页面顶部阴影\"></a>页面顶部阴影</h3><p>下面这个简单的 css3 代码片段可以给网页加上漂亮的顶部阴影效果：</p>\n<p>body:before {<br>content: “”;<br>position: fixed;<br>top: -10px;<br>left: 0;<br>width: 100%;<br>height: 10px;<br>-webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8);<br>-moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8);<br>box-shadow: 0px 0px 10px rgba(0,0,0,.8);<br>z-index: 100;<br>}</p>\n<h3 id=\"给-body-添加行高\"><a href=\"#给-body-添加行高\" class=\"headerlink\" title=\"给 body 添加行高\"></a>给 body 添加行高</h3><p>你不需要分别添加 line-height 到每个p,h标记等。只要添加到 body 即可：</p>\n<p>body {<br>line-height: 1;<br>}</p>\n<p>这样文本元素就可以很容易地从 body 继承。</p>\n<h3 id=\"所有一切都垂直居中\"><a href=\"#所有一切都垂直居中\" class=\"headerlink\" title=\"所有一切都垂直居中\"></a>所有一切都垂直居中</h3><p>要将所有元素垂直居中，太简单了</p>\n<p>html, body {<br>height: 100%;<br>margin: 0;<br>}<br>body {<br>-webkit-align-items: center;<br>-ms-flex-align: center;<br>align-items: center;<br>display: -webkit-flex;<br>display: flex;<br>}</p>\n<p>注意：在IE11中要小心flexbox。  </p>\n<h3 id=\"逗号分隔的列表\"><a href=\"#逗号分隔的列表\" class=\"headerlink\" title=\"逗号分隔的列表\"></a>逗号分隔的列表</h3><p>让HTML列表项看上去像一个真正的，用逗号分隔的列表：</p>\n<p>ul &gt; li:not(:last-child)::after {<br>content: “,”;<br>}</p>\n<p>对最后一个列表项使用 :not() 伪类。  </p>\n<h3 id=\"使用负的-nth-child-选择项目\"><a href=\"#使用负的-nth-child-选择项目\" class=\"headerlink\" title=\"使用负的 nth-child 选择项目\"></a>使用负的 nth-child 选择项目</h3><p>在CSS中使用负的 nth-child 选择项目1到项目n。</p>\n<p>li {<br>display: none;<br>}<br>/* select items 1 through 3 and display them */<br>li:nth-child(-n+3) {<br>display: block;<br>}</p>\n<p> </p>\n<h3 id=\"对图标使用-SVG\"><a href=\"#对图标使用-SVG\" class=\"headerlink\" title=\"对图标使用 SVG\"></a>对图标使用 SVG</h3><p>我们没有理由不对图标使用SVG：</p>\n<p>.logo {<br>background: url(“logo.svg”);<br>}</p>\n<p>SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。  </p>\n<h3 id=\"优化显示文本\"><a href=\"#优化显示文本\" class=\"headerlink\" title=\"优化显示文本\"></a>优化显示文本</h3><p>有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：</p>\n<p>html {<br>-moz-osx-font-smoothing: grayscale;<br>-webkit-font-smoothing: antialiased;<br>text-rendering: optimizeLegibility;<br>}</p>\n<p>注：请负责任地使用 optimizeLegibility。此外，IE /Edge没有 text-rendering 支持。  </p>\n<h3 id=\"对纯-CSS-滑块使用-max-height\"><a href=\"#对纯-CSS-滑块使用-max-height\" class=\"headerlink\" title=\"对纯 CSS 滑块使用 max-height\"></a>对纯 CSS 滑块使用 max-height</h3><p>使用 max-height 和溢出隐藏来实现只有CSS的滑块：</p>\n<p>.slider ul {<br>max-height: 0;<br>overlow: hidden;<br>}<br>.slider:hover ul {<br>max-height: 1000px;<br>transition: .3s ease;<br>}</p>\n<p> </p>\n<h3 id=\"继承-box-sizing\"><a href=\"#继承-box-sizing\" class=\"headerlink\" title=\"继承 box-sizing\"></a>继承 box-sizing</h3><p>让 box-sizing 继承 html：</p>\n<p>html {<br>box-sizing: border-box;<br>}<br>*, *:before, *:after {<br>box-sizing: inherit;<br>}</p>\n<p>这样在插件或杠杆其他行为的其他组件中就能更容易地改变 box-sizing 了。  </p>\n<h3 id=\"表格单元格等宽\"><a href=\"#表格单元格等宽\" class=\"headerlink\" title=\"表格单元格等宽\"></a>表格单元格等宽</h3><p>表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽：</p>\n<p>.calendar {<br>table-layout: fixed;<br>}</p>\n<p> </p>\n<h3 id=\"用-Flexbox-摆脱外边距的各种-hack\"><a href=\"#用-Flexbox-摆脱外边距的各种-hack\" class=\"headerlink\" title=\"用 Flexbox 摆脱外边距的各种 hack\"></a>用 Flexbox 摆脱外边距的各种 hack</h3><p>当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了：</p>\n<p>.list {<br>display: flex;<br>justify-content: space-between;<br>}<br>.list .person {<br>flex-basis: 23%;<br>}</p>\n<p>现在，列表分隔符就会在均匀间隔的位置出现。</p>\n<h3 id=\"使用属性选择器用于空链接\"><a href=\"#使用属性选择器用于空链接\" class=\"headerlink\" title=\"使用属性选择器用于空链接\"></a>使用属性选择器用于空链接</h3><p>当a元素没有文本值，但 href 属性有链接的时候显示链接：</p>\n<p>a[href^=”http”]:empty::before {<br>content: attr(href);<br>}</p>\n<p> </p>\n<h3 id=\"检测鼠标双击\"><a href=\"#检测鼠标双击\" class=\"headerlink\" title=\"检测鼠标双击\"></a>检测鼠标双击</h3><p>.test3 span {<br>position: relative;<br>}<br>.test3 span a {<br>position: relative;<br>z-index: 2;<br>}<br>.test3 span a:hover, .test3 span a:active {<br>z-index: 4;<br>}<br>.test3 span input {<br>background: transparent;<br>border: 0;<br>cursor: pointer;<br>position: absolute;<br>top: -1px;<br>left: 0;<br>width: 101%; /* Hacky */<br>height: 301%; /* Hacky */<br>z-index: 3;<br>}<br>.test3 span input:focus {<br>background: transparent;<br>border: 0;<br>z-index: 1;<br>}</p>\n<p> </p>\n<h3 id=\"CSS-写出三角形\"><a href=\"#CSS-写出三角形\" class=\"headerlink\" title=\"CSS 写出三角形\"></a>CSS 写出三角形</h3><p>利用border来写三角形代码，并且兼容IE6.</p>\n<p>/* create an arrow that points up */<br>div.arrow-up {<br>width:0px;<br>height:0px;<br>border-left:5px solid transparent; /* left arrow slant */<br>border-right:5px solid transparent; /* right arrow slant */<br>border-bottom:5px solid #2f2f2f; /* bottom, add background color here */<br>font-size:0px;<br>line-height:0px;<br>}<br>/* create an arrow that points down */<br>div.arrow-down {<br>width:0px;<br>height:0px;<br>border-left:5px solid transparent;<br>border-right:5px solid transparent;<br>border-top:5px solid #2f2f2f;<br>font-size:0px;<br>line-height:0px;<br>}<br>/* create an arrow that points left */<br>div.arrow-left {<br>width:0px;<br>height:0px;<br>border-bottom:5px solid transparent; /* left arrow slant */<br>border-top:5px solid transparent; /* right arrow slant */<br>border-right:5px solid #2f2f2f; /* bottom, add background color here */<br>font-size:0px;<br>line-height:0px;<br>}<br>/* create an arrow that points right */<br>div.arrow-right {<br>width:0px;<br>height:0px;<br>border-bottom:5px solid transparent; /* left arrow slant */<br>border-top:5px solid transparent; /* right arrow slant */<br>border-left:5px solid #2f2f2f; /* bottom, add background color here */<br>font-size:0px;<br>line-height:0px;<br>}</p>\n<p> </p>\n<h3 id=\"CSS3-calc-的使用\"><a href=\"#CSS3-calc-的使用\" class=\"headerlink\" title=\"CSS3 calc() 的使用\"></a>CSS3 calc() 的使用</h3><p>calc() 用法类似于函数，能够给元素设置动态的值：</p>\n<p>/* basic calc */<br>.simpleBlock {<br>width: calc(100% - 100px);<br>}<br>/* calc in calc */<br>.complexBlock {<br>width: calc(100% - 50% / 3);<br>padding: 5px calc(3% - 2px);<br>margin-left: calc(10% + 10px);<br>}</p>\n<h3 id=\"文本渐变\"><a href=\"#文本渐变\" class=\"headerlink\" title=\"文本渐变\"></a>文本渐变</h3><p>文本渐变效果很流行，使用 CSS3 能够很简单就实现：</p>\n<p>h2[data-text] {<br>position: relative;<br>}<br>h2[data-text]::after {<br>content: attr(data-text);<br>z-index: 10;<br>color: #e3e3e3;<br>position: absolute;<br>top: 0;<br>left: 0;<br>-webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));<br>}</p>\n<p> </p>\n<h3 id=\"禁用鼠标事件\"><a href=\"#禁用鼠标事件\" class=\"headerlink\" title=\"禁用鼠标事件\"></a>禁用鼠标事件</h3><p>CSS3 新增的 pointer-events 让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。</p>\n<p>.disabled { pointer-events: none; }</p>\n<p> </p>\n<h3 id=\"模糊文本\"><a href=\"#模糊文本\" class=\"headerlink\" title=\"模糊文本\"></a>模糊文本</h3><p>简单但很漂亮的文本模糊效果，简单又好看！</p>\n<p>.blur {<br>color: transparent;<br>text-shadow: 0 0 5px rgba(0,0,0,0.5);<br>}</p>\n","categories":["HTML/CSS"],"tags":["css3","flex","calc()",":after",":before"]},{"title":"让你更好的编写 JavaScript(ES6) 中条件语句的5个技巧","url":"/2019/04/23/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%BC%96%E5%86%99-javascriptes6-%E4%B8%AD%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E7%9A%845%E4%B8%AA%E6%8A%80%E5%B7%A7/","content":"<p>使用 JavaScript 时，我们经常需要处理很多条件语句，这里分享5个小技巧，可以让你编写更好/更清晰的条件语句。</p>\n<h2 id=\"1-使用-Array-includes-来处理多个条件\"><a href=\"#1-使用-Array-includes-来处理多个条件\" class=\"headerlink\" title=\"1.使用 Array.includes 来处理多个条件\"></a>1.使用 Array.includes 来处理多个条件</h2><p>我们来看看下面的例子：</p>\n<p>// condition<br>function test(fruit) {<br>    if (fruit == ‘apple’  fruit == ‘strawberry’) {<br>        console.log(‘red’);<br>    }<br>}</p>\n<p>乍一看，上面的例子看起来似乎没什么问题。 但是，如果我们还有更多的红色水果呢？比如樱桃（<code>cherry</code>）和蔓越莓（<code>cranberries</code>）。 我们是否要用更多的 操作符来扩展该语句呢？ 我们可以使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes\">Array.includes</a> 重写上面的条件语句。</p>\n<p>function test(fruit) {<br>    // 条件提取到数组中<br>    const redFruits = [‘apple’, ‘strawberry’, ‘cherry’, ‘cranberries’];<br>    if (redFruits.includes(fruit)) {<br>        console.log(‘red’);<br>    }<br>}</p>\n<p>我们将红色水果（条件）提取到一个数组中。这样做，可以让代码看起来更整洁。</p>\n<h2 id=\"2-减少嵌套，提前使用-return-语句\"><a href=\"#2-减少嵌套，提前使用-return-语句\" class=\"headerlink\" title=\"2.减少嵌套，提前使用 return 语句\"></a>2.减少嵌套，提前使用 return 语句</h2><p>让我们扩展前面的示例，再包含另外两个条件：</p>\n<ul>\n<li>  如果没有提供水果，抛出错误</li>\n<li>  接受水果 <code>quantity</code>（数量）参数，如果超过 <code>10</code>，则并打印相关信息。</li>\n</ul>\n<p>function test(fruit, quantity) {<br>    const redFruits = [‘apple’, ‘strawberry’, ‘cherry’, ‘cranberries’];<br>    // 条件 1：fruit 必须有值<br>    if (fruit) {<br>        // 条件 2：必须为红色<br>        if (redFruits.includes(fruit)) {<br>            console.log(‘red’);</p>\n<pre><code>        // 条件 3：数量必须大于 10\n        if (quantity &gt; 10) &#123;\n            console.log(&#39;big quantity&#39;);\n        &#125;\n    &#125;\n&#125; else &#123;\n    throw new Error(&#39;No fruit!&#39;);\n&#125;\n</code></pre>\n<p>}</p>\n<p>// 测试结果<br>test(null); // 抛出错误：No fruits<br>test(‘apple’); // 打印：red<br>test(‘apple’, 20); // 打印：red，big quantity</p>\n<p>看看上面的代码，我们有： – 1 个 <code>if / else</code> 语句过滤掉无效条件 – 3 层 <code>if</code> 语句嵌套（分别是条件1,2和3） 我个人遵循的一般规则是 在发现无效条件时提前 <code>return</code>。</p>\n<p>/* 在发现无效条件时提前 return */<br>function test(fruit, quantity) {<br>    const redFruits = [‘apple’, ‘strawberry’, ‘cherry’, ‘cranberries’];</p>\n<pre><code>// 条件 1：提前抛出错误\nif (!fruit) throw new Error(&#39;No fruit!&#39;);\n\n// 条件2：必须为红色\nif (redFruits.includes(fruit)) &#123;\n    console.log(&#39;red&#39;);\n\n    // 条件 3：数量必须大于 10\n    if (quantity &gt; 10) &#123;\n        console.log(&#39;big quantity&#39;);\n    &#125;\n&#125;\n</code></pre>\n<p>}</p>\n<p>这样做，我们可以减少一个嵌套层级。 这种编码风格很好，特别是当你的 <code>if</code> 语句很长时（想象一下，你需要滚动到最底部才知道那里有一个 <code>else</code> 语句，这样代码的可读性就变得很差了）。 如果通过反转条件并提前 <code>return</code> ，我们可以进一步减少嵌套。 请查看下面的条件 <code>2</code> ，看看我们是如何做到的：</p>\n<p>/* 在发现无效条件时提前 return */<br>function test(fruit, quantity) {<br>    const redFruits = [‘apple’, ‘strawberry’, ‘cherry’, ‘cranberries’];</p>\n<pre><code>if (!fruit) throw new Error(&#39;No fruit!&#39;); // 条件 1：提前抛出错误\nif (!redFruits.includes(fruit)) return; // 条件 2：当 fruit 不是红色的时候，提前 return\n\nconsole.log(&#39;red&#39;);\n\n// 条件 3：必须是大量存在\nif (quantity &gt; 10) &#123;\n    console.log(&#39;big quantity&#39;);\n&#125;\n</code></pre>\n<p>}</p>\n<p>通过反转条件2的条件，我们的代码现在没有嵌套语句了。 当我们有很长的逻辑代码时，这种技巧非常有用，我们希望在条件不满足时停止下一步的处理。 然而，这并不是严格的规定。问问自己，这个版本（没有嵌套）是否要比前一个版本（条件 <code>2</code> 有嵌套）的更好、可具可读性？ 对我来说，我会选择前一个版本（条件 <code>2</code> 有嵌套）。 这是因为：</p>\n<ul>\n<li>  代码简短直接，嵌套 <code>if</code> 更清晰</li>\n<li>  反转条件可能会引发更多的思考过程（增加认知负担）</li>\n</ul>\n<p>因此，始终追求更少的嵌套，提前 <code>return</code>，但是不要过度。但不要过度。如果您感兴趣，这里有一篇文章和 <code>StackOverflow</code> 的讨论， 进一步讨论这个话题：</p>\n<ul>\n<li>  <a href=\"http://blog.timoxley.com/post/47041269194/avoid-else-return-early\">Avoid Else, Return Early</a> by Tim Oxley</li>\n<li>  <a href=\"https://softwareengineering.stackexchange.com/questions/18454/should-i-return-from-a-function-early-or-use-an-if-statement\">StackOverflow 上关于 if/else 代码风格的讨论</a></li>\n</ul>\n<h2 id=\"3-使用函数的默认参数-和-解构\"><a href=\"#3-使用函数的默认参数-和-解构\" class=\"headerlink\" title=\"3.使用函数的默认参数 和 解构\"></a>3.使用函数的默认参数 和 解构</h2><p>我想下面的代码可能看起来很熟悉，我们在使用 JavaScript 时总是需要检查 <code>null / undefined</code> 值并分配默认值：</p>\n<p>function test(fruit, quantity) {<br>    if (!fruit) return;<br>    const q = quantity  1; // 如果没有提供 quantity 参数，则默认为 1</p>\n<pre><code>console.log(\\`We have $&#123;q&#125; $&#123;fruit&#125;!\\`);\n</code></pre>\n<p>}</p>\n<p>// 测试结果<br>test(‘banana’); // We have 1 banana!<br>test(‘apple’, 2); // We have 2 apple!</p>\n<p>实际上，我们可以通过分配默认函数参数来消除变量 <code>q</code> 。</p>\n<p>function test(fruit, quantity = 1) { // i如果没有提供 quantity 参数，则默认为 1<br>    if (!fruit) return;<br>    console.log(`We have ${quantity} ${fruit}!`);<br>}</p>\n<p>// 测试结果<br>test(‘banana’); // We have 1 banana!<br>test(‘apple’, 2); // We have 2 apple!</p>\n<p>更简单直观不是吗？ 请注意，每个函数参数都有自己的默认值。 例如，我们也可以为 <code>fruit</code> 分配一个默认值：<code>function test(fruit = &#39;unknown&#39;, quantity = 1)</code>。 如果我们的 <code>fruit</code> 是一个 <code>Object</code> 对象怎么办？ 我们可以指定默认参数吗？</p>\n<p>function test(fruit) {<br>    // 如果有值，则打印 fruit.name<br>    if (fruit &amp;&amp; fruit.name) {<br>        console.log(fruit.name);<br>    } else {<br>        console.log(‘unknown’);<br>    }<br>}</p>\n<p>//测试结果<br>test(undefined); // unknown<br>test({}); // unknown<br>test({ name: ‘apple’, color: ‘red’ }); // apple</p>\n<p>看看上面的例子，我们想要的是如果 <code>fruit.name</code> 可用则打印水果名称，否则将打印 <code>unknown</code> 。我们可以使用默认函数参数和解构(<code>destructing</code>) 来避免 <code>fruit &amp;&amp; fruit.name</code> 这样的检查。</p>\n<p>// 解构 —— 只获得 name 属性<br>// 参数默认分配空对象 {}<br>function test({ name } = {}) {<br>    console.log(name  ‘unknown’);<br>}</p>\n<p>//测试结果<br>test(undefined); // unknown<br>test({}); // unknown<br>test({ name: ‘apple’, color: ‘red’ }); // apple</p>\n<p>由于我们只需要来自 <code>fruit</code> 的 <code>name</code> 属性，我们可以使用 <code>&#123;name&#125;</code> 来解构参数，然后我们可以在代码中使用 <code>name</code> 作为变量来取代<code>fruit.name</code>。 我们还将空对象 <code>&#123;&#125;</code> 指定为默认值。 如果我们不这样做，你将在执行行测试时遇到<code>test(undefined) – Cannot destructure property name of &#39;undefined&#39; or &#39;null&#39;.</code>(无法解析’undefined’或’null’的属性名称)。 因为 <code>undefined</code>中 没有 <code>name</code> 属性。 如果您不介意使用第三方库，有几种方法可以减少空检查：</p>\n<ul>\n<li>  使用 <a href=\"https://lodash.com/docs/4.17.11#get\">Lodash get</a> 函数</li>\n<li>  使用 Facebook 开源的 <a href=\"https://github.com/facebookincubator/idx\">idx</a> 库（需搭配 Babeljs）</li>\n</ul>\n<p>以下是使用Lodash的示例：</p>\n<p>// 引入 lodash 库，我们将获得 _.get()<br>function test(fruit) {<br>console.log(_.get(fruit, ‘name’, ‘unknown’); // 获取 name 属性，如果没有分配，则设为默认值 unknown<br>}</p>\n<p>//测试结果<br>test(undefined); // unknown<br>test({ }); // unknown<br>test({ name: ‘apple’, color: ‘red’ }); // apple</p>\n<p>您可以在这里 <a href=\"http://jsbin.com/bopovajiye/edit?js,console\">运行演示代码</a> 。此外，如果你喜欢函数式编程（FP），您可以选择使用<a href=\"https://github.com/lodash/lodash/wiki/FP-Guide\">Lodash fp</a> ，Lodash的函数式能版本（方法名更改为 <code>get</code> 或 <code>getOr</code>）。</p>\n<h2 id=\"4-选择-Map-Object-字面量，而不是Switch语句\"><a href=\"#4-选择-Map-Object-字面量，而不是Switch语句\" class=\"headerlink\" title=\"4.选择 Map / Object 字面量，而不是Switch语句\"></a>4.选择 Map / Object 字面量，而不是Switch语句</h2><p>让我们看看下面的例子，我们想根据颜色打印水果：</p>\n<p>function test(color) {<br>    // 使用 switch case 语句，根据颜色找出对应的水果<br>    switch (color) {<br>        case ‘red’:<br>            return [‘apple’, ‘strawberry’];<br>        case ‘yellow’:<br>            return [‘banana’, ‘pineapple’];<br>        case ‘purple’:<br>            return [‘grape’, ‘plum’];<br>        default:<br>            return [];<br>    }<br>}</p>\n<p>//测试结果<br>test(null); // []<br>test(‘yellow’); // [‘banana’, ‘pineapple’]</p>\n<p>上面的代码似乎没有错，但我觉得它很冗长。使用具有更清晰语法的 <code>object</code> 字面量可以实现相同的结果：</p>\n<p>// 使用对象字面量，根据颜色找出对应的水果<br>const fruitColor = {<br>    red: [‘apple’, ‘strawberry’],<br>    yellow: [‘banana’, ‘pineapple’],<br>    purple: [‘grape’, ‘plum’]<br>};</p>\n<p>function test(color) {<br>    return fruitColor[color]  [];<br>}</p>\n<p>或者，您可以使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">Map</a> 来实现相同的结果：</p>\n<p>// 使用 Map ，根据颜色找出对应的水果<br>const fruitColor = new Map()<br>    .set(‘red’, [‘apple’, ‘strawberry’])<br>    .set(‘yellow’, [‘banana’, ‘pineapple’])<br>    .set(‘purple’, [‘grape’, ‘plum’]);</p>\n<p>function test(color) {<br>    return fruitColor.get(color)  [];<br>}</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">Map</a> 是 <code>ES2015(ES6)</code> 引入的新的对象类型，允许您存储键值对。 我们是不是应该禁止使用 <code>switch</code> 语句呢？ 不要局限于此。 就个人而言，我尽可能使用对象字面量，但我不会设置硬规则来阻止使用 <code>switch</code> ，是否使用应该根据你的场景而决定。 Todd Motto 有一篇文章深入地研究了 switch语句与对象字面量，你可以在 <a href=\"https://toddmotto.com/deprecating-the-switch-statement-for-object-literals/\">这里</a> 阅读。 <strong>重构语法</strong> 对于上面的示例，我们实际上可以使用 <code>Array.filter</code> 来重构我们的代码，以实现相同的结果。</p>\n<p>const fruits = [<br>    { name: ‘apple’, color: ‘red’ },<br>    { name: ‘strawberry’, color: ‘red’ },<br>    { name: ‘banana’, color: ‘yellow’ },<br>    { name: ‘pineapple’, color: ‘yellow’ },<br>    { name: ‘grape’, color: ‘purple’ },<br>    { name: ‘plum’, color: ‘purple’ }<br>];</p>\n<p>function test(color) {<br>    // 使用 Array filter ，根据颜色找出对应的水果</p>\n<pre><code>return fruits.filter(f =&gt; f.color == color);\n</code></pre>\n<p>}</p>\n<p>总有不止一种方法可以达到相同的效果。对于这个例子我们展示了 <code>4</code> 种实现方法。编码很有趣！</p>\n<h2 id=\"5-使用-Array-every-和-Array-some-来处理全部-部分满足条件\"><a href=\"#5-使用-Array-every-和-Array-some-来处理全部-部分满足条件\" class=\"headerlink\" title=\"5. 使用 Array.every 和 Array.some 来处理全部/部分满足条件\"></a>5. 使用 Array.every 和 Array.some 来处理全部/部分满足条件</h2><p>最后一个小技巧更多地是利用新的（但不是那么新的）<code>Javascript Array</code>函数来减少代码行。查看下面的代码，我们想检查所有水果是否都是红色的：</p>\n<p>const fruits = [<br>    { name: ‘apple’, color: ‘red’ },<br>    { name: ‘banana’, color: ‘yellow’ },<br>    { name: ‘grape’, color: ‘purple’ }<br>];</p>\n<p>function test() {<br>    let isAllRed = true;</p>\n<pre><code>// 条件：所有的水果都必须是红色\nfor (let f of fruits) &#123;\n    if (!isAllRed) break;\n    isAllRed = (f.color == &#39;red&#39;);\n&#125;\n\nconsole.log(isAllRed); // false\n</code></pre>\n<p>}</p>\n<p>代码太长了！我们可以使用 <code>Array.every</code> 减少行数：</p>\n<p>const fruits = [<br>    { name: ‘apple’, color: ‘red’ },<br>    { name: ‘banana’, color: ‘yellow’ },<br>    { name: ‘grape’, color: ‘purple’ }<br>];</p>\n<p>function test() {<br>    // 条件：简短方式，所有的水果都必须是红色<br>    const isAllRed = fruits.every(f =&gt; f.color == ‘red’);</p>\n<pre><code>console.log(isAllRed); // false\n</code></pre>\n<p>}</p>\n<p>干净多了对吧？类似的，如果我们想要检查是否有至少一个水果是红色的，我们可以使用 <code>Array.some</code> 仅用一行代码就实现出来。</p>\n<p>const fruits = [<br>    { name: ‘apple’, color: ‘red’ },<br>    { name: ‘banana’, color: ‘yellow’ },<br>    { name: ‘grape’, color: ‘purple’ }<br>];</p>\n<p>function test() {<br>    // 条件：是否存在红色的水果<br>    const isAnyRed = fruits.some(f =&gt; f.color == ‘red’);</p>\n<pre><code>console.log(isAnyRed); // true\n</code></pre>\n<p>}</p>\n<p>  原文地址：<a href=\"https://scotch.io/bar-talk/5-tips-to-write-better-conditionals-in-javascript\">https://scotch.io</a></p>\n","categories":["JavaScript"],"tags":["javascript","Array.includes","Map","Object","Array.some","es6","对象字面量","Array.every","default parameters","Destructuring","if / else","lodash","return","减少嵌套","条件语句","编程技巧","解构","重构","默认参数"]},{"title":"这6个强大的CSS选择器学会，将真正帮你写出干净的CSS代码！","url":"/2020/09/23/%E8%BF%996%E4%B8%AA%E5%BC%BA%E5%A4%A7%E7%9A%84css%E9%80%89%E6%8B%A9%E5%99%A8%E5%AD%A6%E4%BC%9A%EF%BC%8C%E5%B0%86%E7%9C%9F%E6%AD%A3%E5%B8%AE%E4%BD%A0%E5%86%99%E5%87%BA%E5%B9%B2%E5%87%80%E7%9A%84css/","content":"<p>CSS中的选择器用于选择元素并设置其样式。在我们使用其中一个之后，它们可能会非常强大。在本文中，我将引导您通过6个功能强大的CSS选择器，这些选择器将真正帮助您在下一个项目中编写干净的CSS。</p>\n<h3 id=\"1-div-gt-a\"><a href=\"#1-div-gt-a\" class=\"headerlink\" title=\"1. div &gt;a\"></a>1. div &gt;a</h3><p>这个选择器将使我们能够选择所有父元素是div标签的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- This one will be selected --&gt; </span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">&lt;a&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- This one won&#39;t be selected --&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;a&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\">&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-div-a\"><a href=\"#2-div-a\" class=\"headerlink\" title=\"2. div +a\"></a>2. div +a</h3><p>选择紧接在div元素之后的每个标签。如果我们在div和a标签之间有一个元素，则不会选择该元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;main&gt;</span><br><span class=\"line\">&lt;!-- This one will be selected --&gt;</span><br><span class=\"line\">&lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;a&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\">&lt;!-- This one won&#39;t be selected --&gt;</span><br><span class=\"line\">&lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;p&gt;&lt;&#x2F;p&gt;</span><br><span class=\"line\">&lt;a&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\">&lt;&#x2F;main&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-div-a\"><a href=\"#3-div-a\" class=\"headerlink\" title=\"3. div ~a\"></a>3. div ~a</h3><p>a标签将选择每个标签，然后在同一级别上添加div标签。换句话说，如果a标签不是紧跟在div标签之后，而是具有div标签作为同级元素，则将选择该标签。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;main&gt;</span><br><span class=\"line\">  &lt;!-- This one will be selected --&gt;</span><br><span class=\"line\">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;a&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\">  &lt;!-- This one will be selected --&gt;</span><br><span class=\"line\">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;p&gt;&lt;&#x2F;p&gt;</span><br><span class=\"line\">  &lt;a&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\">  &lt;section&gt;</span><br><span class=\"line\">    &lt;!-- This one will be selected --&gt;</span><br><span class=\"line\">    &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;p&gt;&lt;&#x2F;p&gt;</span><br><span class=\"line\">    &lt;a&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\">  &lt;&#x2F;section&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;footer&gt;</span><br><span class=\"line\">    &lt;!-- This one won&#39;t be selected --&gt;</span><br><span class=\"line\">    &lt;p&gt;&lt;&#x2F;p&gt;</span><br><span class=\"line\">    &lt;a&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\">  &lt;&#x2F;footer&gt;</span><br><span class=\"line\">&lt;&#x2F;main&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-属性-值\"><a href=\"#4-属性-值\" class=\"headerlink\" title=\"4. [属性^=值]\"></a>4. [属性^=值]</h4><p>例如：<code>[class ^ =&quot;list-&quot;]</code>此选择器将选择每个包含class属性且其值以list-开头的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;main&gt;</span><br><span class=\"line\">&lt;!-- This one will be selected --&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;list-element&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;!-- This one will be selected --&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;list-container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;!-- This one will be selected --&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;list-item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;!-- This one won&#39;t be selected --&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;list__footer&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;main&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-属性-值\"><a href=\"#5-属性-值\" class=\"headerlink\" title=\"5. [属性$=值]\"></a>5. [属性$=值]</h3><p>例如：[src $ =”.png”]这将选择每个值以.png结尾的src属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">&lt;!-- This one will be selected --&gt;</span><br><span class=\"line\">&lt;img src&#x3D;&quot;image1.png&quot;&gt;</span><br><span class=\"line\">&lt;!-- This one will be not selected --&gt;</span><br><span class=\"line\">&lt;img src&#x3D;&quot;image2.jpg&quot;&gt;</span><br><span class=\"line\">&lt;!-- This one will be selected --&gt;</span><br><span class=\"line\">&lt;img src&#x3D;&quot;image3.png&quot;&gt;</span><br><span class=\"line\">&lt;!-- This one won&#39;t be selected --&gt;</span><br><span class=\"line\">&lt;img src&#x3D;&quot;image4.svg&quot;&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-属性-值\"><a href=\"#6-属性-值\" class=\"headerlink\" title=\"6. [属性*=值]\"></a>6. [属性*=值]</h3><p>例如：<code>[class * =&quot;-list&quot;]</code>此选择器将选择其class属性包含-list的每个元素。 不管-list是在类值的开头，中间还是结尾都没有关系。最重要的是该值必须包含-list。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;main&gt;</span><br><span class=\"line\">&lt;!-- This one will be selected --&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;main-list-container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;!-- This one will be selected --&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;primary-list&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;!-- This one will be selected --&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;primary-list-item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;!-- This one won&#39;t be selected --&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;list-footer&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;main&gt;</span><br></pre></td></tr></table></figure>\n\n<p>结论 有时候，很难找到所需样式的元素，这是因为我们对CSS选择器不够熟悉，而导致被滥用。在实际应用中，这些选择器可能是非常有用。</p>\n","categories":["HTML/CSS"],"tags":["css","css3教程","css选择器"]},{"title":"10 个最常见的 JavaScript 错误（以及如何避免它们）","url":"/2019/04/25/10-%E4%B8%AA%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84-javascript-%E9%94%99%E8%AF%AF%EF%BC%88%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%AE%83%E4%BB%AC%EF%BC%89/","content":"<p>为了回馈我们的开发者社区，我们查看了数千个项目的数据库，发现了 JavaScript 的 10 大错误。我们将向你展示这些错误的原因，以及如何防止这些错误发生。如果你避免了这些 “陷阱” ，这将使你成为一个更好的开发人员。 由于数据是国王，我们收集，分析并排名前十的 <a href=\"https://rollbar.com/error-tracking/javascript/\">JavaScript 错误</a>。 Rollbar 会收集每个项目的所有错误，并总结每个项目发生的次数。 我们根据 <a href=\"https://rollbar.com/docs/grouping-algorithm/\">指纹</a> 对错误进行分组，来做到这一点。基本上，如果第二个错误只是第一个错误的重复，我们会把两个错误分到同一组。 这给用户一个很好的概括，而不是像在日志文件中看到的那些压迫性的一大堆垃圾描述。 我们专注于最有可能影响你和你的用户的错误。 为此，我们通过横跨不同公司的项目数来排列错误。 如果我们只查看每个错误发生的总次数，那么大流量的项目可能会淹没与大多数读者无关的错误的数据集。 以下是排名前 10 的 JavaScript 错误： <img src=\"http://file.w3cbest.com/file/images/javascript-error-graph.png\"> 为了便于阅读，没有花大段的文字来描述每个错误。让我们深入到每一个错误，来确定什么可以导致它，以及如何避免它发生。</p>\n<h2 id=\"1-Uncaught-TypeError-Cannot-read-property\"><a href=\"#1-Uncaught-TypeError-Cannot-read-property\" class=\"headerlink\" title=\"1.Uncaught TypeError: Cannot read property\"></a>1.Uncaught TypeError: Cannot read property</h2><p>如果你是一个 JavaScript 开发人员，你可能已经看到这个错误的次数比你敢承认的要多。当你读取一个属性或调用一个未定义的对象的方法时，这个错误会在 Chrome 中发生。你可以在 Chrome 开发者工具的控制台中轻松测试。 <img src=\"http://file.w3cbest.com/file/images/cannot-read-property.png\" alt=\"Screenshot of Uncaught TypeError: Cannot read property\"> 发生这种情况的原因很多，但常见的一种情况是在渲染UI组件时不恰当地初始化了 state(状态)。 我们来看一个在真实应用程序中如何发生的例子。 我们将选择 React，但不正确初始化的原则也适用于Angular，Vue或任何其他框架。</p>\n<p>class Quiz extends Component {<br>    componentWillMount() {<br>        axios.get(‘/thedata’).then(res =&gt; {<br>            this.setState({ items: res.data });<br>        });<br>    }</p>\n<pre><code>render() &#123;\n    return (\n        &lt;ul&gt;\n    &#123;this.state.items.map(item =&gt;\n      &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;\n    )&#125;\n  &lt;/ul&gt;\n    );\n&#125;\n</code></pre>\n<p>}</p>\n<p>这里有两件重要的事情要实现：</p>\n<ol>\n<li> 组件的状态（例如 <code>this.state</code>）从 undefined 开始。</li>\n<li> 当您异步获取数据时，组件在数据加载之前至少会渲染一次，而不管它是在构造函数 <code>componentWillMount</code> 还是 <code>componentDidMount</code> 中获取的。 当 Quiz 第一次渲染时，<code>this.state.items</code> 是 <code>undefined</code> 。 这又意味着 <code>ItemList</code> 将 items 定义为 <code>undefined</code> ，并且在控制台中出现错误 – “Uncaught TypeError: Cannot read property ‘map’ of undefined”。</li>\n</ol>\n<p>这个问题很容易解决。最简单的方法：在构造函数中用合理的默认值来初始化 state。</p>\n<p>class Quiz extends Component {<br>    // Added this:<br>    constructor(props) {<br>        super(props);</p>\n<pre><code>    // Assign state itself, and a default value for items\n    this.state = &#123;\n        items: \\[\\]\n    &#125;;\n&#125;\n\ncomponentWillMount() &#123;\n    axios.get(&#39;/thedata&#39;).then(res =&gt; &#123;\n        this.setState(&#123; items: res.data &#125;);\n    &#125;);\n&#125;\n\nrender() &#123;\n    return (\n        &lt;ul&gt;\n    &#123;this.state.items.map(item =&gt;\n      &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;\n    )&#125;\n  &lt;/ul&gt;\n    );\n&#125;\n</code></pre>\n<p>}</p>\n<p>你的应用中的确切代码可能会有所不同，但是我们希望我们已经给了你足够的线索，来解决或避免在你的应用程序中出现这个问题。如果你还没有碰到，请继续阅读，因为我们将在下面覆盖更多相关错误的示例。</p>\n<h2 id=\"2-TypeError-‘undefined’-is-not-an-object-evaluating\"><a href=\"#2-TypeError-‘undefined’-is-not-an-object-evaluating\" class=\"headerlink\" title=\"2.TypeError: ‘undefined’ is not an object (evaluating\"></a>2.TypeError: ‘undefined’ is not an object (evaluating</h2><p>这是在 Safari 中读取属性或调用未定义对象上的方法时发生的错误。你可以在 Safari Developer Console 中轻松测试。这与 Chrome 的上述错误基本相同，但 Safari 使用不同的错误消息。 <img src=\"http://file.w3cbest.com/file/images/undefined-is-not-an-object.png\" alt=\"Screenshot of TypeError: ‘undefined’ is not an object\"></p>\n<h2 id=\"3-TypeError-null-is-not-an-object-evaluating\"><a href=\"#3-TypeError-null-is-not-an-object-evaluating\" class=\"headerlink\" title=\"3.TypeError: null is not an object (evaluating\"></a>3.TypeError: null is not an object (evaluating</h2><p>这是在Safari中读取属性或调用 空对象(null) 上的方法时发生的错误。您可以在 Safari Developer Console中轻松测试。 <img src=\"http://file.w3cbest.com/file/images/null-is-not-an-object.png\" alt=\"Screenshot of TypeError: null is not an object\"> 有趣的是，在 JavaScript 中，null 和 undefined 是不一样的，这就是为什么我们看到两个不同的错误信息。 undefined 通常是一个尚未分配的变量，而 null 表示该值为空。 要验证它们不相等，请尝试使用严格相等运算符 === ： <img src=\"http://file.w3cbest.com/file/images/null-is-not-an-object1.png\" alt=\"Screenshot of TypeError: null is not an object\"> 在现实的例子中，这种错误可能发生的一种场景是：如果在加载元素之前尝试在 JavaScript 中使用 DOM 元素。这是因为 DOM API 对于空白的对象引用返回 null 。 任何执行和处理 DOM 元素的 JS 代码都应在 DOM 元素创建后执行。JS 代码按照 HTML 中的规定从上到下进行解析。所以，如果 DOM 元素之前有一个 script 标签， script 标签内的JS代码将在浏览器解析 HTML 页面时执行。如果在加载脚本之前尚未创建 DOM 元素，则会出现此错误。 在这个例子中，我们可以通过添加一个事件监听器来解决这个问题，这个监听器会在页面准备好的时候通知我们。一旦 <code>addEventListener</code> 被触发，<code>init()</code> 方法就可以使用 DOM 元素。</p>\n<script>\nfunction init() {\n    var myButton = document.getElementById(\"myButton\");\n    var myTextfield = document.getElementById(\"myTextfield\");\n    myButton.onclick = function() {\n        var userName = myTextfield.value;\n    }\n}\ndocument.addEventListener('readystatechange', function() {\n    if (document.readyState === \"complete\") {\n        init();\n    }\n});\n</script>\n\n<form>\n<input type=\"text\" id=\"myTextfield\" placeholder=\"Type your name\" />\n<input type=\"button\" id=\"myButton\" value=\"Go\" />\n</form>\n\n<h2 id=\"4-unknown-Script-error\"><a href=\"#4-unknown-Script-error\" class=\"headerlink\" title=\"4.(unknown): Script error\"></a>4.(unknown): Script error</h2><p>当一个未捕获的 JavaScript 错误违反了跨域策略时，就会出现这类脚本错误。例如，如果你将 JavaScript 代码托管在 CDN 上，任何未被捕获的错误（这个会冒泡到 window.onerror 处理程序，而不是在 try-catch 捕获）将被报告为简单的 “脚本错误” ，而不会包含有用的信息。这是一种浏览器安全措施，旨在防止跨域传递数据，否则将不允许进行通信。 如果你要获取到真实的错误消息，请执行以下操作： <strong>1.发送 Access-Control-Allow-Origin 头信息</strong> 将 <code>Access-Control-Allow-Origin</code> 头信息设置为 <code>*</code> ，表示可以从任何域正确访问资源。如有必要，您可以用你的域名替换 <code>*</code>，例如 <code>Access-Control-Allow-Origin: www.example.com</code> 。但是，处理多个域名会有些棘手，如果你使用 CDN ，由此出现的缓存问题可能会让你感觉不值得付出努力。 <a href=\"http://stackoverflow.com/questions/1653308/access-control-allow-origin-multiple-origin-domains\">点击这里</a> 看到更多。 下面是一些如何在不同环境中设置 Access-Control-Allow-Origin 头信息的例子。 <strong>Apache</strong> 在 JavaScript 文件所在的文件夹中，使用以下内容创建一个 <code>.htaccess</code> 文件：</p>\n<p>Header add Access-Control-Allow-Origin “*“</p>\n<p><strong>Nginx</strong> 将 add_header 指令添加到提供 JavaScript 文件的位置块中：</p>\n<p>location~ ^ /assets/ {<br>    add_header Access - Control - Allow - Origin * ;<br>}</p>\n<p><strong>HAProxy</strong> 将以下内容添加到提供资源服务的后端，并提供 JavaScript 文件：</p>\n<p>rspadd Access-Control-Allow-Origin:\\ *</p>\n<p><strong>2.在 script 标签上设置 crossorigin=”anonymous” 属性</strong> 在你的 HTML 源代码中，对于你设置的 <code>Access-Control-Allow-Origin</code> 头信息的每个脚本，在 script 标签上设置 <code>crossorigin=&quot;anonymous&quot;</code> 。在添加脚本标记上的 crossorigin 属性之前，请确保验证上述头信息是否正确发送。在 Firefox 中，如果存在 crossorigin 属性，但 <code>Access-Control-Allow-Origin</code> 头信息不存在，则脚本将不会执行。</p>\n<h2 id=\"5-TypeError-Object-doesn’t-support-property\"><a href=\"#5-TypeError-Object-doesn’t-support-property\" class=\"headerlink\" title=\"5.TypeError: Object doesn’t support property\"></a>5.TypeError: Object doesn’t support property</h2><p>这是你在调用未定义方法时发生在IE中的错误。你可以在IE开发者工具的控制台进行测试。 <img src=\"http://file.w3cbest.com/file/images/object-doesnot-support-property.png\" alt=\"Screenshot of TypeError: Object doesn’t support property\"> 这相当于 Chrome 中的错误：”TypeError: ‘undefined’ is not a function” 。是的，对于相同的逻辑错误，不同的浏览器可能会有不同的错误消息。 在使用 JavaScript 命名空间的Web应用程序中，这中错误对于 IE 来说是一个常见问题。在这种情况下，这种问题 99.9％ 是 IE 无法将当前名称空间内的方法绑定到 <code>this</code> 关键字。例如，如果你的 JS 命名空间 <code>Rollbar</code> 中有 <code>isAwesome</code> 方法。通常，如果你在 <code>Rollbar</code> 命名空间内，则可以使用以下语法调用 <code>isAwesome</code> 方法：</p>\n<p>this.isAwesome();</p>\n<p>Chrome，Firefox 和 Opera 会欣然地接受这个语法。 IE 则不会。 因此，使用 JS 命名空间时最安全的选择是始终以实际命名空间作为前缀。</p>\n<p>Rollbar.isAwesome();</p>\n<h2 id=\"6-TypeError-‘undefined’-is-not-a-function\"><a href=\"#6-TypeError-‘undefined’-is-not-a-function\" class=\"headerlink\" title=\"6.TypeError: ‘undefined’ is not a function\"></a>6.TypeError: ‘undefined’ is not a function</h2><p>当你调用未定义的函数时，在 Chrome 中会发生这种错误。 你可以在 Chrome 开发者工具的控制台和 Mozilla Firefox 开发者工具的控制台中对此进行测试。 <img src=\"http://file.w3cbest.com/file/images/undefined-is-nota-function.png\" alt=\"Screenshot of undefined is not a function\"> 随着 JavaScript 编码技术和设计模式在这些年来越来越复杂，回调和闭包内的自引用作用域也相应增加，这是使用 this/that 混乱的一个相当常见的原因。 考虑这个示例代码片段：</p>\n<p>function clearBoard() {<br>    alert(“Cleared”);<br>}<br>document.addEventListener(“click”, function() {<br>    this.clearBoard(); // what is “this” ?<br>});</p>\n<p>如果你执行上面的代码然后点击页面，会导致以下错误： “Uncaught TypeError: this.clearBoard is not a function”。原因是正在执行的匿名函数在 document 上下文中， 而 <code>clearBoard</code> 定义在 window 中。 一个传统的，旧浏览器兼容的解决方案是简单地将你的 <code>this</code> 保存在一个变量，然后该变量可以被闭包继承。 例如：</p>\n<p>var self = this; // save reference to ‘this’, while it’s still this!<br>document.addEventListener(“click”, function() {<br>    self.clearBoard();<br>});</p>\n<p>或者，在较新的浏览器中，可以使用 <code>bind()</code> 方法传递适当的引用：</p>\n<p>document.addEventListener(“click”,this.clearBoard.bind(this));</p>\n<h2 id=\"7-Uncaught-RangeError-Maximum-call-stack\"><a href=\"#7-Uncaught-RangeError-Maximum-call-stack\" class=\"headerlink\" title=\"7.Uncaught RangeError: Maximum call stack\"></a>7.Uncaught RangeError: Maximum call stack</h2><p>这是 Chrome 在一些情况下会发生的错误。一个情况是当你调用一个不终止的递归函数时。你可以在Chrome开发者工具的控制台中进行测试。 <img src=\"http://file.w3cbest.com/file/images/maximum-call-stack.png\" alt=\"Screenshot of Uncaught RangeError: Maximum call stack\"> 如果你将一个值传递给超出范围的函数，也可能会发生这种情况。许多函数只接受其输入值的特定范围的数字。 例如，<code>Number.toExponential(digits)</code> 和 <code>Number.toFixed(digits)</code> 接受0到20之间的数字， 和 <code>Number.toPrecision(digits)</code> 接受从1到21的数字。</p>\n<p>var a = new Array(4294967295); //OK<br>var b = new Array(-1); //range error</p>\n<p>var num = 2.555555;<br>document.writeln(num.toExponential(4)); //OK<br>document.writeln(num.toExponential(-2)); //range error!</p>\n<p>num = 2.9999;<br>document.writeln(num.toFixed(2)); //OK<br>document.writeln(num.toFixed(25)); //range error!</p>\n<p>num = 2.3456;<br>document.writeln(num.toPrecision(1)); //OK<br>document.writeln(num.toPrecision(22)); //range error!</p>\n<h2 id=\"8-TypeError-Cannot-read-property-‘length’\"><a href=\"#8-TypeError-Cannot-read-property-‘length’\" class=\"headerlink\" title=\"8.TypeError: Cannot read property ‘length’\"></a>8.TypeError: Cannot read property ‘length’</h2><p>这是 Chrome 中发生的错误，因为读取未定义变量的长度属性。你可以在Chrome开发者工具的控制台中进行测试。 <img src=\"http://file.w3cbest.com/file/images/cannot-read-property-length.png\" alt=\"Screenshot of TypeError: Cannot read property ‘length’\"> 你通常会在数组中找到定义的长度，但是如果数组未初始化或变量名隐藏在另一个上下文中，则可能会遇到此错误。让我们用下面的例子来理解这个错误。</p>\n<p>var testArray = [“Test”];<br>function testFunction(testArray) {<br>    for (var i = 0; i &lt; testArray.length; i++) {<br>        console.log(testArray[i]);<br>    }<br>}<br>testFunction();</p>\n<p>当你用参数声明一个函数时，这些参数变成了本地参数。这意味着即使你有名称为 testArray 的变量，函数中具有相同名称的参数仍将被视为 本地参数。 你有两种方法可以解决这个问题： 1，删除函数声明语句中的参数（事实证明如果你想访问那些在函数之外声明的变量，你不需要将其作为你函数的参数传入）：</p>\n<p>var testArray = [“Test”];<br>/* Precondition: defined testArray outside of a function */<br>function testFunction( /* No params */ ) {<br>    for (var i = 0; i &lt; testArray.length; i++) {<br>        console.log(testArray[i]);<br>    }<br>}<br>testFunction();</p>\n<p>2，调用函数时，将我们声明的数组传递给它：</p>\n<p>var testArray = [“Test”];<br>function testFunction(testArray) {<br>    for (var i = 0; i &lt; testArray.length; i++) {<br>        console.log(testArray[i]);<br>    }<br>}<br>testFunction(testArray);</p>\n<h2 id=\"9-Uncaught-TypeError-Cannot-set-property\"><a href=\"#9-Uncaught-TypeError-Cannot-set-property\" class=\"headerlink\" title=\"9.Uncaught TypeError: Cannot set property\"></a>9.Uncaught TypeError: Cannot set property</h2><p>当我们尝试访问一个未定义的变量时，它总是返回 undefined ，我们不能获取或设置任何 undefined 的属性。在这种情况下，应用程序将抛出 “Uncaught TypeError cannot set property of undefined.” 错误。 例如，在Chrome浏览器中： <img src=\"http://file.w3cbest.com/file/images/cannot-set-property.png\" alt=\"Screenshot of Uncaught TypeError: Cannot set property\"> 如果 test 对象不存在，错误将会抛出 “Uncaught TypeError cannot set property of undefined.” 。</p>\n<h2 id=\"10-ReferenceError-event-is-not-defined\"><a href=\"#10-ReferenceError-event-is-not-defined\" class=\"headerlink\" title=\"10.ReferenceError: event is not defined\"></a>10.ReferenceError: event is not defined</h2><p>当你尝试访问未定义的变量或超出当前作用域的变量时，会引发此错误。你可以在Chrome浏览器中轻松测试。 <img src=\"http://file.w3cbest.com/file/images/event-is-not-defined.png\" alt=\"Screenshot of ReferenceError: event is not defined\"> 如果你在使用事件处理时遇到这种错误，请确保你使用传入的事件对象作为参数。像IE这样的老浏览器提供了一个全局变量事件， Chrome 会自动将事件变量附加到处理程序。Firefox 不会自动添加它。像jQuery这样的库试图规范化这种行为。不过，最佳实践是使用传递到事件处理程序函数的方法。</p>\n<p>document.addEventListener(“mousemove”, function(event) {<br>    console.log(event);<br>})</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>事实证明很多都是一些 null 或 undefined 错误。如果您使用严格的编译器选项，比如 Typescript 这样的好的静态类型检查系统可以帮助您避免它们。它可以警告你，如果一个类型是预期的，但尚未定义。 我们希望你学到了一些新的东西，并且可以避免将来出现这些错误，或者本指南帮助你解决了头痛的问题。尽管如此，即使有最佳做法，生产环境中还是会出现意想不到的错误。了解影响用户的错误非常重要，并有很好的工具来快速解决它们。 Rollbar 为你提供生产环境 JavaScript 错误的可视性，并为您提供更多上下文来快速解决它们。例如，它提供了额外的调试功能，例如 <a href=\"https://rollbar.com/blog/introducing-javascript-telemetry/\">遥测功能</a>，可以告诉你用户的浏览器发生了什么导致错误。这可以使在本地开发者工具的控制台之外发现问题。你可以在 Rollbar 的 <a href=\"https://rollbar.com/error-tracking/javascript/\">JavaScript 应用程序的完整功能列表</a> 中了解更多信息。 文章来源：<a href=\"https://rollbar.com/blog/top-10-javascript-errors/\">https://rollbar.com/</a></p>\n","categories":["JavaScript"],"tags":["javascript","Cannot set property","Error","event is not defined","Web Development","错误"]},{"title":"CSS 选择器技能使用指南","url":"/2018/09/25/css-%E9%80%89%E6%8B%A9%E5%99%A8%E6%8A%80%E8%83%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","content":"<p>我已经使用CSS多年了，但直到最近我还没有深入研究过关于 CSS 选择器的主题。 为什么我需要学习 CSS 选择器呢？ 我们现在知道了所有的内部选择器了吗？ 问题是(至少对我来说是这样)随着时间的推移，很容易习惯在每个项目上使用相同的习惯的选择器集合来完成你要做的事情。 因此，我自己对 CSS 选择器知识进行了深入的审查，并发现了一些有趣的内容，这些内容对我来说是新的，或者是以前我从来没有想过这些使用方式。 我还发现了一些很酷的新选择器，将来可用，但还没有广泛使用。 我们一起来深入研究一下各种类型的 CSS 选择器吧。 您在日常工作中已经使用了，或者本文没涉及到的 CSS 选择器技能欢迎留言告诉我。 准备好提升你的 CSS 选择器技能了吗？我们一起 GO！</p>\n<h2 id=\"组合选择器\"><a href=\"#组合选择器\" class=\"headerlink\" title=\"组合选择器\"></a>组合选择器</h2><p>让我们从熟悉的选择器开始。组合选择器用于选择子元素和兄弟元素，并且相信大家已经使用了很长一段时间了吧。</p>\n<ul>\n<li>  一般子元素选择器（空格）。例如A B。</li>\n<li>  直接子元素选择器。例如 A &gt; B 。</li>\n<li>  相邻兄弟元素选择器。例如 A + B。</li>\n<li>  一般兄弟元素选择器。例如 A ~ B。</li>\n</ul>\n<p>您应该熟悉相邻兄弟元素选择器 A + B ，他会选择紧跟 A 的 B 元素。但是一般兄弟元素选择器 A~B 呢？ 他将选择跟随 A 的所有兄弟 B 元素： 以下是实例：</p>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/RyvYXd/\">Combinator Selectors</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>第二行 New York 行被选中是因为它紧跟在第一行之后 table tbody tr:first-child + tr，并且最后两个城市被高亮显示，因为他们被一般兄弟选择器 table tbody tr:nth-child(4) ~ tr 匹配，也就是第四行之后的所有行。</p>\n<h2 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h2><p>我非常喜欢属性选择器。当您需要将包含某个属性的元素与特定值匹配时，它们可以非常灵活。</p>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/MGLZEK/\">Attribute Selectors #1</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>此示例演示如何选择所有复选框元素并将样式应用于其匹配标签，以使其变为粗体和蓝色。 然后，我们覆盖具有特定名称的 chk2 复选框的样式，并将其匹配的标签着色为红色。 请注意其他表单元素标签如何不受影响且未应用标签样式。 属性选择器不仅适用于表单元素，它们还可以定位任何元素的属性。 您可以匹配任何属性，而不仅仅是官方支持的属性。 此外，您可以检查属性是否存在，如下所示：</p>\n<p>button[icon]</p>\n<p>这匹配包含 icon 属性的 <button> 元素。它将匹配 icon 属性，无论 icon 属性是空值还是设置为特定值。 更多例子：</p>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/pVGGye/\">Attribute Selectors #2</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>第一个链接没有 target 属性，因此不匹配。 接下来的两个链接是匹配的，因为它们的 target 属性具有空值或特定值的属性。 最后，最后一个链接设置为粉红色，因为它 fluffy 属性匹配。 它的值无关紧要，只需要与 a[fluffy] 选择器相匹配即可。 一个实际的例子可能是突出显示没有alt属性的图像。 此属性对于网页的可访问性来说是所必需的，因此对于SEO而言，确保所有图像元素都包含此属性非常重要。 我们可以使用以下规则来实现此目的：</p>\n<p>img:not([alt]) {<br>border: 2px red dashed;<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/OZdqLp/\">Attribute Selectors #3</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>如果要匹配属性值的特定部分，则可以使用一些非常有用的选择器。</p>\n<ul>\n<li>  A[attr^=val] – 属性值以 val 开头。</li>\n<li>  A[attr=val] – 属性值以 val 开头，或者以 val- 开头。</li>\n<li>  A[attr$=val] – 属性值以 val 结尾。</li>\n<li>  A[attr*=val] – 属性值中包含 val 。</li>\n<li>  A[attr~=val] – 匹配用空格分隔的属性值列表，并且列表中包含 val 。</li>\n</ul>\n<p>以下是每个例子：</p>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/MGLdvE/\">Attribute Selectors #4</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>前两个示例非常相似，不同之处是 A[attr=val] 匹配后跟一个 - 字符串的值。 这对于匹配语言属性 lang 很有用。 例如 <p lang =\"en-us\">。 使用 A[attr$=”val”] 可以轻松匹配文件扩展名，并且与 ::after 相结合你可以轻松显示匹配文件。 注意使用 attr() 方法和 content 属性将它与静态字符串连接起来。 A[attr*=val] 显示了无论使用何种协议或子域，您都可以匹配特定域 mysite.com。 最后，A[attr<del>=val]，它非常适合匹配由空格分隔的值列表组成的属性中的值。 这只匹配整个单词而不是单词片段，而 *= 匹配单词片段，因此单词复数形式将不匹配。这个有点不好理解：例如某 div 元素的 categories 属性为 <div categories=\"table wooden maple\">，其 categories 属性用空格分隔。那么 div[categories</del>=”table”] 将匹配各元素，还有一个特别要注意的是， <div categories=\"wooden maple table\"> 也将被匹配。而 <div categories=\"wooden maple tables\"> 或者 <div categories=\"wooden tableee maple\"> 都不会被 div[categories~=”table”] 匹配。 以上所有属性选择器示例都区分大小写。 但是我们有一个技巧。 如果我们在结束方括号之前插入一个 i ，我们可以启用区分大小写的匹配，这有点类似于 JavaScript 中的正则表达式匹配。</p>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/LmaYzp/\">Attribute Selectors #5</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>除 Internet Explorer 和 Microsoft Edge 外，大多数主流浏览器都支持不区分大小写的匹配。</p>\n<h2 id=\"用户交互选择器\"><a href=\"#用户交互选择器\" class=\"headerlink\" title=\"用户交互选择器\"></a>用户交互选择器</h2><p>如果您处理过表单样式，那么您之前无疑会遇到这些类型的伪类选择器：</p>\n<ul>\n<li>  :enabled</li>\n<li>  :disabled</li>\n<li>  :checked</li>\n</ul>\n<p>例如，我们可以使用 :checked 来设置一个简单的待办事项列表。</p>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/BxbjoO/\">User Interface Selectors #1</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>这是非常标准的，但我们可以使用其他一些有趣的伪类。 :default 匹配一个或多个元素，这些元素是一组相关元素中的默认元素。这也可以与复位按钮类型组合使用。</p>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/ELMoNK/\">User Interface Selectors #2</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>我们可以使用伪类选择器来匹配输入值是否与 CSS 直接有效，以及在提交表单之前检查是否需要任何元素。</p>\n<ul>\n<li>  :valid</li>\n<li>  :invalid</li>\n<li>  :required</li>\n<li>  :optional (即不必须)</li>\n</ul>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/qYvpMP/\">User Interface Selectors #3</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>如果您开始输入个人 email 输入字段，则必须检查有效性。 但是，工作 email 地址始终是必需的，并且需要有效检查有效性，因此不能留空。 还要注意我们可以链接伪类选择器（例如 :required:invalid ）来实现我们所需要的。 接下来，如果表单元素（支持 min 和 max 属性）在范围内，我们有两个可以匹配的伪类。</p>\n<ul>\n<li>  :in-range</li>\n<li>  :out-of-range</li>\n</ul>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/Jvzpgz/\">User Interface Selectors #4</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>同样，我们可以使用重置按钮类型来重置数字输入元素的默认值。 为了完善本节，我们来看看 :read-only ，:read-write 和 :placeholder-shown 的伪类。</p>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/ZoPREB/\">User Interface Selectors #5</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>使用这些可以轻松匹配只读或可写（可编辑）的元素。 匹配元素不必是表单输入字段，如示例中所示。 最后，:placeholder-shown 将匹配尚未与之交互的元素，并仍显示默认占位符文本。 应谨慎使用此特定选择器，因为它尚未得到广泛支持。</p>\n<h2 id=\"结构选择器\"><a href=\"#结构选择器\" class=\"headerlink\" title=\"结构选择器\"></a>结构选择器</h2><p>结构选择器非常强大，基于它们在DOM中的位置匹配元素。 它们使您可以灵活地将元素与CSS完全匹配，否则需要 JavaScript 执行相同的操作。 这种类型的选择器与显示的选择器不同，因为其中一些选择器允许您传入参数来修改选择器的工作方式。 例如：nth-child() 接收一个值，该值将匹配特定子元素相对于其父容器的值。 因此，如果我们有一个项目列表，则以下选择器将匹配第三个项目：</p>\n<p>ul:nth-child(3)</p>\n<p>但是，参数不是必须是简单的数字，它可以是一个简单的表达式，而使伪类更强大。 有效表达式有：</p>\n<ul>\n<li>  ul:nth-child(2) – 匹配第 2 个子元素</li>\n<li>  ul:nth-child(4n) – 匹配每 4th 个子元素（4,8,12，…）</li>\n<li>  ul:nth-child(2n + 1) – 匹配每 2n + 1 个子元素偏移一个（1,3,5，…）</li>\n<li>  ul:nth-child(3n - 1) – 匹配每 3n – 1 个子元素偏移负数1（2,5,8，…）</li>\n<li>  ul:nth-child(odd) – 匹配奇数元素（1,3,5，…）</li>\n<li>  ul:nth-child(even) – 匹配偶数元素（2,4,6，…）</li>\n</ul>\n<p>表达式变量 n 总是从零开始，因此确切地计算出哪些元素将匹配，n 从 0 开始，然后 n 为 1 ，依此类推以编译元素列表。 这里还有 1 个简单而实用的小技巧，我们把n当做负数来用，会发生什么呢？</p>\n<ul>\n<li>  ul li:nth-child(-n+3) – 匹配第 1 到 第 3 个 li 子元素 （1,2,3）</li>\n<li>  ul li:nth-child(-2n+6) – 匹配每 2th 个子元素，最多不超过第 8 个 li 子元素 （2,4,6，8）</li>\n<li>  ul li:nth-child(n + 10):nth-child(-n + 12) – 匹配第 10 到 第 12 个 li 子元素 （10,11,12）</li>\n</ul>\n<p>例如：</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/mveKRe/\">把`n` 当做负数来用</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>您可以将简单表达式与以下结构选择器一起使用：</p>\n<ul>\n<li>  :nth-child()</li>\n<li>  :nth-last-child()</li>\n<li>  :nth-of-type()</li>\n<li>  :nth-last-of-type()</li>\n</ul>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/MGxzEq/\">Structural Selectors #1</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>:nth-last-child() 和 :nth-last-of-type() 非常类似于 :nth-child() 和 nth-of-type() ，唯一区别是 :nth-last-child() 和 :nth-last-of-type() 是从最后一个元素开始匹配，而不是第一个元素开始匹配。 通过玩各种组合，您可以通过选择器获得相当多的创意。 例如，之前的示例包含选择器：</p>\n<p>ul:last-of-type li:nth-last-of-type(2)::after {<br>content: “(2nd from end)”;<br>/* Other styles… */<br>}</p>\n<p>这匹配第 2 个无序列表中最后一个列表项之后的伪元素。 如果你一直在努力解码一个复杂的选择器，那么最好从右到左阅读它，这样它就可以在逻辑上解构。 下一组选择器是专用的结构选择器，因为它们只匹配特定的子元素。 您无法将表达式传递给它们以修改其行为。</p>\n<ul>\n<li>  :first-child</li>\n<li>  :last-child</li>\n<li>  :only-child</li>\n<li>  :first-of-type</li>\n<li>  :last-of-type</li>\n</ul>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/JvzwJE/\">Structural Selectors #2</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>乍一看，这里有很多事情，你在使用这些类型的选择器时需要小心，因为你可能得到你没想到的结果。 例如，您可能想知道为什么在 <section> 标记内的等等……文本是蓝色的。 实际上所有部分内容都是蓝色的，因为它是主 div 容器的最后一个子节点。 其他部分元素通过其他选择器覆盖自己的颜色，使单个段落变为蓝色。 如果你觉得这些结构选择器还不够，或者你觉得记不住，使用起来很麻烦，那么你可以使用 Family.scss – 轻松搞定这些 :nth-child 伪类 :nth-child</p>\n<h2 id=\"否定、排除选择器\"><a href=\"#否定、排除选择器\" class=\"headerlink\" title=\"否定、排除选择器\"></a>否定、排除选择器</h2><p>CSS 否定伪类选择器 :not(X)，是以一个简单的以选择器 X 为参数的功能性标记函数，将从匹配的元素集合中排除选择器 X 所匹配的元素。选择器 X 中不能包含另外一个 :not 选择器。</p>\n<ul>\n<li>  :not() 伪类的优先级即为它参数选择器的优先级。 可以利用这个伪类提高规则的优先级。例如， #foo:not(#bar) 和 #foo 会匹配相同的元素。 但是前者的优先级更高。但是 :not() 伪类不像其它伪类，它不会增加选择器的优先级。</li>\n<li>  :not() 伪类可以将一个或多个以逗号分隔的选择器作为其参数。但是以多个以逗号分隔的选择器作为参数是实验性的，尚未广泛支持。</li>\n</ul>\n<p>:not() 伪类时我们得选择器组合更加灵活，我们来看一些简单应用：</p>\n<p>See the Pen <a href=\"https://codepen.io/w3cbest/pen/JxYZWz/\">:not() 伪类</a> by w3cbest.com (<a href=\"https://codepen.io/w3cbest\">@w3cbest</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>上例中，.content :not(.notice) em 匹配了 .content 中所有的 em 元素，但是排除了 .content .notice 中 em 元素。 我们再来看看 :not() 和其他伪类选择器结合的例子：</p>\n<p>See the Pen <a href=\"https://codepen.io/feiwen8772/pen/kkELxa/\">:not伪类</a> by feiwen8772 (<a href=\"https://codepen.io/feiwen8772\">@feiwen8772</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>在做一个有间隔线的列表时，我们通常会去除最后一个 li 下的横线。li:not(:last-child) 表示除了最后一个 li 元素之外的所有其他 li 元素。</p>\n<h2 id=\"内容选择器\"><a href=\"#内容选择器\" class=\"headerlink\" title=\"内容选择器\"></a>内容选择器</h2><p>这些属于用于匹配内容的一组专用选择器。我们可以立即使用的是：</p>\n<ul>\n<li>  ::first-line</li>\n<li>  ::first-letter</li>\n<li>  ::selection</li>\n</ul>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/xjBBqN/\">Content Selectors #1</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>::first-line 和 ::first-letter 仅在应用于块级元素时才起作用。另外要小心只在特定元素上使用 ::first-letter ，否则每个段落都可能会应用。 目前还没有一些令人兴奋的内容选择器，但是当它们得到支持时，它们将开启各种可能性。 以下是需要注意的内容选择器列表：</p>\n<ul>\n<li>  ::inactive-selection?—?非活动窗口内的选定内容</li>\n<li>  ::spelling-error?—?检查可编辑元素的拼写和语法</li>\n<li>  ::grammar-error?—?匹配语法错误</li>\n<li>  ::marker?—?匹配列表项标记</li>\n<li>  ::placeholder?—?匹配表单元素的 placeholder 文本样式；</li>\n</ul>\n<h2 id=\"其他选择器\"><a href=\"#其他选择器\" class=\"headerlink\" title=\"其他选择器\"></a>其他选择器</h2><p>我们接下来提到其他几个选择器不适合不适合归类到上面任何类别。 别担心我们差不多完成了！ 不幸的是，其中大部分是实验性的，所以你必须等待一段时间才能在生产中使用它们。 :target 选择器的目标是一个 id 与当前 URL 的一部分匹配的元素。 比如下面 URL 匹配该URL页面中 id 为 part1 的元素：</p>\n<p><a href=\"https://www.w3cbest.com/#part1\">https://www.w3cbest.com#part1</a></p>\n<p>我们可以将该元素应用以下样式：</p>\n<p>:target { border: 1px red solid; }</p>\n<p>其实 :target 选择器目前可以用于一些特殊的用例，欢迎查看： :target 伪类使用技巧 如果你有一个很大的选择器，那么 :matches() 可以帮助简化它。例如，如果您有以下选择器：</p>\n<p>nav p.content,<br>header p.content,<br>main p.content,<br>sidebar p.content,<br>footer p.content {<br>margin: 15px;<br>padding: 10px;<br>}</p>\n<p>然后可以通过 :matches() 简化，相当于： 太好了！这将有助于使样式表更具可读性。 接下来我们还有一个 :any-link 选择器，这个选择器是:link 和 :visited 组合的简写。 所以下面这两个选择器实际上是相同的：</p>\n<p>:any-link {<br>color: red;<br>}</p>\n<p>:link, :visited {<br>color: red;<br>}</p>\n<p>本文中最后两个选择器：</p>\n<ul>\n<li>  :dir()</li>\n<li>  :lang()</li>\n</ul>\n<p>这些都与您网站的语言有关。 :dir() 接受参数 ltr 或 rtl ，具体取决于您要匹配的文本的方向，目前仅 Firefox 支持。 所以：:dir(rtl) 会匹配所有具有 RTL 方向内容的元素。 HTML文档中的每个元素都可以使用 lang 属性设置自己的单独语言。</p>\n<div lang=\"en\">The language of this element is set to English.</div>\n<div lang=\"el\">Η γλ?σσα αυτο? του στοιχε?ου ?χει οριστε? στα ελληνικ?.</div>\n<div lang=\"is\">Tungumál ?essa ?áttar er sett á íslensku.</div>\n\n<p>将相同的基本文本输入到三个 <div> 标记中，但将特定国家/地区添加到内容的末尾。此外，lang 属性中使用的国家代码代表相应的国家/地区。</p>\n<ul>\n<li>  :lang(en) { color: red; }</li>\n<li>  :lang(el) { color: green; }</li>\n<li>  :lang(is) { color: blue; }</li>\n</ul>\n<p>演示：</p>\n<p>See the Pen <a href=\"https://codepen.io/dgwyer/pen/xjBoNG/\">Misc Selectors</a> by David Gwyer (<a href=\"https://codepen.io/dgwyer\">@dgwyer</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>好消息是所有主流浏览器都支持 :lang() 选择器。</p>\n<h2 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h2><p>如果你试图查找一个选择器，或者需要深入研究CSS规范，那么你可能需要查看一些有用的资源：</p>\n<ul>\n<li>  <a href=\"https://developer.mozilla.org/en-US/\">MDN Web Docs</a></li>\n<li>  <a href=\"https://www.w3.org/Style/CSS/specs.en.html\">CSS Specifications</a></li>\n<li>  <a href=\"https://caniuse.com/\">Can I Use</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>我希望你会发现这篇文章很有用。 可以帮助刷新你的CSS选择器技能，并尝试各种可能性。 使用纯 CSS 可以做很多很酷的事情，这在几年前是不可能实现的。 对于能够在纯 CSS 中进行一些非常高级的样式和动画的设计师来说，这是令人兴奋的，并且所有人都看不到一行 JavaScript 。 文章来源 <a href=\"https://blog.logrocket.com/level-up-your-css-selector-skills-5d7bb45ddd37\">https://blog.logrocket.com</a></p>\n","categories":["HTML/CSS"],"tags":["css3教程","css教程","前端教程","css选择器","css伪类"]},{"title":"CSS变量使用指南（自定义属性）","url":"/2018/09/19/css%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%EF%BC%89/","content":"<p>CSS预处理器，如Sass和Less，使得CSS代码易于组织和维护。通过提供变量、混合、循环等特性，使得CSS具有动态编写的能力，从而减少重复性工作，提高开发速度。 最近，CSS开始添加一些动态特性。<a href=\"https://www.w3.org/TR/css-variables/\">CSS变量</a> （自定义属性）已经加入规范，并且获得了大多数浏览器的支持。但是<a href=\"https://tabatkins.github.io/specs/css-apply-rule/\">CSS混合特性还在进行中</a>。 在这篇文章中，我们将会向你展示怎么把CSS变量应用到开发中，从而使得样式表更加可维护和<a href=\"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\">DRY</a> (Don’t Repeat Yourself)。 让我们现在开始！</p>\n<h2 id=\"CSS变量是什么？\"><a href=\"#CSS变量是什么？\" class=\"headerlink\" title=\"CSS变量是什么？\"></a>CSS变量是什么？</h2><p>如果你使用过任何编程语言，你肯定熟悉变量这个概念。变量让你存储和更新程序运行需要的值。 例如，考虑下面的JavaScript片段：</p>\n<p>let number1 = 2;<br>let number2 = 3;<br>let total = number1 + number2;<br>console.log(total); // 5<br>number1 = 4;<br>total = number1 + number2;<br>console.log(total); // 7</p>\n<p>number1和number2是两个变量，分别存储数字2和3。 total也是一个变量，存储<code>number1</code>和<code>number2</code>变量的和，在这个例子中是5。你可以动态更新这些变量的值，并且在程序的任何地方使用更新后的值。在上面的代码片段中，我把<code>number1</code>的值更新为<code>4</code>，当我使用相同的变量再次执行加法操作时，存储在<code>total</code>中的值就变成7，而不是5了。 变量的好处在于你可以把值存储在一个地方，然后在你需要的地方修改它。这样你就不用在程序的不同地方为不同的值添加不同的变量：所有变量更新使用同一个存储地址，比如你的变量。 CSS主要是一门声明式语言，缺乏动态性。你可能会说给CSS添加变量会与CSS本身相矛盾。如果前端开发仅仅关注语义，那么给CSS添加变量确实会与CSS本身矛盾。幸运的是，网络语言更像动态语言，它会随着周围环境和开发者的需求不断变化。CSS也不例外。 总而言之，变量已经成为CSS中令人激动的实现，你很快也会发现，学习和使用它非常直观。</p>\n<h2 id=\"使用CSS变量有什么好处？\"><a href=\"#使用CSS变量有什么好处？\" class=\"headerlink\" title=\"使用CSS变量有什么好处？\"></a>使用CSS变量有什么好处？</h2><p>在CSS中使用变量的好处和在编程语言中没有特别大的不同。 下面是规范对上述问题的回答：</p>\n<blockquote>\n<p>[使用CSS变量]使大文件更易于阅读，因为看起来很随意的值有了一个提示信息的名字，并且编辑这些文件更加简单，更不易于出错。因为你只需要在自定义属性处修改一次，然后这个修改就会自动应用到使用该变量的任何地方。 <a href=\"https://www.w3.org/TR/css-variables/#intro\">W3C规范</a>。</p>\n</blockquote>\n<p>换句话说： 通过与项目相关的方式命名变量，管理和维护代码会变得更加容易。例如，如果项目的主色调保存在<code>--primary-color</code>中，修改项目的主色调就会变得很容易，仅仅改变该变量的值就可以，而不用去修改遍布在代码各处、不同CSS属性中的颜色值。</p>\n<h2 id=\"CSS变量和预处理器变量的不同之处？\"><a href=\"#CSS变量和预处理器变量的不同之处？\" class=\"headerlink\" title=\"CSS变量和预处理器变量的不同之处？\"></a>CSS变量和预处理器变量的不同之处？</h2><p>在给网站添加样式时，你可能已经通过预处理器，如<a href=\"http://sass-lang.com/\">Sass</a>和<a href=\"http://lesscss.org/\">Less</a>，体验过变量的灵活性带来的好处。 预处理器可以让你设置变量，并且在函数、循环和数学操作等中使用。这是不是意味着CSS变量就没有什么用处了？ 不完全是，主要是因为CSS变量和预处理器变量并不一样。 不同之处在于CSS变量是运行在浏览器中的动态CSS属性，而预处理器变量会被编译成普通的CSS代码。因此，浏览器并不知道预处理器变量的存在。 这就意味着你可以更改样式表、行内样式属性和SVG展示型属性中的CSS变量，或者使用JavaScript操作它们。这是预处理器变量做不到的。CSS变量提供了更多可能性！ 但这并不是说你需要在二者之间选择其一：你可以同时使用CSS变量和预处理器变量的强大功能。</p>\n<h2 id=\"CSS变量的语法\"><a href=\"#CSS变量的语法\" class=\"headerlink\" title=\"CSS变量的语法\"></a>CSS变量的语法</h2><p>为了简单起见，在这篇文章中我使用了CSS变量这个术语，但是官方文档给出的是级联变量的CSS自定义属性。CSS自定义属性形式如下：</p>\n<p>--my-cool-background: #73a4f4;</p>\n<p>在自定义属性前面添加两个短横线，然后像普通的CSS属性一样给它赋值。在上面的代码片段中，给<code>--my-cool-background</code>自定义属性赋了一个颜色值。 级联变量部分包括使用<code>var()</code>函数应用自定义属性，形式如下：</p>\n<p>var(–my-cool-background)</p>\n<p>自定义属性的使用范围是CSS选择器的内部，<code>var()</code>像一个真正的CSS属性值被使用。</p>\n<p>:root {<br>  –my-cool-background: #73a4f4;<br>}<br>/* CSS文件的其他部分 */<br>#foo {<br>  background-color: var(–my-cool-background);<br>}</p>\n<p>上面的代码片段把<code>--my-cool-background</code>自定义属性定义在<code>:root</code>伪元素内，这使得自定义属性的值全局可用（:root匹配元素内的任何元素）。然后使用var()函数把值应用到ID是foo的容器的background-color属性上，然后这个容器就会得到一个淡蓝色背景。 除此之外，还可以把淡蓝色应用到多个HTML元素的其他颜色属性上，如<code>color</code>，<code>border-color</code>等。你需要做得仅仅是通过<code>var(--my-cool-background)</code>获取自定义属性的值，然后应用到相应的属性上。当然，你需要好好考虑CSS变量的命名规范，使你的变量名能更好地反映变量的内容。</p>\n<p>p {<br>    color: var(–my-cool-background);<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/SitePoint/pen/gRMaJw/\">Basic Workings of CSS Variables</a> by SitePoint (<a href=\"https://codepen.io/SitePoint\">@SitePoint</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>你也可以在CSS变量中使用另一个CSS变量，举例如下：</p>\n<p>--top-color: orange;<br>–bottom-color: yellow;<br>–my-gradient: linear-gradient(var(–top-color), var(–bottom-color));</p>\n<p>上面的代码片段创建了<code>--my-gradient</code>变量，它的值是使用<code>--top-color</code>和<code>--bottom-color</code>变量创建的一个渐变。现在，你可以在任何地方通过仅仅改变变量的值来修改渐变，而不必到处在样式表中创建渐变实例。 下面是一个在线CodePen演示。</p>\n<p>See the Pen <a href=\"https://codepen.io/SitePoint/pen/RgRrba/\">Setting Value of CSS Variable with Another CSS Variable</a> by SitePoint (<a href=\"https://codepen.io/SitePoint\">@SitePoint</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>最后，在使用CSS变量的时候，还可以添加一个或多个后备值，举例如下：</p>\n<p>var(–main-color, #333);</p>\n<p>在上面的代码片段中，<code>#333</code>是一个后备值。如果没有提供后备值，当自定义属性无效或者没有赋值的时候，会使用继承值。</p>\n<h2 id=\"CSS变量是大小写敏感的\"><a href=\"#CSS变量是大小写敏感的\" class=\"headerlink\" title=\"CSS变量是大小写敏感的\"></a>CSS变量是大小写敏感的</h2><p>和一般的CSS属性不一样，CSS变量是大小写敏感的。 例如，<code>var(--foo)</code>和<code>var(--Foo)</code>使用的是两个不同的自定义属性，分别是<code>--foo</code>和<code>--Foo</code>。</p>\n<h2 id=\"CSS变量是级联的\"><a href=\"#CSS变量是级联的\" class=\"headerlink\" title=\"CSS变量是级联的\"></a>CSS变量是级联的</h2><p>类似一般的CSS属性，CSS变量也会继承。例如，我们定义一个值是blue的自定义属性：</p>\n<p>:root {<br>    –main-color: blue;<br>}</p>\n<p><code>&lt;html&gt;</code>根元素内的所有元素如果应用<code>--main-color</code>就会继承值<code>blue</code>。 如果你在另一个元素里面给自定义属性赋了一个不同的值，这个元素的所有子元素就会继承这个新值，举例如下：</p>\n<p>:root {<br>    –main-color: blue;<br>}</p>\n<p>.alert {<br>    –main-color: red;<br>}</p>\n<p>p {<br>    color: var(–main-color);<br>}</p>\n<p>&lt;–! HTML –&gt;</p>\n<html>\n  <head>\n    <!-- head code here -->\n  </head>\n  <body>\n    <div>\n      <p>blue paragraph.</p>\n      <div class=\"alert\">\n        <p>red paragraph.</p>\n      </div>\n    </div>\n  </body>\n</html>\n\n<p>上面的标记语言中的第一个段落会继承全局<code>--main-color</code>的值，所以字体颜色是蓝色。 具有<code>.alert</code>类的div元素内部的段落元素的字体颜色是红色的，因为它继承了局部范围内的<code>--main-color</code>变量，这个变量的值是red。</p>\n<p>See the Pen <a href=\"https://codepen.io/SitePoint/pen/vZKLOG/\">Simple Example of CSS Variables Inheritance</a> by SitePoint (<a href=\"https://codepen.io/SitePoint\">@SitePoint</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>现在了解了规则，让我们开始实践吧！</p>\n<h2 id=\"在SVG中使用CSS变量\"><a href=\"#在SVG中使用CSS变量\" class=\"headerlink\" title=\"在SVG中使用CSS变量\"></a>在SVG中使用CSS变量</h2><p>CSS变量和SVG可以很好的一起工作！你可以使用CSS变量来修改内联SVG中的样式和展示型属性。 比如，你想通过SVG图标元素的父元素来给它一个不同的颜色。你可以在父元素内设置一个局部的CSS变量，然后把它赋值成你想要的颜色，然后，父元素内的图标就能从父元素继承到合适的颜色。 下面是相关代码：</p>\n<p>/* 图标的内联SVG symbol */<br><svg><br>  <symbol id=\"close-icon\" viewbox=\"0 0 200 200\"><br>    <circle cx=\"96\" cy=\"96\" r=\"88\" fill=\"none\" stroke=\"var(--icon-color)\" stroke-width=\"15\" /><br>    <text x=\"100\" y=\"160\" fill=\"var(--icon-color)\" text-anchor=\"middle\" style=\"font-size:250px;\">x</text><br>  </symbol><br></svg></p>\n<p>/* 图标的第一个实例  */<br><svg><br>  <use xlink:href=\"#close-icon\" /><br></svg></p>\n<p>上面的标记语言使用了标签，使用它可以创建不可见的SVG图形。然后使用标签实例化了一个上述图形的可见版本。使用这种方式通过简单地引用元素的ID(<code>#close-icon</code>)就能创建大量的图标，然后再根据你的喜好对图标进行自定义。这比重复的写同一段代码要简便的多。如果你想复习这个技术，Massimo Cassandro在他的创造你<a href=\"https://www.sitepoint.com/build-svg-icons/\">自己的SVG图标</a>中提供了一个快速教程。 注意SVG中的圆形元素的stroke属性值和文本元素的fill属性值：它们都使用了一个CSS变量，<code>--icon-color</code>，这个变量定义在CSS文档的<code>:root</code>选择器上，如下所示：</p>\n<p>:root {<br>  –icon-color: black;<br>}</p>\n<p>图标现在的样子如下： <img src=\"http://file.w3cbest.com/file/images/1497293805default-svg-icon.png\"> 如果你现在把SVG图标放到不同的容器中，然后在每个父元素的选择器中给这个变量赋不同的颜色值，你就能在不添加任何样式规则的情况下创建不同颜色的图标。真酷！ 举个例子，把上面图标的一个实例放在一个有类<code>.success</code>的div中。</p>\n<div class=\"success\">\n  <svg>\n    <use xlink:href=\"#close-icon\" />\n  </svg> \n</div>\n\n<p>现在，在.success选择器内给–icon-color变量赋值green，然后看下效果。</p>\n<p>.success {<br>    –icon-color: green;<br>}</p>\n<p>现在，图标的颜色变成了绿色： <img src=\"http://file.w3cbest.com/file/images/1497293895success-icon.png\"> 查看下面完整的演示示例：</p>\n<p>See the Pen <a href=\"https://codepen.io/SitePoint/pen/JJKGbj/\">Basic Use of SVG Icon and CSS Variables</a> by SitePoint (<a href=\"https://codepen.io/SitePoint\">@SitePoint</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"在-keyframes动画中使用CSS变量\"><a href=\"#在-keyframes动画中使用CSS变量\" class=\"headerlink\" title=\"在@keyframes动画中使用CSS变量\"></a>在@keyframes动画中使用CSS变量</h2><p>CSS变量可以和CSS动画一起使用，不论是在一般的HTML元素还是内联SVG元素上。只需要记住在想添加动画的元素的选择器上定义自定义属性，然后使用<code>var()</code>函数在<code>@keyframes</code>中引用。 比如，给SVG的一个有类<code>.bubble</code>的元素添加动画，CSS代码如下：</p>\n<p>.bubble {<br>  –direction-y: 30px;<br>  –transparency: 0;<br>  animation: bubbling 3s forwards infinite;<br>}</p>\n<p>@keyframes bubbling {<br>  0% {<br>    transform: translatey(var(–direction-y));<br>    opacity: var(–transparency);<br>  }<br>  40% {<br>    opacity: calc(var(–transparency) + 0.2);<br>  }<br>  70% {<br>    opacity: calc(var(–transparency) + 0.1);<br>  }<br>  100% {<br>    opacity: var(–transparency);<br>  }<br>}</p>\n<p>你可能已经注意到我们可以使用CSS的<code>calc()</code>通过<code>var()</code>函数对变量进行计算，这使代码更加灵活。 这个例子中使用CSS变量的灵活之处是通过简单的改变相应选择器内部的变量值，就可以改变动画效果，而不必查找<code>@keyframes</code>指令中的每个属性。 下面是完整的CodePen演示：</p>\n<p>See the Pen <a href=\"https://codepen.io/SitePoint/pen/zzBrNV/\">Simple Animation with CSS Variables and SVG</a> by SitePoint (<a href=\"https://codepen.io/SitePoint\">@SitePoint</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"使用JavaScript操作CSS变量\"><a href=\"#使用JavaScript操作CSS变量\" class=\"headerlink\" title=\"使用JavaScript操作CSS变量\"></a>使用JavaScript操作CSS变量</h2><p>一件更酷的事情是你可以直接通过JavaScript代码访问CSS变量。 假设有一个叫<code>--left-pos</code>的CSS变量，它的值的<code>100px</code>，定义在CSS文档的<code>.sidebar</code>类中：</p>\n<p>.sidebar {<br>  –left-pos: 100px;<br>}</p>\n<p>使用类似下面的JavaScript代码获取<code>--left-pos</code>的值：</p>\n<p>// 获取你想添加动画的元素<br>const sidebarElement = document.querySelector(‘.sidebar’);</p>\n<p>// 把侧边栏元素的样式存储在cssStyles变量中<br>const cssStyles = getComputedStyle(sidebarElement);</p>\n<p>// 获取CSS变量–left-pos的值<br>const cssVal = String(cssStyles.getPropertyValue(‘–left-pos’)).trim();</p>\n<p>// 在控制台打印CSS变量的值<br>// 控制台会输出变量的值为100px<br>console.log(cssVal);</p>\n<p>使用类似下面的JavaScript代码给CSS变量赋值：</p>\n<p>sidebarElement.style.setProperty(‘–left-pos’, ‘200px’);</p>\n<p>上面的代码片段把侧边栏元素的<code>--left-pos</code>变量设置成<code>200px</code>。 相对于改变大量的类或者重写全部的CSS规则，使用CSS变量给网站添加交互更直接，也更易于维护。 查看下面的CodePen演示，你可以通过侧边栏来改变<a href=\"https://www.sitepoint.com/close-up-css-mix-blend-mode-property/\">混合模式</a>属性和背景颜色，而这仅仅需要CSS变量和JavaScript:</p>\n<p>See the Pen <a href=\"https://codepen.io/SitePoint/pen/NgrxvM/\">Blend Modes, CSS Variables and JavaScript</a> by SitePoint (<a href=\"https://codepen.io/SitePoint\">@SitePoint</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"浏览器对CSS变量的支持情况\"><a href=\"#浏览器对CSS变量的支持情况\" class=\"headerlink\" title=\"浏览器对CSS变量的支持情况\"></a>浏览器对CSS变量的支持情况</h2><p>除了IE11（不支持）和Microsoft Edge（buggy支持），在本文编写的时候，所有主流浏览器都完全<a href=\"http://caniuse.com/#feat=css-variables\">支持CSS变量</a>。 适配有问题的浏览器的方式之一是使用@supports进行条件查询：</p>\n<p>section {<br>  color: gray;<br>}</p>\n<p>@supports(–css: variables) {<br>  section {<br>    –my-color: blue;<br>    color: var(–my-color, ‘blue’);<br>}<br>}</p>\n<p>因为IE/Edge支持<code>@supports</code>，所以上面的代码会生效。如果在<code>var()</code>函数中添加一个后备值，你的代码将会更加健壮，在支持的更加不好的浏览器中也能优雅降级。 所以，在Chrome和其他支持CSS变量的浏览器中， 元素内部的文本是蓝色的： <img src=\"http://file.w3cbest.com/file/images/1497294865browser-with-css-variables-support.png\"> IE11不支持CSS变量，文本会被渲染成灰色： <img src=\"http://file.w3cbest.com/file/images/1497294899browser-without-css-variables-support.png\"> 查看在线演示：</p>\n<p>See the Pen <a href=\"https://codepen.io/SitePoint/pen/zzBrWY/\">@supports with CSS Variables</a> by SitePoint (<a href=\"https://codepen.io/SitePoint\">@SitePoint</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>这种方式的缺点是如果你在项目中使用了大量的CSS变量，但是该项目主要通过不支持CSS变量的浏览器打开，那么代码不仅会变得有点儿复杂，维护也将会是噩梦。 在这种情况下，你可以选择使用支持cssnext的<a href=\"http://cssnext.io/\">PostCSS</a>，然后你就可以编写尖端的CSS代码了，兼容不支持的浏览器交给PostCSS去做就可以了，这有点儿像JavaScript的编译器。如果你想了解PostCSS，SitePoint Premium为其所有成员提供了有关此主题的精彩<a href=\"https://www.sitepoint.com/premium/courses/kick-starting-postcss-2948\">视频课程</a>。</p>\n<h2 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h2><p>想了解更多CSS变量的细节，包括浏览器兼容问题的解决方案和有趣的例子，查看下面的资源：</p>\n<ul>\n<li>  <a href=\"https://www.w3.org/TR/css-variables/\">用于级联变量的CSS自定义属性模块级别1</a> - W3C规范</li>\n<li>  <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables\">使用CSS变量</a> - MDN</li>\n<li>  <a href=\"https://www.youtube.com/watch?v=kZOJCVvyF-4\">Lea Verou为CSSConf Asia 2016谈论CSS变量</a>（视频）</li>\n<li>  <a href=\"https://css-tricks.com/difference-between-types-of-css-variables/\">CSS变量和预处理器变量之间有什么区别？</a> - Chris Coyier（CSS-Tricks）</li>\n<li>  <a href=\"https://www.smashingmagazine.com/2017/04/start-using-css-custom-properties/\">现在是时候开始使用CSS自定义属性</a> - Serg Hospodarets（Smashing Magazine）</li>\n<li>  <a href=\"https://una.im/local-css-vars/\">本地范围的CSS变量：什么，如何以及为什么</a> - Una Kravets</li>\n<li>  <a href=\"https://csswizardry.com/2016/10/pragmatic-practical-progressive-theming-with-custom-properties/\">自定义属性的实用，实用和渐进式主题</a> - Harry Roberts（CSS Wizardry）</li>\n<li>  <a href=\"https://codepen.io/AmeliaBR/post/customizable-svg-icons-css-variables\">带CSS变量的可定制SVG图标</a> - Amelia Bellamy-Royds（CodePen）。</li>\n</ul>\n<h2 id=\"有趣的例子\"><a href=\"#有趣的例子\" class=\"headerlink\" title=\"有趣的例子\"></a>有趣的例子</h2><ul>\n<li>  <a href=\"https://codepen.io/wesbos/pen/gPZBZQ?editors=0010\">CSS变量的动画</a>- Wes Bos</li>\n<li>  <a href=\"https://codepen.io/wesbos/pen/adQjoY?editors=0110\">使用JS更新CSS变量</a>- Wes Bos</li>\n<li>  <a href=\"https://codepen.io/chriscoyier/pen/ORdLvq?editors=0110\">简单的响应网格与CSS变量</a>- 克里斯科伊尔</li>\n<li>  <a href=\"https://codepen.io/ramenhog/pen/yXYNzz?editors=1010\">Slack主题与CSS自定义属性</a>- 斯蒂芬妮</li>\n<li>  <a href=\"https://codepen.io/search/pens/?q=css+variables&limit=thebabydino\">Ana Tudor在CodePen上的CSS变量演示</a>。</li>\n</ul>\n<p>你还在等什么？尝试使用CSS变量并通过评论让我知道你的想法！ 文章来源：<a href=\"https://www.sitepoint.com/practical-guide-css-variables-custom-properties/\">https://www.sitepoint.com/</a></p>\n","categories":["HTML/CSS"],"tags":["javascript","css var()","CSS Variables","css函数","css教程","前端开发","web开发","层叠样式表","设计"]},{"title":"ECMAScript 2016,2017和2018中所有新功能的示例","url":"/2018/07/22/ecmascript-20162017%E5%92%8C2018%E4%B8%AD%E6%89%80%E6%9C%89%E6%96%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E7%A4%BA%E4%BE%8B/","content":"<p>很难追踪 JavaScript（ECMAScript）中的新功能。 想找到有用的代码示例更加困难。 因此，在本文中，我将介绍 TC39 已完成 ES2016，ES2017 和 ES2018（最终草案）提案中所有添加的 18 个功能，并展示有用的示例。 很难跟踪各种版本的ECMAScript中的新内容，而且如果没有跳转就更难获得有用的示例。因此，在本文中，我将介绍在ES2016，ES2017和ES2018（最终草案）中添加的TC39完成提案中列出的所有18个功能，并向他们展示有用的示例。</p>\n<h2 id=\"ECMAScript-2016\"><a href=\"#ECMAScript-2016\" class=\"headerlink\" title=\"ECMAScript 2016\"></a>ECMAScript 2016</h2><h3 id=\"1-Array-prototype-includes\"><a href=\"#1-Array-prototype-includes\" class=\"headerlink\" title=\"1.Array.prototype.includes\"></a>1.Array.prototype.includes</h3><p>includes 是 Array 上的一个简单实例方法，有助于轻松查找某项元素是否在数组中（包括NaN ,与 indexOf不同）。 <img src=\"http://file.w3cbest.com/file/images/1_OhhFTNabUEz8ZeI4vaCIJw.png\"> 人们想要 contains 来命名该规范，但显然 Mootools 已经使用过这个命名，所以使用了 includes。</p>\n<h3 id=\"2-指数运算符\"><a href=\"#2-指数运算符\" class=\"headerlink\" title=\"2.指数运算符\"></a>2.指数运算符</h3><p>加法和减法等数学运算分别具有 + 和 - 等中缀运算符。与它们类似，** 中缀运算符通常用于指数运算。在 ECMAScript 2016 中，引入了 ** 代替 Math.pow 。 <img src=\"http://file.w3cbest.com/file/images/1_c1k1vgBgGaam7XA8xAp49w.png\"></p>\n<h2 id=\"ECMAScript-2017\"><a href=\"#ECMAScript-2017\" class=\"headerlink\" title=\"ECMAScript 2017\"></a>ECMAScript 2017</h2><h3 id=\"1-Object-values\"><a href=\"#1-Object-values\" class=\"headerlink\" title=\"1.Object.values()\"></a>1.Object.values()</h3><p>Object.values() 是一个与 Object.keys() 类似的新函数，但返回 Object 自身属性的所有值，不包括原型链中的任何值。 <img src=\"http://file.w3cbest.com/file/images/1_OkcC2Sozg0MKvkaqZWxmnw.png\"></p>\n<h3 id=\"2-Object-entries\"><a href=\"#2-Object-entries\" class=\"headerlink\" title=\"2.Object.entries()\"></a>2.Object.entries()</h3><p>Object.entries() 与 Object.keys 相关，但它不仅仅返回 keys ，而是以数组方式返回 keys 和 values 。这使得在循环中使用对象或将对象转换为 Maps 等操作变得非常简单。 <img src=\"http://file.w3cbest.com/file/images/1_23RYJzstZ7iMxKNYbfAAWg.png\"> <img src=\"http://file.w3cbest.com/file/images/1_XAXiVkw2zKyBio4OX6DQoQ.png\"></p>\n<h3 id=\"3-字符串填充\"><a href=\"#3-字符串填充\" class=\"headerlink\" title=\"3.字符串填充\"></a>3.字符串填充</h3><p>String 中添加了两个实例方法，String.prototype.padStart 和 String.prototype.padEnd – 允许将空字符串或其他字符串附加到原始字符串的开头或结尾。</p>\n<p>‘someString’.padStart(numberOfCharcters [,stringForPadding]);<br>‘5’.padStart(10) // ‘ 5’<br>‘5’.padStart(10, ‘=*‘) //‘=*=*=*=*=5’<br>‘5’.padEnd(10) // ‘5 ‘<br>‘5’.padEnd(10, ‘=*‘) //‘5=*=*=*=*=’</p>\n<h4 id=\"3-1-padStart-示例\"><a href=\"#3-1-padStart-示例\" class=\"headerlink\" title=\"3.1 padStart 示例\"></a>3.1 padStart 示例</h4><p>在下面的示例中，我们列出了不同长度的数字。我们希望前置“0”，以便所有项具有相同的 10 位数长度显示。我们可以使用 padStart(10, ‘0’) 轻松实现这一目标。 <img src=\"http://file.w3cbest.com/file/images/1_KLrT9Xmh43cIi2MFUmIfcw.png\"></p>\n<h4 id=\"3-2-padEnd-示例\"><a href=\"#3-2-padEnd-示例\" class=\"headerlink\" title=\"3.2 padEnd 示例\"></a>3.2 padEnd 示例</h4><p>当我们打印不同长度的多个项并希望正确对齐它们时，padEnd 真的很方便。 下面的示例是 padEnd，padStart 和 Object.entries 组合在一起以产生漂亮输出的一个很好的现实示例。 <img src=\"http://file.w3cbest.com/file/images/1_fLXPci_E_yXK9uSqLz-axQ.png\"></p>\n<p>const cars = {<br>    ‘?BMW’: ‘10’,<br>    ‘?Tesla’: ‘5’,<br>    ‘?Lamborghini’: ‘0’<br>}<br>Object.entries(cars).map(([name, count]) =&gt; {<br>    //padEnd appends ‘ -‘ until the name becomes 20 characters<br>    //padStart prepends ‘0’ until the count becomes 3 characters.<br>    console.log(`${name.padEnd(20, ‘ -‘)} Count: ${count.padStart(3, ‘0’)}`)<br>});<br>//Prints..<br>// ?BMW - - - - - - -  Count: 010<br>// ?Tesla - - - - - -  Count: 005<br>// ?Lamborghini - - -  Count: 000</p>\n<h4 id=\"3-3-⚠️padStart-和-padEnd-用于-Emojis-表情和其他双字节字符\"><a href=\"#3-3-⚠️padStart-和-padEnd-用于-Emojis-表情和其他双字节字符\" class=\"headerlink\" title=\"3.3 ⚠️padStart 和 padEnd 用于 Emojis 表情和其他双字节字符\"></a>3.3 ⚠️padStart 和 padEnd 用于 Emojis 表情和其他双字节字符</h4><p>Emojis 和其他双字节字符使用多个字节的 unicode 表示。 所以 padStart 和 padEnd 可能无法按预期工作！⚠️ 例如：假设我们把字符串 heart 通过 emoji表情 ❤️ 使用 padStart 延长到十个字节，这个时候我们得到如下的输出：</p>\n<p>//Notice that instead of 5 hearts, there are only 2 hearts and 1 heart that looks odd!<br>‘heart’.padStart(10, “❤️”); // prints.. ‘❤️❤️❤heart’</p>\n<p>这是因为 ❤️ 本身占据两个字节（\\u2764\\uFE0F），而 heart 本身有 5 个字节，所以我们只剩 5 个字节的位置可以填充，JS使用\\u2764\\uFE0F 来填充两颗心并产生 ❤️❤️ 。对于最后一个，它只使用 heart \\u2764 的第一个字节产生 ❤ 所以我们最终得到：❤️❤️❤heart</p>\n<h4 id=\"4-Object-getOwnPropertyDescriptors\"><a href=\"#4-Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"4.Object.getOwnPropertyDescriptors\"></a>4.Object.getOwnPropertyDescriptors</h4><p>此方法返回给定对象的所有属性的所有详细信息（包括 getter get 和 setter set方法）。 添加它的主要动机是允许浅复制/克隆对象到另一个对象，该对象也复制 getter 和 setter 函数而不像 Object.assign。 <strong>Object.assign 浅复制除原始源对象的 getter 和 setter 函数之外的所有信息。</strong> 下面的示例显示了 Object.assign 和 Object.getOwnPropertyDescriptors 以及 Object.defineProperties 之间的区别，以将原始对象 Car 复制到新对象 ElectricCar 中。 你将看到，通过使用 Object.getOwnPropertyDescriptors，discount getter 和 setter 函数也会复制到目标对象中。 之前… <img src=\"http://file.w3cbest.com/file/images/1_7r4pk8hfx5VQ9-ERu--xCw.png\"> 以后… <img src=\"http://file.w3cbest.com/file/images/1_gvlG4DfnkiOrlgPsQrjLfg.png\"></p>\n<p>var Car = {<br>    name: ‘BMW’,<br>    price: 1000000,<br>    set discount(x) {<br>        this.d = x;<br>    },<br>    get discount() {<br>        return this.d;<br>    },<br>};<br>//Print details of Car object’s ‘discount’ property<br>console.log(Object.getOwnPropertyDescriptor(Car, ‘discount’));<br>//prints..<br>// {<br>//   get: [Function: get],<br>//   set: [Function: set],<br>//   enumerable: true,<br>//   configurable: true<br>// }<br>//Copy Car’s properties to ElectricCar using Object.assign<br>const ElectricCar = Object.assign({}, Car);<br>//Print details of ElectricCar object’s ‘discount’ property<br>console.log(Object.getOwnPropertyDescriptor(ElectricCar, ‘discount’));<br>//prints..<br>// {<br>//   value: undefined,<br>//   writable: true,<br>//   enumerable: true,<br>//   configurable: true </p>\n<p>// }<br>//⚠️Notice that getters and setters are missing in ElectricCar object for ‘discount’ property !??<br>//Copy Car’s properties to ElectricCar2 using Object.defineProperties<br>//and extract Car’s properties using Object.getOwnPropertyDescriptors<br>const ElectricCar2 = Object.defineProperties({}, Object.getOwnPropertyDescriptors(Car));<br>//Print details of ElectricCar2 object’s ‘discount’ property<br>console.log(Object.getOwnPropertyDescriptor(ElectricCar2, ‘discount’));<br>//prints..<br>// { get: [Function: get],  ??????<br>//   set: [Function: set],  ??????<br>//   enumerable: true,<br>//   configurable: true<br>// }<br>// Notice that getters and setters are present in the ElectricCar2 object for ‘discount’ property!</p>\n<h3 id=\"5-在函数参数中添加尾逗号\"><a href=\"#5-在函数参数中添加尾逗号\" class=\"headerlink\" title=\"5.在函数参数中添加尾逗号\"></a>5.在函数参数中添加尾逗号</h3><p>这是一个小更新，允许我们在函数最后一个参数后面有逗号。 为什么？ 帮助使用像 git blame 这样的工具，防止添加一个参数却需要修改两行代码。 以下示例显示了问题和解决方案。 <img src=\"http://file.w3cbest.com/file/images/1_-SKZCxQdf8Rk48SSaPtDGg.png\"></p>\n<h3 id=\"6-Async-Await\"><a href=\"#6-Async-Await\" class=\"headerlink\" title=\"6. Async/Await\"></a>6. Async/Await</h3><p>到目前为止，这个特性应该是目前为止是最重要和最有用的功能。async 函数解决了回调地狱的问题，并使整个代码看起来简单。 async 关键字告诉 JavaScript 编译器以不同方式处理函数。 只要到达该函数中的 await 关键字，编译器就会暂停。 它假定 await 之后的表达式返回一个 promise 并等待，直到 promise 被 resolved 或被 rejected ，然后才继续执行。 在下面的示例中，getAmount 函数调用两个异步函数 getUser 和 getBankBalance。 我们可以用 Promise 做到这一点，但是使用 async await 更加优雅和简单。 <img src=\"http://file.w3cbest.com/file/images/1_L3FZ0onbBD4ay6UhZvPoMw.png\"></p>\n<h4 id=\"6-1-Async-函数本身返回一个-Promise-。\"><a href=\"#6-1-Async-函数本身返回一个-Promise-。\" class=\"headerlink\" title=\"6.1 Async 函数本身返回一个 Promise 。\"></a>6.1 Async 函数本身返回一个 Promise 。</h4><p>如果你正在等待 async 函数的结果，则需要使用 Promise 的 then 语法来捕获其结果。 在以下示例中，我们希望使用 console.log 但不在 doubleAndAdd 中记录结果。 所以我们想等待并使用 then 语法将结果传递给console.log 。 <img src=\"http://file.w3cbest.com/file/images/1_ylheY6gJawprWEVNL68mRQ.png\"></p>\n<h4 id=\"6-2-并行调用-async-await\"><a href=\"#6-2-并行调用-async-await\" class=\"headerlink\" title=\"6.2 并行调用 async/await\"></a>6.2 并行调用 async/await</h4><p>在前面的例子中，我们调用 await 两次，但每次我们等待一秒钟（总共2秒）。相反，我们可以并行调用它，因为使用 Promise.all 并行调用 a 和 b 。 <img src=\"http://file.w3cbest.com/file/images/1_VEF_Sq067Liq4lfTV8Xv0A.png\"></p>\n<h4 id=\"6-3-async-await-函数的错误处理\"><a href=\"#6-3-async-await-函数的错误处理\" class=\"headerlink\" title=\"6.3 async/await 函数的错误处理\"></a>6.3 async/await 函数的错误处理</h4><p>使用 async/await 时，有多种方法可以处理错误。</p>\n<h5 id=\"选项1-在函数中使用try-catch\"><a href=\"#选项1-在函数中使用try-catch\" class=\"headerlink\" title=\"选项1-在函数中使用try catch\"></a>选项1-在函数中使用try catch</h5><p><img src=\"http://file.w3cbest.com/file/images/1_iP84ax2TOt5dbaIjW7kzcw.png\"></p>\n<p>//Option 1 - Use try catch within the function<br>async function doubleAndAdd(a, b) {<br>    try {<br>        a = await doubleAfter1Sec(a);<br>        b = await doubleAfter1Sec(b);<br>    } catch (e) {<br>        return NaN; //return something<br>    }<br>    return a + b;<br>}<br>//?Usage:<br>doubleAndAdd(‘one’, 2).then(console.log); // NaN<br>doubleAndAdd(1, 2).then(console.log); // 6<br>function doubleAfter1Sec(param) {<br>    return new Promise((resolve, reject) =&gt; {<br>        setTimeout(function() {<br>            let val = param * 2;<br>            isNaN(val) ? reject(NaN) : resolve(val);<br>        }, 1000);<br>    });<br>}</p>\n<h5 id=\"选项2-捕获-Catch-await-表达式\"><a href=\"#选项2-捕获-Catch-await-表达式\" class=\"headerlink\" title=\"选项2-捕获(Catch) await 表达式\"></a>选项2-捕获(Catch) await 表达式</h5><p>由于每一个 await 表达式返回的都是 Promise，我们可以直接在每一行上面添加 catch。 <img src=\"http://file.w3cbest.com/file/images/1_Bkls3dXMIRGKAwFN2r--qg.png\"></p>\n<p>//Option 2 - *Catch* errors on  every await line<br>//as each await expression is a Promise in itself<br>async function doubleAndAdd(a, b) {<br>    a = await doubleAfter1Sec(a).catch(e =&gt; console.log(‘“a” is NaN’)); // ?<br>    b = await doubleAfter1Sec(b).catch(e =&gt; console.log(‘“b” is NaN’)); // ?<br>    if (!a  !b) {<br>        return NaN;<br>    }<br>    return a + b;<br>}<br>//?Usage:<br>doubleAndAdd(‘one’, 2).then(console.log); // NaN  and logs:  “a” is NaN<br>doubleAndAdd(1, 2).then(console.log); // 6<br>function doubleAfter1Sec(param) {<br>    return new Promise((resolve, reject) =&gt; {<br>        setTimeout(function() {<br>            let val = param * 2;<br>            isNaN(val) ? reject(NaN) : resolve(val);<br>        }, 1000);<br>    });<br>}</p>\n<h5 id=\"选项3-捕获-Catch-整个async-await函数\"><a href=\"#选项3-捕获-Catch-整个async-await函数\" class=\"headerlink\" title=\"选项3-捕获(Catch) 整个async-await函数\"></a>选项3-捕获(Catch) 整个async-await函数</h5><p><img src=\"http://file.w3cbest.com/file/images/1_hhkv5ZBOUYViCL2UP0sv5Q.png\"></p>\n<p>//Option 3 - Dont do anything but handle outside the function<br>//since async / await returns a promise, we can catch the whole function’s error<br>async function doubleAndAdd(a, b) {<br>    a = await doubleAfter1Sec(a);<br>    b = await doubleAfter1Sec(b);<br>    return a + b;<br>}<br>//?Usage:<br>doubleAndAdd(‘one’, 2)<br>    .then(console.log)<br>    .catch(console.log); // ???&lt;——- use “catch”<br>function doubleAfter1Sec(param) {<br>    return new Promise((resolve, reject) =&gt; {<br>        setTimeout(function() {<br>            let val = param * 2;<br>            isNaN(val) ? reject(NaN) : resolve(val);<br>        }, 1000);<br>    });<br>}</p>\n<h2 id=\"ECMAScript-2018\"><a href=\"#ECMAScript-2018\" class=\"headerlink\" title=\"ECMAScript 2018\"></a>ECMAScript 2018</h2><h3 id=\"1-共享内存和-atomics\"><a href=\"#1-共享内存和-atomics\" class=\"headerlink\" title=\"1. 共享内存和 atomics\"></a>1. 共享内存和 atomics</h3><p>这是一个巨大的，非常先进的功能，并且是对 JS 引擎的核心增强。 这个特性的主要目的是给 JavaScript 提供多线程功能，以便JS开发人员通过自己管理内存来编写高性能的并发程序，而不是让JS引擎管理内存。 这是通过一种名为<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\">SharedArrayBuffer</a>的新型全局对象完成的，该对象实质上将数据存储在共享内存空间中。因此，这些数据可以在主JS线程和 Web-worker 线程之间共享。 之前，如果我们想在主JS线程和 web-worker 之间共享数据，我们必须复制数据并使用postMessage将其发送到另一个线程。 现在，你只需使用SharedArrayBuffer，主线程和多个web-worker线程都可以立即访问数据。 但是在线程之间共享内存会导致竞争条件(即多个进程同时操作一个内存)。为了帮助避免竞争条件，引入了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics\">Atomics</a>全局对象。 Atomics提供了各种方法来在线程使用其数据时锁定共享内存。它还提供了安全地更新共享内存中的此类数据的方法。 建议通过某个库使用此功能，但是现在没有基于此功能构建的库。 如果你有兴趣，我建议阅读：</p>\n<ol>\n<li> <a href=\"http://lucasfcosta.com/2017/04/30/JavaScript-From-Workers-to-Shared-Memory.html\"><em>From Workers to Shared Memor</em></a>_y — _<a href=\"http://lucasfcosta.com/\"><em>lucasfcosta</em></a></li>\n<li> <a href=\"https://hacks.mozilla.org/category/code-cartoons/a-cartoon-intro-to-sharedarraybuffers/\"><em>A cartoon intro to SharedArrayBuffers</em></a>_ — _<a href=\"https://medium.com/@linclark\"><em>Lin Clark</em></a></li>\n<li> <a href=\"http://2ality.com/2017/01/shared-array-buffer.html\"><em>Shared memory and atomics</em></a>_ — _<a href=\"http://rauschma.de/\"><em>Dr. Axel Rauschmayer</em></a></li>\n</ol>\n<h3 id=\"2-移除了标记模板字面量的限制\"><a href=\"#2-移除了标记模板字面量的限制\" class=\"headerlink\" title=\"2.移除了标记模板字面量的限制\"></a>2.移除了标记模板字面量的限制</h3><p>首先，我们需要澄清“标记模板字面量”是什么，以便我们更好地理解这个功能。 在 ES2015+ 中，有一个称为标记模板文字的功能，允许开发人员自定义字符串的插值方式。 例如，在标准方式中，字符串被插入如下… <img src=\"http://file.w3cbest.com/file/images/1_4EizdrE9LlRZ5GXRq4G3Yw.png\"> 在标记的字面量中，你可以编写一个函数来接收字符串字面量的硬编码部分，例如 [‘Hello’，’！’] 并且替换变量，例如 [‘Raja’] ，作为参数进入一个自定义函数（例如 greet ），并从该自定义函数返回任何你想要的内容。 下面的示例显示我们的自定义 “Tag” 函数 greet，如“Good Morning” “Good afternoon”，等等，取决于当天到字符串字面量的时间，并返回自定义字符串。 <img src=\"http://file.w3cbest.com/file/images/1_PfeJ5R0h6SHx6SxSkPCLmg.png\"></p>\n<p>//A “Tag” function returns a custom string literal.<br>//In this example, greet calls timeGreet() to append Good //Morning/Afternoon/Evening depending on the time of the day.<br>function greet(hardCodedPartsArray, …replacementPartsArray) {<br>    console.log(hardCodedPartsArray); //[ ‘Hello ‘, ‘!’ ]<br>    console.log(replacementPartsArray); //[ ‘Raja’ ]<br>    let str = ‘’;<br>    hardCodedPartsArray.forEach((string, i) =&gt; {<br>        if (i &lt; replacementPartsArray.length) {<br>            str += `${string} ${replacementPartsArray[i]  ‘’}`;<br>        } else {<br>            str += `${string} ${timeGreet()}`; //&lt;– append Good morning/afternoon/evening here<br>        }<br>    });<br>    return str;<br>}<br>//?Usage:<br>const firstName = ‘Raja’;<br>const greetings = greet `Hello ${firstName}!`; //??&lt;– Tagged literal<br>console.log(greetings); //‘Hello  Raja! Good Morning!’ ?<br>function timeGreet() {<br>    const hr = new Date().getHours();<br>    return hr &lt; 12 ?<br>        ‘Good Morning!’ :<br>        hr &lt; 18 ? ‘Good Afternoon!’ : ‘Good Evening!’;<br>}</p>\n<p>现在我们讨论了 “Tagged” 函数是什么，许多人想要在不同的场景下中使用此功能，例如在终端中使用命令和 HTTP 请求来编写 URI ，等等。</p>\n<h4 id=\"⚠️标签字符串模版存在的问题\"><a href=\"#⚠️标签字符串模版存在的问题\" class=\"headerlink\" title=\"⚠️标签字符串模版存在的问题\"></a>⚠️标签字符串模版存在的问题</h4><p>ES2015 和 ES2016 规范不允许使用转义字符，如 \\u（unicode），\\x（十六进制），除非它们看起来完全像 \\u00A9 或 \\u{2F804} 或 \\xA9 。 因此，如果你有一个内部使用其他域规则（如终端规则）的 Tagged 函数，可能需要使用 \\ubla123abla ，而不能是 \\u0049 或 \\u{@F804} ，这样你会得到一个语法错误。 在 ES2018 中，只要 Tagged 函数返回具有 “cooked” 属性（无效字符为 “undefined” ）的对象中的值，然后是 “raw” 属性（ 无论你想要什么）。</p>\n<p>function myTagFunc(str) { return { “cooked”: “undefined”, “raw”: str.raw[0] }} var str = myTagFunc `hi \\</p>\n<h3 id=\"3-正则表达式中的-‘dotall’-标记\"><a href=\"#3-正则表达式中的-‘dotall’-标记\" class=\"headerlink\" title=\"3. 正则表达式中的 ‘dotall’ 标记\"></a>3. 正则表达式中的 ‘dotall’ 标记</h3><p>目前在RegEx中，点(“.”)可以表示任何的单一字符，但它不能与 \\n ， \\r，\\f 等换行符匹配。 例如：</p>\n<p>//Before<br>/first.second/.test(‘first\\nsecond’); //false</p>\n<p>此增强功能使点运算符可以匹配任何单个字符。为了确保不会破坏任何内容，我们需要在创建RegEx时使用 \\s 标记才能使其正常工作。</p>\n<p>//ECMAScript 2018<br>/first.second/s.test(‘first\\nsecond’); //true Notice: /s ??</p>\n<p><img src=\"http://file.w3cbest.com/file/images/1_t5xegqe5su6XgRDcBObyDw.png\"></p>\n<h3 id=\"4-正则表达式捕获命名组\"><a href=\"#4-正则表达式捕获命名组\" class=\"headerlink\" title=\"4. 正则表达式捕获命名组\"></a>4. 正则表达式捕获命名组</h3><p>这个增强功能带来了其他语言（如Python，Java等）的有用 RegExp 功能，称为“命名组”。这个功能允许允许正则表达式给每一个捕获组起一个名字(?<name>…)，然后，我们可以使用该名称轻松获取我们需要的任何群组。</p>\n<h4 id=\"4-1-基本的命名组例子\"><a href=\"#4-1-基本的命名组例子\" class=\"headerlink\" title=\"4.1 基本的命名组例子\"></a>4.1 基本的命名组例子</h4><p>在下面的例子中，我们使用(?<year>) (?<month>) and (?year)来为正则表达式中的不同部分分组，结果对象中会包含一个 groups 属性，其拥有 year month day 三个对象。 <img src=\"http://file.w3cbest.com/file/images/1_1ORiZapMHp_SV5gvOVT2WA.png\"></p>\n<h4 id=\"4-2-在正则表达式本身内使用命名组\"><a href=\"#4-2-在正则表达式本身内使用命名组\" class=\"headerlink\" title=\"4.2 在正则表达式本身内使用命名组\"></a>4.2 在正则表达式本身内使用命名组</h4><p>我们可以使用\\k<group name>格式来反向引用正则表达式本身中的组。以下示例显示了它的工作原理。 <img src=\"http://file.w3cbest.com/file/images/1_O6i-gXHBifD27qD73Sw7TA.png\"></p>\n<h4 id=\"4-3-在-String-prototype-replace-中使用命名组\"><a href=\"#4-3-在-String-prototype-replace-中使用命名组\" class=\"headerlink\" title=\"4.3 在 String.prototype.replace 中使用命名组\"></a>4.3 在 String.prototype.replace 中使用命名组</h4><p>命名组也可以在 String 的 replace 方法中使用，比如用来交换一个字符串中各个部分的位置。 例如，将firstName, lastName 更改为 lastName, firstName。 <img src=\"http://file.w3cbest.com/file/images/1_weBLy9CAXFnWNwUqcwNMAg.png\"></p>\n<h3 id=\"5-对象的剩余属性\"><a href=\"#5-对象的剩余属性\" class=\"headerlink\" title=\"5. 对象的剩余属性\"></a>5. 对象的剩余属性</h3><p>Rest 运算符 …（三个点）允许我们提取 Object 的剩余属性。</p>\n<h4 id=\"5-1-我们可以使用展开运算符展开我们想要的属性：\"><a href=\"#5-1-我们可以使用展开运算符展开我们想要的属性：\" class=\"headerlink\" title=\"5.1 我们可以使用展开运算符展开我们想要的属性：\"></a>5.1 我们可以使用展开运算符展开我们想要的属性：</h4><p><img src=\"http://file.w3cbest.com/file/images/1_Uh4-1F3aeoy5k3hq8nVlfQ.png\"></p>\n<h4 id=\"5-2-或者我们借助展开运算符，移除我们不想要的属性\"><a href=\"#5-2-或者我们借助展开运算符，移除我们不想要的属性\" class=\"headerlink\" title=\"5.2 或者我们借助展开运算符，移除我们不想要的属性 ??\"></a>5.2 或者我们借助展开运算符，移除我们不想要的属性 ??</h4><p><img src=\"http://file.w3cbest.com/file/images/1_43kFc4JJy8DSQiA_zQXZZA.png\"></p>\n<h2 id=\"6-展开对象的属性\"><a href=\"#6-展开对象的属性\" class=\"headerlink\" title=\"6.展开对象的属性\"></a>6.展开对象的属性</h2><p>展开属性看起来就像 Rest 运算符，都是三个点 …，但不同之处在于你使用展开操作符来创建（重构）新对象。 提示：展开（spread）运算符用于等号的右侧。剩余（Rest）运算符用在等号的左侧。 <img src=\"http://file.w3cbest.com/file/images/1_QmSUhdHQiXaXL9vdE27Djg.png\"></p>\n<h2 id=\"7-正则表达式后行断言-Lookbehind\"><a href=\"#7-正则表达式后行断言-Lookbehind\" class=\"headerlink\" title=\"7.正则表达式后行断言(Lookbehind)\"></a>7.正则表达式后行断言(Lookbehind)</h2><p>这是 RegEx 的一个增强，它允许我们确保某些子字符串恰好出现在某些子字符串之前。 你现在可以使用一个组 (?&lt;=…)（问号，小于，等于）来查看先行断言。 此外，你可以使用 (?&lt;!…)（问号，小于，感叹号）来查看后行断言。基本上，只要-ve断言通过，这将匹配。 肯定断言：假设我们要确保 # 符号存在于 winning 之前（即：#winning），并希望正则表达式只返回字符串 “winning” 。下面是我们的做法： <img src=\"http://file.w3cbest.com/file/images/1_MJuEF0dePb_NE8DHFm0XNw.png\"> 否定断言：假设我们想要从具有 € 符号的行中提取数字，而不是 $ 。 <img src=\"http://file.w3cbest.com/file/images/1_e1N-waOWBc3ykLRFCIzXSA.png\"></p>\n<h2 id=\"8-RegExp-Unicode属性转义\"><a href=\"#8-RegExp-Unicode属性转义\" class=\"headerlink\" title=\"8. RegExp Unicode属性转义\"></a>8. RegExp Unicode属性转义</h2><p>编写 RegEx 以匹配各种 unicode 字符并不容易。像 \\w，\\W，\\d 等只匹配英文字符和数字。但是其他语言中的数字如印地语，希腊语等等该怎么办呢？ 这就是 Unicode 属性转义的用武之地。事实证明，Unicode 为每个符号（字符）添加元数据属性，并使用它来分组或表征各种符号。 例如，Unicode 数据库将所有印地语字符（??????）归为一个名为 Script 的属性，其值为 Devanagari ，另一个属性为Script_Extensions，其值为 Devanagari 。所以我们可以搜索 Script=Devanagari 并获得所有印地语字符。 梵文可以用于各种印度语言，如马拉地语，印地语，梵语等。 从 ECMAScript 2018 开始，我们可以使用 \\p 来转义字符以及 {Script = Devanagari} 以匹配所有这些印度字符。也就是说，我们可以在 RegEx 中使用：\\p{Script=Devanagari} 来匹配所有梵文字符。 <img src=\"http://file.w3cbest.com/file/images/1_c-bRDN8WERPUYevc38jZMg.png\"></p>\n<p>//The following matches multiple hindi character<br>/^\\p{Script=Devanagari}+$/u.test(‘हिन्दी’); //true<br>//PS:there are 3 hindi characters h</p>\n<p>同样，Unicode 数据库将 Script_Extensions（和 Script ）属性下的所有希腊字符组合为希腊语。 所以我们可以使用 Script_Extensions=Greek 或 Script=Greek 搜索所有希腊字符。 也就是说，我们可以在RegEx中使用： \\p{Script=Greek} 来匹配所有希腊字符。 <img src=\"http://file.w3cbest.com/file/images/1_DwP_VN4VUp7osFQC-I9OsQ.png\"></p>\n<p>//The following matches a single Greek character<br>/\\p{Script_Extensions=Greek}/u.test(‘π’); // true</p>\n<p>此外，Unicode数据库在布尔属性 Emoji ，Emoji_Component， Emoji_Presentation ，Emoji_Modifier 和 Emoji_Modifier_Base 下存储各种类型的 Emojis，其属性值为 true。 因此，我们只需选择 Emoji 符号即可搜索所有表情符号。 也就是说，我们可以使用：\\p{Emoji}，\\Emoji_Modifier 等来匹配各种 Emojis 。 以下示例将使一切清楚。 <img src=\"http://file.w3cbest.com/file/images/1_DsQryeDlp8fAKBS8k_ohqw.png\"></p>\n<p>//The following matches an Emoji character<br>/\\p{Emoji}/u.test(‘❤️’); //true<br>//The following fails because yellow emojis don’t need/have Emoji_Modifier!<br>/\\p{Emoji}\\p{Emoji_Modifier}/u.test(‘✌️’); //false<br>//The following matches an emoji character\\p{Emoji} followed by \\p{Emoji_Modifier}<br>/\\p{Emoji}\\p{Emoji_Modifier}/u.test(‘✌?’); //true<br>//Explaination:<br>//By default the victory emoji is yellow color.<br>//If we use a brown, black or other variations of the same emoji, they are considered<br>//as variations of the original Emoji and are represented using two unicode characters.<br>//One for the original emoji, followed by another unicode character for the color.<br>//<br>//So in the below example, although we only see a single brown victory emoji,<br>//it actually uses two unicode characters, one for the emoji and another<br>// for the brown color.<br>//<br>//In Unicode database, these colors have Emoji_Modifier property.<br>//So we need to use both \\p{Emoji} and \\p{Emoji_Modifier} to properly and<br>//completely match the brown emoji.<br>/\\p{Emoji}\\p{Emoji_Modifier}/u.test(‘✌?’); //true</p>\n<p>最后，我们可以使用大写“P”（ \\P ）转义字符,而不是小写“p”（ \\p ）来否定匹配。 参考阅读：</p>\n<ol>\n<li> <a href=\"https://mathiasbynens.be/notes/es-unicode-property-escapes\"><em>ECMAScript 2018 Proposal</em></a></li>\n<li> <a href=\"https://mathiasbynens.be/notes/es-unicode-property-escapes\"><em>https://mathiasbynens.be/notes/es-unicode-property-escapes</em></a></li>\n</ol>\n<h2 id=\"9-Promise-prototype-finally\"><a href=\"#9-Promise-prototype-finally\" class=\"headerlink\" title=\"9.Promise.prototype.finally()\"></a>9.Promise.prototype.finally()</h2><p>finally() 是一个添加到 Promise 实例的新方法。 主要考虑是允许在 resolve 或 reject 调用之后执行一些清理性质的代码。finally 被执行的时候不会被传入任何函数，并且无论什么时候都会被执行。 我们来看看各种情况。 <img src=\"http://file.w3cbest.com/file/images/1_P1V6c1ncEjeCgtS6zzR0gg.png\"> <img src=\"http://file.w3cbest.com/file/images/1_tSbu3kZCkoGpXaWDuP6MPA.png\"> <img src=\"http://file.w3cbest.com/file/images/1_kB6Ar5YJoAlwwhFqzMGBGg.png\"> <img src=\"http://file.w3cbest.com/file/images/1_wCcbabJsS8UbFclumSISqg.png\"></p>\n<h2 id=\"10-异步迭代\"><a href=\"#10-异步迭代\" class=\"headerlink\" title=\"10.异步迭代\"></a>10.异步迭代</h2><p>这是一个非常有用的特性。 基本上它允许我们轻松创建异步代码循环！ 此特性添加了一个新的“for-await-of”循环，允许我们在循环中调用返回 promises（或带有一堆 promise 的 Arrays ）的异步函数。 循环会等待每个 Promise 在进行下一个循环之前 resolve 。 <img src=\"http://file.w3cbest.com/file/images/1_liLeNfWxZ3x1sqrVmRUdRQ.png\"></p>\n<h2 id=\"相关阅读\"><a href=\"#相关阅读\" class=\"headerlink\" title=\"相关阅读\"></a>相关阅读</h2><ul>\n<li>  <a href=\"/p/r1WOgVw-7/javascript-fundamentals-for-absolute-beginners-2018\">JavaScript Fundamentals for Absolute Beginners 2018</a></li>\n<li>  <a href=\"/p/Skiy3aabX/top-10-javascript-questions\">Top 10 JavaScript Questions</a></li>\n<li>  <a href=\"/p/B1DhjT6bQ/developing-in-html5-with-javascript-and-css3\">Developing in HTML5 with JavaScript and CSS3</a></li>\n<li>  <a href=\"/p/ByuSrSU07/object-oriented-programming-in-javascript\">Object-Oriented Programming in JavaScript</a></li>\n<li>  <a href=\"/p/SkzXrVzA7/javascript-tutorial-learn-javascript-apps-like-an-expert\">JavaScript Tutorial Learn JavaScript Apps Like An Expert</a></li>\n<li>  <a href=\"/p/Hk6qojzyM/functional-programming-in-javascript\">Functional Programming In JavaScript</a></li>\n</ul>\n<p>文章来源：<a href=\"https://school.geekwall.in/p/BkEFDtfoM/examples-of-everything-new-in-ecmascript-2016-2017-and-2018\">https://school.geekwall.in</a></p>\n","categories":["JavaScript"],"tags":["javascript教程","ECMAScript2016","ECMAScript教程","js教程","ECMAScript","ECMAScript 2017","ECMAScript 2018","ES教程"]},{"title":"HTML5语义化开发指南","url":"/2019/06/20/html5%E8%AF%AD%E4%B9%89%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","content":"<h2 id=\"为什么要做-HTML5-语义化\"><a href=\"#为什么要做-HTML5-语义化\" class=\"headerlink\" title=\"为什么要做 HTML5 语义化\"></a>为什么要做 HTML5 语义化</h2><p>HTML5的主要进步之一是引入了一组标准化的语义元素。 ”语义元素“是用于以更有意义的方式标记文档结构的元素，这种方式可以清楚地表明它们的用途和目的是什么。而且重要的是，由于它们是标准化的，定义文档的这些元素可以被每个人使用并理解，包括机器人。 在web无障碍开发领域，给视障用户使用的屏幕阅读器是视障群体访问网络的必备工具，合理的 HTML5 语义化元素，会让屏幕阅读器正确的理解网页的内容，从而以最为合适的方式朗读。 站在开发者的角度，写出符合 HTML5 语义化的结构，也是显示我们职业素养的一种方式，最为重要的是这样的代码自带翻译，比如下面的div结构，为了让开发者明白div的含义，我们必须在class命名上下功夫。</p>\n<div class=\"header\">\n    <h1>Super duper best blog ever</h1> ...\n</div>\n<div class=\"main\">\n    <h2>Why you should buy more cheeses than you currently do</h2> ...\n</div>\n<div class=\"footer\">\nContact us! \n<div class=\"contact-info\">this.is.us@example.com</div>\n</div>\n\n<p>而如果采用语义化元素，结构一目了然，不管是日后维护还是交接给他人，都是件轻松的事情。</p>\n<header>\n    <h1>Super duper best blog ever</h1> ...\n</header>\n<main>\n    <h2>Why you should buy more cheeses than you currently do</h2> ...\n</main>\n<footer>\nContact us! \n<div class=\"contact-info\">this.is.us@example.com</div>\n</footer>\n\n<p>先来回顾一下 HTML5 有哪些元素（根据 MDN 资料整理）</p>\n<h2 id=\"HTML5-元素大全\"><a href=\"#HTML5-元素大全\" class=\"headerlink\" title=\"HTML5 元素大全\"></a>HTML5 元素大全</h2><h3 id=\"文档元素\"><a href=\"#文档元素\" class=\"headerlink\" title=\"文档元素\"></a>文档元素</h3><p>元素</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/html\">html</a></p>\n<p>HTML 文档中最外层的元素，也可称为根元素。</p>\n<h3 id=\"文档元数据\"><a href=\"#文档元数据\" class=\"headerlink\" title=\"文档元数据\"></a>文档元数据</h3><p>元素</p>\n<p>元素</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/head\">head</a></p>\n<p>表示文档的头部</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/title\">title</a></p>\n<p>用来定义文档的标题</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/base\">base</a></p>\n<p>为页面上的所有的相对链接规定默认 URL 或默认目标</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link\">link</a></p>\n<p>定义文档与外部资源的关系</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta\">meta</a></p>\n<p>提供了 HTML 文档的元数据</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/style\">style</a></p>\n<p>用于表示文档所使用的样式</p>\n<h3 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a>区块</h3><p>元素</p>\n<p>元素</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body\">body</a></p>\n<p>表示文档的内容</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article\">article</a></p>\n<p>表示文档、页面、应用或网站中的独立结构</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section\">section</a></p>\n<p>表示文档中的一个区域（或节）</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/nav\">nav</a></p>\n<p>描绘一个含有多个超链接的导航栏区域</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/aside\">aside</a></p>\n<p>表示一个和其余页面内容几乎无关的部分</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Heading_Elements\">h1-h6</a></p>\n<p>标题(Heading)元素呈现了六个不同的级别的标题，<code>&lt;h1&gt;</code> 级别最高，而 <code>&lt;h6&gt;</code> 级别最低</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/footer\">footer</a></p>\n<p>表示最近一个章节内容或者根节点（sectioning root ）元素的页脚</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/header\">header</a></p>\n<p>用于展示介绍性内容</p>\n<h3 id=\"内容分组\"><a href=\"#内容分组\" class=\"headerlink\" title=\"内容分组\"></a>内容分组</h3><p>元素</p>\n<p>元素</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/p\">p</a></p>\n<p>表示文本的一个段落</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/address\">address</a></p>\n<p>表示其中的内容提供了某个人或某个组织（等等）的联系信息</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/hr\">hr</a></p>\n<p>表示段落级元素之间的主题转换</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/pre\">pre</a></p>\n<p>表示预定义格式文本</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/blockquote\">blockquote</a></p>\n<p>表示其中的文字是引用内容</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol\">ol</a></p>\n<p>表示多个元素的有序列表</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul\">ul</a></p>\n<p>表示多个元素的无序列表</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/li\">li</a></p>\n<p>表示列表里的条目</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/dl\">dl</a></p>\n<p>表示一个包含术语定义以及描述的列表</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/dt\">dt</a></p>\n<p>用于在一个定义列表中声明一个术语</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/dd\">dd</a></p>\n<p>用来指明一个描述列表元素中一个术语的描述</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/figure\">figure</a></p>\n<p>代表一段独立的内容</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/figcaption\">figcaption</a></p>\n<p>与其相关联的图片的说明/标题</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/main\">main</a></p>\n<p>呈现了文档的 <code>&lt;body&gt;</code> 或应用的主体部分</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/div\">div</a></p>\n<p>通用型的流内容容器，它应该在没有任何其它语义元素可用时才使用</p>\n<h3 id=\"文本级语义\"><a href=\"#文本级语义\" class=\"headerlink\" title=\"文本级语义\"></a>文本级语义</h3><p>元素</p>\n<p>元素</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a\">a</a></p>\n<p>定义超链接，用于从一个页面链接到另一个页面</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/em\">em</a></p>\n<p>标记出需要用户着重阅读的内容</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/strong\">strong</a></p>\n<p>表示文本十分重要</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/small\">small</a></p>\n<p>表示边注释和附属细则，包括版权和法律文本</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/s\">s</a></p>\n<p>表示不再相关，或者不再准确的事情</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/cite\">cite</a></p>\n<p>表示一个作品的引用</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/q\">q</a></p>\n<p>表示一个封闭的并且是短的行内引用的文本</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/dfn\">dfn</a></p>\n<p>表示术语的一个定义</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/abbr\">abbr</a></p>\n<p>用于展示缩写</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ruby\">ruby</a></p>\n<p>用来展示东亚文字注音或字符注释</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/rb\">rb</a></p>\n<p>用于分隔<code>&lt;ruby&gt;</code>注释的基本文本组件</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/rt\">rt</a></p>\n<p>包含字符的发音</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/rtc\">rtc</a></p>\n<p>包含 <code>&lt;ruby&gt;</code> 元素中文字的语义注解</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/rp\">rp</a></p>\n<p>用于为那些不能使用 <code>&lt;ruby&gt;</code> 元素展示 ruby 注解的浏览器</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/data\">data</a></p>\n<p>将一个指定内容和机器可读的翻译联系在一起</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/time\">time</a></p>\n<p>用来表示24小时制时间或者公历日期</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/code\">code</a></p>\n<p>呈现一段计算机代码</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/var\">var</a></p>\n<p>表示变量的名称，或者由用户提供的值</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/samp\">samp</a></p>\n<p>用于标识计算机程序输出</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/kbd\">kbd</a></p>\n<p>表示用户输入</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sub\">sub</a></p>\n<p>定义了一个下标文本区域</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sup\">sup</a></p>\n<p>定义了一个上标文本区域</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/i\">i</a></p>\n<p>用于表现因某些原因需要区分普通文本的一系列文本</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/b\">b</a></p>\n<p>用于吸引读者的注意到该元素的内容上</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/u\">u</a></p>\n<p>表示具有未标注的文本跨度，显示渲染，非文本注释</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/mark\">mark</a></p>\n<p>用来表示上下文的关联性的而突出显示的文字</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/bdi\">bdi</a></p>\n<p>隔离可能以不同方向进行格式化的外部文本</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/bdo\">bdo</a></p>\n<p>用于覆盖当前文本的朝向</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/span\">span</a></p>\n<p>短语内容的通用行内容器，并没有任何特殊语义</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/br\">br</a></p>\n<p>在文本中生成一个换行（回车）符号</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/wbr\">wbr</a></p>\n<p>一个文本中的位置，其中浏览器可以选择来换行</p>\n<h3 id=\"修改记录\"><a href=\"#修改记录\" class=\"headerlink\" title=\"修改记录\"></a>修改记录</h3><p>元素</p>\n<p>元素</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ins\">ins</a></p>\n<p>定义已经被插入文档中的文本</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/del\">del</a></p>\n<p>表示一些被从文档中删除的文字内容</p>\n<h3 id=\"嵌入内容\"><a href=\"#嵌入内容\" class=\"headerlink\" title=\"嵌入内容\"></a>嵌入内容</h3><p>元素</p>\n<p>元素</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/picture\">picture</a></p>\n<p>通过包含零或多个 <code>&lt;source&gt;</code> 元素和一个 <code>&lt;img&gt;</code> 元素来为不同的显示/设备场景提供图像版本</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/source\">source</a></p>\n<p>为 <code>&lt;picture&gt;</code>, <code>&lt;audio&gt;</code> 或者 <code>&lt;video&gt;</code> 元素指定多个媒体资源</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img\">img</a></p>\n<p>代表文档中的一个图像</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe\">iframe</a></p>\n<p>表示嵌套的浏览上下文，有效地将另一个HTML页面嵌入到当前页面中</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed\">embed</a></p>\n<p>将外部内容嵌入文档中的指定位置。此内容由外部应用程序或其他交互式内容源（如浏览器插件）提供</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object\">object</a></p>\n<p>表示引入一个外部资源，这个资源可能是一张图片，一个嵌入的浏览上下文，亦或是一个插件所使用的资源</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/param\">param</a></p>\n<p>为<code>&lt;object&gt;</code>元素定义参数</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video\">video</a></p>\n<p>用于支持文档内的视频播放</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio\">audio</a></p>\n<p>用于在文档中表示音频内容</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/track\">track</a></p>\n<p>指定计时字幕（或者基于时间的数据）</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/map\">map</a></p>\n<p>与 <code>&lt;area&gt;</code>属性一起使用来定义一个图像映射(一个可点击的链接区域)</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/area\">area</a></p>\n<p>在图片上定义一个热点区域，可以关联一个超链接</p>\n<h3 id=\"表格数据\"><a href=\"#表格数据\" class=\"headerlink\" title=\"表格数据\"></a>表格数据</h3><p>元素</p>\n<p>元素</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table\">table</a></p>\n<p>表示表格数据</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/caption\">caption</a></p>\n<p>展示一个表格的标题</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/colgroup\">colgroup</a></p>\n<p>用来定义表中的一组列表</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/col\">col</a></p>\n<p>定义表格中的列，并用于定义所有公共单元格上的公共语义</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/tbody\">tbody</a></p>\n<p>表示它们包含表的主体</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/thead\">thead</a></p>\n<p>定义了一组定义表格的列头的行</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/tfoot\">tfoot</a></p>\n<p>定义了一组表格中各列的汇总行</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/tr\">tr</a></p>\n<p>定义表格中的行</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td\">td</a></p>\n<p>定义包含数据的表格的单元格</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/th\">th</a></p>\n<p>定义表格内的表头单元格</p>\n<h3 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h3><p>元素</p>\n<p>元素</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form\">form</a></p>\n<p>示了文档中的一个区域，这个区域包含有交互控制元件</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/label\">label</a></p>\n<p>表示用户界面中某个元素的说明</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input\">input</a></p>\n<p>用于为基于Web的表单创建交互式控件，以便接受来自用户的数据</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button\">button</a></p>\n<p>表示一个可点击的按钮</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/select\">select</a></p>\n<p>表示一个控件，提供一个选项菜单</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/datalist\">datalist</a></p>\n<p>包含了一组<code>&lt;option&gt;</code>元素，这些元素表示其它表单控件可选值</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/optgroup\">optgroup</a></p>\n<p>创建包含在一个 <code>&lt;select&gt;</code>元素中的一组选项</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/option\">option</a></p>\n<p>用于定义在<code>&lt;select&gt;</code>, <code>&lt;optgroup&gt;</code> 或<code>&lt;datalist&gt;</code> 元素中包含的项</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea\">textarea</a></p>\n<p>表示一个多行纯文本编辑控件</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/output\">output</a></p>\n<p>表示计算或用户操作的结果</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/progress\">progress</a></p>\n<p>用来显示一项任务的完成进度</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meter\">meter</a></p>\n<p>用来显示已知范围的标量值或者分数值</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/fieldset\">fieldset</a></p>\n<p>用来对表单中的控制元素进行分组</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/legend\">legend</a></p>\n<p>用于表示它的父元素<code>&lt;fieldset&gt;</code>的内容的标题</p>\n<h3 id=\"交互元素\"><a href=\"#交互元素\" class=\"headerlink\" title=\"交互元素\"></a>交互元素</h3><p>元素</p>\n<p>元素</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/details\">details</a></p>\n<p>可创建一个挂件，仅在被切换成展开状态时，它才会显示内含的信息</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/summary\">summary</a></p>\n<p>用作 一个<code>&lt;details&gt;</code>元素的一个内容的摘要，标题或图例</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/dialog\">dialog</a></p>\n<p>表示一个对话框或其他交互式组件</p>\n<h3 id=\"脚本元素\"><a href=\"#脚本元素\" class=\"headerlink\" title=\"脚本元素\"></a>脚本元素</h3><p>元素</p>\n<p>元素</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script\">script</a></p>\n<p>用于嵌入或引用可执行脚本</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/noscript\">noscript</a></p>\n<p>定义脚本未被执行时的替代内容</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/template\">template</a></p>\n<p>用于保存客户端内容机制，该内容在加载页面时不会呈现</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas\">canvas</a></p>\n<p>用来通过脚本（通常是JavaScript）绘制图形</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/slot\">slot</a></p>\n<p>是 Web Components 技术套件的一部分，是Web组件内的一个占位符</p>\n<h2 id=\"基本布局\"><a href=\"#基本布局\" class=\"headerlink\" title=\"基本布局\"></a>基本布局</h2><html>\n<head>\n    <title>示例页面</title>\n</head>\n<body>\n    <div>\n        <header>\n            <h1>我的网站</h1>\n            <nav> <a href=\"\">首页</a> <a href=\"\">文章</a> <a href=\"\">留言</a> </nav>\n            <aside> <img src=\"https://via.placeholder.com/30.png/09f/fff\" alt=\"用户头像\"> </aside>\n        </header>\n        <div>\n            <main>\n                <article>\n                    <section>\n                        <h2>文章标题11111</h2>\n                        <p>巴拉巴拉巴拉巴拉巴拉巴拉巴拉</p>\n                    </section>\n                    <section>\n                        <h2>文章标题2222</h2>\n                        <p>巴拉巴拉巴拉巴拉巴拉巴拉巴拉</p>\n                    </section>\n                    <section>\n                        <h2>文章标题3333</h2>\n                        <p>巴拉巴拉巴拉巴拉巴拉巴拉巴拉</p>\n                    </section>\n                </article>\n                <ul> <a href=\"\" title=\"第1页\">1</a> <a href=\"\" title=\"第2页\">2</a> <a href=\"\" title=\"第3页\">3</a> </ul>\n            </main>\n            <aside>\n                <section>\n                    <h2>作者介绍</h2>\n                    <p>巴拉巴拉巴拉巴拉巴拉巴拉巴拉</p>\n                </section>\n                <nav> <a href=\"\">HTML</a> <a href=\"\">JS</a> <a href=\"\">CSS</a> </nav>\n            </aside>\n        </div>\n    </div>\n    <footer> <address> xxxx@xxx.com <br /> <a href=\"\">https://www.w3cbest.com</a> </address> </footer>\n</body>\n</html>\n\n<p><a href=\"http://gafish.github.io/demo/basicLayout.html\">查看示例</a></p>\n<h2 id=\"header-、footer-不止表示页头页尾\"><a href=\"#header-、footer-不止表示页头页尾\" class=\"headerlink\" title=\"header 、footer 不止表示页头页尾\"></a>header 、footer 不止表示页头页尾</h2><p>通常的用法都是把一个页面的页头用header，页尾用footer来表示，但这并不是它们的唯一用法，根据元素的定义，它们表示的是章节或区块的头和尾，严格来说一个<code>&lt;article&gt;</code> 元素的头部需要用 header 来表示，如：</p>\n<article>\n    <header>\n        <h2>我们是相亲相爱的一家人</h2>\n    </header>\n    <p>.....</p>\n</article>\n\n<p>但以上这种 header 中只有一个 h2 的场景中 header 是可以忽略的。 MacOs VoiceOver 读屏软件对 div 中的 header 会说“横幅”，而对 article 、section 中的 header 会忽略，直接读内部的内容。<a href=\"http://gafish.github.io/demo/headerFooter.html\">查看示例</a></p>\n<h2 id=\"section-、-figure-的用法区别\"><a href=\"#section-、-figure-的用法区别\" class=\"headerlink\" title=\"section 、 figure 的用法区别\"></a>section 、 figure 的用法区别</h2><p>section 和 figure 有相似的地方，都可以表示一个区域，结构上也相似，都可以有标题和内容，但两个元素的用法是完全不一样的。</p>\n<ul>\n<li>  section 的内容跟上下文结构存在关联关系，figure 的内容是独立存在的一部分，把 figure 移除不影响主体内容的表达；</li>\n<li>  section 中存在标题只能在开始的位置，figure 中的标题可以在开头也可以在结尾；</li>\n</ul>\n<p>MacOs VoiceOver 读屏软件会把 section 的标题说成“标题”，但对 figure 的标题会说成“文本”。<a href=\"http://gafish.github.io/demo/sectionFigure.html\">查看示例</a></p>\n<h2 id=\"article-、-section-、-div-的用法区别\"><a href=\"#article-、-section-、-div-的用法区别\" class=\"headerlink\" title=\"article 、 section 、 div 的用法区别\"></a>article 、 section 、 div 的用法区别</h2><ul>\n<li>  如果元素内容可以分为几个部分的话，应该使用 <code>&lt;article&gt;</code> 而不是 <code>&lt;section&gt;</code>。</li>\n<li>  如果内容中的几个部分是互相独立的，应该使用 <code>&lt;article&gt;</code> 嵌套，几个部分的内容之间是关联的应该使用 <code>&lt;section&gt;</code>。</li>\n<li>  不要把 <code>&lt;section&gt;</code> 元素作为一个普通的容器来使用，这是本应该是<code>&lt;div&gt;</code>的用法（特别是当片段仅仅是为了美化样式的时候）。</li>\n</ul>\n<p>MacOs VoiceOver 读屏软件对3个元素的朗读方式没有区别，都是直接读取内部的内容。<a href=\"http://gafish.github.io/demo/articleSectionDiv.html\">查看示例</a></p>\n<h2 id=\"不是所有的导航链接都需要-nav\"><a href=\"#不是所有的导航链接都需要-nav\" class=\"headerlink\" title=\"不是所有的导航链接都需要 nav\"></a>不是所有的导航链接都需要 nav</h2><p>只用来将一些热门的链接放入 <code>&lt;nav&gt;</code> 导航栏，建议这些链接应该是跟当前页面或站点有较强的关联性。例如 <code>&lt;footer&gt;</code> 元素就常用来在页面底部包含一个不常用到，没必要加入 <code>&lt;nav&gt;</code> 的链接列表。 MacOs VoiceOver 读屏软件遇到 nav 时会先说“导航“，下一步读取内部的内容，最后会说”导航的结尾“。<a href=\"http://gafish.github.io/demo/nav.html\">查看示例</a></p>\n<h2 id=\"address-的内容不只是地址\"><a href=\"#address-的内容不只是地址\" class=\"headerlink\" title=\"address 的内容不只是地址\"></a>address 的内容不只是地址</h2><p>HTML <code>&lt;address&gt;</code> 元素 表示其中的内容提供了某个人或某个组织的联系信息，包括真实地址、URL、电子邮箱、电话号码、社交媒体账号、地理坐标等等，通过它会被放到 footer 里，但这并不是唯一的用法，在页头 header 中，article 或其它区块中需要显示联系信息的地方都可以使用 address。 MacOs VoiceOver 读屏软件遇到 address 只是当作普通文本朗读。<a href=\"http://gafish.github.io/demo/address.html\">查看示例</a></p>\n<h2 id=\"em-、-strong-、-b-、-i-、-mark-的用法区别\"><a href=\"#em-、-strong-、-b-、-i-、-mark-的用法区别\" class=\"headerlink\" title=\"em 、 strong 、 b 、 i 、 mark 的用法区别\"></a>em 、 strong 、 b 、 i 、 mark 的用法区别</h2><p>这几个元素表示的都是对文本内容的强调，但强调的含义是不一样的</p>\n<ul>\n<li>  em 强调的是语句的重心，如“我<code>&lt;em&gt;</code>今天<code>&lt;/em&gt;</code>吃薯条了”、“我今天吃<code>&lt;em&gt;</code>薯条<code>&lt;/em&gt;</code>了”；</li>\n<li>  strong 强调的是一句话中重要的一定要看的部分，如”每天早上9点打卡，<code>&lt;strong</code>迟到者罚款1000元<code>&lt;/strong&gt;</code>“；</li>\n<li>  b 强调的是视觉上需要吸引用户来看的内容，类似广告语，对用户来说并不一定很重要；</li>\n<li>  i 强调的是一段文本中，某些部分需要跟周边的文本做一些视觉上区别，但不一定是吸引人的；</li>\n<li>  mark 强调的是上下文的关联性，如搜索关键字；</li>\n</ul>\n<p>MacOs VoiceOver 读屏软件遇到这5个元素时只是当作普通文本朗读。<a href=\"http://gafish.github.io/demo/emStrongBIMark.html\">查看示例</a></p>\n<h2 id=\"small-、-s-、-u-还能用吗\"><a href=\"#small-、-s-、-u-还能用吗\" class=\"headerlink\" title=\"small 、 s 、 u 还能用吗\"></a>small 、 s 、 u 还能用吗</h2><p>这三个元素在 HTML5 之前，都是为了表示明显的排版视觉效果，HTML5 中保留下来并添加了新的语义</p>\n<ul>\n<li>  small 用来描述对内容的注释，如版权和法律文本等；</li>\n<li>  s 用来表示不再相关或不再准确的事，如之前对某句话的解释，很多年之后已经不适用，但要保留在内容中的时候；</li>\n<li>  u 用来标记中文文本中的专有名称，或将文本标记为拼写错误；</li>\n</ul>\n<p>建议在除了上面提到的几个特殊用途之外，不再使用这三个元素； MacOs VoiceOver 读屏软件遇到这3个元素时只是当作普通文本朗读。<a href=\"http://gafish.github.io/demo/smallSU.html\">查看示例</a></p>\n<h2 id=\"blockquote-、-q-、-cite-都表示引用，如何区分\"><a href=\"#blockquote-、-q-、-cite-都表示引用，如何区分\" class=\"headerlink\" title=\"blockquote 、 q 、 cite 都表示引用，如何区分\"></a>blockquote 、 q 、 cite 都表示引用，如何区分</h2><ul>\n<li>  blockquote 引用的是长文本；</li>\n<li>  q 引用的是短文本；</li>\n<li>  cite 引用的是一个作品的名称或链接；</li>\n</ul>\n<p>MacOs VoiceOver 读屏软件遇到这3个元素时只是当作普通文本朗读。<a href=\"http://gafish.github.io/demo/blockquoteQCite.html\">查看示例</a></p>\n<h2 id=\"什么时候使用-div\"><a href=\"#什么时候使用-div\" class=\"headerlink\" title=\"什么时候使用 div\"></a>什么时候使用 div</h2><p>根据元素的定义，只有在所有 html5 标签都不适用于你想表达的语义时，这时候才使用终极大法 div，从这个角度来说，目前对 div 元素的滥用其实是程序员偷懒的一种表现，反正有 div 兜底，也就懒得去思考那些语义元素的区别。 在追求开发效率和做不完的需求面前，使用 div 兜底也是很多人无奈的选择，我觉得这个是可以理解，某种程度上也可以接受的，但进一步去想一想，你的产品面向的用户也有可能会是存在各种行为障碍的视障、残障人群，他们无法像正常人那样使用你开发的功能，而需要借助类似于屏幕阅读器这样的辅助工具，这时候才是真正考验你的产品是否合格的时候。 我们做语义化开发，很大程度上就是在帮助更多人的人正常的使用我们的产品，同时也会让你离专业的程序员更进一步。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li>  <a href=\"https://www.w3.org/TR/html53/\">https://www.w3.org/TR/html53/</a></li>\n<li>  <a href=\"https://www.w3cschool.cn/html5/\">https://www.w3cschool.cn/html5/</a></li>\n<li>  <a href=\"https://juejin.im/post/5cb1a7af5188251b0c653736\">https://juejin.im/post/5cb1a7af5188251b0c653736</a></li>\n</ul>\n<p>来源：<a href=\"http://gafish.github.io/\">http://gafish.github.io</a></p>\n","categories":["HTML/CSS"],"tags":["footer","html5","html教程","aside","datalist","details","dialog","header","option"]},{"title":"JavaScript Prototype(原型) 初学者指南","url":"/2018/10/05/javascript-prototype%E5%8E%9F%E5%9E%8B-%E5%88%9D%E5%AD%A6%E8%80%85%E6%8C%87%E5%8D%97/","content":"<p>如果不处理对象，您就无法在 JavaScript 方面取得很大进展。它们几乎是 JavaScript 编程语言的所有方面的基础。事实上，学习如何创建对象可能是你刚开始学习的第一件事。话虽如此，为了最有效地学习 JavaScript 中的原型，我们将从基础开始。 首先，对象是键/值对。创建对象的最常用方法是使用花括号{}，并使用点表示法向对象添加属性和方法。</p>\n<p>let animal = {}<br>animal.name = ‘Leo’<br>animal.energy = 10</p>\n<p>animal.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>\n<p>animal.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>\n<p>animal.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>\n<p>这个很简单。现在，我们在应用程序中我们需要创建多个动物。很自然地，下一步就是将逻辑封装到一个函数中，以便我们在需要创建新动物时调用这个函数。我们将调用这个模式 <code>Functional Instantiation</code>(函数实例化)，并将函数本身称为 <code>constructor function</code>(构造函数) ，因为它负责“构造”一个新对象。</p>\n<h2 id=\"Functional-Instantiation-函数实例化\"><a href=\"#Functional-Instantiation-函数实例化\" class=\"headerlink\" title=\"Functional Instantiation (函数实例化)\"></a>Functional Instantiation (函数实例化)</h2><p>function Animal(name, energy) {<br>    let animal = {}<br>    animal.name = name<br>    animal.energy = energy</p>\n<pre><code>animal.eat = function(amount) &#123;\n    console.log(\\`$&#123;this.name&#125; is eating.\\`)\n    this.energy += amount\n&#125;\n\nanimal.sleep = function(length) &#123;\n    console.log(\\`$&#123;this.name&#125; is sleeping.\\`)\n    this.energy += length\n&#125;\n\nanimal.play = function(length) &#123;\n    console.log(\\`$&#123;this.name&#125; is playing.\\`)\n    this.energy -= length\n&#125;\n\nreturn animal\n</code></pre>\n<p>}</p>\n<p>const leo = Animal(‘Leo’, 7)<br>const snoop = Animal(‘Snoop’, 10)</p>\n<p>现在，每当我们想要创建一种新动物（或者更广泛地说是一种新的“实例”）时，我们所要做的就是调用我们的 <code>Animal</code> 函数，将动物的 <code>name</code> 和<code>energy</code> 传递给这个函数。这非常有效，而且非常简单。但是，你有发现这种模式的不足之处吗？我们要尝试解决的最大的问题与三种方法有关 – <code>eat</code>，<code>sleep</code> 和 <code>play</code>。这些方法中的每一种都不仅是动态的，而且它们也是完全通用的。这意味着没有理由重新创建这些方法，正如我们在创建新动物时所做的那样。我们只是在浪费内存，让每个动物物体都比它需要的更大。你能想到一个解决方案吗？ 如果我们每次创建一个新动物时不需要重新创建这些方法，而是将它们移动到它们自己的对象上，那么我们就可以让每个动物引用那个对象了?我们可以把这种模式称为 <code>Functional Instantiation with Shared Methods</code>(共享方法的函数实例化) 。描述起来有点啰嗦。</p>\n<h3 id=\"Functional-Instantiation-with-Shared-Methods-共享方法的函数实例化\"><a href=\"#Functional-Instantiation-with-Shared-Methods-共享方法的函数实例化\" class=\"headerlink\" title=\"Functional Instantiation with Shared Methods (共享方法的函数实例化)\"></a>Functional Instantiation with Shared Methods (共享方法的函数实例化)</h3><p>const animalMethods = {<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`)<br>        this.energy += amount<br>    },<br>    sleep(length) {<br>        console.log(`${this.name} is sleeping.`)<br>        this.energy += length<br>    },<br>    play(length) {<br>        console.log(`${this.name} is playing.`)<br>        this.energy -= length<br>    }<br>}</p>\n<p>function Animal(name, energy) {<br>    let animal = {}<br>    animal.name = name<br>    animal.energy = energy<br>    animal.eat = animalMethods.eat<br>    animal.sleep = animalMethods.sleep<br>    animal.play = animalMethods.play</p>\n<pre><code>return animal\n</code></pre>\n<p>}</p>\n<p>const leo = Animal(‘Leo’, 7)<br>const snoop = Animal(‘Snoop’, 10)</p>\n<p>通过将共享方法移动到它们自己的对象并在 <code>Animal</code> 函数中引用该对象，我们现在已经解决了内存浪费和动物对象过大的问题。</p>\n<h2 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create\"></a>Object.create</h2><p>让我们使用 <code>Object.create</code> 再次改进我们的例子。 简而言之，<code>Object.create</code> 允许您创建一个对象，该对象将在查找失败时委托给另一个对象。 换句话说，<code>Object.create</code> 允许您创建一个对象，只要该对象上的属性查找失败，它就可以查询另一个对象，以查看另一个对象中是否具有该属性。 说清楚需要很多文字， 我们来看一些代码。</p>\n<p>const parent = {<br>    name: ‘Stacey’,<br>    age: 35,<br>    heritage: ‘Irish’<br>}</p>\n<p>const child = Object.create(parent),<br>child.name = ‘Ryan’,<br>child.age = 7;</p>\n<p>console.log(child.name); // Ryan<br>console.log(child.age); // 7<br>console.log(child.heritage); // Irish</p>\n<p>在上面的示例中，因为 <code>child</code> 是通过 <code>Object.create(parent)</code> 创建的，所以每当在 <code>child</code> 中查找属性失败时，JavaScript 就会将该查找委托给 <code>parent</code> 对象。这意味着即使 <code>child</code> 没有 <code>heritage</code> 属性，当你查找 <code>child.heritage</code> 时你会得到 <code>parent</code> 的<code>heritage</code> 属性，即 <code>Irish</code>。 现在，通过使用 <code>Object.create</code> ，我们该如何使用它来简化之前的 <code>Animal</code> 代码呢？好吧，我们可以使用 <code>Object.create</code> 委托给<code>animalMethods</code> 对象，而不是像我们之前一样逐个将所有共享方法添加到 <code>Animal</code> 中。 为了听起来很智能，让我们称之为 <code>Functional Instantiation with Shared Methods and Object.create</code>(使用共享方法和Object.create进行函数实例化)。</p>\n<h2 id=\"Functional-Instantiation-with-Shared-Methods-and-Object-create-使用共享方法和Object-create进行函数实例化\"><a href=\"#Functional-Instantiation-with-Shared-Methods-and-Object-create-使用共享方法和Object-create进行函数实例化\" class=\"headerlink\" title=\"Functional Instantiation with Shared Methods and Object.create (使用共享方法和Object.create进行函数实例化)\"></a>Functional Instantiation with Shared Methods and Object.create (使用共享方法和Object.create进行函数实例化)</h2><p>const animalMethods = {<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`);<br>        this.energy += amount;<br>    },<br>    sleep(length) {<br>        console.log(`${this.name} is sleeping.`);<br>        this.energy += length;<br>    },<br>    play(length) {<br>        console.log(`${this.name} is playing.`);<br>        this.energy -= length;<br>    }<br>}</p>\n<p>function Animal(name, energy) {<br>    let animal = Object.create(animalMethods);<br>    animal.name = name;<br>    animal.energy = energy;</p>\n<pre><code>return animal;\n</code></pre>\n<p>}</p>\n<p>const leo = Animal(‘Leo’, 7);<br>const snoop = Animal(‘Snoop’, 10);</p>\n<p>leo.eat(10);<br>snoop.play(5);</p>\n<p>所以现在当我们调用 <code>leo.eat</code> 时，JavaScript 会在 <code>leo</code> 对象上查找 <code>eat</code> 方法。 这个查找将失败，因为使用了 <code>Object.create</code>，它将委托给 <code>animalMethods</code> 对象，然后在这里将找到 <code>eat</code> 方法。 到现在为止还挺好的。 尽管如此，我们仍然可以做出一些改进。 为了跨实例共享方法，必须管理一个单独的对象（<code>animalMethods</code>）似乎有点“hacky”。 这似乎是您希望在语言本身中实现的常见功能。 事实证明，这就是你看这篇文章的原因 – prototype(原型) 。 那么究竟什么是 JavaScript 的 prototype（原型）呢？ 简单地说，JavaScript 中的每个函数都有一个引用对象的 prototype 属性。 我们来亲自测试一下。</p>\n<p>function doThing () {};<br>console.log(doThing.prototype); // {}</p>\n<p>如果不是创建一个单独的对象（比如我们正在使用的 <code>animalMethods</code> ）来管理我们的方法，也就是我们只是将每个方法放在 <code>Animal</code> 函数的 prototype(原型) 对象上，该怎么办呢？我们所要做的就是不使用 <code>Object.create</code> 委托给 <code>animalMethods</code>，我们可以用使用来委托<code>Animal.prototype</code>。 我们将这种模式称为 <code>Prototypal Instantiation</code>(原型实例化)。</p>\n<h2 id=\"Prototypal-Instantiation-原型实例化\"><a href=\"#Prototypal-Instantiation-原型实例化\" class=\"headerlink\" title=\"Prototypal Instantiation (原型实例化)\"></a>Prototypal Instantiation (原型实例化)</h2><p>function Animal(name, energy) {<br>    let animal = Object.create(Animal.prototype);<br>    animal.name = name;<br>    animal.energy = energy;</p>\n<pre><code>return animal;\n</code></pre>\n<p>}</p>\n<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`);<br>    this.energy += amount;<br>}</p>\n<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`);<br>    this.energy += length;<br>}</p>\n<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`);<br>    this.energy -= length;<br>}</p>\n<p>const leo = Animal(‘Leo’, 7);<br>const snoop = Animal(‘Snoop’, 10);</p>\n<p>leo.eat(10);<br>snoop.play(5);</p>\n<p>这里你可以为自己鼓掌鼓励一下了。 同样，原型只是 JavaScript 中每个函数都具有的属性，并且如上所述，它允许我们在函数的所有实例之间共享方法。 我们所有的功能仍然相同，但现在我们不必为所有方法管理一个单独的对象，我们可以使用另一个内置于 <code>Animal</code> 函数本身的对象<code>Animal.prototype</code>。</p>\n<h2 id=\"更深的，走起！\"><a href=\"#更深的，走起！\" class=\"headerlink\" title=\"更深的，走起！\"></a>更深的，走起！</h2><p>首先，我们需要知道三件事：</p>\n<ol>\n<li> 如何创建构造函数。</li>\n<li> 如何将方法添加到构造函数的原型中。</li>\n<li> 如何使用 <code>Object.create</code> 将失败的查找委托给函数的原型。</li>\n</ol>\n<p>这三个任务似乎是任何编程语言的基础。 JavaScript 是否真的那么糟糕，没有更简单，“内置”的方式来完成同样的事情？ 正如你可能已经猜测的那样，它是通过使用 <code>new</code> 关键字。 我们采用的这种缓慢而有条理的方法的好处是，您现在可以深入了解 JavaScript 中的 <code>new</code> 关键字在幕后的作用。 回顾一下我们的 <code>Animal</code> 构造函数，最重要的两个部分是创建对象并返回它。 如果不使用 <code>Object.create</code>创建对象，我们将无法在查找失败时委托给函数的原型。 如果没有 <code>return</code> 语句，我们将永远不会返回创建的对象。</p>\n<p>function Animal(name, energy) {<br>    let animal = Object.create(Animal.prototype);<br>    animal.name = name;<br>    animal.energy = energy;<br>    return animal;<br>}</p>\n<p><code>new</code> 有一个很酷的地方——当您使用 <code>new</code> 关键字调用函数时，注释掉的这两行代码是隐式(引擎)完成的，创建的对象称为 <code>this</code>。 使用注释来显示在幕后发生的事情并假设使用 <code>new</code> 关键字调用 <code>Animal</code> 构造函数，可以将其重写为这样：</p>\n<p>function Animal(name, energy) {<br>    // const this = Object.create(Animal.prototype)<br>    this.name = name<br>    this.energy = energy<br>    // return this<br>}<br>const leo = new Animal(‘Leo’, 7)<br>const snoop = new Animal(‘Snoop’, 10)</p>\n<p>去掉注释后：</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}<br>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}<br>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}<br>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}<br>const leo = new Animal(‘Leo’, 7)<br>const snoop = new Animal(‘Snoop’, 10)</p>\n<p>同样，这样做以及为我们创建 <code>this</code> 对象的原因是，我们使用 <code>new</code> 关键字调用构造函数。如果在调用函数时不使用 <code>new</code> ，则该对象永远不会创建，也不会隐式返回。我们可以在下面的例子中看到这个问题。</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}<br>const leo = Animal(‘Leo’, 7)<br>console.log(leo) // undefined</p>\n<p>此模式的名称是 <code>Pseudoclassical Instantiation</code>(伪类实例化) 。 如果 JavaScript 不是您的第一种编程语言，您可能会有点不安。</p>\n<blockquote>\n<p>“WTF这个家伙只是重新创造了一个更糟糕的版本” – 你</p>\n</blockquote>\n<p>对于那些不熟悉的人，Class(类) 允许您为对象创建模板。然后，无论何时创建该类的实例，都会获得一个具有模板中定义的属性和方法的对象。 听起来有点熟悉？这基本上就是我们对上面的 <code>Animal</code> 构造函数所做的事情。但是对于 <code>Animal</code> 构造函数，我们只使用常规的旧 JavaScript 函数来重新创建相同的功能，而不是使用 <code>class</code> 关键字。当然，它需要一些额外的工作以及一些关于 JavaScript “引擎” 所处理的事情的相关知识，但结果是一样的。 这是个好消息。 JavaScript 不是一种 “死” 语言。它不断得到改进，并由 <a href=\"https://tylermcginnis.com/videos/ecmascript/\">TC-39委员会</a> 不断的制定标准。这意味着即使 JavaScript 的初始版本不支持类，也不影响后续将它们添加到官方规范中。事实上，这正是TC-39委员会所做的事情。 2015年，发布了 EcmaScript（官方JavaScript规范）6 ，支持 Classes(类) 和 <code>class</code> 关键字。让我们看看上面的 <code>Animal</code> 构造函数如何使用新的 class(类) 语法。</p>\n<p>class Animal {<br>    constructor(name, energy) {<br>        this.name = name<br>        this.energy = energy<br>    }<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`)<br>        this.energy += amount<br>    }<br>    sleep(length) {<br>        console.log(`${this.name} is sleeping.`)<br>        this.energy += length<br>    }<br>    play(length) {<br>        console.log(`${this.name} is playing.`)<br>        this.energy -= length<br>    }<br>}<br>const leo = new Animal(‘Leo’, 7)<br>const snoop = new Animal(‘Snoop’, 10)</p>\n<p>很干净是吧？ 因此，如果这是创建类的新方法，为什么我们前面花了这么多时间来讨论旧的方式呢？ 原因是新的方式（使用 <code>class</code> 关键字）只是经典伪类模式的 “语法糖”。 为了完全理解 ES6 类的便捷语法，首先必须理解经典的伪类模式。 我们已经介绍了 JavaScript 原型的基础知识。 本文的其余部分将致力于加深理解相关知识的主题。 在另一篇文章中，我们将看看如何利用这些基础知识并使用它们来理解 JavaScript 中继承的工作原理。</p>\n<h2 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h2><p>我们在上面深入讨论了如何在类的实例之间共享方法，您应该将这些方法放在类（或函数）原型上。 如果我们查看 <code>Array</code> 类，我们可以看到相同的模式。 从历史上看，您可能已经创建了这样的数组：</p>\n<p>const friends = []</p>\n<p>事实证明，这只是创建一个新的 <code>Array</code> 类实例的语法糖。</p>\n<p>const friendsWithSugar = []<br>const friendsWithoutSugar = new Array()</p>\n<p>您可能从未想过：数组的每个实例是如何具有所有内置方法的（<code>splice</code> , <code>slice</code>, <code>pop</code> 等）？ 正如您现在所知，这是因为这些方法存在于 <code>Array.prototype</code> 上，当您创建一个新的 <code>Array</code> 实例时，您使用 <code>new</code> 关键字在查找失败时将该委托设置为 <code>Array.prototype</code> 。 我们可以通过简单地 <code>console.log(Array.prototype)</code> 来查看所有数组的方法。</p>\n<p>console.log(Array.prototype)<br>/*<br>  concat: ?n concat()<br>  constructor: ?n Array()<br>  copyWithin: ?n copyWithin()<br>  entries: ?n entries()<br>  every: ?n every()<br>  fill: ?n fill()<br>  filter: ?n filter()<br>  find: ?n find()<br>  findIndex: ?n findIndex()<br>  forEach: ?n forEach()<br>  includes: ?n includes()<br>  indexOf: ?n indexOf()<br>  join: ?n join()<br>  keys: ?n keys()<br>  lastIndexOf: ?n lastIndexOf()<br>  length: 0n<br>  map: ?n map()<br>  pop: ?n pop()<br>  push: ?n push()<br>  reduce: ?n reduce()<br>  reduceRight: ?n reduceRight()<br>  reverse: ?n reverse()<br>  shift: ?n shift()<br>  slice: ?n slice()<br>  some: ?n some()<br>  sort: ?n sort()<br>  splice: ?n splice()<br>  toLocaleString: ?n toLocaleString()<br>  toString: ?n toString()<br>  unshift: ?n unshift()<br>  values: ?n values()<br>*/</p>\n<p>Objects(对象) 也是完全相同的逻辑。 所有对象将在查找失败时委托给 <code>Object.prototype</code> ，这就是所有对象都有 <code>toString</code> 和<code>hasOwnProperty</code> 等方法的原因。</p>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><p>到目前为止，我们已经介绍了为什么，以及如何在类的实例之间共享方法。 但是，如果我们有一个对 Class 很重要但不需要又跨实例共享的方法，该怎么办呢？ 例如，如果我们有一个函数，它接收一系列 <code>Animal</code> 实例并决定下一个需要喂食的对象，会怎样? 我们将其称为 <code>nextToEat</code>。</p>\n<p>function nextToEat(animals) {<br>    const sortedByLeastEnergy = animals.sort((a, b) =&gt; {<br>        return a.energy - b.energy<br>    })<br>    return sortedByLeastEnergy[0].name<br>}</p>\n<p>我们不希望在所有实例之间共享它，所以在 <code>Animal.prototype</code> 上使用 <code>nextToEat</code> 是没有意义的。 相反，我们可以将其视为辅助方法。 所以如果 <code>nextToEat</code> 不应该存在于 <code>Animal.prototype</code> 中，我们应该把它放在哪里呢？ 那么显而易见的答案是我们可以将 <code>nextToEat</code> 放在与 <code>Animal</code> 类相同的作用域中，然后像我们平常那样，在需要时引用它。</p>\n<p>class Animal {<br>    constructor(name, energy) {<br>        this.name = name<br>        this.energy = energy<br>    }<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`)<br>        this.energy += amount<br>    }<br>    sleep(length) {<br>        console.log(`${this.name} is sleeping.`)<br>        this.energy += length<br>    }<br>    play(length) {<br>        console.log(`${this.name} is playing.`)<br>        this.energy -= length<br>    }<br>}<br>function nextToEat(animals) {<br>    const sortedByLeastEnergy = animals.sort((a, b) =&gt; {<br>        return a.energy - b.energy<br>    })</p>\n<pre><code>return sortedByLeastEnergy\\[0\\].name\n</code></pre>\n<p>}<br>const leo = new Animal(‘Leo’, 7)<br>const snoop = new Animal(‘Snoop’, 10)<br>console.log(nextToEat([leo, snoop])) // Leo</p>\n<p>现在这可行，但有更好的方法。 只要有一个特定于类本身的方法，但不需要在该类的实例之间共享，就可以将其添加为类的 <code>static</code>(静态) 属性。</p>\n<p>class Animal {<br>    constructor(name, energy) {<br>        this.name = name<br>        this.energy = energy<br>    }<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`)<br>        this.energy += amount<br>    }<br>    sleep(length) {<br>        console.log(`${this.name} is sleeping.`)<br>        this.energy += length<br>    }<br>    play(length) {<br>        console.log(`${this.name} is playing.`)<br>        this.energy -= length<br>    }<br>    static nextToEat(animals) {<br>        const sortedByLeastEnergy = animals.sort((a, b) =&gt; {<br>            return a.energy - b.energy<br>        })</p>\n<pre><code>    return sortedByLeastEnergy\\[0\\].name\n&#125;\n</code></pre>\n<p>}</p>\n<p>现在，因为我们在类上添加了 <code>nextToEat</code> 作为 <code>static</code>(静态) 属性，所以它存在于 <code>Animal</code> 类本身（而不是它的原型）中，并且可以使用 <code>Animal.nextToEat</code> 进行访问。</p>\n<p>const leo = new Animal(‘Leo’, 7) const snoop = new Animal(‘Snoop’, 10) console.log(Animal.nextToEat([leo, snoop])) // Leo</p>\n<p>因为我们在这篇文章中都遵循了类似的模式，让我们来看看如何使用 ES5 完成同样的事情。 在上面的例子中，我们看到了如何使用 <code>static</code> 关键字将方法直接放在类本身上。 使用ES5，同样的模式就像手动将方法添加到函数对象一样简单。</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>\n<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>\n<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>\n<p>Animal.nextToEat = function(nextToEat) {<br>    const sortedByLeastEnergy = animals.sort((a, b) =&gt; {<br>        return a.energy - b.energy<br>    })</p>\n<pre><code>return sortedByLeastEnergy\\[0\\].name\n</code></pre>\n<p>}</p>\n<p>const leo = new Animal(‘Leo’, 7)<br>const snoop = new Animal(‘Snoop’, 10)</p>\n<p>console.log(Animal.nextToEat([leo, snoop])) // Leo</p>\n<h2 id=\"获取对象的原型\"><a href=\"#获取对象的原型\" class=\"headerlink\" title=\"获取对象的原型\"></a>获取对象的原型</h2><p>无论您使用哪种模式创建对象，都可以使用 <code>Object.getPrototypeOf</code> 方法完成获取该对象的原型。</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>\n<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>\n<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>\n<p>const leo = new Animal(‘Leo’, 7)<br>const prototype = Object.getPrototypeOf(leo)</p>\n<p>console.log(prototype)<br>// {constructor: ?, eat: ?, sleep: ?, play: ?}</p>\n<p>prototype === Animal.prototype // true</p>\n<p>上面的代码有两个要点。 首先，你会注意到 <code>proto</code> 是一个对象，有4种方法，<code>constructor</code>，<code>eat</code>，<code>sleep</code>，和<code>play</code>。那讲得通。我们将实例传递给<code>getPrototypeOf</code>，<code>leo</code> 获取了实例的原型，这里是所有的方法。这提示我们，关于原型的另外一件事我们还没有讨论过。默认情况下，原型对象将具有 <code>constructor</code> 属性，该属性指向原始函数或创建实例的类。这也意味着 JavaScript 默认在原型上放置 <code>constructor</code> 属性，所以任何实例都可以通过 <code>instance.constructor</code> 访问它们的构造函数。 上面的第二个要点是 <code>Object.getPrototypeOf(leo) === Animal.prototype</code> 。这也是有道理的。 <code>Animal</code> 构造函数有一个 prototype(原型) 属性，我们可以在所有实例之间共享方法，<code>getPrototypeOf</code> 允许我们查看实例本身的原型。</p>\n<p>function Animal(name, energy) {<br>this.name = name<br>this.energy = energy<br>}</p>\n<p>const leo = new Animal(‘Leo’, 7)<br>console.log(leo.constructor) // Logs the constructor function</p>\n<p>为了配合我们之前使用 <code>Object.create</code> 所讨论的内容，其工作原因是因为任何 <code>Animal</code> 实例都会在查找失败时委托给 <code>Animal.prototype</code>。 因此，当您尝试访问 <code>leo.prototype</code> 时， <code>leo</code> 没有 <code>prototype</code> 属性，因此它会将该查找委托给<code>Animal.prototype</code>，它确实具有 <code>constructor</code> 属性。 如果这段没有看懂，请回过头来阅读上面的 <code>Object.create</code> 。 您可能以前看到过使用 <code>__proto__</code> 获取实例的原型。 这是过去的遗物。 现在，如上所述使用 <code>Object.getPrototypeOf(instance)</code> 获取实例的原型。</p>\n<h2 id=\"确定属性是否存在于原型上\"><a href=\"#确定属性是否存在于原型上\" class=\"headerlink\" title=\"确定属性是否存在于原型上\"></a>确定属性是否存在于原型上</h2><p>在某些情况下，您需要知道属性是否存在于实例本身上，还是存在于对象委托的原型上。 我们可以通过循环我们创建的 <code>leo</code> 对象来知道这一点。假设目标是循环 <code>leo</code> 并记录其所有键和值。使用 <code>for in</code> 循环，可能看起来像这样。</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>\n<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>\n<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>\n<p>const leo = new Animal(‘Leo’, 7)</p>\n<p>for (let key in leo) {<br>    console.log(`Key: ${key}. Value: ${leo[key]}`)<br>}</p>\n<p>你期望看到什么？最有可能的是，它是这样的 –</p>\n<p>Key: name. Value: Leo<br>Key: energy. Value: 7</p>\n<p>但是，如果你运行代码，你看到的是这样的 –</p>\n<p>Key: name.Value: Leo<br>Key: energy.Value: 7<br>Key: eat.Value: function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}<br>Key: sleep.Value: function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}<br>Key: play.Value: function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>\n<p>这是为什么？ <code>for in</code> 循环将循环遍历对象本身以及它所委托的原型的所有 <strong>可枚举属性</strong> 。 因为默认情况下，您添加到函数原型的任何属性都是可枚举的，我们不仅会看到<code>name</code> 和 <code>energy</code> ，还会看到原型上的所有方法 – <code>eat</code>，<code>sleep</code> 和 <code>play</code> 。 要解决这个问题，我们需要指定所有原型方法都是不可枚举的，或者如果属性在 <code>leo</code> 对象本身上而不是 <code>leo</code> 查找失败时委托给的原型上。 <code>hasOwnProperty</code> 可以帮助我们实现这个需求。 <code>hasOwnProperty</code> 是每个对象上的一个属性，它返回一个布尔值，指示对象是否具有指定的属性作为其自身的属性，而不是对象委托给的原型。 这正是我们所需要的。 现在有了这些新知识，我们可以修改我们的代码，以便利用 <code>for in</code> 循环中的 <code>hasOwnProperty</code> 。</p>\n<p>…</p>\n<p>const leo = new Animal(‘Leo’, 7)</p>\n<p>for (let key in leo) {<br>    if (leo.hasOwnProperty(key)) {<br>        console.log(`Key: ${key}. Value: ${leo[key]}`)<br>    }<br>}</p>\n<p>而现在我们看到的只是 <code>leo</code> 对象本身的属性，而不是 <code>leo</code> 原型中的方法。</p>\n<p>Key: name. Value: Leo<br>Key: energy. Value: 7</p>\n<p>如果你仍然对 <code>hasOwnProperty</code> 感到困惑，这里有一些代码可以帮你消除困惑。</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>\n<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>\n<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>\n<p>const leo = new Animal(‘Leo’, 7)</p>\n<p>leo.hasOwnProperty(‘name’) // true<br>leo.hasOwnProperty(‘energy’) // true<br>leo.hasOwnProperty(‘eat’) // false<br>leo.hasOwnProperty(‘sleep’) // false<br>leo.hasOwnProperty(‘play’) // false</p>\n<h2 id=\"检查对象是否是类的实例\"><a href=\"#检查对象是否是类的实例\" class=\"headerlink\" title=\"检查对象是否是类的实例\"></a>检查对象是否是类的实例</h2><p>有时您想知道对象是否是指定类的实例。 为此，您可以使用 <code>instanceof</code> 运算符。 用例非常简单，但如果您以前从未见过它，实际的语法有点奇怪。 它的工作原理如下</p>\n<p>object instanceof Class</p>\n<p>如果 <code>object</code> 是 <code>Class</code> 的实例，则上面的语句将返回 <code>true</code> ，否则返回 <code>false</code> 。回到我们的 <code>Animal</code> 示例，我们会有类似的东西。</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>function User() {}</p>\n<p>const leo = new Animal(‘Leo’, 7)</p>\n<p>leo instanceof Animal // true<br>leo instanceof User // false</p>\n<p><code>instanceof</code> 的工作方式是检查对象原型链中是否存在 <code>constructor.prototype</code> 。 在上面的例子中，<code>leo instanceof Animal</code> 为 <code>true</code> ，因为<code>Object.getPrototypeOf(leo) === Animal.prototype</code>。 另外，<code>leo instanceof User</code> 为 <code>false</code> ，因为 <code>Object.getPrototypeOf(leo) !== User.prototype</code>。</p>\n<h2 id=\"创建新的不可知构造函数\"><a href=\"#创建新的不可知构造函数\" class=\"headerlink\" title=\"创建新的不可知构造函数\"></a>创建新的不可知构造函数</h2><p>你能发现下面代码中的错误吗？</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>const leo = Animal(‘Leo’, 7)</p>\n<p>即使是经验丰富的 JavaScript 开发人员有时也会因为上面的例子而被绊倒。 因为我们正在使用之前学过的 <code>pseudoclassical pattern</code>(经典伪类模式)，所以当调用 <code>Animal</code> 构造函数时，我们需要确保使用 <code>new</code> 关键字调用它。 如果我们不这样做，则不会创建 <code>this</code> 关键字，也不会隐式返回。 作为复习，注释掉的行是在函数上使用 <code>new</code> 关键字时幕后所做的事情。</p>\n<p>function Animal(name, energy) {<br>    // const this = Object.create(Animal.prototype)</p>\n<pre><code>this.name = name\nthis.energy = energy\n\n// return this\n</code></pre>\n<p>}</p>\n<p>这似乎是一个非常重要的细节，让其他开发人员记住。 假设我们正在与其他开发人员合作，有没有办法确保我们的 <code>Animal</code> 构造函数始终使用 <code>new</code> 关键字调用呢？ 事实证明，它是通过使用我们之前学到的 <code>instanceof</code> 运算符来实现的。 如果使用 <code>new</code> 关键字调用构造函数，那么构造函数体的内部将是构造函数本身的实例。 那是很多文字才能说清楚的。 这是一些代码。</p>\n<p>function Animal(name, energy) {<br>    if (this instanceof Animal === false) {<br>        console.warn(‘Forgot to call Animal with the new keyword’)<br>    }<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>现在，如果我们使用 <code>new</code> 关键字重新调用函数，而不是只向函数的使用者打印警告，会发生什么呢？</p>\n<p>function Animal(name, energy) {<br>    if (this instanceof Animal === false) {<br>        return new Animal(name, energy)<br>    }<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>现在无论是否使用 <code>new</code> 关键字调用 <code>Animal</code>，它都可以正常工作。</p>\n<h2 id=\"重新创建-Object-create\"><a href=\"#重新创建-Object-create\" class=\"headerlink\" title=\"重新创建 Object.create\"></a>重新创建 Object.create</h2><p>在这篇文章中，我们非常依赖于 <code>Object.create</code> 来创建委托给构造函数原型的对象。 此时，您应该知道如何在代码中使用 <code>Object.create</code> ，但您可能没有想到的一件事是<code>Object.create</code> 实际上是如何工作的。 为了让您真正了解 <code>Object.create</code> 的工作原理，我们将重新创建它。 首先，我们对 <code>Object.create</code> 的工作原理了解多少？</p>\n<ol>\n<li> 它接受一个对象作为参数。</li>\n<li> 它创建一个对象，该对象在查找失败时委托给参数对象。</li>\n<li> 它返回新创建的对象。</li>\n</ol>\n<p>让我们从第1点开始吧。</p>\n<p>Object.create = function (objToDelegateTo) {}</p>\n<p>很简单。 现在第2点 – 我们需要创建一个对象，该对象将在查找失败时委托给参数对象。 这个有点棘手。 为此，我们将使用我们对 <code>new</code> 关键字和原型如何在 JavaScript 中工作的知识。首先，在 <code>Object.create</code> 实现的主体中，我们将创建一个空函数。 然后，我们将该空函数的原型设置为参数对象。然后，为了创建一个新对象，我们将使用 <code>new</code> 关键字调用空函数。如果我们返回新创建的对象，也会完成第3点。</p>\n<p>Object.create = function(objToDelegateTo) {<br>    function Fn() {}<br>    Fn.prototype = objToDelegateTo<br>    return new Fn()<br>}</p>\n<p>有点野蛮是吧？让我们来看看吧。 当我们在上面的代码中创建一个新函数 <code>Fn</code> 时，它带有一个 <code>prototype</code> 属性。 当我们使用 <code>new</code> 关键字调用它时，我们知道我们将得到的是一个对象，该对象将在查找失败时委托给函数的原型。 如果我们覆盖函数的原型，那么我们可以决定在查找失败时委托给哪个对象。 所以在我们上面的例子中，我们用调用 <code>Object.create</code> 时传入的对象覆盖 <code>Fn</code>的原型，我们称之为 <code>objToDelegateTo</code>。 请注意，我们只支持 <code>Object.create</code> 的单个参数。官方实现还支持第二个可选参数，该参数允许您向创建的对象添加更多属性。</p>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>箭头函数没有自己的 <code>this</code> 关键字。因此，箭头函数不能用于构造函数，如果您尝试使用 <code>new</code> 关键字调用箭头函数，它将抛出错误。</p>\n<p>const Animal = () =&gt; {}<br>const leo = new Animal() // Error: Animal is not a constructor</p>\n<p>另外，因为我们在上面证明了 <code>pseudoclassical pattern</code>(经典伪类模式) 不能与箭头函数一起使用，所以箭头函数也没有 <code>prototype</code>(原型) 属性。</p>\n<p>const Animal = () =&gt; {}<br>console.log(Animal.prototype) // undefined</p>\n<p>  原文地址：<a href=\"https://tylermcginnis.com/beginners-guide-to-javascript-prototype/\">https://tylermcginnis.com/</a></p>\n","categories":["JavaScript"],"tags":["hasOwnProperty","class","constructor","getPrototypeOf","instanceof","Object.create","prototype","原型","可枚举属性","构造函数"]},{"title":"JavaScript继承和原型链","url":"/2018/11/28/javascript%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","content":"<blockquote>\n<p>本文为 <a href=\"http://www.w3cbest.com/529.html\">JavaScript Class 类的私有和公共属性</a> 续篇</p>\n</blockquote>\n<p>之前我们学习了如何在 ES5 和 ES6 中创建 <code>Animal</code> 类。我们还学习了如何使用 JavaScrip t的原型在这些类之间共享方法。查看我们在之前文章中看到的代码。</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>\n<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>\n<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>\n<p>const leo = new Animal(‘Leo’, 7)</p>\n<p>class Animal {<br>constructor(name, energy) {<br>this.name = name<br>this.energy = energy<br>}<br>eat(amount) {<br>console.log(`${this.name} is eating.`)<br>this.energy += amount<br>}<br>sleep() {<br>console.log(`${this.name} is sleeping.`)<br>this.energy += length<br>}<br>play() {<br>console.log(`${this.name} is playing.`)<br>this.energy -= length<br>}<br>}</p>\n<p>const leo = new Animal(‘Leo’, 7)</p>\n<p>现在我们想为特定动物建一个别 class(类) 。 例如，如果我们想要开始制作一堆狗实例，该怎么办？ 这些狗有哪些属性和方法？ 嗯，类似于我们的 <code>Animal</code> 类，我们可以给每只狗一个 <code>name</code> ，一个 <code>energy</code> 等级，以及 <code>eat</code> ，<code>sleep</code> 和 <code>play</code> 的能力。 我们的 <code>Dog</code> 类是独一无二的，我们也可以给<code>Dog</code> 类一些独一无二的的属性，比如一个 <code>breed</code>(品种) 属性以及 <code>bark</code>(吠叫) 的能力。 在 ES5 中，我们的 <code>Dog</code> 类可能看起来像这样:</p>\n<p>function Dog(name, energy, breed) {<br>    this.name = name<br>    this.energy = energy<br>    this.breed = breed<br>}</p>\n<p>Dog.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>\n<p>Dog.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>\n<p>Dog.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>\n<p>Dog.prototype.bark = function() {<br>    console.log(‘Woof-Woof!’)<br>    this.energy -= .1<br>}</p>\n<p>const charlie = new Dog(‘Charlie’, 10, ‘Goldendoodle’)</p>\n<p>你应该看出来了，我们刚刚重新创建了 <code>Animal</code> 类并为它添加了一些新属性。 如果我们想创建另一个动物，比如说 <code>Cat</code> ，那么我们必须再次创建一个 <code>Cat</code> 类，将 <code>Animal</code> 类中的所有常用逻辑复制到 <code>Cat</code> ，然后像 <code>Dog</code> 类一样添加 <code>Cat</code> 特定属性。 就是说，我们必须对我们创造的每一种不同类型的动物都这样做。</p>\n<p>function Dog (name, energy, breed) {}</p>\n<p>function Cat (name, energy, declawed) {}</p>\n<p>function Giraffe (name, energy, height) {}</p>\n<p>function Monkey (name, energy, domesticated) {}</p>\n<p>这项工作似乎很浪费。 <code>Animal</code> 类是完美的基类。 这意味着它具有我们每只动物的共同特征。 无论我们是创造 狗，猫，长颈鹿还是猴子，它们都会有一个<code>name</code> ，<code>energy</code> 等级，以及 <code>eat</code> ，<code>sleep</code> 和 <code>play</code> 的能力。 那么每当我们为每个不同的动物创建单独的类时，我们是否可以利用 <code>Animal</code>类？ 我们来试试吧。 我将在下面再次粘贴 <code>Animal</code> 类以便于参考。</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>\n<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>\n<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>\n<p>function Dog(name, energy, breed) {</p>\n<p>}</p>\n<p>我们对上面的 <code>Dog</code> 构造函数你了解多少？ 首先，我们知道它需要3个参数，<code>name</code>, <code>energy</code> 和 <code>breed</code>。 其次，我们知道它将使用 <code>new</code> 关键字调用，因此我们将拥有一个 <code>this</code> 对象。 第三，我们知道我们需要利用 <code>Animal</code> 函数，这样任何狗的实例都会有一个<code>name</code> ，<code>energy</code> 等级，以及 <code>eat</code> ，<code>sleep</code> 和 <code>play</code> 的能力。 第三点是有点棘手的问题。 你“利用”一个函数的方式就是调用它。 所以我们知道在 <code>Dog</code> 里面，我们想要调用 <code>Animal</code> 。 我们需要弄清楚的是我们如何在<code>Dog</code> 的上下文中调用 <code>Animal</code>。 这意味着我们想用 <code>Dog</code> 中的 <code>this</code> 关键字调用 <code>Animal</code>。 如果我们正确地做到了，那么 <code>Dog</code> 函数内部将具有 <code>Animal</code> 的所有属性（<code>name</code> ，<code>energy</code>）。 如果你记得 <a href=\"https://tylermcginnis.com/this-keyword-call-apply-bind-javascript/\">上一节我们所讨论的内容</a>，JavaScript 中的每个函数都有一个 <code>.call</code> 方法。</p>\n<blockquote>\n<p><code>.call()</code> 是函数的一个方法，它允许你调用函数时，指定该函数的上下文。</p>\n</blockquote>\n<p>听起来正是我们所需要的。我们想在 <code>Dog</code> 上下文中调用 <code>Animal</code> 。</p>\n<p>function Dog(name, energy, breed) {<br>    Animal.call(this, name, energy)</p>\n<pre><code>this.breed = breed\n</code></pre>\n<p>}</p>\n<p>const charlie = new Dog(‘Charlie’, 10, ‘Goldendoodle’)</p>\n<p>charlie.name // Charlie<br>charlie.energy // 10<br>charlie.breed // Goldendoodle</p>\n<p>知道这个，我们就已经成功一半了。你将在上面的代码中注意到，因为这一行是 <code>Animal.call(this, name, energy)</code>， <code>Dog</code> 的每个实例都将有一个 <code>name</code> 和 <code>energy</code> 属性。同样，这样做的原因是，就好像我们使用从 <code>Dog</code> 生成的 <code>this</code> 关键字运行 <code>Animal</code> 函数一样。在我们添加了一个<code>name</code> 和 <code>energy</code> 属性之后，我们又像往常一样添加了一个 <code>breed</code> 属性。 请记住，这里的目标是让 <code>Dog</code> 的每个实例不仅具有 <code>Animal</code> 的所有属性，而且还具有所有方法。如果你运行上面的代码，你会注意到如果你尝试运行 <code>charlie.eat(10)</code> ，你将收到一个错误。目前 <code>Dog</code> 的每个实例都具有 <code>Animal</code>（<code>name</code> 和 <code>energy</code>）的属性，但我们没有做任何事情来确保他们也有方法（<code>eat</code> ，<code>sleep</code> 和 <code>play</code>）。 让我们考虑如何解决这个问题。我们知道所有 <code>Animal</code> 的方法都位于 <code>Animal.prototype</code> 上。这意味着我们想要确保 <code>Dog</code> 的所有实例都可以访问<code>Animal.prototype</code> 上的方法。如果我们在这里使用我们的好朋友 <code>Object.create</code> 怎么办？如果你还记得，<code>Object.create</code> 允许你创建一个对象，该对象将在失败的查找中委托给另一个对象。所以在我们的例子中，我们想要创建的对象将是 <code>Dog</code> 的原型，而我们想要在失败的查找中委托的对象是<code>Animal.prototype</code>。</p>\n<p>function Dog(name, energy, breed) {<br>    Animal.call(this, name, energy)</p>\n<pre><code>this.breed = breed\n</code></pre>\n<p>}</p>\n<p>Dog.prototype = Object.create(Animal.prototype)</p>\n<p>现在，只要在 <code>Dog</code> 实例上查找失败，JavaScript 就会将该查找委托给 <code>Animal.prototype</code> 。 如果这仍然有点模糊，请重新阅读 <a href=\"http://www.w3cbest.com/720.html\">JavaScript Prototype(原型) 初学者指南</a>，其中我们讨论了 <code>Object.create</code> 和 JavaScript 的 原型(prototype) 。 让我们一起看完整个代码，然后我们将了解发生的事情。</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>\n<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>\n<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>\n<p>function Dog(name, energy, breed) {<br>    Animal.call(this, name, energy)</p>\n<pre><code>this.breed = breed\n</code></pre>\n<p>}</p>\n<p>Dog.prototype = Object.create(Animal.prototype)</p>\n<p>现在我们已经创建了我们的基类（ <code>Animal</code> ）以及我们的子类（ <code>Dog</code> ），让我们在创建 <code>Dog</code> 实例时看看它的样子。</p>\n<p>const charlie = new Dog(‘Charlie’, 10, ‘Goldendoodle’)</p>\n<p>charlie.name // Charlie<br>charlie.energy // 10<br>charlie.breed // Goldendoodle</p>\n<p>到目前为止没有任何花哨的东西，但让我们来看看当我们调用位于 <code>Animal</code> 上的方法时会发生什么。</p>\n<p>charlie.eat(10)</p>\n<p>/*</p>\n<ol>\n<li>JavaScript checks if charlie has an eat property - it doesn’t.</li>\n<li>JavaScript then checks if Dog.prototype has an eat property</li>\n</ol>\n<ul>\n<li>it doesn’t.</li>\n</ul>\n<ol start=\"3\">\n<li>JavaScript then checks if Animal.prototype has an eat property</li>\n</ol>\n<ul>\n<li>it does so it calls it.<br>*/</li>\n</ul>\n<p><code>Dog.prototype</code> 被检查的原因是因为当我们创建一个新的 <code>Dog</code> 实例时，我们使用了 <code>new</code> 关键字。在引擎中，为我们创建的 <code>this</code> 对象委托给<code>Dog.prototype</code>（见下面的注释）。</p>\n<p>function Dog(name, energy, breed) {<br>    // this = Object.create(Dog.prototype)<br>    Animal.call(this, name, energy)</p>\n<pre><code>this.breed = breed\n// return this\n</code></pre>\n<p>}</p>\n<p>之所以检查 <code>Animal.prototype</code> 是因为我们用这一行覆盖了 <code>Dog.prototype</code> 以委托给失败的查找的 <code>Animal.prototype</code></p>\n<p>Dog.prototype = Object.create(Animal.prototype)</p>\n<p>现在我们还没有谈到的一件事是，如果 <code>Dog</code> 有自己的方法呢？ 嗯，这是一个简单的解决方案。 就像 <code>Animal</code> 一样，如果我们想在该类的所有实例之间共享一个方法，我们将它添加到函数的原型中。</p>\n<p>…</p>\n<p>function Dog(name, energy, breed) {<br>    Animal.call(this, name, energy)</p>\n<pre><code>this.breed = breed\n</code></pre>\n<p>}</p>\n<p>Dog.prototype = Object.create(Animal.prototype)</p>\n<p>Dog.prototype.bark = function() {<br>    console.log(‘Woof Woof!’)<br>    this.energy -= .1<br>}</p>\n<p>非常好。我们需要做一个小小的补充。如果你不记得了请回到 <a href=\"http://www.w3cbest.com/720.html\">JavaScript Prototype(原型) 初学者指南</a>了解详情，我们可以通过使用 <code>instance.constructor</code> 来访问实例的构造函数。</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>const leo = new Animal(‘Leo’, 7)<br>console.log(leo.constructor) // Logs the constructor function</p>\n<p>正如前一篇文章中所解释的那样，“其工作原因是因为任何 <code>Animal</code> 实例都会在失败的查找中委托给 <code>Animal.prototype</code> 。 因此，当你尝试访问<code>leo.prototype</code> 时，<code>leo</code> 没有 <code>prototype</code> 属性，因此它会将该查找委托给 <code>Animal.prototype</code> ，它确实具有 <code>constructor</code> 属性。“ 我提出这个问题的原因是因为在我们的实现中，我们用一个委托给 <code>Animal.prototype</code> 的对象覆盖了 <code>Dog.prototype</code> 。</p>\n<p>function Dog(name, energy, breed) {<br>    Animal.call(this, name, energy)</p>\n<pre><code>this.breed = breed\n</code></pre>\n<p>}</p>\n<p>Dog.prototype = Object.create(Animal.prototype)</p>\n<p>Dog.prototype.bark = function() {<br>    console.log(‘Woof Woof!’)<br>    this.energy -= .1<br>}</p>\n<p>这意味着现在，任何打印 <code>Dog</code> 的实例 <code>instance.constructor</code> 都将获得 <code>Animal</code> 构造函数而不是 <code>Dog</code> 构造函数。你可以通过运行此代码自行查看</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>\n<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>\n<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>\n<p>function Dog(name, energy, breed) {<br>    Animal.call(this, name, energy)</p>\n<pre><code>this.breed = breed\n</code></pre>\n<p>}</p>\n<p>Dog.prototype = Object.create(Animal.prototype)</p>\n<p>Dog.prototype.bark = function() {<br>    console.log(‘Woof Woof!’)<br>    this.energy -= .1<br>}</p>\n<p>const charlie = new Dog(‘Charlie’, 10, ‘Goldendoodle’)<br>console.log(charlie.constructor)</p>\n<p>请注意，即使 <code>charlie</code> 是 <code>Dog</code> 的直接实例，它也会为你提供 <code>Animal</code> 构造函数。同样，我们可以像上面一样了解这里发生的事情。</p>\n<p>const charlie = new Dog(‘Charlie’, 10, ‘Goldendoodle’)<br>console.log(charlie.constructor)<br>/* </p>\n<ol>\n<li>JavaScript checks if charlie has a constructor property - it doesn’t. </li>\n<li>JavaScript then checks if Dog.prototype has a constructor property - it doesn’t because it was deleted when we overwrote Dog.prototype. </li>\n<li>JavaScript then checks if Animal.prototype has a constructor property - it does so it logs that.<br>*/</li>\n</ol>\n<p>我们该如何解决这个问题？嗯，这很简单。一旦我们覆盖它，我们就可以向 <code>Dog.prototype</code> 添加正确的 <code>constructor</code> 属性。</p>\n<p>function Dog(name, energy, breed) {<br>    Animal.call(this, name, energy)</p>\n<pre><code>this.breed = breed\n</code></pre>\n<p>}</p>\n<p>Dog.prototype = Object.create(Animal.prototype)</p>\n<p>Dog.prototype.bark = function() {<br>    console.log(‘Woof Woof!’)<br>    this.energy -= .1<br>}</p>\n<p>Dog.prototype.constructor = Dog</p>\n<p>此时如果我们想要创建另一个子类，比如 <code>Cat</code> ，我们将遵循相同的模式。</p>\n<p>function Cat(name, energy, declawed) {<br>    Animal.call(this, name, energy)</p>\n<pre><code>this.declawed = declawed\n</code></pre>\n<p>}</p>\n<p>Cat.prototype = Object.create(Animal.prototype)<br>Cat.prototype.constructor = Cat</p>\n<p>Cat.prototype.meow = function() {<br>    console.log(‘Meow!’)<br>    this.energy -= .1<br>}</p>\n<p>这种具有委托给它的子类的基类的概念称为继承，它是面向对象编程（OOP）的主要部分。 如果你来自不同的编程语言，你可能已经熟悉OOP和继承了。 在 ES6 classes 之前，在 JavaScript 中，继承是一项非常艰巨的任务，正如你在上面所看到的。你现在只需要了解什么时候使用继承，以及 <code>.call</code> 和 <code>Object.create</code>， <code>this</code> ，和 <code>FN.prototype</code> 的良好组合。- 这些都是高级 JS 主题。让我们看看如何使用 ES6 类来完成同样的事情。 首先，让我们回顾一下使用我们的 <code>Animal</code> 类从 ES5 “类” 到 ES6 类的样子。</p>\n<p>function Animal(name, energy) {<br>    this.name = name<br>    this.energy = energy<br>}</p>\n<p>Animal.prototype.eat = function(amount) {<br>    console.log(`${this.name} is eating.`)<br>    this.energy += amount<br>}</p>\n<p>Animal.prototype.sleep = function(length) {<br>    console.log(`${this.name} is sleeping.`)<br>    this.energy += length<br>}</p>\n<p>Animal.prototype.play = function(length) {<br>    console.log(`${this.name} is playing.`)<br>    this.energy -= length<br>}</p>\n<p>const leo = new Animal(‘Leo’, 7)</p>\n<p>class Animal {<br>    constructor(name, energy) {<br>        this.name = name<br>        this.energy = energy<br>    }<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`)<br>        this.energy += amount<br>    }<br>    sleep() {<br>        console.log(`${this.name} is sleeping.`)<br>        this.energy += length<br>    }<br>    play() {<br>        console.log(`${this.name} is playing.`)<br>        this.energy -= length<br>    }<br>}</p>\n<p>const leo = new Animal(‘Leo’, 7)</p>\n<p>现在我们已经将我们的 <code>Animal</code> 构造函数重构为 ES6 类，接下来我们需要做的是弄清楚如何重构我们的基类（ <code>Dog</code> ）。好消息是它更加直观。作为参考，在ES5 中，这是我们所拥有的。</p>\n<p>function Dog(name, energy, breed) {<br>    Animal.call(this, name, energy)</p>\n<pre><code>this.breed = breed\n</code></pre>\n<p>}</p>\n<p>Dog.prototype = Object.create(Animal.prototype)</p>\n<p>Dog.prototype.bark = function() {<br>    console.log(‘Woof Woof!’)<br>    this.energy -= .1<br>}</p>\n<p>Dog.prototype.constructor = Dog</p>\n<p>在我们进入继承之前，让我们使用 ES6 类来重构 <code>Dog</code> ，就像我们在之前的帖子中学到的那样。</p>\n<p>class Dog {<br>    constructor(name, energy, breed) {<br>        this.breed = breed<br>    }<br>    bark() {<br>        console.log(‘Woof Woof!’)<br>        this.energy -= .1<br>    }<br>}</p>\n<p>看起来很棒。现在，让我们弄清楚如何确保 <code>Dog</code> 继承自 <code>Animal</code> 。我们需要做的第一步是非常直接的。使用 ES6 类，你可以使用此语法 <code>extend</code> 基类</p>\n<p>class Subclass extends Baseclass {}</p>\n<p>翻译成我们的例子，这将使我们的 <code>Dog</code> 类看起来像这样：</p>\n<p>class Animal {<br>    constructor(name, energy) {<br>        this.name = name<br>        this.energy = energy<br>    }<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`)<br>        this.energy += amount<br>    }<br>    sleep() {<br>        console.log(`${this.name} is sleeping.`)<br>        this.energy += length<br>    }<br>    play() {<br>        console.log(`${this.name} is playing.`)<br>        this.energy -= length<br>    }<br>}</p>\n<p>class Dog extends Animal {<br>    constructor(name, energy, breed) {<br>        this.breed = breed<br>    }<br>    bark() {<br>        console.log(‘Woof Woof!’)<br>        this.energy -= .1<br>    }<br>}</p>\n<p>在ES5中，为了确保 <code>Dog</code> 的每个实例都具有<code>name</code> 和 <code>energy</code> 属性，我们使用 <code>.call</code> 以在 <code>Dog</code> 实例的上下文中调用 <code>Animal</code> 构造函数。 幸运的是，在 ES6 中，它更直接。 每当你扩展一个基类并且你需要调用那个基类的构造函数时，你调用 <code>super</code> 传递它需要的任何参数即可。 所以在我们的例子中，我们的 <code>Dog</code> 构造函数被重构为这样:</p>\n<p>class Animal {<br>    constructor(name, energy) {<br>        this.name = name<br>        this.energy = energy<br>    }<br>    eat(amount) {<br>        console.log(`${this.name} is eating.`)<br>        this.energy += amount<br>    }<br>    sleep() {<br>        console.log(`${this.name} is sleeping.`)<br>        this.energy += length<br>    }<br>    play() {<br>        console.log(`${this.name} is playing.`)<br>        this.energy -= length<br>    }<br>}<br>class Dog extends Animal {<br>    constructor(name, energy, breed) {<br>        super(name, energy) // calls Animal’s constructor<br>        this.breed = breed<br>    }<br>    bark() {<br>        console.log(‘Woof Woof!’)<br>        this.energy -= .1<br>    }<br>}</p>\n<p>就是这样。不使用 <code>.call</code> ，不使用 <code>Object.create</code> ，不用担心重置原型上的构造函数 – 只需 <code>extends</code> 基类并确保调用 <code>super</code> 即可。 JavaScript 的有趣之处在于你学到的相同模式，最后几篇文章直接融入语言本身。 以前你了解到 <code>Array</code> 的所有实例都可以访问 <code>pop</code> ，<code>slice</code> ，<code>filter</code> 等数组方法的原因是因为所有这些方法都存在于 <code>Array.prototype</code> 中。</p>\n<p>console.log(Array.prototype)<br>/*<br>concat: ?n concat()<br>constructor: ?n Array()<br>copyWithin: ?n copyWithin()<br>entries: ?n entries()<br>every: ?n every()<br>fill: ?n fill()<br>filter: ?n filter()<br>find: ?n find()<br>findIndex: ?n findIndex()<br>forEach: ?n forEach()<br>includes: ?n includes()<br>indexOf: ?n indexOf()<br>join: ?n join()<br>keys: ?n keys()<br>lastIndexOf: ?n lastIndexOf()<br>length: 0n<br>map: ?n map()<br>pop: ?n pop()<br>push: ?n push()<br>reduce: ?n reduce()<br>reduceRight: ?n reduceRight()<br>reverse: ?n reverse()<br>shift: ?n shift()<br>slice: ?n slice()<br>some: ?n some()<br>sort: ?n sort()<br>splice: ?n splice()<br>toLocaleString: ?n toLocaleString()<br>toString: ?n toString()<br>unshift: ?n unshift()<br>values: ?n values()<br>*/</p>\n<p>你知道，所有 <code>Object</code> 实例都可以访问 <code>hasOwnProperty</code> 和 <code>toString</code> 等方法的原因是因为这些方法存在于 <code>Object.prototype</code> 上。</p>\n<p>console.log(Object.prototype)<br>/*<br>constructor: ?n Object()<br>hasOwnProperty: ?n hasOwnProperty()<br>isPrototypeOf: ?n isPrototypeOf()<br>propertyIsEnumerable: ?n propertyIsEnumerable()<br>toLocaleString: ?n toLocaleString()<br>toString: ?n toString()<br>valueOf: ?n valueOf()<br>*/</p>\n<p>这对你来说是一个挑战。使用上面的 Array 方法和 Object 方法列表，为什么下面的代码有效？</p>\n<p>const friends = [‘Mikenzi’, ‘Jake’, ‘Ean’]<br>friends.hasOwnProperty(‘push’) // false</p>\n<p>如果查看 <code>Array.prototype</code> ，则没有 <code>hasOwnProperty</code> 方法。 好吧，如果 <code>Array.prototype</code> 上没有 <code>hasOwnProperty</code> 方法，上面示例中的 <code>friends</code> 数组如何访问 <code>hasOwnProperty</code>？ 原因是因为 <code>Array</code> 类扩展了 <code>Object</code> 类。 因此，在上面的示例中，当 JavaScript 看到<code>friends</code> 没有 <code>hasOwnProperty</code> 属性时，它会检查 <code>Array.prototype</code> 是否具有该方法。 当 <code>Array.prototype</code> 没有时，它会检查 <code>Object.prototype</code> 是否有该方法，然后再调用它。 这是我们在这篇博客文章中看到的相同过程。 JavaScript 有两种类型 – 原始类型 和 引用类型 。 原始类型是 <code>boolean</code> ， <code>number</code>， <code>string</code>，<code>null</code> 和 <code>undefined</code> 并且是不可变的。 其他所有内容都是引用类型，它们都扩展了 <code>Object.prototype</code> 。 这就是为什么你可以为函数和数组添加属性，这就是为什么函数和数组都可以访问 <code>Object.prototype</code> 上的方法。</p>\n<p>function speak(){} speak.woahFunctionsAreLikeObjects = true console.log(speak.woahFunctionsAreLikeObjects) // true const friends = [‘Mikenzi’, ‘Jake’, ‘Ean’] friends.woahArraysAreLikeObjectsToo = true console.log(friends.woahArraysAreLikeObjectsToo) // true</p>\n<p>原文地址：<a href=\"https://tylermcginnis.com/javascript-inheritance-and-the-prototype-chain/\">https://tylermcginnis.com/javascript-inheritance-and-the-prototype-chain/</a></p>\n","categories":["JavaScript"],"tags":["es6","$.extend()","ES5","inheritance","Prototype Chain","super","原型链","继承"]},{"title":"jquery脚本的动态加载","url":"/2018/09/14/jquery%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/","content":"<h4 id=\"我们平时如何挂载脚本\"><a href=\"#我们平时如何挂载脚本\" class=\"headerlink\" title=\"我们平时如何挂载脚本?\"></a>我们平时如何挂载脚本?</h4><p>众所周知，在web应用中，我们时常需要使用js脚本对应用做这样或者那样的操作。而仙贝们为了解放大家的双手，降低大家的开发成本，创造了很多具有各种用途，或者针对对应问题的解决方案。这些解决方案，被称作框架和库。 而作为这些脚本的使用者，我们只需要简单而又传统的将脚本使用script标签插入我们的应用中就行了。</p>\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<title>test</title>\n</head>\n<body>\n<script src=\"myscript.js\"></script>\n</body>\n</html>\n\n<p>如上文所说，这是简单而又传统的使用方法。事实上在技术快速迭代的今天，传统方式有时候并不能满足我们的需求。当一个webapp含有过多的功能的时候，我们的脚本可能越来越大。而用户的体验则是：这网站打开真慢啊～～～ 然而事实上我们功能做得相当的多，效果做得相当的好，大部分用户其实只是使用了其中的某几个基础功能而已。但只是为了所有功能能够使用而增加了加载量，似乎有些得不偿失。</p>\n<h4 id=\"然后，我们有了动态加载脚本的想法\"><a href=\"#然后，我们有了动态加载脚本的想法\" class=\"headerlink\" title=\"然后，我们有了动态加载脚本的想法\"></a>然后，我们有了动态加载脚本的想法</h4><p>从_Netscape Navigator 4.0_为起点，浏览器厂商们都开始支持起了不同形态的动态html。通过dom api，程序猿们可以轻松的对节点进行各种操作。于是对我们来说，又有了新的方法去加载脚本。</p>\n<p>var script = document.createElement(‘script’);<br>script.async = true;<br>script.src = ‘myScript.js’;<br>document.getElementsByTagName(‘head’)[0].appendChild(script);</p>\n<p>当然了，这样的写法是最基础的增加方法。在这样的写法下，我们无法得知脚本到底有没有加载完，如果依赖脚本没有加载并解释完毕，那么我们加载它就没有任何意义，还会因此阻断所有相关操作。 谢天谢地，天无绝人之路，浏览器老板们还是给我们提供了方法对脚本加载情况进行探知。我们所知的onreadystatechange事件和onload事件可以帮我们判断脚本是否加载完毕～</p>\n<p>script.onreadystatechange = script.onload = function (evt) {<br>var evt = evt ? evt : window.event;<br>if (!evt.readyState  evt.readyState === ‘loaded’  evt.readyState === ‘complete’) {<br>cb &amp;&amp; cb();<br>script.onreadystatechange = script.onload ＝ null;<br>script.parent.removeChild(script);<br>script = null;<br>}<br>}</p>\n<h4 id=\"作为一个正常人，我们想不想加载更多东西呢？\"><a href=\"#作为一个正常人，我们想不想加载更多东西呢？\" class=\"headerlink\" title=\"作为一个正常人，我们想不想加载更多东西呢？\"></a>作为一个正常人，我们想不想加载更多东西呢？</h4><p>想！当然想。作为一个正常人，我们极其希望也load别的东西过来，那现在我们还有什么东西可以通过动态加载呢？css／picture／function都可以成为我们的加载对象。这时候，我们就该有一个简单的加载器了，聚合我们想要的功能，让我们解放双手！</p>\n<p>var handler = {<br>js: jsHandler,<br>css: cssHandler,<br>fn: fnHandler<br>};</p>\n<p>var Loader = function (src, type) {</p>\n<p>if (src === undefined) {<br>throw new Error(‘木有参数’);<br>}<br>// 修正参数<br>if (!type) {<br>if (typeof src === ‘string’) {<br>if (/\\.css$\\.css\\?/i.test(src)) {<br>type = ‘css’;<br>}<br>if (/\\.js$\\.js\\?/i.test(src)) {<br>type = ‘js’;<br>}<br>}<br>if (typeof src === ‘function’) {<br>type = ‘fn’<br>}<br>}<br>type = type  ‘js’;</p>\n<p>handler[type](src);<br>};</p>\n<p>function jsHandler(src) {}</p>\n<p>function cssHandler(href) {}</p>\n<p>function fnHandler(fn) {}</p>\n<h4 id=\"如何填充我们的函数\"><a href=\"#如何填充我们的函数\" class=\"headerlink\" title=\"如何填充我们的函数\"></a>如何填充我们的函数</h4><p><img src=\"http://www.w3cbest.com/wp-content/uploads/2018/09/lhtfg.jpg\"> 我们有了处理不同类型加载项的逻辑，但首先，我们还是要完善jsHandler函数</p>\n<h4 id=\"获取head元素\"><a href=\"#获取head元素\" class=\"headerlink\" title=\"获取head元素\"></a>获取head元素</h4><p>var doc = document;<br>var head = doc.head  doc.getElementsByTagName(“head”)[0]  doc.documentElement;</p>\n<p>将document和head缓存起来，以便多次使用，这可以提高一点点的性能… 为jsHandler完善加载部分</p>\n<p>function jsHandler(src, callback) {<br>var script = doc.createElement(‘script’);<br>script.async = true;<br>script.src = src;</p>\n<p>// 对支持onload事件的浏览器做处理<br>var hasOnload = ‘onload’ in script;<br>if (hasOnload) {<br>script.onload = jsOnload;<br>script.onerror = function () {<br>jsOnload(true);<br>}<br>}</p>\n<p>// 对支持onreadystatechange的浏览器做处理<br>else {<br>script.onreadystatechange = function() {<br>if (/loadedcomplete/.test(script.readyState)) {<br>jsOnload();<br>}<br>}<br>}</p>\n<p>head.appendChild(script);</p>\n<p>// 当事件<br>function jsOnload(error) {<br>isTimeout = false;<br>script.onload = script.onerror = script.onreadystatechange = null;<br>head.removeChild(script);<br>script = null;<br>callback(error);<br>}<br>}</p>\n<p>在上面这段代码中，我们为加载js做了一系列处理，由于浏览器厂商的实现问题，我们要对脚本是否加载成功或失败作出判断，这是个很麻烦的事情，尤其是对需要向下兼容的同学来说。 从<a href=\"http://qianduanblog.com/post/headjs.html\">headjs</a>这篇文章的注释来看，脚本是否加载完毕依赖于onload事件，而ie9及以下依赖于对状态标志进行load或者complete字符的检测。</p>\n<p>// IE 7/8 (2 events on 1st load)<br>// 1) event.type = readystatechange, s.readyState = loading<br>// 2) event.type = readystatechange, s.readyState = loaded</p>\n<p>// IE 7/8 (1 event on reload)<br>// 1) event.type = readystatechange, s.readyState = complete</p>\n<p>// event.type === ‘readystatechange’ &amp;&amp; /loaded¦complete/.test(s.readyState)</p>\n<p>// IE 9 (3 events on 1st load)<br>// 1) event.type = readystatechange, s.readyState = loading<br>// 2) event.type = readystatechange, s.readyState = loaded<br>// 3) event.type = load , s.readyState = loaded</p>\n<p>// IE 9 (2 events on reload)<br>// 1) event.type = readystatechange, s.readyState = complete<br>// 2) event.type = load , s.readyState = complete</p>\n<p>// event.type === ‘load’ &amp;&amp; /loaded¦complete/.test(s.readyState)<br>// event.type === ‘readystatechange’ &amp;&amp; /loaded¦complete/.test(s.readyState)</p>\n<p>// IE 10 (3 events on 1st load)<br>// 1) event.type = readystatechange, s.readyState = loading<br>// 2) event.type = load , s.readyState = complete<br>// 3) event.type = readystatechange, s.readyState = loaded</p>\n<p>// IE 10 (3 events on reload)<br>// 1) event.type = readystatechange, s.readyState = loaded<br>// 2) event.type = load , s.readyState = complete<br>// 3) event.type = readystatechange, s.readyState = complete</p>\n<p>// event.type === ‘load’ &amp;&amp; /loaded¦complete/.test(s.readyState)<br>// event.type === ‘readystatechange’ &amp;&amp; /complete/.test(s.readyState)</p>\n<p>// Other Browsers (1 event on 1st load)<br>// 1) event.type = load, s.readyState = undefined</p>\n<p>// Other Browsers (1 event on reload)<br>// 1) event.type = load, s.readyState = undefined</p>\n<p>// event.type == ‘load’ &amp;&amp; s.readyState = undefined</p>\n<p>当然，如果遇到了既不支持onload又不支持onreadystatechange的浏览器的时候，我们只能另寻他法了。 如果要加载的脚本是你写的，那你自己可以处理～如果加载的脚本不是你写的～哦喽，不在本文讨论范围之内～</p>\n<h4 id=\"当你需要jsHandler检测加载是否超时的时候\"><a href=\"#当你需要jsHandler检测加载是否超时的时候\" class=\"headerlink\" title=\"当你需要jsHandler检测加载是否超时的时候\"></a>当你需要jsHandler检测加载是否超时的时候</h4><p>我们为jsHandler增加一个参数timeout，并在函数中实现如下逻辑</p>\n<p>function jsHandler(src, callback, timeout) {<br>…<br>// 检测是否超时的标志<br>var isTimeout = true;<br>…</p>\n<p>if (timeout) {<br>setTimeout(timeoutHandler, timeout);<br>}</p>\n<p>head.appendChild(script);</p>\n<p>function jsOnload(error) {<br>// 当在时间内完成操作时，不管是否成功，将超时标志设为false<br>isTimeout = false;<br>script.onload = script.onerror = script.onreadystatechange = null;<br>head.removeChild(script);<br>script = null;<br>callback(error);<br>}</p>\n<p>function timeoutHandler() {<br>// 如果标志未改变，认为其超时<br>if (isTimeout) {<br>jsOnload(true);<br>}<br>}<br>}</p>\n<h4 id=\"当我们同步执行代码的时候\"><a href=\"#当我们同步执行代码的时候\" class=\"headerlink\" title=\"当我们同步执行代码的时候\"></a>当我们同步执行代码的时候</h4><p>当我们需要加载一个或者多个脚本的时候，我们会发现，“奥我次奥，怎么请求了那么多次呢？这不科学。” 这是因为我们的loader在多处被调用或同步调用了，于是我们想啊，搞个map纪录缓存算了。于是乎： － 我们需要一些变量</p>\n<p>// 用作存储脚本信息<br>var cache = {};<br>// 用作生成不重复的客户端id<br>var _cid = 0;<br>// 用作存储其他loader实例需要运行的脚本任务<br>var processCache = {};</p>\n<p>// 加载状态标识<br>var DONE = ‘done’;<br>var REJECTED = ‘rejected’;<br>var PENDING = ‘pending’;<br>我们需要产生不同的存储id<br>/**<br>* 产生客户端id<br>* @return {Number} [description]<br>*/<br>function cid() {<br>return _cid++;<br>}</p>\n<p>我们需要创建一个Script类，new一个实例用于存储任务的基本信息</p>\n<p>/**<br>* Script对象，储存需要加载的任务的基本信息<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>*/<br>function Script(uri, type) {<br>this.uri = uri;<br>this.type = type;<br>this.cid = cid();<br>this.status = PENDING;<br>}</p>\n<p>－ 当我们寻找缓存中的任务对象的时候，因该返回正确的对象。怎么寻找缓存呢，当然是通过地址来索引啦</p>\n<p>/**<br>* 从缓存中获取需要的Script对象<br>* 如果没有，新建一个<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>* @return {Object} 需要的Script对象<br>*/<br>function get(uri, type) {<br>// 如果不存在于缓存中，创建一个新的Script对象<br>return cache[uri]  (cache[uri] = new Script(uri, type));<br>}</p>\n<h4 id=\"如果我们的脚本或函数有别名怎么办！\"><a href=\"#如果我们的脚本或函数有别名怎么办！\" class=\"headerlink\" title=\"如果我们的脚本或函数有别名怎么办！\"></a>如果我们的脚本或函数有别名怎么办！</h4><p>var alias = {};<br>/**<br>* 获取有别名的Script对象<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>* @return {Object} Script Object<br>*/<br>function getCache(uri, type) {<br>var src = getAlias(uri);<br>return src ? get(src) : get(uri, type);<br>}</p>\n<p>/**<br>* 获取真实地址<br>* @param {String} name [description]<br>* @return {[type]} return uri<br>*/<br>function getAlias(name) {<br>return alias[name];<br>}</p>\n<p>别名的用途在于我们不用多次输入同样长度的uri,或者说是函数。</p>\n<h4 id=\"现在，该填充我们的Loader类了。\"><a href=\"#现在，该填充我们的Loader类了。\" class=\"headerlink\" title=\"现在，该填充我们的Loader类了。\"></a>现在，该填充我们的Loader类了。</h4><p>我们要很清楚的知道，Loader需要做什么。 一个简单的Loader应该可以多次添加需要加载的内容，then或者add方法可以让用户添加任务。那它应该有一个内置的list，可以存储这些待添加的任务。 它也应该可以在全部脚本加载完的时候执行我们的callback，那么我们应该实现一个方法接受一个回调，在任务执行完时调用。 我们也要可以对某些地址进行别名命名，也需要设置超时时间 实现Loader类</p>\n<p>/**<br>* Loader类<br>*/<br>var Loader = function () {<br>this.list = [];<br>this.timeout = 0;<br>this.callback = null;<br>};</p>\n<p>实现then方法，使用then的时候应该可以连续使用</p>\n<p>/**<br>* 实现的then方法<br>* @param {String} src 地址<br>* @param {String} type 类型<br>* @return {Object} Loader对象<br>*/<br>Loader.prototype.then = function(src, type) {<br>if (src === undefined) {<br>throw new Error(‘木有参数’);<br>}</p>\n<p>// 修正参数<br>if (!type) {<br>if (typeof src === ‘string’) {<br>if (/\\.css$\\.css\\?/i.test(src)) {<br>type = ‘css’;<br>}<br>if (/\\.js$\\.js\\?/i.test(src)) {<br>type = ‘js’;<br>}<br>}<br>if (typeof src === ‘function’) {<br>type = ‘fn’<br>}<br>}</p>\n<p>type = type  ‘js’;<br>this.list.push(getCache(src, type));<br>return this;<br>};</p>\n<p>实现done方法</p>\n<p>/**<br>* done方法，接受一个callback，在所有任务完成时调用<br>* @param {Function} cb 完成后的回调<br>* @return {Object} 第一次调用done后返回一个新的对象<br>*/<br>Loader.prototype.done = function(cb) {<br>if (this.callback === null) {<br>this.callback = cb;<br>}<br>if (!this.list.length) {<br>this.callback &amp;&amp; this.callback();<br>return;<br>}<br>var script = this.list.shift();<br>handler[script.type](this, script);<br>if (!this.called) {<br>this.called = true;<br>return new Loader();<br>}<br>};</p>\n<p>实现config配置</p>\n<p>Loader.prototype.config = function (opts) {<br>this.timeout = opts.timeout  0;<br>if (opts.alias &amp;&amp; !opts.alias.length) {<br>for (var i = opts.alias.length - 1; i &gt;= 0; i–) {<br>alias[i] = opts.alias[i];<br>}<br>}<br>}</p>\n<h4 id=\"如何让错误集中显示\"><a href=\"#如何让错误集中显示\" class=\"headerlink\" title=\"如何让错误集中显示\"></a>如何让错误集中显示</h4><p>我们需要接入一个resolve方法，Loader类也应该有一个errors的列表来储存每次错误的信息，最后放到callback中集中显示。</p>\n<p>function resolve(loader, s) {<br>if (s.error) {<br>loader.errors.push(s);<br>}<br>loader.done();<br>var cache = processCache[s.cid];<br>if (cache &amp;&amp; !cache.length) {<br>for (var i = 0, len = cache.length; i &lt; len; i++) {<br>cache.shift().loader.done();<br>}<br>}<br>}</p>\n<p>var Loader = function () {<br>this.list = [];<br>this.timeout = 0;<br>this.errors = [];<br>this.callback = null;<br>};</p>\n<p>最终，我们将所有的思路组装起来</p>\n<p>(function (root, factory) {<br>if (typeof define === ‘function’ &amp;&amp; define.amd) {<br>// AMD. Register as an anonymous module.<br>define(factory);<br>} else {<br>// Browser globals<br>root.Loader = factory();<br>}<br>}(this, function () {</p>\n<p>// 用作存储脚本信息<br>var cache = {};<br>// 用作生成不重复的客户端id<br>var _cid = 0;<br>// 用作存储其他loader实例需要运行的脚本任务<br>var processCache = {};<br>// 用作储存别名<br>window.alias = {};</p>\n<p>// 加载状态标识<br>var DONE = ‘done’;<br>var REJECTED = ‘rejected’;<br>var PENDING = ‘pending’;</p>\n<p>// 获取document,head<br>var doc = document;<br>var head = doc.head  doc.getElementsByTagName(“head”)[0]  doc.documentElement;</p>\n<p>/**<br>* 产生客户端id<br>* @return {Number} [description]<br>*/<br>function cid() {<br>return _cid++;<br>}</p>\n<p>/**<br>* Script对象，储存需要加载的任务的基本信息<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>*/<br>function Script(uri, type) {<br>this.uri = uri;<br>this.type = type;<br>this.cid = cid();<br>this.status = PENDING;<br>}</p>\n<p>/**<br>* 从缓存中获取需要的Script对象<br>* 如果没有，新建一个<br>* @param {String} uri uri 地址  需要执行的函数<br>* @param {String} type 任务类型<br>* @return {Object} 需要的Script对象<br>*/<br>function get(uri, type) {<br>// 如果不存在于缓存中，创建一个新的Script对象<br>return cache[uri]  (cache[uri] = new Script(uri, type));<br>}</p>\n<p>/**<br>* 获取真实地址<br>* @param {String} name [description]<br>* @return {[type]} return uri<br>*/<br>function getAlias(name) {<br>return alias[name];<br>}</p>\n<p>function getCache(uri, type) {<br>var opts = getAlias(uri);<br>return opts ? get(opts.uri, opts.type) : get(uri, type);<br>}</p>\n<p>// 处理<br>var handler = {<br>js: jsHandler,<br>css: cssHandler,<br>fn: fnHandler<br>};</p>\n<p>// 对函数的处理<br>function fnHandler(context, s) {<br>// 函数不需要判断是否为正在加载状态<br>try {<br>s.uri();<br>resolve(context, s);<br>}<br>catch (e) {<br>s.error = e.message;<br>resolve(context, s);<br>}<br>}</p>\n<p>// 对css请求的处理<br>function cssHandler(context, s) {<br>// 当其他Loader实体中的任务已经完成时<br>if (s.status !== PENDING) {<br>resolve(context, s);<br>return;<br>}<br>var link = document.createElement(‘link’);<br>link.type = ‘text/css’;<br>link.rel = ‘stylesheet’<br>link.href = s.uri;<br>head.appendChild(link);<br>resolve(context, s);<br>};</p>\n<p>// 对js动态加载的处理<br>function jsHandler(context, s) {</p>\n<p>// 处理已完成任务<br>if (s.status !== PENDING) {<br>resolve(context, s);<br>return;<br>}</p>\n<p>// 如果非第一个加载，将剩余的任务和任务关联的上下文塞进正在进行的进程中<br>if (s.changeState) {<br>processCache[s.cid] = processCache[s.cid]  [];<br>processCache[s.cid].push({ loader: context, s: s });<br>return;<br>}</p>\n<p>s.changeState = true;</p>\n<p>// 设置超时标志<br>var isTimeout = true;<br>var script = document.createElement(‘script’);<br>script.async = true;<br>script.src = s.uri;</p>\n<p>// 如果支持onload事件<br>var hasOnload = ‘onload’ in script;</p>\n<p>if (hasOnload) {<br>script.onload = jsOnload;<br>script.onerror = function () {<br>jsOnload(‘ScriptError’);<br>}<br>}<br>else {<br>script.onreadystatechange = function() {<br>if (/loadedcomplete/.test(script.readyState)) {<br>jsOnload();<br>}<br>}<br>}</p>\n<p>// 如果设置了超时，启动一个计时器<br>if (context.timeout) {<br>setTimeout(timeoutHandler, context.timeout);<br>}</p>\n<p>head.appendChild(script);</p>\n<p>function jsOnload(error) {<br>isTimeout = false;<br>script.onload = script.onerror = script.onreadystatechange = null;<br>head.removeChild(script);<br>script = null;<br>if (error &amp;&amp; typeof error === ‘string’) {<br>s.error = error;<br>}<br>resolve(context, s);<br>}</p>\n<p>function timeoutHandler() {<br>if (isTimeout) {<br>console.log(‘timeout’);<br>jsOnload(‘RequestTimeout’);<br>}<br>}<br>}</p>\n<p>function resolve(loader, s) {<br>if (s.error) {<br>loader.errors.push(s);<br>}<br>loader.done();<br>var cache = processCache[s.cid];<br>if (cache &amp;&amp; !cache.length) {<br>for (var i = 0, len = cache.length; i &lt; len; i++) {<br>cache.shift().loader.done();<br>}<br>}<br>}</p>\n<p>var Loader = function () {<br>this.list = [];<br>this.errors = [];<br>this.timeout = [];<br>this.callback = null;<br>};</p>\n<p>Loader.prototype.then = function(src, type) {<br>if (src === undefined) {<br>throw new Error(‘木有参数’);<br>}</p>\n<p>// 修正参数<br>if (!type) {<br>if (typeof src === ‘string’) {<br>if (/\\.css$\\.css\\?/i.test(src)) {<br>type = ‘css’;<br>}<br>if (/\\.js$\\.js\\?/i.test(src)) {<br>type = ‘js’;<br>}<br>}<br>if (typeof src === ‘function’) {<br>type = ‘fn’<br>}<br>}</p>\n<p>type = type  ‘js’;<br>this.list.push(getCache(src, type));<br>return this;<br>};</p>\n<p>Loader.prototype.done = function(cb) {<br>if (this.callback === null) {<br>this.callback = cb;<br>}<br>if (!this.list.length) {<br>this.callback &amp;&amp; this.callback(this.errors);<br>return;<br>}<br>var script = this.list.shift();<br>handler[script.type](this, script);<br>if (!this.called) {<br>this.called = true;<br>return new Loader();<br>}<br>};</p>\n<p>Loader.prototype.config = function (opts) {<br>this.timeout = opts.timeout  0;<br>if (opts.alias &amp;&amp; !opts.alias.length) {<br>for (var i in alias) {</p>\n<p>}<br>for (var i = opts.alias.length - 1; i &gt;= 0; i–) {<br>alias[i] = opts.alias[i]<br>}<br>}<br>return this;<br>};</p>\n<p>return Loader;<br>}));</p>\n<p>除了此类常规的写法，我们其实还可以使用其他更多的方法来实现脚本动态加载，比如自定义事件，比如模块化加载的实现，比如promise实现等等 这篇文章的意义在于开阔思维，回顾基础。 下面的observer对象实现了一个简单的事件注册，监听，销毁的功能，对模式有过研究或者码力深厚的同学肯定不陌生。</p>\n<p>var observer = (function () {</p>\n<p>var list = {};</p>\n<p>var on = function (evt, cb) {<br>if (!list[evt]) {<br>list[evt] = [];<br>}<br>list[evt].push(cb);<br>};</p>\n<p>var trigger = function () {<br>var evtName = Array.prototype.shift.call(arguments);<br>callbacks = list[evtName];<br>if (!callbacks  callbacks.length === 0) {<br>return;<br>}<br>for (var i = 0, len = callbacks.length; i &lt; len; i++) {<br>callbacks[i].apply(this, arguments);<br>}<br>};</p>\n<p>var off = function (evt, fn) {<br>var callbacks = list[evt];<br>if (!callbacks) {<br>return;<br>}<br>if (!fn) {<br>callbacks &amp;&amp; callbacks.length = 0;<br>return;<br>}<br>for (var i = 0, len = callbacks.length i &lt; len; i++) {<br>if (fn === callbacks[i]) {<br>callbacks.splice(i, 1);<br>}<br>}<br>};</p>\n<p>// 暴露对外接口<br>return {<br>trigger: trigger,<br>on: on,<br>off: off<br>}<br>})();</p>\n<p>转载：<a href=\"http://eux.baidu.com/blog\">http://eux.baidu.com/blog</a></p>\n","categories":["JavaScript"],"tags":["javascript","jquery","动态加载"]},{"title":"关于CSS变量你需要知道的一切","url":"/2018/09/18/%E5%85%B3%E4%BA%8Ecss%E5%8F%98%E9%87%8F%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87/","content":"<p>多数编程语言都支持变量。但是CSS从最初就一直缺少对原生变量的功能支持。 你写CSS吧？那你就没办法用变量。不过，你还可以用Sass这样的预编译器。 Sass这样的预编译器就把变量作为一个巨大的卖点，一个尝试新东西的原因。你知道吗？我们还真的很吃这一套。 不过互联网还在飞速前行。所以我也很开心的宣布CSS现在终于支持变量了。 预编译器支持更多的特性，其中CSS变量就是一个不错的卖点。这些工作让互联网更加接近未来。 在这篇指南里，我会展示如何使用CSS原生变量，以及如何在日常工作里使用它们，让生活变的更美好。</p>\n<h2 id=\"你会学到这些\"><a href=\"#你会学到这些\" class=\"headerlink\" title=\"你会学到这些\"></a>你会学到这些</h2><p>首先，我会介绍一些CSS变量的基础知识。我相信理解CSS变量应该从这里开始。 学习基础知识是非常酷的一件事。更酷的把这些基础知识应用到现实应用当中去。 所以我会用三个例子来展示如何方便的使用CSS变量。下面我们简单过一下这三个例子。</p>\n<h3 id=\"例1：使用CSS变量创建可变组件\"><a href=\"#例1：使用CSS变量创建可变组件\" class=\"headerlink\" title=\"例1：使用CSS变量创建可变组件\"></a>例1：使用CSS变量创建可变组件</h3><p>今天你可能已经在构建自己可变组件了。无论你是在使用React，Angular，或者Vue，CSS变量都能使这个过程简洁许多。 <img src=\"http://file.w3cbest.com/file/images/1_qElS3I43_SdpdRA8-m2iew.gif\"> 参见 <a href=\"https://codepen.io/ohansemmanuel/full/PQYzvv/\">Codepen的这个例子</a>;</p>\n<h3 id=\"例2-带有CSS变量的主题样式\"><a href=\"#例2-带有CSS变量的主题样式\" class=\"headerlink\" title=\"例2: 带有CSS变量的主题样式\"></a>例2: 带有CSS变量的主题样式</h3><p>你可能已经在别处看到过这样的用法。我接下来要展示的是CSS变量如何使得创建站点级别的主题样式更加简便。 <img src=\"http://file.w3cbest.com/file/images/1_r2TrlsC-gWRD5Hu6Tp2gjQ.gif\"> 参见 <a href=\"https://codepen.io/ohansemmanuel/full/xYKgwE/\">Codepen的这个例子</a></p>\n<h3 id=\"例3-创建CSS变量盒\"><a href=\"#例3-创建CSS变量盒\" class=\"headerlink\" title=\"例3: 创建CSS变量盒\"></a>例3: 创建CSS变量盒</h3><p>恩，这是最后一个例子。请忽略这个名字，我想不到更好的了… <img src=\"http://file.w3cbest.com/file/images/1_E6H-wT6a0BDR9OJK7Z0dTA.gif\"> 注意这些盒子的颜色是动态更新的，盒子容器也是可以3D旋转的。 <img src=\"http://file.w3cbest.com/file/images/1_iy_MjZVlp-H0KUQa7H7fUg.gif\"> 这个例子让我们看到如何使用JavaScript更新CSS变量，并展示出一个很好的交互效果。</p>\n<h2 id=\"接下来的更有趣！\"><a href=\"#接下来的更有趣！\" class=\"headerlink\" title=\"接下来的更有趣！\"></a>接下来的更有趣！</h2><p>花点时间尝试一下 <a href=\"https://codepen.io/ohansemmanuel/full/EoBLgd/\">Codepen上的这个例子</a>。 请注意：本文假设你已经熟练掌握了CSS。如果你还不了解CSS，或者想学习创造让人瞠目结舌的UI，我建议你上一下我的这堂高级<a href=\"https://bit.ly/learn_css\">CSS课程</a>（付费课程，包括85节课）。本文是其中一课的摘录（不害臊脸）。</p>\n<h2 id=\"为何变量如此重要\"><a href=\"#为何变量如此重要\" class=\"headerlink\" title=\"为何变量如此重要\"></a>为何变量如此重要</h2><p>如果你刚开始学预编译器的变量，或者熟悉原生CSS，下面便是一些你要了解变量的原因：</p>\n<h3 id=\"原因1-提高代码可读性\"><a href=\"#原因1-提高代码可读性\" class=\"headerlink\" title=\"原因1:提高代码可读性\"></a>原因1:提高代码可读性</h3><p>无需赘言，变量让代码可读性更强，可维护性更好。</p>\n<h3 id=\"原因2-使大型文档中的代码改动更容易\"><a href=\"#原因2-使大型文档中的代码改动更容易\" class=\"headerlink\" title=\"原因2: 使大型文档中的代码改动更容易\"></a>原因2: 使大型文档中的代码改动更容易</h3><p>如果你所有的常量都存在一个单独的文件里，你就不需要在几千行代码里一一修改变量了。这就很容易了。 只要改一行，就结了！</p>\n<h3 id=\"原因3-更快的发现拼写错误\"><a href=\"#原因3-更快的发现拼写错误\" class=\"headerlink\" title=\"原因3: 更快的发现拼写错误\"></a>原因3: 更快的发现拼写错误</h3><p>在多行代码里找错，是很痛苦的一件事。更烦人的是，这个错误可能只是简单的拼写错误。很难查找。合理使用变量，就能消除一些烦心事。 因此，可读性和可维护性可以双赢。 感谢CSS变量，现在我们终于可以在原生CSS中使用它们了。</p>\n<h2 id=\"定义CSS变量\"><a href=\"#定义CSS变量\" class=\"headerlink\" title=\"定义CSS变量\"></a>定义CSS变量</h2><p>让我们从你熟悉的开始吧：JavaScript中的变量。 一个JavaScript中的变量可能是这样定义的：</p>\n<p>var amAwesome;</p>\n<p>然后这样赋值：</p>\n<p>amAwesome = “awesome string”</p>\n<p>CSS中，一个CSS变量是任意一个以两个破折号开头的”属性“值，</p>\n<p>/*能找到这里定义变量么? */<br>.block {<br>color: #8cacea;<br>–color: blue<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/0_2Pl5qBF8DCTGL_np.png\"></p>\n<h2 id=\"CSS变量作用域\"><a href=\"#CSS变量作用域\" class=\"headerlink\" title=\"CSS变量作用域\"></a>CSS变量作用域</h2><p>还有一点你需要注意。 在JavaScript里，变量都有一个作用域。它们或是一个全局变量，或是一个局部变量。 CSS变量也一样。请看下面的例子：</p>\n<p>:root {<br>–main-color: red<br>}</p>\n<p><code>:root</code>选择器能让我们选择DOM树里的最顶级的元素，也就是文档树。所以，这样定义的变量，也就相当于全局变量了。理解了么？ <img src=\"http://file.w3cbest.com/file/images/0_GLjARI5CCGA3xJAx.png\"></p>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p>假设你想设置一个存储网站主题样式的CSS变量，你会怎么做？</p>\n<h4 id=\"1，你需要使用范围选择器。用-root来定义一个全局变量。\"><a href=\"#1，你需要使用范围选择器。用-root来定义一个全局变量。\" class=\"headerlink\" title=\"1，你需要使用范围选择器。用:root来定义一个全局变量。\"></a>1，你需要使用范围选择器。用<code>:root</code>来定义一个全局变量。</h4><p>:root {}</p>\n<h4 id=\"2，定义变量\"><a href=\"#2，定义变量\" class=\"headerlink\" title=\"2，定义变量\"></a>2，定义变量</h4><p>:root {<br>–primary-color: red<br>}</p>\n<p>请记住，CSS变量是任意一个以两个破折号开始的“属性”。就这么简单。</p>\n<h2 id=\"使用CSS变量\"><a href=\"#使用CSS变量\" class=\"headerlink\" title=\"使用CSS变量\"></a>使用CSS变量</h2><p>变量定义且被赋值后，你就可以使用它了。不过要上手还是有一些麻烦的地方。 如果你习惯了预编译器，那么肯定知道如何使用变量了。例如：</p>\n<p>$font-size: 20px<br>.test {<br>font-size: $font-size<br>}</p>\n<p>CSS变量和这稍有不同。 你需要使用<code>var()</code>这个函数引用变量。 上面的例子中，CSS变量是这样引用的：</p>\n<p>:root {<br>–font-size: 20px<br>}<br>.test {<br>font-size: var(–font-size)<br>}</p>\n<p>非常不同。 <img src=\"http://file.w3cbest.com/file/images/0_Gv8Nci9VTrJBxpBe.png\"> 一旦你习惯了这样的方式，你就会爱上CSS变量的，非常爱！ 另一个重要的提示是，不像Sass或者其他预编译器中的变量，你可以在很多地方使用变量。CSS的变量需要小心谨慎，如果需要你还能做数学运算。多数情况下你应该把它们当作属性值来使用。</p>\n<p>/*下面这样是不对的*/<br>.margin {<br>–side: margin-top;<br> var(–side): 20px;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/0_vtIhP9EGm_vTxeio.png\"> 你也无法直接使用数学运算功能。运算功能需要使用<code>calc()</code>函数。后面遇到时我会加以讨论。</p>\n<p>/*下面这样也不对 */<br>.margin {<br>–space: 20px * 2;<br>font-size:  var(–space);  //这不是 40px<br>}</p>\n<p>如果你一定需要用数学计算，那么请使用 calc()函数，如下：</p>\n<p>.margin {<br>–space: calc(20px * 2);<br>font-size:  var(–space);  /*equals 40px*/<br>}</p>\n<h2 id=\"值得一提的属性\"><a href=\"#值得一提的属性\" class=\"headerlink\" title=\"值得一提的属性\"></a>值得一提的属性</h2><p>有一些行为是值得提醒注意的。</p>\n<h3 id=\"1-自定义属性是普通属性值，因此它们可以定义在任意元素上。\"><a href=\"#1-自定义属性是普通属性值，因此它们可以定义在任意元素上。\" class=\"headerlink\" title=\"1. 自定义属性是普通属性值，因此它们可以定义在任意元素上。\"></a>1. 自定义属性是普通属性值，因此它们可以定义在任意元素上。</h3><p>在段落p元素，section，aside元素或者root根元素，甚至是伪元素上使用变量，都是可以的。 <img src=\"http://file.w3cbest.com/file/images/0_plpQVof3v3JrzC1P.png\"></p>\n<h3 id=\"2-CSS变量和普通CSS继承和叠加的规则相同\"><a href=\"#2-CSS变量和普通CSS继承和叠加的规则相同\" class=\"headerlink\" title=\"2. CSS变量和普通CSS继承和叠加的规则相同\"></a>2. CSS变量和普通CSS继承和叠加的规则相同</h3><p>看这个例子：</p>\n<p>div {<br>–color: red;<br>}<br>div.test {<br>color: var(–color)<br>}<br>div.ew {<br>color: var(–color)<br>}</p>\n<p>和普通变量相同，<code>--color</code>的值也会从其他的div元素继承下来。 <img src=\"http://file.w3cbest.com/file/images/0_GNSU5IDdk7dx3B8t.png\"></p>\n<h3 id=\"3-CSS变量也可以和-media或其他条件选择的规则同时使用\"><a href=\"#3-CSS变量也可以和-media或其他条件选择的规则同时使用\" class=\"headerlink\" title=\"3. CSS变量也可以和@media或其他条件选择的规则同时使用\"></a>3. CSS变量也可以和<code>@media</code>或其他条件选择的规则同时使用</h3><p>和其他属性一样，你也可以使用<code>@media</code>或其他的条件规则里使用变量， 例如，下面的代码改变了变量的值，在不同的设备上使用不同值。</p>\n<p>:root {<br>–gutter: 10px<br>}<br>@media screen and (min-width: 768px) {<br>    –gutter: 30px<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/0_qmsVGjnWjLCKfyvt.png\"></p>\n<h3 id=\"4-CSS变量可以在HTML的style属性中使用\"><a href=\"#4-CSS变量可以在HTML的style属性中使用\" class=\"headerlink\" title=\"4. CSS变量可以在HTML的style属性中使用\"></a>4. CSS变量可以在HTML的style属性中使用</h3><p>你也可以在内联样式里使用变量，它们也正常工作。</p>\n<html style=\"--color: red\">\nbody {\ncolor: var(--color)\n}\n\n<p><img src=\"http://file.w3cbest.com/file/images/0_EQiFgdDyNBQ1AfDk.png\"> CSS变量大小写敏感。请注意这一点。我为了省事全部都用小写。你的情况可能不一样。</p>\n<p>/*这是两个不同的变量*/<br>:root {<br>   –color: blue;<br>–COLOR: red;<br>}</p>\n<h2 id=\"解决多重定义\"><a href=\"#解决多重定义\" class=\"headerlink\" title=\"解决多重定义\"></a>解决多重定义</h2><p>和其他属性是一样的，重定义变量也遵循标准级联规则。 下面来看个例子：</p>\n<p>/*变量定义*/<br>:root { –color: blue; }<br>div { –color: green; }<br>#alert { –color: red; }</p>\n<p>/*使用变量 */<br>* { color: var(–color); }</p>\n<p>有了上面的定义，不同元素的值是什么样的呢？</p>\n<p>我的颜色是?</p>\n<div>我的呢?</div>\n<div>\n我的颜色是?\n<p>颜色?</p>\n</div>\n\n<p>你能猜出来么？ 第一个p元素是 blue，没有任何–color 变量定义是在 p元素的，因此它会继承自根元素 :root。</p>\n<p>:root { –color: blue; }</p>\n<p>第一个div是绿色green。毋庸赘述。在div`上有一个颜色变量定义。</p>\n<p>div { –color: green; }</p>\n<p>使用ID值为alert 定义的 div，不是绿色，而是红色red。</p>\n<p>#alert { –color: red; }</p>\n<p>The ID has a direct variable scoping. As such, the value within the definition will override the others. The selector #alert is more specific. 这个ID有一个更直接的变量范围。因此，这个范围内定义的变量值会覆盖其他的变量值。#alert ID选择器更具体。 最后， 在ID<code>#alert</code>中的这个p 是红色red。 在第一个p 元素上，并没有变量声明。可以推测，这个元素是在根元素 <code>:root</code>以内的，因此它的颜色是蓝色。</p>\n<p>:root { –color: blue; }</p>\n<p>和其他属性一样，CSS变量也是可继承的。这个值也会从其父节点上获得。</p>\n<p>#alert { –color: red; }</p>\n<p><img src=\"http://file.w3cbest.com/file/images/1_lGioVJqkKo0N91R9eMvywQ.png\"></p>\n<h2 id=\"解决循环依赖\"><a href=\"#解决循环依赖\" class=\"headerlink\" title=\"解决循环依赖\"></a>解决循环依赖</h2><p>循环依赖通常会在下面几种情况下发生： 变量需要依赖其自身值。也就是说，定义时就使用了var()引用其值。</p>\n<p>:root {<br>    –m: var(–m)<br>}<br>body {<br>    margin: var(–m)<br>}</p>\n<p>多个变量相互引用时。</p>\n<p>:root {<br>    –one: calc(var(–two) + 10px);<br>    –two: calc(var(–one) - 10px);<br>}</p>\n<p>请注意，不要在代码中创建这样的循环引用。</p>\n<h2 id=\"使用无效变量会怎样？\"><a href=\"#使用无效变量会怎样？\" class=\"headerlink\" title=\"使用无效变量会怎样？\"></a>使用无效变量会怎样？</h2><p>语法错误会被忽略，但是无效的使用<code>var()</code>会导致错误的初始值或者是继承到有问题的值。 看下面的代码：</p>\n<p>:root {–color: 20px;}<br>p {background-color: red;}<br>p {background-color: var(–color);}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/0_fa59XRLGKo5Rsqm4.png\"> <code>--color</code>会被代入<code>var()</code>，但是这条属性值，<code>background-color: 20px</code> 在变量代入后是无效的（译者注：错误的颜色值）。因为<code>backgroud-color</code>不是继承属性，那么它的值就会是这个属性的初始值 <code>transparent</code>。 <img src=\"http://file.w3cbest.com/file/images/0_uVic7R1o96n-T1l5.png\"> 请注意，如果你直接写<code>backgroud-color: 20px</code>，那么这个属性声明就是无效的。这一行之前的定义就正常工作了。 <img src=\"http://file.w3cbest.com/file/images/0_9HzCVQdyvqeo5dZq.png\"></p>\n<h2 id=\"创建单一标记时，请注意\"><a href=\"#创建单一标记时，请注意\" class=\"headerlink\" title=\"创建单一标记时，请注意\"></a>创建单一标记时，请注意</h2><p>当你设置一个类似下面的属性的变量时，20px就被编译成一个单一标记。</p>\n<p>font-size: 20px</p>\n<p>简单理解就是，20px 就是一个单独的整体。 使用CSS变量构建独立单一标记需要十分小心。 例如，看下面的代码：</p>\n<p>:root {<br>–size: 20<br>}</p>\n<p>div {<br>font-size: var(–size)px **/*错了*/**<br>}</p>\n<p>你也许会认为，font-size的值是20px，但你错了。浏览器会解析成 20 px， 注意20和px之间的空格。 因此，如果你一定需要创建独立标记，那么就一定要用变量表示这个整体。例如： <code>--size: 20px</code>,或者是用 <code>calc()</code> 这个函数，例如， <code>calc(var(--size) * 1px)</code>，然后其中的<code>--size</code> 值就是20。 不要着急。如果你还不太能理解这一点，后面的例子中我会解释的更具体。</p>\n<h2 id=\"一起来动手吧！\"><a href=\"#一起来动手吧！\" class=\"headerlink\" title=\"一起来动手吧！\"></a>一起来动手吧！</h2><p>下面就是本文里我们最期待的一部分。 我会带着大家做一些有用的例子，把实际应用中的概念都过一遍。我们开始吧。</p>\n<h3 id=\"例1-使用CSS变量创建可变组件\"><a href=\"#例1-使用CSS变量创建可变组件\" class=\"headerlink\" title=\"例1: 使用CSS变量创建可变组件\"></a>例1: 使用CSS变量创建可变组件</h3><p>假设你需要创建两个不同的按钮。基本样式相同，只有一点小小的区别。 <img src=\"http://file.w3cbest.com/file/images/1_qElS3I43_SdpdRA8-m2iew.gif\"> 在这个例子里，不同的属性只有 <code>background-color</code>和<code>border-color</code> 。 那怎样处理这种情况呢？下面是一种典型的解决方案： 创建一个基类，比如 .btn，然后加上其他的不同类，例如：</p>\n<p><button class=\"btn\">Hello</button><br><button class=\"btn red\">Hello</button></p>\n<p>.btn 包含了按钮的基本样式，例如：</p>\n<p>.btn {<br>padding: 2rem 4rem;<br>border: 2px solid black;<br>background: transparent;<br>font-size: 0.6em;<br>border-radius: 2px;<br>}</p>\n<p>/*on hover */<br>.btn:hover {<br>cursor: pointer;<br>background: black;<br>color: white;<br>}</p>\n<p>那按钮样式如何变化呢?像这样：</p>\n<p>/* variations */<br>.btn.red {<br>border-color: red<br>}</p>\n<p>.btn.red:hover {<br>background: red<br>}</p>\n<p>你看，这里就有重复的代码了吧？这样也好，但使用CSS变量可以更简洁。</p>\n<h2 id=\"第一步是什么呢？\"><a href=\"#第一步是什么呢？\" class=\"headerlink\" title=\"第一步是什么呢？\"></a>第一步是什么呢？</h2><p>把变化的颜色值用CSS变量定义出来，不要忘记加默认值！</p>\n<p>.btn {<br>padding: 2rem 4rem;<br>border: 2px solid var(–color, black);<br>background: transparent;<br>font-size: 0.6em;<br>border-radius: 2px;<br> }</p>\n<p> /*on hover*/<br>.btn:hover {<br>cursor: pointer;<br>background: var(–color, black);<br>color: white;<br>}</p>\n<p>你这样设置<code>background: **var(--color, black)**</code>时，也就是说把背景设置为变量–color的值。如果这个变量不存在，那就用默认值黑色**black**替代 。 这就是设置默认值的方法，和JavaScript或者其他语言一样。 下面是有趣的部分了。 有了变量，你就可以像下面这样设置新的变量值了：</p>\n<p>.btn.red {<br>–color: red<br>}</p>\n<p>这就可以了。如果元素class中使用了<code>.red</code>，那么浏览器就能注意到不同的<code>--color</code>值，这样就使得不同的按钮有不同的颜色了。 这样你就可以省下来很多时间，创建可复用的组件了。 下图是简单的对比： <img src=\"http://file.w3cbest.com/file/images/1_bdT9ITBx1wpXjLOYoWBI7w.png\"> 哦，对了，如果你有更多的变量，那还能省下很多打字的时间： <img src=\"http://file.w3cbest.com/file/images/1_erZb3Z5FtTIR8EV9fl0QOA.png\"></p>\n<h3 id=\"例2：使用CSS变量制作网站主题\"><a href=\"#例2：使用CSS变量制作网站主题\" class=\"headerlink\" title=\"例2：使用CSS变量制作网站主题\"></a>例2：使用CSS变量制作网站主题</h3><p>我想你肯定遇到过这样的情况。有主题的网站可以让用户有自己定制的感觉，就像是由他们来控制一样。 下面这个例子就是我们要做的。   <img src=\"http://file.w3cbest.com/file/images/1_r2TrlsC-gWRD5Hu6Tp2gjQ.gif\"> 那么CSS变量是如何让这件事变得简单一点的呢？ 让我们一起来看。 在这之前，我想提醒你，这个例子非常重要。在这个例子里，我会介绍如何使用JavaScript更新CSS变量。超有趣！你肯定会喜欢的。</p>\n<h2 id=\"我们实际要做的\"><a href=\"#我们实际要做的\" class=\"headerlink\" title=\"我们实际要做的\"></a>我们实际要做的</h2><p>CSS变量的美妙是它们的互动性。一旦它们的值发生了变化，对应CSS的属性也会相应的进行更新。 下图从概念上解释了在本例中这个过程是如何发生的 。 <img src=\"http://file.w3cbest.com/file/images/1_ZONC-xXCXnGc8nr_QMv8rg.png\"> 所以，我们需要增加一些JavaScript来监听点击事件。 在这个例子里，背景颜色和文字颜色是基于CSS变量的。 当你点击上面任何一个按钮时，它们就将对应的CSS变量设置成另一种颜色。于是，页面的背景颜色也更新了。 你看，这就是所有的内容了。 哦，还有一件事。 当我说把CSS变量设置成另一个值的时候，这又是怎样做到的呢？ <img src=\"http://file.w3cbest.com/file/images/1_FeTfEPsJuDQNGDuZQQBIew.png\"> 即便是设置在inline style中，CSS变量也会生效。和JavaScript一起，我们就可以控制整个root文档，这样也就能设置CSS变量的值了。 理解了么？ 不过前面都是说的，下面我们来看代码。</p>\n<h2 id=\"初始代码\"><a href=\"#初始代码\" class=\"headerlink\" title=\"初始代码\"></a>初始代码</h2><p>最初代码像这样： <div class=\"theme\"> <button value=\"dark\">dark</button> <button value=\"calm\">calm</button> <button value=\"light\">light</button> </div> <article> . . . </article> 这段代码由三个button和一个 class是<code>.theme</code> 父元素组成。为了简洁一点我去掉了中间的内容部分，只用article元素替代。article元素内就是页面内容。</p>\n<h2 id=\"页面样式\"><a href=\"#页面样式\" class=\"headerlink\" title=\"页面样式\"></a>页面样式</h2><p>这个小项目的成功点就是页面的样式。技巧其实很简单。 没必要为每种风格设置<code>background-color</code>和 <code>color</code>，我们只需要使用变量来设置即可。 就像下面这样：</p>\n<p>body {<br>    background-color: **var(–bg, white)**;<br>    color: **var(–bg-text, black)**<br>}</p>\n<p>这样做目的很明显。点击每个button时，这个页面的背景和文字颜色就可以随之变化。 基于这个改变，整体的页面就很容易改变了。小菜一碟。 <img src=\"http://file.w3cbest.com/file/images/1_HmDLDbOPHpEE2F8x4aSDYA.png\"> 接下来我们就来增加处理更新值的JavaScript脚本部分。</p>\n<h2 id=\"涉及JavaScript的部分\"><a href=\"#涉及JavaScript的部分\" class=\"headerlink\" title=\"涉及JavaScript的部分\"></a>涉及JavaScript的部分</h2><p>接下来我会把项目需要的JavaScript逐步分析。</p>\n<p>const root = document.documentElement<br>const themeBtns = document.querySelectorAll(‘.theme &gt; button’)<br>themeBtns.forEach((btn) =&gt; {<br>  btn.addEventListener(‘click’, handleThemeUpdate)<br>})</p>\n<p>function handleThemeUpdate(e) {<br>  switch(e.target.value) {<br>    case ‘dark’:<br>      root.style.setProperty(‘–bg’, ‘black’)<br>      root.style.setProperty(‘–bg-text’, ‘white’)<br>      break<br>    case ‘calm’:<br>       root.style.setProperty(‘–bg’, ‘#B3E5FC’)<br>       root.style.setProperty(‘–bg-text’, ‘#37474F’)<br>      break<br>    case ‘light’:<br>      root.style.setProperty(‘–bg’, ‘white’)<br>      root.style.setProperty(‘–bg-text’, ‘black’)<br>      break<br>  }<br>}</p>\n<p>别被吓到了。代码其实比你想的简单的多。 首先，创建一个对root元素的引用， <code>const root = document.documentElement</code>。 这里的root元素就是 HTML。一会你就明白为什么这一点很重要了。如果你很好奇，就先理解这是为了设置CSS变量使用的。 然后，对不同button也保存对应的引用， <code>const themeBtns = document.querySelectorAll(&#39;.theme &gt; button&#39;)</code>。 <code>querySelectorAll</code>会返回一个可以遍历的数组结构。这样我们就可以遍历每个按钮给它们增加对应的点击事件。 就像这样：</p>\n<p>themeBtns.forEach((btn) =&gt; {<br>    btn.addEventListener(‘click’, handleThemeUpdate)<br>})</p>\n<p><code>handleThemeUpdate</code> 在哪呢？接下来就是。 点击按钮时，对应的<code>handleThemeUpdate</code>就会触发。因此要记下哪个按钮点击了，应该执行对应什么样的操作。 因此，这里用了一个<code>switch</code>的<code>operator</code>，不同的按钮的点击事件在这里有了区别。 现在你再回去看一下前面的JavaScript的代码。你应该能更好的理解它了。</p>\n<h3 id=\"例3-创建CSS变量盒-1\"><a href=\"#例3-创建CSS变量盒-1\" class=\"headerlink\" title=\"例3: 创建CSS变量盒\"></a>例3: 创建CSS变量盒</h3><p>假如你忘了，那再提一下，我们要做的例子是这样的: <img src=\"http://file.w3cbest.com/file/images/1_E6H-wT6a0BDR9OJK7Z0dTA.gif\"> 请记住，盒子的颜色是动态变化的，盒子可以根据用户的输入进行3D的旋转。 <img src=\"http://file.w3cbest.com/file/images/1_iy_MjZVlp-H0KUQa7H7fUg.gif\"> 你可以在<a href=\"https://codepen.io/ohansemmanuel/full/EoBLgd/\">Codepen</a>上玩一下。 这是使用CSS变量和JavaScript共同创造出的一个即有交互性又很美妙的例子。 我们一起看看怎么做的。</p>\n<h3 id=\"代码片段\"><a href=\"#代码片段\" class=\"headerlink\" title=\"代码片段\"></a>代码片段</h3><p>我们需要下面一些元素：</p>\n<ol>\n<li> 一个范围输入</li>\n<li> 一个容器来显示说明部分</li>\n<li> 一个部分用来列出不同的盒子和每一种输入</li>\n</ol>\n<p><img src=\"http://file.w3cbest.com/file/images/1_39k9sbEsldtRtJ1-Woq0rQ.png\"> 代码部分很简单，下面就是:</p>\n<main class=\"booth\">\n    <aside class=\"slider\">\n        <label>Move this ? </label>\n        <input class=\"booth-slider\" type=\"range\" min=\"-50\" max=\"50\" value=\"-50\" step=\"5\"/>\n    </aside>\n\n<pre><code>&lt;section class=&quot;color-boxes&quot;&gt;\n  &lt;div class=&quot;color-box&quot; id=&quot;1&quot;&gt;&lt;input value=&quot;red&quot;/&gt;&lt;/div&gt;\n  &lt;div class=&quot;color-box&quot; id=&quot;2&quot;&gt;&lt;input/&gt;&lt;/div&gt;\n  &lt;div class=&quot;color-box&quot; id=&quot;3&quot;&gt;&lt;input/&gt;&lt;/div&gt;\n  &lt;div class=&quot;color-box&quot; id=&quot;4&quot;&gt;&lt;input/&gt;&lt;/div&gt;\n  &lt;div class=&quot;color-box&quot; id=&quot;5&quot;&gt;&lt;input/&gt;&lt;/div&gt;\n  &lt;div class=&quot;color-box&quot; id=&quot;6&quot;&gt;&lt;input/&gt;&lt;/div&gt;\n&lt;/section&gt;\n\n&lt;footer class=&quot;instructions&quot;&gt;\n    Move the slider&lt;br/&gt;\n    Write any color in the red boxes \n&lt;/footer&gt;\n</code></pre>\n</main>\n\n<p>需要注意以下几点：</p>\n<ol>\n<li> 输入的范围是从<code>-50</code>到<code>50</code>，步长是<code>5</code>。而且，最小值是<code>-50</code>。</li>\n<li> 如果你不太清楚这个范围输入是什么原理，可以在 w3schools找到相关说明。</li>\n<li> 注意外层带有<code>.color-boxes</code>类的容器，它包含了<code>.color-box</code>的容器，再其中就是各种输入了。</li>\n<li> 或许应该提一下，第一个输入框的默认值是红色。</li>\n</ol>\n<p>理解了页面的结构，接下来我们看一下页面样式： <img src=\"http://file.w3cbest.com/file/images/1_LbgNgLeTjACXCfDBExkqgg.png\"></p>\n<ol>\n<li> 首先把<code>.slider</code>和<code>.instructions</code>的元素移出文档流，进行绝对定位。</li>\n<li> 然后给body元素添加日出的背景颜色，再用一朵花的背景图做装饰，放在页面的左下角。</li>\n<li> 然后把<code>color-boxes</code>居中对齐。</li>\n<li> 接下来给<code>color-boxes</code>增加样式。</li>\n</ol>\n<p>我们一起来深入一下细节。下面的代码完成的是第一个任务。</p>\n<p>/* Slider */<br>.slider,<br>.instructions {<br>    position: absolute;<br>    background: rgba(0,0,0,0.4);<br>    padding: 1rem 2rem;<br>    border-radius: 5px<br>}<br>.slider {<br>    right: 10px;<br>    top: 10px;<br>}<br>.slider &gt; * {<br>    display: block;<br>}</p>\n<p>/* Instructions */<br>.instructions {<br>    text-align: center;<br>    bottom: 0;<br>    background: initial;<br>    color: black;<br>}</p>\n<p>这段代码非常简单。我想你肯定能读懂，如果不懂就发评论或者发推。 给 body元素加上样式就复杂一些了。希望你能很好的理解这部分CSS。 因为我们需要设置元素的背景颜色和背景图像，那么我们最好使用简化的background属性来增加多种不同的背景。代码如下：</p>\n<p>body {<br>    margin: 0;<br>    color: rgba(255,255,255,0.9);<br>    background: url(‘<a href=\"http://bit.ly/2FiPrRA&#39;\">http://bit.ly/2FiPrRA&#39;</a>) 0 100%/340px no-repeat, var(–primary-color);<br>    font-family: ‘Shadows Into Light Two’, cursive;<br>}</p>\n<p>url部分设置向日葵图片的链接。 接下来<code>0``100%</code>代表图像在背景中的位置。 这里有对于CSS中background属性定位的具体阐释：</p>\n<p><img src=\"http://file.w3cbest.com/file/images/1_uFlBKNdQ-FOcZ-XaACi4uA.png\"> 来源：<a href=\"http://bit.ly/learn_css\">the advanced guide to CSS</a></p>\n<p><img src=\"http://file.w3cbest.com/file/images/1_NOPEnEV_H2RB8XYFxEcFpA.png\"> 来源：<a href=\"http://bit.ly/learn_css\">the advanced guide to CSS</a></p>\n<p>在斜线后的另一部分是代表<code>background-size</code>，这个值是340px。如果这个值小一些，那图片也会更小一点。 你也许会想no-repeat是什么意思，它意味着背景不允许重复。 最后，逗号之后的部分就是第二种背景声明。这次我们把<code>background-color</code>设置成<code>var(primary-color)</code>。 哦，它是一个变量。 这就意味着你需要定义这个变量，就像这样：</p>\n<p>:root {<br>    –primary-color: rgba(241,196,15 ,1)<br>}</p>\n<p>现在的颜色是日出的黄色。不是什么大问题。接下来我们会设置更多的变量。 然后，把<code>color-boxes</code>居中对齐。</p>\n<p>main.booth {<br>    min-height: 100vh;<br>    display: flex;<br>    justify-content: center;<br>    align-items: center;<br>}</p>\n<p>主要容器是布局设置成flex，然后直接将子元素放在页面中间， 也就是接下来<code>color-box</code>的部分。 下面我们把容器和子元素美化一下。 首先是子元素：</p>\n<p>.color-box {<br>    padding: 1rem 3.5rem;<br>    margin-bottom: 0.5rem;<br>    border: 1px solid rgba(255,255,255,0.2);<br>    border-radius: 0.3rem;<br>    box-shadow: 10px 10px 30px rgba(0,0,0,0.4);<br>}</p>\n<p>这样就够了。还加了一个漂亮的阴影。这样就有了酷炫的效果了。 不过这还不够。还有<code>container-boxes</code>容器的样式：</p>\n<p>/* Color Boxes */<br>.color-boxes {<br>    background: var(–secondary-color);<br>    box-shadow: 10px 10px 30px rgba(0,0,0,0.4);<br>    border-radius: 0.3rem;<br>    transform: perspective(500px) rotateY( calc(var(–slider) * 1deg));<br>    transition: transform 0.3s<br>}</p>\n<p>棒！ 这样就好多了。 让我们细化一下。 下面是简单的部分：</p>\n<p>.color-boxes {<br>    background: **var(–secondary-color)**;<br>    box-shadow: 10px 10px 30px rgba(0,0,0,0.4);<br>    border-radius: 0.3rem;<br>}</p>\n<p>你知道意思，对吧？ 这里用了一个新的变量。因此我们需要在root选择器里加上定义。</p>\n<p>:root {<br>    –primary-color: rgba(241,196,15 ,1);<br>    –secondary-color: red;<br>}</p>\n<p>这里的<code>secondary-color</code>是红色。这样就使得容器有一个红色的背景。 但你可能对下面的部分感到疑惑，</p>\n<p>/* Color Boxes */<br>.color-boxes {<br>    transform: perspective(500px) rotateY( calc(var(–slider) * 1deg));<br>    transition: transform 0.3s<br>}</p>\n<p>我们可以暂时简化上面代码里<code>transfrom</code>的属性。 <img src=\"http://file.w3cbest.com/file/images/1_oNaNYDRDRZPSEga9Oo4bPw.png\"> 例如：</p>\n<p>transform: perspective(500px) rotateY( 30deg);</p>\n<p><code>transform</code>合并了两个不同的函数。一个是透视，一个是以Y轴为标准的旋转。 不过，<code>perspective</code>和<code>rotateY</code>又起了什么样的作用呢？ <code>perspective()</code>函数可以使元素在3D的空间内变形。它会激活一个三维空间，使元素增加一个z轴。 你可以在 codrops看到更多关于<code>perspective</code>函数的介绍。 那么rotateY函数又有什么用呢？ 激活了三维空间后，元素就有了x，y，z三个轴。 rotateY函数就意味着把元素以 Y 轴为中心进行旋转。 codrops的这幅图可以帮我们直观的理解这一点。 <img src=\"http://file.w3cbest.com/file/images/1_kFdzSl4wwyPJt_Crmbtuow.png\"></p>\n<p><a href=\"https://tympanus.net/codrops/css_reference/transform/#section_rotate3d\">Codrops</a></p>\n<p>希望这能帮你拨开云雾见天日。 回到前面的主题。 <img src=\"http://file.w3cbest.com/file/images/1_oNaNYDRDRZPSEga9Oo4bPw.png\"> 移动滑块的时候，你知道是哪个函数影响了<code>.container-box</code>的旋转效果么？ 是的，就是这个 rotateY函数被调用了。因此这个盒元素就沿着Y轴进行旋转。 因为这个值可以通过JavaScript传给函数，所以这个值就用一个变量来表示。 <img src=\"http://file.w3cbest.com/file/images/1_oL_Ik1Xg_ByTc28g2B1ESg.png\"> 那为什么要用这个变量乘以1deg呢？ 按通常的经验来说，也为了自由定义变量，我们建议在创建变量时，不带单位。 这样你就可以在任何需要使用单位的时候通过calc函数达成目标。 <img src=\"http://file.w3cbest.com/file/images/1_jsB27oUUYY48n3s9wAmd_Q.png\"> 这就使得你可以在需要时任意使用了。它即可以转化成deg， 也可以转化成一个相对于用户视窗单位vw的比例 ，你可以想怎么做就怎么做。 在这个例子中，我们把一个数字通过乘以一个1deg的值，得到了一个有单位的数值。 <img src=\"http://file.w3cbest.com/file/images/1_5j1qhUmE2pB99qw17Zp4iA.png\"> 因为CSS并不理解数学计算，因此你需要把这个算术放在calc函数里才能得到CSS属性需要的对应数值。 这些都完成，我们就可以开始下一步了。现在我们要用JavaScript来更新这个变量值。 不过还剩下一点CSS的代码。这就是了：</p>\n<p>/* Handle colors for each color box */<br>.color-box:nth-child(1) {<br>    background: var(–bg-1)<br>}<br>.color-box:nth-child(2) {<br>    background: var(–bg-2)<br>}<br>.color-box:nth-child(3) {<br>    background: var(–bg-3)<br>}<br>.color-box:nth-child(4) {<br>    background: var(–bg-4)<br>}<br>.color-box:nth-child(5) {<br>    background: var(–bg-5)<br>}<br>.color-box:nth-child(6) {<br>    background: var(–bg-6)<br>}</p>\n<p>这又是什么鬼? 首先，<code>nth-child</code>选择器用来选择不同的子元素。 <img src=\"http://file.w3cbest.com/file/images/1_T5oqa3Kh5ChIcgi5ldqXKg.png\"> 这里我们需要看深入一点。我们已经了解需要更新每个盒子的颜色，也知道每盒子的颜色需要用一个变量以便使用JavaScript更新，对把？ 因此，我们就这样设置：</p>\n<p>.color-box:nth-child(1) {<br>    background: var(–bg-1)<br>}</p>\n<p>简单吧？ 不过还有一个问题，如果这个变量不存在，那会怎么样呢？ 我们需要默认值。 这样就没问题了：</p>\n<p>.color-box:nth-child(1) {<br>    background: var(–bg-1, red)<br>}</p>\n<p>不过在这个实际的例子里，我选择不提供任何默认值。 如果这个变量的属性值不合法，那么这个属性值就会用其初始值。 也就是说，如果 <code>--bg-1</code>不合法或者无效，那么背景就是它的初始值，也就是透明色。 没有明确指定时，初始值就是这个属性的默认值。例如，如果你不设置元素的<code>background-color</code>，那它就是默认就是透明的。 初始值也是一种默认值。 开始写JavaScript 需要写的JavaScript的部分非常少。 首先让我们处理滑块。 五行就够了！</p>\n<p>const root = document.documentElement<br>const range = document.querySelector(‘.booth-slider’)</p>\n<p>//as slider range’s value changes, do something<br>range.addEventListener(‘input’, handleSlider)</p>\n<p>function handleSlider (e) {<br>    let value = e.target.value<br>    root.style.setProperty(‘–slider’, value)<br>}</p>\n<p>很简单吧？ 不过我还是要解释一下，以防我把你搞糊涂了。 首先，保存一个对slider元素的引用，<code>const range = document.querySelector(&#39;.booth-slider&#39;)</code>。 <img src=\"http://file.w3cbest.com/file/images/1_bQwZp0psRdiNn2harZW-HQ.png\"> 然后给它增加一个事件，用来处理滑块值变化，<code>range.addEventListener(&#39;input&#39;, handleSlider)</code>。 接下来就是这个回调事件handleSlider：</p>\n<p>function handleSlider (e) {<br>    let value = e.target.value<br>    root.style.setProperty(‘–slider’, value)<br>}</p>\n<p><code>root.style.setProperty(&#39;--slider&#39;, value)</code> 是指把root元素的style属性设置成对应值。 处理颜色变化 这和处理滑块值的变化一样简单。下面就是：</p>\n<p>const inputs = document.querySelectorAll(‘.color-box &gt; input’)<br>//as the value in the input changes, do something.<br>inputs.forEach(input =&gt; {<br>    input.addEventListener(‘input’, handleInputChange)<br>})</p>\n<p>function handleInputChange (e) {<br>    let value = e.target.value<br>    let inputId = e.target.parentNode.id<br>    let inputBg = `–bg-${inputId}`<br>    root.style.setProperty(inputBg, value)<br>}</p>\n<p>保存一个对所有输入框的引用， const inputs = document.querySelectorAll(‘.color-box &gt; input’)。 为每一个输入框增加一个事件处理：</p>\n<p>inputs.forEach(input =&gt; {<br>    input.addEventListener(‘input’, handleInputChange)<br>})</p>\n<p>接下来是 handleInputChange 函数：</p>\n<p>function handleInputChange (e) {<br>    let value = e.target.value<br>    let inputId = e.target.parentNode.id<br>    let inputBg = `–bg-${inputId}`<br>    root.style.setProperty(inputBg, value)<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/1_A3e4duLT1V1-8_NqVF1DGg.png\"> 嗯… 这就没了！ 样例做完了！ 我怎么能忘记这些呢？ 我写完这篇文章还改了初稿之后，才想起来我还没提到浏览器的兼容性。所以，让我补上这一部分。 CSS变量的浏览器支持并不差。可以说相当好了，几乎所有的现代浏览器都能支持（我写这篇文章的时候超过87%）。 <img src=\"http://file.w3cbest.com/file/images/20190118223123.jpg\"></p>\n<p><a href=\"https://caniuse.com/#search=css%20var\">caniuse</a></p>\n<p>所以，你可以在生产环境中使用么？我当然说是啦！不过你还是要检查一下适用的比例。 往好的方向面看，你也可以使用 Myth类似的预编译器。它可以把你现在使用的CSS变成未来可期的CSS，超酷的，对吧？ 如果你有用过postCSS的经验，那这也是一个现在使用未来CSS的不错的方法。这里有一些使用postCSS的例子。 好啦，我都讲完了。 原文翻译：<a href=\"https://medium.freecodecamp.org/everything-you-need-to-know-about-css-variables-c74d922ea855\">https://medium.freecodecamp.org</a></p>\n","categories":["HTML/CSS"],"tags":["css3","css var()","CSS Variables","前端开发","var()","web开发","设计"]},{"title":"如何有效的学习 CSS","url":"/2019/05/19/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%A6%E4%B9%A0-css/","content":"<p>很多人想让我给他们推荐有关CSS部分的教程，或者问我如何学习CSS。 我也看到很多人对CSS的部分内容感到困惑，一部分原因是由于对语言的过时认识。 鉴于CSS在过去几年中发生了相当大的变化，这是一个更新知识的好时机。 即使CSS只是你所做工作的一小部分（因为你使用其他技术栈），CSS是你最终希望在屏幕上显示的结果，所以值得合理去学习。 因此，本文旨在概述CSS的关键基础和资源，以便进一步阅读现代CSS开发的关键领域。 其中许多资源在Smashing杂志上已经有了，但我也选择了其他一些资源，也有人关注CSS的关键领域。 这不是一本完整的初学者指南或旨在涵盖所有知识点。 我的目标是覆盖现代CSS的广度，同时重点关注几个关键领域，将帮助你理解CSS的其他部分。</p>\n<h2 id=\"语言基础知识\"><a href=\"#语言基础知识\" class=\"headerlink\" title=\"语言基础知识\"></a>语言基础知识</h2><p>对于CSS的大部分内容，你不需要特意去学习属性和值，你可以在需要时查找它们。 然而，CSS中一些基础知识没有掌握好，你将很难去理解它。 这些基础知识值得你花时间去理解，从长远看，它会帮你节省很多时间和少走弯路。</p>\n<h2 id=\"选择器，不仅仅有类\"><a href=\"#选择器，不仅仅有类\" class=\"headerlink\" title=\"选择器，不仅仅有类\"></a>选择器，不仅仅有类</h2><p>选择器的表现如标题所说的，它选择文档的某些部分，以便你可以将CSS规则应用于它。 大多数人都熟悉使用 <code>class</code>，或在 直接使用HTML元素设置样式，比如 <code>body</code>，但是还有很多更高级的选择器可以根据文档中的位置选择元素，直接选择位于元素之后的元素，或选择表格中的奇数行。 这些选择器是CSS3规范的一部分（你可能听说过它们被称为第3级选择器）具有出色的<a href=\"https://caniuse.com/#feat=css-sel3\">浏览器支持</a>。 有关可以使用的各种选择器的详细信息，请参阅 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors\">MDN</a> 参考。 有些选择器的行为就好像你已经将类应用于文档中的某些内容。 例如<code>p:first-child</code>就像你在第一个<code>p</code>元素中添加了一个类一样，这些被称为 <code>伪类选择器</code>。 伪元素选择器就像动态插入一个元素一样，例如<code>::first-line</code>的表现与用<code>span</code> 包裹第一行文本类似。 但是，如果该行的长度发生变化，它将重新应用，如果插入该元素则不会出现这种情况。 这些选择器可能会相当复杂。 在下面的CodePen中是一个用伪类链接的伪元素的例子。 我们使用<code>:first-child</code>伪类定位第一个p元素，然后<code>::first-line</code>选择器选择该元素的第一行，就好像在第一行周围添加了一个<code>&lt;span&gt;</code>以使其变为粗体和改变颜色。</p>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/wRdJdQ/\">first-line of first-child</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"继承和层叠\"><a href=\"#继承和层叠\" class=\"headerlink\" title=\"继承和层叠\"></a>继承和层叠</h2><p>层叠是指当元素应用了多个样式规则，哪个规则优先应用。 如果你曾经遇到过无法理解为什么某些CSS似乎没有应用的情况，那可能是层叠没有运用好。 层叠与继承紧密相关，继承定义了子元素可以继承父元素的样式属性。 它还与特异性有关，不同的选择器具有不同的特异性，当有几个选择器可以应用于一个元素时，继承可以决定应用哪个规则。</p>\n<blockquote>\n<p>注意：为了理解所有这些内容，我建议阅读MDN CSS简介中的 <a href=\"https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Cascade_and_inheritance\">层叠和继承</a>。</p>\n</blockquote>\n<p>如果你正在尝试将一些CSS应用于一个元素，那么你的浏览器开发者工具是开始最好的地方。看看下面的例子，我用元素选择器 <code>h1</code> 将 <code>h1</code> 标题设置为橙色。同时，我也使用类选择器设置<code>h1</code> 设置为紫色。 由于类更具体，因此<code>h1</code>是紫色的。 在开发者工具中，您可以看到元素选择器被划掉，因为它没有被应用。 一旦你看到浏览器正在获取你的CSS（但其他东西已经推翻了它），那么你可以开始找出原因。</p>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/yGbMoL/\">specificity</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p><img src=\"http://file.w3cbest.com/file/images/smashing-css-specificity.png\"></p>\n<h2 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a>盒模型</h2><p>CSS里一切都是盒子。 屏幕上显示的所有内容都有一个框，盒模型描述了如何计算该框的大小 - 将外边距，内边距和边框考虑进去。 标准的CSS框模型接受给定元素的宽度，然后将内边框和边框添加到该宽度上——这意味着元素占用的空间大于给定的宽度。 最近，我们已经能够选择使用IE盒模型，使得元素上的给定宽度作为屏幕上可见元素的宽度。 任何内边距或边框都会从边缘插入框的内容。 这对许多布局更有意义。 在下面的演示中，我有两个盒子。 两者的宽度均为200像素，边框为5像素，内边距为20像素。 第一个框使用标准框模型，因此占用总宽度为250像素，第二个框使用IE盒模型，因此实际上是200像素宽。</p>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/xmdqjd/\">box models</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>浏览器开发者工具可以再次帮助你了解正在使用的盒子模型。 在下图中，我使用火狐浏览器的开发者工具使用默认的内容框框模型检查框。 工具告诉我这是正在使用的盒模型，我可以看到大小以及如何将边框和内边框添加到指定的宽度。 <img src=\"http://file.w3cbest.com/file/images/smashing-css-box-model.png\"></p>\n<blockquote>\n<p>注意：在IE6之前，Internet Explorer<a href=\"https://en.wikipedia.org/wiki/Internet_Explorer_box_model_bug\">使用IE盒模型</a>，内边框和边框插入给定宽度的内容里。 所以有一段时间浏览器使用不同的盒模型！ 如果今天的互操作性问题感到沮丧，现在已经有所改善，那么我们就不会处理浏览器以不同的方式计算元素的宽度。</p>\n</blockquote>\n<p>在 <a href=\"https://css-tricks.com/box-sizing/\">CSS Tricks</a> 里，有关于盒模型和盒子尺寸的很好的解释，并解释了在你的网站中全局使用<a href=\"https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/\">IE盒模型</a>的最佳方法。</p>\n<h2 id=\"标准流\"><a href=\"#标准流\" class=\"headerlink\" title=\"标准流\"></a>标准流</h2><p>如果你的文档内容用一些HTML标记，你的文档将具有可读性。标题和段落会另起新的一行，单词组成句子时，它们之间有一个空格。标记是用来格式化的，像 <code>em</code> 不会破坏句子的流。 句子会表现<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout\">标准流</a>，或块流布局。句子的每个部分都被描述为“在流中”，它知道句子其余内容，所以不会重叠。 如果你去了解，而不是去反对这种行为，你会变得更加轻松。这是为什么从正确标记的<a href=\"https://www.brucelawson.co.uk/2018/the-practical-value-of-semantic-html/\">HTML文档</a>开始很有意义的原因之一，由于浏览器遵守正常流和内置样式表，你的内容从可读的地方开始。</p>\n<h2 id=\"格式化上下文\"><a href=\"#格式化上下文\" class=\"headerlink\" title=\"格式化上下文\"></a>格式化上下文</h2><p>一旦文档的内容处于正常流程中，您可能希望更改其中一些内容的外观。 你可以通过更改元素的格式上下文来完成此操作。 举个一个非常简单的示例，如果你希望所有段落连在一起而不是从新行开始，你可以设置 <code>p</code> 元素的样式属性<code>display:inline</code> ，将 <code>p</code> 元素由块级元素变成内联元素。 本质上，格式化上下文定义了外部和内部类型。外部控制元素与页面上其他元素的行为，内部控制子元素的外观。例如，当你设置 <code>display:flex</code> ，你在设置外部为块格式化上下文，设置子元素为 flex 格式化上下文。 注意：最新版本的Display规范改变了 <code>display</code> 的值，显式声明外部和内部的类型。因此，将你可能会声明 <code>display:block flex;</code> （外部为 <code>block</code>，内部为 <code>flex</code>） 在 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/display\">MDN</a> 上阅读更多关于 <code>display</code>的信息</p>\n<h2 id=\"进入或离开流\"><a href=\"#进入或离开流\" class=\"headerlink\" title=\"进入或离开流\"></a>进入或离开流</h2><p>CSS中的元素被描述为“在流中”或“脱离流”。流中的元素被赋予空间，并且空间被流中的其他元素所影响。 如果通过浮动或定位元素使元素脱离流，则该元素的空间将不再受到其他流元素的影响。 对于绝对定位的元素，是最明显的。 如果你设置一个元素 <code>position: absolute</code> ，该元素会从流中脱离，你需要确保这个元素不会与流中的元素重叠，且不影响你布局的其他部分的可读性。</p>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/Ormgzj/\">out of flow: abspos</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>然而，浮动元素也会从流中脱离，但后面的元素的文本将环绕该浮动元素。你可以设置后面元素的背景颜色，你会看到他们会上升并占用了原来浮动元素原来的空间。</p>\n<p>See the Pen <a href=\"https://codepen.io/rachelandrew/pen/BvRZYw/\">Out of flow: floated</a> by rachelandrew (<a href=\"https://codepen.io/rachelandrew\">@rachelandrew</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>你可以在<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/In_Flow_and_Out_of_Flow\">MDN</a>上阅读更多有关 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/In_Flow_and_Out_of_Flow\">流中和脱离流</a> 的信息。 需要记住的重要一点是，如果从流中取出一个元素，则需要自己管理重叠，因为块流布局的常规规则不再适用。</p>\n<h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><p>十五年来，我们一直使用CSS布局，但没有设计一套布局系统。这已经改变了。 我们现在拥有功能完备的布局系统，其中包括 Grid 和 Flexbox ，还有多列布局和旧布局方法也应用于实际目的。如果你想对CSS布局还不熟悉，你可以阅读 MDN 上的<a href=\"https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout\">布局教程</a>，或阅读我发表在Smashing杂志上的文章 《<a href=\"https://www.smashingmagazine.com/2018/05/guide-css-layout/\">开始学习CSS布局</a>》。 不要认为grid和flexbox等方法在某种程度上是竞争的。为了更好地使用布局，你有时会发现组件最好作为 flex ，有时作为 Grid。有时，你想要多列流动布局。所有这些都是不错的选择。如果你觉得自己在与某些事物的行为方式作斗争，这通常是一个非常好的迹象，表明它可能值得退一步，尝试一种不同的方法。我们已经习惯了在CSS上做一些我们想做的事情，以至于我们可能会忘记我们还有很多其他的选择可以尝试。 布局是我的主要专业领域，我在Smashing Magazine和其他地方写了很多文章，试图开拓新的布局美化。 除了上面提到的布局文章，我在Flexbox上有一整套系列 - 《<a href=\"https://www.smashingmagazine.com/2018/08/flexbox-display-flex-container/\">从创建Flex 容器时，发生了什么</a>》。 在 <a href=\"https://gridbyexample.com/\">Grid示例</a> 上，我列出很多CSS Grid 的例子 — 以及一个视频教程。 此外 - 特别是对于设计师 - 查看 <a href=\"https://twitter.com/jensimmons\">Jen Simmons</a> 和她的《<a href=\"https://www.youtube.com/channel/UC7TizprGknbDalbHplROtag\">Layout Land</a>》视频系列。</p>\n<h2 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h2><p>通常，我会将对齐和布局分开，虽然大多数人把对齐当作 Flexbox的一部分。对齐这些属性适用于所有布局方法上，应该在上下文去理解对齐，而不是考虑 “Flexbox对齐”或“CSSGrid 对齐”。对齐属性在大体上表现一样，但不同布局方式里会有一些差异。 在MDN上，您可以深入了解 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Alignment\">盒对齐</a> 及其在Grid，Flexbox，多列和块布局中的实现方式。 在Smashing Magazine上，我有一篇文章专门介绍Flexbox中的对齐方式：<a href=\"https://www.smashingmagazine.com/2018/08/flexbox-alignment/\">你需要知道的有关Flexbox中对齐的所有内容</a>。</p>\n<h2 id=\"尺寸\"><a href=\"#尺寸\" class=\"headerlink\" title=\"尺寸\"></a>尺寸</h2><p>我在2018年花了很多时间讨论了内部和外部尺寸规范，特别是它与Grid和Flexbox的关系。在web上，我们习惯于设置尺寸为长度或百分比，这就是我们如何使用浮动来制作网格类型布局的方法。然而，现代的布局方法可以为我们做很多空间分配——如果我们允许的话。值得花时间去了解Flexbox如何分配空间(或Grid <code>fr</code> 单元如何工作)。 在Smashing Magazine上，我写了一些关于 <a href=\"https://www.smashingmagazine.com/2018/01/understanding-sizing-css-layout/\">布局中的尺寸</a> 的文章，也写了一些关于Flexbox的文章，比如 <a href=\"https://www.smashingmagazine.com/2018/09/flexbox-sizing-flexible-box/\">Flex 盒子有多大</a>?</p>\n<h2 id=\"响应式设计\"><a href=\"#响应式设计\" class=\"headerlink\" title=\"响应式设计\"></a>响应式设计</h2><p>通常，新的Grid和Flexbox布局方法意味着我们可以使用比旧方法更少的媒体查询，因为它们非常灵活，可以响应视口或组件大小的变化，而无需我们更改元素的宽度。 但是，有些地方需要添加一些断点来进一步增强设计。 以下是<a href=\"https://responsivedesign.is/\">响应式设计</a>的一些简单指南，一般情况下，对于媒体查询，请查看我的文章《<a href=\"https://www.smashingmagazine.com/2018/02/media-queries-responsive-design-2018/\">在2018年使用媒体查询进行响应式设计</a>》。我将查看媒体查询的用途，并介绍规范4的媒体查询的新功能。</p>\n<h2 id=\"字体和排版\"><a href=\"#字体和排版\" class=\"headerlink\" title=\"字体和排版\"></a>字体和排版</h2><p>与布局一样，网络上的字体使用在去年发生了巨大的变化。现在，可变字体，使单个字体文件具有无限的变化。 要了解它们是什么以及它们如何工作，请观看<a href=\"https://twitter.com/mandy_kerr\">Mandy Michael</a>的精彩简短演讲：<a href=\"https://www.youtube.com/watch?v=luAqYCd_TC8\">可变字体和网页设计的未来</a>。 另外，我会推荐<a href=\"https://twitter.com/jpamental\">Jason Pamental</a>的<a href=\"https://noti.st/jpamental/WNNxqQ/dynamic-typography-with-modern-css-variable-fonts\">动态排版与现代CSS和可变字体</a>。 为了探索可变字体和它们的功能，微软提供了一个<a href=\"https://developer.microsoft.com/en-us/microsoft-edge/testdrive/demos/variable-fonts/\">有趣的演示</a>，以及一些尝试可变字体的游乐场 - <a href=\"https://www.axis-praxis.org/\">Axis Praxis</a>是最知名的（我也喜欢<a href=\"https://play.typedetail.com/\">字体游乐场</a>）。 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fonts/Variable_Fonts_Guide\">MDN上的指南</a>将证明一开始使用可变字体是非常有用的。要了解如何为不支持可变字体的浏览器实现回退解决方案，请阅读Oliver Schondorfer的《<a href=\"https://www.zeichenschatz.net/typografie/implementing-a-variable-font-with-fallback-web-fonts.html\">使用回退Web字体实现可变字体</a>》<a href=\"https://developer.mozilla.org/en-US/docs/Tools/Page_Inspector/How_to/Edit_fonts\">Firefox DevTools字体编辑器</a>还支持使用可变字体。</p>\n<h2 id=\"变形和动画\"><a href=\"#变形和动画\" class=\"headerlink\" title=\"变形和动画\"></a>变形和动画</h2><p>CSS转换和动画绝对是我需要知道的基础。 我不经常需要使用它们，在使用时会忘记语法。 值得庆幸的是，MDN上的参考资料帮助了我，我建议从使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transforms/Using_CSS_transforms\">CSS变换</a>和使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations\">CSS动画</a>的指南开始。 <a href=\"https://twitter.com/zellwk\">Zell Liew</a>也有一篇很好的文章，为<a href=\"https://zellwk.com/blog/css-transitions/\">CSS过渡</a>提供了很好的<a href=\"https://zellwk.com/blog/css-transitions/\">解释</a>。 要发现一些可能的事情，请查看<a href=\"http://animista.net/\">Animista</a>网站。 关于动画可能令人困惑的事情之一是采取哪种方法。 除了CSS支持的内容之外，你可能还需要涉及JavaScript，SVG或Web Animation API，而这些事情往往都会被混为一谈。 在她的演讲中，选择你的<a href=\"https://aneventapart.com/news/post/choose-your-animation-adventure-by-val-head-aea-video\">动画冒险</a>记录在事件中，<a href=\"https://twitter.com/vlh\">Val Head</a>解释了这些选项。</p>\n<h2 id=\"使用速查表作为回忆，而不是学习工具\"><a href=\"#使用速查表作为回忆，而不是学习工具\" class=\"headerlink\" title=\"使用速查表作为回忆，而不是学习工具\"></a>使用速查表作为回忆，而不是学习工具</h2><p>当我提到Grid或Flexbox资源时，我经常看到回复说，如果没有特定的速查表，他们就不能使用Flexbox。我觉得把速查表作为记忆助手查找语法没有问题，我自己也出版过一些速查表。完全依赖速查表的问题是当你复制语法时，你可能会忽略为什么要这样写。然后，当你遇到属性的行为似乎不同的情况时，这种明显的不一致性似乎令人困惑，或者是语言的错误 。 如果你发现CSS在做一些非常奇怪的事情的情况下，问问为什么。创建一个简单的测试用例来强调这个问题，问问对规范更熟悉的人。我被问到的许多CSS问题都是因为人们认为属性的表现与它在现实中的表现不同。这就是为什么我经常讨论关于对齐和尺寸，因为这些地方经常会混淆。 是的，CSS中有一些奇怪的东西。它是一门经过多年进化的语言，有些东西我们无法改变，除非我们<a href=\"https://wiki.csswg.org/ideas/mistakes\">发明了时间机器</a>。然而，一旦你掌握了一些基础知识，并且理解了为什么会这样，你就可以更轻松地处理棘手的问题。 来源：<a href=\"https://www.smashingmagazine.com/2019/01/how-to-learn-css\">https://www.smashingmagazine.com</a></p>\n","categories":["HTML/CSS"],"tags":["css","css3","css3教程","css 布局","css 排版","css选择器","css伪类"]},{"title":"是时候使用CSS自定义属性了","url":"/2018/09/03/%E6%98%AF%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8css%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%BA%86/","content":"<p>在今天，css预加载已经成为了前端开发的一个标准。预加载的一个主要优势就是可以让你使用变量。它可以让你避免复制黏贴你的代码，并且简化了开发和重构。 我们用预加载来存储颜色、字体偏好，布局的细节——几乎是我们在css里面用到的所有东西。 但是预加载的变量有一些使用上的限制：</p>\n<ul>\n<li>  你不能动态的改变他们。</li>\n<li>  他们不能认出DOM结构。</li>\n<li>  他们不能用JavaScript读取和改变。</li>\n</ul>\n<p>为了解决这样或那样的问题，社区发明了CSS自定义属性。本质上这看上去和实现起来就像CSS变量。并且他们的实现方式就像他们的名字一样。 自定义属性为前端开发打开了新的大门。</p>\n<h2 id=\"申明和使用自定义属性的语法\"><a href=\"#申明和使用自定义属性的语法\" class=\"headerlink\" title=\"申明和使用自定义属性的语法\"></a>申明和使用自定义属性的语法</h2><p>在你开始学习心得预处理器或者框架的使用通常的问题是你必须学习新的语法。 每一种预处理器都使用不同的方法申明变量。通常使用一个保留字符作为开始——举个例子，Sass的$、LESS的@。 CSS自定义属性同样也是用保留字符 –来引入声明。但是好处是你只需要学一遍语法就能在所有浏览器上使用。 你可能会问，“为什么不使用已经有的语法？” <a href=\"http://www.xanthir.com/blog/b4KT0\">这是有原因的</a>。简单来说这提供了一种在任何预处理器中使用自定义属性的方式。在这种方式下我们可以使用自定义属性，预处理器也不会编译他们，所以这些属性会直接输出到编译后的CSS中。并且你也可以重复使用预处理器变量在源文件中，这个我稍后会细说。 （关于这个名字：因为他们的想法和目标非常相似，有些时候自定义属性被叫做CSS变量，尽管正确名称叫CSS自定义属性，往下读你就会明白为什么这个名字是最正确的。） 所以要声明一个变量来代替常用的CSS属性，就像color或者padding，用–连接一个自定义名称属性就可以：</p>\n<p>.box{<br>  –box-color: #4d4e53;<br>  –box-padding: 0 10px;<br>}</p>\n<p>属性的值可以是任何有效的CSS值：颜色、字符串、布局甚至是表达式。 这里是有效的自定义属性的例子：</p>\n<p>:root{<br>  –main-color: #4d4e53;<br>  –main-bg: rgb(255, 255, 255);<br>  –logo-border-color: rebeccapurple;</p>\n<p>  –header-height: 68px;<br>  –content-padding: 10px 20px;</p>\n<p>  –base-line-height: 1.428571429;<br>  –transition-duration: .35s;<br>  –external-link: “external link”;<br>  –margin-top: calc(2vh + 20px);</p>\n<p>  /* Valid CSS custom properties can be reused later in, say, JavaScript. */<br>  –foo: if(x &gt; 5) this.width = 10;<br>}</p>\n<p>以防万一你不知道什么是<a href=\"http://www.xanthir.com/blog/b4KT0\">:root</a>匹配，在HTML里他就等同与html标签，但是具有更高的特异性。 自定义属性和其他的CSS属性一样是动态的、级联的。这意味着他们能在任何时候被改变是由浏览器来进行的。 为了使用自定义的变量，你需要使用 <code>var()</code> CSS函数，并且提供属性参数：</p>\n<p>.box{<br>–box-color:#4d4e53;<br>–box-padding: 0 10px;</p>\n<p>padding: var(–box-padding);<br>}</p>\n<p>.box div{<br>color: var(–box-color);<br>}</p>\n<h2 id=\"声明和用例\"><a href=\"#声明和用例\" class=\"headerlink\" title=\"声明和用例\"></a>声明和用例</h2><p>var()函数有一个非常便利的提供默认值的方法。如果你不确信自定义属性已经被定义并且需要一个默认值，函数的第二个参数用来作为默认值的:</p>\n<p>.box{<br>–box-color:#4d4e53;<br>–box-padding: 0 10px;</p>\n<p>/* 10px is used because –box-margin is not defined. */<br>margin: var(–box-margin, 10px);<br>}</p>\n<p>你可能会希望在声明新的变量的时候能重复使用已有的变量值：</p>\n<p>.box{<br>/* The –main-padding variable is used if –box-padding is not defined. */<br>padding: var(–box-padding, var(–main-padding));</p>\n<p>–box-text: ‘This is my box’;</p>\n<p>/* Equal to –box-highlight-text:’This is my box with highlight’; */<br>–box-highlight-text: var(–box-text)’ with highlight’;<br>}</p>\n<h2 id=\"运算：-，-，-，\"><a href=\"#运算：-，-，-，\" class=\"headerlink\" title=\"运算：+，-，*，/\"></a>运算：+，-，*，/</h2><p>既然我们习惯使用预处理器和其他语言，我们也希望在处理变量的时候能使用基本运算。为了达到这个目的，CSS提供了<code>calc()</code>函数，作用当自定义属性的值被改变的时候浏览器会重新计算表达式：</p>\n<p>:root{<br>–indent-size: 10px;</p>\n<p>–indent-xl: calc(2*var(–indent-size));<br>–indent-l: calc(var(–indent-size) + 2px);<br>–indent-s: calc(var(–indent-size) - 2px);<br>–indent-xs: calc(var(–indent-size)/2);<br>}</p>\n<p>特别是当你想用一个没有单位的值得时候，就需要使用calc()函数：</p>\n<p>:root{<br>–spacer: 10;<br>}</p>\n<p>.box{<br>padding: var(–spacer)px 0; /* DOESN’T work */<br>padding: calc(var(–spacer)*1px) 0; /* WORKS */<br>}</p>\n<h2 id=\"作用域和继承\"><a href=\"#作用域和继承\" class=\"headerlink\" title=\"作用域和继承\"></a>作用域和继承</h2><p>在讨论CSS自定义属性的作用域之前，我们先来回顾一下JavaScript和预处理器的作用域。这样就能更好的认识他们之间的区别。 我们知道在JavaScript中如果在函数中使用<code>var</code>关键字声明变量，那么他的作用域就在函数里面。 同样的我们可以使用<code>let</code>和<code>const</code>关键字，但他们的作用域相对于变量的块作用域。 在JavaScript中闭包(closure)是一个可以访问外部函数变量的函数——作用域链。闭包有三个作用域链：</p>\n<ul>\n<li>  它自己的作用域（即 变量定义在大括号中）</li>\n<li>  外部函数的变量</li>\n<li>  全局变量</li>\n</ul>\n<p><img src=\"http://file.w3cbest.com/file/images/closure-780w-opt.png\"> 预处理器也是相同的，让我们用Sass来举个例子。因为这大概是今天最流行的预处理器了。 在Sass中有两种类型的变量：当前作用域变量(local) 和 全局变量。 一个全局变量能被申明在选择器和构造器（比如mixin）外，其他的变量就是当前作用域变量。 任何嵌套的代码块都可以访问封闭变量（如JavaScript）。 <img src=\"http://file.w3cbest.com/file/images/closure-scss-780w-opt.png\"> 这意味着在Sass中变量的作用域完全依赖代码的嵌套结构。 然而CSS自定义属性完全和其他的CSS属性一样使用级联方式默认继承。 当然你也不能在CSS中定义一个在选择器外的属于全局的自定义属性变量，因为这不是有效的CSS。自定义属性的全局作用域实际上就是:root的作用域，这里面定义的属性就是全局的。 让我们用已知的语法知识和Sass的例子来创建一个使用原生的CSS自定义属性的例子，首先是HTML：</p>\n<p>global</p>\n<div class=\"enclosing\">\n  enclosing\n  <div class=\"closure\">\n    closure\n  </div>\n</div>\n\n<p>然后是CSS:</p>\n<p>:root {<br>  –globalVar: 10px;<br>}</p>\n<p>.enclosing {<br>  –enclosingVar: 20px;<br>}</p>\n<p>.enclosing .closure {<br>  –closureVar: 30px;</p>\n<p>  font-size: calc(var(–closureVar) + var(–enclosingVar) + var(–globalVar));<br>  /* 60px for now */<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/malyw/pen/MJmebz/\">css-custom-properties-time-to-start-using 1</a> by Serg Hospodarets (<a href=\"https://codepen.io/malyw\">@malyw</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h2 id=\"对自定义属性的更改将立即应用于所有实例\"><a href=\"#对自定义属性的更改将立即应用于所有实例\" class=\"headerlink\" title=\"对自定义属性的更改将立即应用于所有实例\"></a>对自定义属性的更改将立即应用于所有实例</h2><p>到目前为止我们还没有看出他和Sass变量有什么区别。然而让我们重新给变量赋值： 在Sass中，是无效的：</p>\n<p>.closure {<br>  $closureVar: 30px; // local variable<br>  font-size: $closureVar +$enclosingVar+ $globalVar;<br>  // 60px, $closureVar: 30px is used</p>\n<p>  $closureVar: 50px; // local variable<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/malyw/pen/bgWerv/\">css-custom-properties-time-to-start-using 3</a> by Serg Hospodarets (<a href=\"https://codepen.io/malyw\">@malyw</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>但是在CSS中计算的值改变了。因为<code>font-size</code>的值因为<code>--closureVar</code>值得改变重新计算了：</p>\n<p>.enclosing .closure {<br>  –closureVar: 30px;<br>  font-size: calc(var(–closureVar) + var(–enclosingVar) + var(–globalVar));<br>  /* 80px for now, –closureVar: 50px is used */<br>  –closureVar: 50px;<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/malyw/pen/WRjxOy/\">css-custom-properties-time-to-start-using 2</a> by Serg Hospodarets (<a href=\"https://codepen.io/malyw\">@malyw</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>这是第一个非常大的区别：如果你对自定义属性重新赋值，浏览器会重新计算所有的变量和<code>calc()</code>表达式。</p>\n<h2 id=\"预处理器不能识别DOM结构\"><a href=\"#预处理器不能识别DOM结构\" class=\"headerlink\" title=\"预处理器不能识别DOM结构\"></a>预处理器不能识别DOM结构</h2><p>假如我们想在除了class是<code>highlighted</code>的div上使用默认的<code>font-size</code> 下面是 HTML代码：</p>\n<div class=\"default\">\n  default\n</div>\n\n<div class=\"default highlighted\">\n  default highlighted\n</div>\n\n<p>让我们使用CSS自定义属性：</p>\n<p>.highlighted {<br>  –highlighted-size: 30px;<br>}</p>\n<p>.default {<br>  –default-size: 10px;</p>\n<p>  /* Use default-size, except when highlighted-size is provided. */<br>  font-size: var(–highlighted-size, var(–default-size));<br>}</p>\n<p>因为第二个div元素使用了<code>highlighted</code>类，在<code>highlighted</code>类上的属性就提供给这个元素了。 在这里就意味着，<code>--hightlighted-size: 30px</code>被提供了。是的<code>font-size</code>的属性被重新赋值了。 一切都是这么直截了当的运行：</p>\n<p>See the Pen <a href=\"https://codepen.io/malyw/pen/ggWMvG/\">css-custom-properties-time-to-start-using 4</a> by Serg Hospodarets (<a href=\"https://codepen.io/malyw\">@malyw</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>接下来让我们尝试使用Sass来实现同样的例子：</p>\n<p>.highlighted {<br>  $highlighted-size: 30px;<br>}</p>\n<p>.default {<br>  $default-size: 10px;</p>\n<p>  /* Use default-size, except when highlighted-size is provided. */<br>  @if variable-exists(highlighted-size) {<br>    font-size: $highlighted-size;<br>  }<br>  @else {<br>    font-size: $default-size;<br>  }<br>}</p>\n<p>结果显示他们都使用默认字体大小：</p>\n<p>See the Pen <a href=\"https://codepen.io/malyw/pen/PWmzQO/\">css-custom-properties-time-to-start-using 5</a> by Serg Hospodarets (<a href=\"https://codepen.io/malyw\">@malyw</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>这是因为所有的Sass的计算和进程都发生在编译过程中，所以理所当然的他不知道DOM结构，所以依赖代码结构。 如你所见自定义属性在变量作用域和通常的css级联样式上具有优势。并且能够识别DOM结构。和普通的CSS属性使用相同的语法规则。 第二个例外是CSS自定义属性能动态的识别DOM结构</p>\n<h2 id=\"CSS关键字和all属性\"><a href=\"#CSS关键字和all属性\" class=\"headerlink\" title=\"CSS关键字和all属性\"></a>CSS关键字和all属性</h2><p>CSS自定义属性遵守与常规CSS自定义属性相同的规则。这意味着您可以为其分配任何常见的CSS关键字：</p>\n<ul>\n<li>  <code>inherit</code> 此CSS关键字应用元素的父对象的值。</li>\n<li>  <code>initial</code> 这将应用CSS规范中定义的初始值（空值，或在某些CSS自定义属性的情况下）。</li>\n<li>  <code>unset</code> 在自定义属性中，如果属性是继承的，则应用继承的值，如果属性是初始化的值，则引用初始化值。</li>\n<li>  <code>revert</code> 这会将该属性重置为用户代理样式表建立的默认值（在CSS自定义属性的情况下为空值）。</li>\n</ul>\n<p>以下是例子：</p>\n<p>.common-values{<br>  –border: inherit;<br>  –bgcolor: initial;<br>  –padding: unset;<br>  –animation: revert;<br>}</p>\n<p>我们来看另外一个例子。假设你想构建一个组件，并且想要确保没有其他样式或自定义属性被无意中应用（在这种情况下，通常会使用模块化的CSS解决方案）。 现在还有另一种方法：使用<a href=\"https://developer.mozilla.org/en/docs/Web/CSS/all\">all CSS属性</a>。这个简写将重置所有CSS属性。 与CSS关键字一起，我们可以执行以下操作：</p>\n<p>.my-wonderful-clean-component{<br>  all: initial;<br>}</p>\n<p>这会为我们的组件重置所有的样式： 不幸的是，all关键字<a href=\"https://drafts.csswg.org/css-variables/#defining-variables\">不会重置自定义属性</a>。<a href=\"https://github.com/w3c/webcomponents/issues/300#issuecomment-144551648\">关于是否添加 – 前缀</a>，这将重置所有CSS自定义属性，正在进行讨论。 所以在将来，一个完整的重置会是这样的：</p>\n<p>.my-wonderful-clean-component{<br>  –: initial; /* reset all CSS custom properties */<br>  all: initial; /* reset all other CSS styles */<br>}</p>\n<h2 id=\"CSS自定义属性用例\"><a href=\"#CSS自定义属性用例\" class=\"headerlink\" title=\"CSS自定义属性用例\"></a>CSS自定义属性用例</h2><p>有许多自定义属性使用的方式，在这里我会展示他们中最有趣的部分。</p>\n<h3 id=\"模拟不存在的CSS规则\"><a href=\"#模拟不存在的CSS规则\" class=\"headerlink\" title=\"模拟不存在的CSS规则\"></a>模拟不存在的CSS规则</h3><p>这些CSS变量的名称是自定义属性，那为什么我们不能用它来模拟不存在的CSS属性？ 有很多比如translateX/Y/Z,background-repeat-x/y(仍然不能跨浏览器兼容)，<code>box-shadow-color</code>。 让我们试着模拟最后一个属性。在这个例子里当hover的时候我们改变box-shadow的颜色。我们只想遵循DRY规则（不要重复你自：），所以我们只是改变它的颜色，而不是在<code>:hover</code>部分重复<code>box-shadow</code>的整个值。（变量的改变会重新计算<code>var()</code>和<code>calc()</code>）</p>\n<p>.test {<br>  –box-shadow-color: yellow;<br>  box-shadow: 0 0 30px var(–box-shadow-color);<br>}</p>\n<p>.test:hover {<br>  –box-shadow-color: orange;<br>  /* Instead of: box-shadow: 0 0 30px orange; */<br>}</p>\n<p>See the Pen <a href=\"https://codepen.io/malyw/pen/KzZXRq/\">Emulating &quot;box-shadow-color&quot; CSS property using CSS Custom Properties</a> by Serg Hospodarets (<a href=\"https://codepen.io/malyw\">@malyw</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<h3 id=\"颜色主题\"><a href=\"#颜色主题\" class=\"headerlink\" title=\"颜色主题\"></a>颜色主题</h3><p>自定义属性有一个最常用的用例就是应用程序中的颜色主题。自定义属性就是用来解决这类问题的。所以，让我们为一个组件提供一个简单的颜色主题（应用程序可以遵循相同的步骤）。 这是<a href=\"https://codepen.io/malyw/pen/XpRjNK\">button组件的代码</a>：</p>\n<p>.btn {<br>  background-image: linear-gradient(to bottom, #3498db, #2980b9);<br>  text-shadow: 1px 1px 3px #777;<br>  box-shadow: 0px 1px 3px #777;<br>  border-radius: 28px;<br>  color: #ffffff;<br>  padding: 10px 20px 10px 20px;<br>}</p>\n<p>我们假设要反转颜色主题。 第一步是将所有颜色变量扩展到CSS自定义属性并重写我们的组件。<a href=\"https://codepen.io/malyw/pen/EZmgmZ\">重写后的代码</a>：</p>\n<p>.btn {<br>  –shadow-color: #777;<br>  –gradient-from-color: #3498db;<br>  –gradient-to-color: #2980b9;<br>  –color: #ffffff;</p>\n<p>  background-image: linear-gradient(<br>    to bottom,<br>    var(–gradient-from-color),<br>    var(–gradient-to-color)<br>  );<br>  text-shadow: 1px 1px 3px var(–shadow-color);<br>  box-shadow: 0px 1px 3px var(–shadow-color);<br>  border-radius: 28px;<br>  color: var(–color);<br>  padding: 10px 20px 10px 20px;<br>}</p>\n<p>这有我们需要的一切。使用它，我们可以将颜色变量重写为反转值，并在需要时应用它们。例如，我们可以添加全局<code>inverted</code>类（例如，<code>body</code>元素），并在应用颜色时更改颜色：</p>\n<p>body.inverted .btn{<br>  –shadow-color: #888888;<br>  –gradient-from-color: #CB6724;<br>  –gradient-to-color: #D67F46;<br>  –color: #000000;<br>}</p>\n<p>以下是一个演示，您可以在其中单击一个按钮来添加和删除全局类</p>\n<p>See the Pen <a href=\"https://codepen.io/malyw/pen/dNWpRd/\">css-custom-properties-time-to-start-using 9</a> by Serg Hospodarets (<a href=\"https://codepen.io/malyw\">@malyw</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>如果不重复代码，在CSS预处理器中无法实现此行为。使用预处理器，您将始终需要覆盖实际的值和规则，这往往会导致额外的CSS。 使用CSS自定义属性，解决方案可以尽可能的干净，复制黏贴是可以避免的。因为只需要对变量进行重新赋值。</p>\n<h2 id=\"在JavaScript中使用自定义属性\"><a href=\"#在JavaScript中使用自定义属性\" class=\"headerlink\" title=\"在JavaScript中使用自定义属性\"></a>在JavaScript中使用自定义属性</h2><p>以前，要将数据从CSS发送到JavaScript，我们经常不得不采取<a href=\"https://blog.hospodarets.com/passing_data_from_sass_to_js\">技巧</a>，通过CSS输出中的纯JSON编写CSS值，然后从JavaScript读取它。 现在，我们可以轻松地使用JavaScript中的CSS变量进行交互，使用众所周知的<code>.getPropertyValue()</code>和<code>.setProperty()</code>方法读取和写入它们，这些方法用于通常的CSS属性:</p>\n<p>/**<br>* Gives a CSS custom property value applied at the element<br>* element {Element}<br>* varName {String} without ‘–’<br>*<br>* For example:<br>* readCssVar(document.querySelector(‘.box’), ‘color’);<br>*/<br>function readCssVar(element, varName){<br>  const elementStyles = getComputedStyle(element);<br>  return elementStyles.getPropertyValue(`–${varName}`).trim();<br>}</p>\n<p>/**<br>* Writes a CSS custom property value at the element<br>* element {Element}<br>* varName {String} without ‘–’<br>*<br>* For example:<br>* readCssVar(document.querySelector(‘.box’), ‘color’, ‘white’);<br>*/<br>function writeCssVar(element, varName, value){<br>  return element.style.setProperty(`–${varName}`, value);<br>}</p>\n<p>假设我们有一系列的媒体查询值</p>\n<p>.breakpoints-data {<br>  –phone: 480px;<br>  –tablet: 800px;<br>}</p>\n<p>因为我们只想在JavaScript中重用它们 - 例如，在<a href=\"https://developer.mozilla.org/en/docs/Web/API/Window/matchMedia\">Window.matchMedia()</a>中，我们可以轻松地从CSS中获取它们</p>\n<p>const breakpointsData = document.querySelector(‘.breakpoints-data’);</p>\n<p>// GET<br>const phoneBreakpoint = getComputedStyle(breakpointsData)<br>  .getPropertyValue(‘–phone’);</p>\n<p>为了展示如何从JavaScript分配自定义属性，我创建了一个交互式3D CSS 立方体demo，以响应用户操作。 这不是很难我们只需要添加一个简单的背景，然后放置五个立方体面与transform属性的相关值：<code>translateZ()</code>，<code>translateY()</code>，<code>rotateX()</code>和<code>rotateY()</code>。 为了提供正确的视角，我向页面添加了以下内容：</p>\n<p>#world{<br>  –translateZ:0;<br>  –rotateX:65;<br>  –rotateY:0;</p>\n<p>  transform-style:preserve-3d;<br>  transform:<br>    translateZ(calc(var(–translateZ) * 1px))<br>    rotateX(calc(var(–rotateX) * 1deg))<br>    rotateY(calc(var(–rotateY) * 1deg));<br>}</p>\n<p>唯一缺少的是交互性。当鼠标移动时，演示应该更改X和Y视角（<code>--rotateX</code>和<code>-rotateY</code>），当鼠标滚动（<code>--translateZ</code>）时应该放大和缩小）。 这是JavaScript的诀窍：</p>\n<p>// Events<br>onMouseMove(e) {<br>  this.worldXAngle = (.5 - (e.clientY / window.innerHeight)) * 180;<br>  this.worldYAngle = -(.5 - (e.clientX / window.innerWidth)) * 180;<br>  this.updateView();<br>};</p>\n<p>onMouseWheel(e) {<br>  /*…*/</p>\n<p>  this.worldZ += delta * 5;<br>  this.updateView();<br>};</p>\n<p>// JavaScript -&gt; CSS<br>updateView() {<br>  this.worldEl.style.setProperty(‘–translateZ’, this.worldZ);<br>  this.worldEl.style.setProperty(‘–rotateX’, this.worldXAngle);<br>  this.worldEl.style.setProperty(‘–rotateY’, this.worldYAngle);<br>};</p>\n<p>现在，当用户移动鼠标时，演示会更改视图。您可以通过移动鼠标并使用鼠标滚轮放大和缩小来检查：</p>\n<p>See the Pen <a href=\"https://codepen.io/malyw/pen/xgdEQp/\">css-custom-properties-time-to-start-using 10</a> by Serg Hospodarets (<a href=\"https://codepen.io/malyw\">@malyw</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>基本上，我们只是更改了CSS自定义属性的值。其他（旋转和放大和缩小）都是由CSS完成的。 提示：调整CSS自定义属性值的最简单方法之一就是在CSS生成的内容中显示其内容（在简单的情况下，例如使用字符串），以便浏览器将自动显示当前应用的值：</p>\n<p>body:after {<br>  content: ‘–screen-category : ‘var(–screen-category);<br>}</p>\n<p>您可以在纯<a href=\"https://codepen.io/malyw/pen/oBWMOY\">CSS演示</a>（无HTML或JavaScript）中查看。 （调整窗口大小，查看浏览器会自动反映更改后的CSS自定义属性值。） 浏览器支持 主流<a href=\"http://caniuse.com/#feat=css-variables\">浏览器</a>都支持了CSS自定义属性: <img src=\"http://file.w3cbest.com/file/images/20190118223123.jpg\"> 这意味着你可以自己开始使用它们。 如果您需要支持旧版浏览器，您可以学习语法和使用示例，并考虑并行切换或使用CSS和预处理器变量的可能方法。 当然，我们需要能够检测CSS和JavaScript中的支持，以便提供回退或增强功能。 这很容易对于CSS，您可以使用带有虚拟功能查询的<a href=\"https://developer.mozilla.org/en/docs/Web/CSS/@supports\">@supports条件</a>：</p>\n<p>@supports ( (–a: 0)) {<br>  /* supported */<br>}</p>\n<p>@supports ( not (–a: 0)) {<br>  /* not supported */<br>}</p>\n<p>在JavaScript中，您可以使用与<code>CSS.supports()</code>静态方法相同的虚拟自定义属性：</p>\n<p>const isSupported = window.CSS &amp;&amp;<br>    window.CSS.supports &amp;&amp; window.CSS.supports(‘–a’, 0);</p>\n<p>if (isSupported) {<br>  /* supported */<br>} else {<br>  /* not supported */<br>}</p>\n<p>我们看到，CSS自定义属性在每个浏览器中仍然不可用。知道这一点，您可以通过检查它们是否受支持来逐步增强您的应用程序。 例如，您可以生成两个主要的CSS文件：一个具有CSS自定义属性，另一个没有它们，其中属性是内联的（我们将在稍后讨论一些方法）。 默认加载第二个。然后，如果支持自定义属性，只需检查JavaScript并切换到增强版本即可:</p>\n<p>// JavaScript<br>if(isSupported){<br>  removeCss(‘without-css-custom-properties.css’);<br>  loadCss(‘css-custom-properties.css’);<br>  // + conditionally apply some application enhancements<br>  // using the custom properties<br>}</p>\n<p>这只是一个例子。往下看，有更好的选择。</p>\n<h2 id=\"如何开始使用它们\"><a href=\"#如何开始使用它们\" class=\"headerlink\" title=\"如何开始使用它们\"></a>如何开始使用它们</h2><p>针对<a href=\"https://ashleynolan.co.uk/blog/frontend-tooling-survey-2016-results\">最近的一项调查</a>，Sass已经成为了开发社区中预处理器的最佳选择。 所以，让我们考虑开始使用CSS自定义属性或使用Sass为他们做准备的方法。 我们有一些观点。</p>\n<h3 id=\"1-手动检查代码支持\"><a href=\"#1-手动检查代码支持\" class=\"headerlink\" title=\"1. 手动检查代码支持\"></a>1. 手动检查代码支持</h3><p>手动检查代码中自定义属性是否支持的方法的一个优点是如果它可行我们就可以直接用它（不要忘记我们已经切换到Sass）：</p>\n<p>$color: red;<br>:root {<br>  –color: red;<br>}</p>\n<p>.box {<br>  @supports ( (–a: 0)) {<br>    color: var(–color);<br>  }<br>  @supports ( not (–a: 0)) {<br>    color: $color;<br>  }<br>}</p>\n<p>这种方法确实有许多缺点，其中不仅仅是代码变得复杂，而且复制和粘贴变得很难维护。</p>\n<h3 id=\"2-使用自动转换CSS的插件\"><a href=\"#2-使用自动转换CSS的插件\" class=\"headerlink\" title=\"2. 使用自动转换CSS的插件\"></a>2. 使用自动转换CSS的插件</h3><p>PostCSS生态系统今天提供了几十个插件。它们中的几个在生成的CSS输出中处理自定义属性（内联值），并使它们工作，假设您仅提供全局变量（即，您只声明或更改：根选择器中的CSS自定义属性），因此它们的值可以轻松内联。 其中一个例子就是<a href=\"https://github.com/postcss/postcss-custom-properties\">postcss-custom-properties</a> 这个插件提供了几个优点：它使语法工作;它与PostCSS的所有基础设施兼容;并且不需要太多的配置。 但是有一些缺点。该插件需要您使用CSS自定义属性，因此您没有准备项目以从Sass变量切换的路径。此外，您将无法对转换进行很多控制，因为在Sass被编译为CSS之后完成。最后，插件不提供很多调试信息。</p>\n<h3 id=\"3-css-vars-Mixin\"><a href=\"#3-css-vars-Mixin\" class=\"headerlink\" title=\"3. css-vars Mixin\"></a>3. <a href=\"https://github.com/malyw/css-vars\">css-vars Mixin</a></h3><p>我开始在我大多数项目里使用CSS自定义属性并且尝试了很多策略：</p>\n<ul>\n<li>  用<a href=\"http://cssnext.io/\">cssnext</a>从Sass切换到<a href=\"http://cssnext.io/\">PostCSS</a>。</li>\n<li>  从Sass变量切换到纯CSS自定义属性。</li>\n<li>  在Sass中使用CSS变量来检测是否支持它们。</li>\n</ul>\n<p>通过这些经验，我开始寻找一个可以满足我的标准的解决方案：</p>\n<ul>\n<li>  它应该很容配合Sass来使用。</li>\n<li>  应该直接使用，并且语法必须尽可能接近原生的CSS自定义属性。</li>\n<li>  将CSS输出从内联值切换到CSS变量应该很容易。</li>\n<li>  熟悉CSS自定义属性的团队成员将能够使用该解决方案。</li>\n<li>  应该有一种方法有使用变量的调试信息。</li>\n</ul>\n<p>因此，我创建了css-vars，一个Sass mixin，可以在<a href=\"https://github.com/malyw/css-vars\">Github</a>上找到。使用它，你就可以使用CSS自定义属性语法。</p>\n<h2 id=\"使用-css-vars-Mixin\"><a href=\"#使用-css-vars-Mixin\" class=\"headerlink\" title=\"使用 css-vars Mixin\"></a>使用 css-vars Mixin</h2><p>声明变量，使用的mixin如下：</p>\n<p>$white-color: #fff;<br>$base-font-size: 10px;</p>\n<p>@include css-vars((<br>  –main-color: #000,<br>  –main-bg: $white-color,<br>  –main-font-size: 1.5*$base-font-size,<br>  –padding-top: calc(2vh + 20px)<br>));</p>\n<p>使用这些变量，用var()函数：</p>\n<p>body {<br>  color: var(–main-color);<br>  background: var(–main-bg, #f00);<br>  font-size: var(–main-font-size);<br>  padding: var(–padding-top) 0 10px;<br>}</p>\n<p>这为您提供了一种从一个地方（从Sass）控制所有CSS输出并开始熟悉语法的方法。此外，您可以使用mixin重用Sass变量和逻辑。 当您想要支持的所有浏览器都使用CSS变量时，您需要做的就是添加：</p>\n<p>$css-vars-use-native: true;</p>\n<p>而不是调整生成的CSS中的变量属性，mixin将开始注册自定义属性，并且<code>var()</code>实例将转到生成的CSS而不进行任何转换。这意味着您将完全切换到CSS自定义属性，并具有我们讨论的所有优点。 如果你想打开有用的调试信息，如下：</p>\n<p>$css-vars-debug-log: true;</p>\n<p>这会给你</p>\n<ul>\n<li>  当变量没有被定义却被使用的日志</li>\n<li>  变量被重复定义的日志</li>\n<li>  当默认值代替了未定义变量值的日志</li>\n</ul>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>现在你对CSS自定义属性有了更多的了解，包括语法、优势、一些有用的例子还有如何在JavaScript中进行交互 你需要知道如何确认他们是否被支持，他们和CSS预处理器的变量有什么区别，以及如何在浏览器支持之前开始使用原生的CSS变量。 这是开始使用CSS自定义属性并为浏览器支持做准备的最佳时机。</p>\n","categories":["HTML/CSS"],"tags":["javascript","css var()","CSS Variables","前端开发","var()"]},{"title":"正则表达式30分钟入门教程","url":"/2019/05/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F30%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","content":"<h2 id=\"正则表达式到底是什么东西？\"><a href=\"#正则表达式到底是什么东西？\" class=\"headerlink\" title=\"正则表达式到底是什么东西？\"></a>正则表达式到底是什么东西？</h2><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 很可能你使用过Windows/Dos下用于文件查找的通配符(wildcard)，也就是*和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索*.doc。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像010-12345678或0376-7654321)。</p>\n<blockquote>\n<p>字符是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。字符串是0个或更多个字符的序列。文本也就是文字，字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。</p>\n</blockquote>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。 假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。 这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。 不幸的是，很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\\bhi\\b。 \\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它<strong>只匹配一个位置</strong>。</p>\n<blockquote>\n<p>如果需要更精确的说法，\\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\\w。</p>\n</blockquote>\n<p>假如你要找的是hi后面不远处跟着一个Lucy，你应该用\\bhi\\b.*\\bLucy\\b。 这里，.是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.*连在一起就意味着任意数量的不包含换行的字符。现在\\bhi\\b.*\\bLucy\\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。 如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：</p>\n<ul>\n<li>  0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。</li>\n</ul>\n<p>这里的\\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。 为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\\d{2}-\\d{8}。这里\\d后面的{2}({8})的意思是前面\\d必须连续重复匹配2次(8次)。</p>\n<blockquote>\n<p>换行符就是’\\n’,ASCII编码为10(十六进制0x0A)的字符。</p>\n</blockquote>\n<h2 id=\"测试正则表达式\"><a href=\"#测试正则表达式\" class=\"headerlink\" title=\"测试正则表达式\"></a>测试正则表达式</h2><p>如果你不觉得正则表达式很难读写的话，要么你是一个天才，要么，你不是地球人。正则表达式的语法很令人头疼，即使对经常使用它的人来说也是如此。由于难于读写，容易出错，所以找一种工具对正则表达式进行测试是很有必要的。 不同的环境下正则表达式的一些细节是不相同的，本教程介绍的是微软 .Net Framework 4.5 下正则表达式的行为，所以，我向你推荐我编写的.Net下的工具 Regester。请参考该页面的说明来安装和运行该软件。 <strong>下载与安装</strong> 你可以使用以下两种方式中的任意一个来下载安装正则表达式测试器.</p>\n<ul>\n<li>安装版<ul>\n<li>  下载 <a href=\"http://deerchao.net/tools/regester/regester.setup.zh.zip\">Regester安装程序</a></li>\n<li>  解压后运行 RegesterSetup.zh.exe</li>\n</ul>\n</li>\n<li>绿色版<ul>\n<li>  下载 <a href=\"http://deerchao.net/tools/regester/regester.zip\">Regester</a></li>\n<li>  解压后运行 Regester.exe</li>\n<li>  如果无法启动,请自行下载安装 <a href=\"https://www.microsoft.com/zh-cn/download/details.aspx?id=30653\">Microsoft .Net Framework 4.5</a> 后再试</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><p>现在你已经知道几个很有用的元字符了，如\\b,.,*，还有\\d.正则表达式里还有更多的元字符，比如\\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\\w匹配字母或数字或下划线或汉字等。 下面来看看更多的例子：</p>\n<ul>\n<li>  \\ba\\w*\\b匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w*)，最后是单词结束处(\\b)。</li>\n<li>  \\d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。</li>\n<li>  \\b\\w{6}\\b 匹配刚好6个字符的单词。</li>\n</ul>\n<p>表1.常用的元字符</p>\n<p>代码</p>\n<p>说明</p>\n<p>.</p>\n<p>匹配除换行符以外的任意字符</p>\n<p>\\w</p>\n<p>匹配字母或数字或下划线或汉字</p>\n<p>\\s</p>\n<p>匹配任意的空白符</p>\n<p>\\d</p>\n<p>匹配数字</p>\n<p>\\b</p>\n<p>匹配单词的开始或结束</p>\n<p>^</p>\n<p>匹配字符串的开始</p>\n<p>$</p>\n<p>匹配字符串的结束</p>\n<p>元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\\d{5,12}$。 这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。 因为使用了^和$，所以输入的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。 和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。</p>\n<h2 id=\"字符转义\"><a href=\"#字符转义\" class=\"headerlink\" title=\"字符转义\"></a>字符转义</h2><p>如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用\\.和\\*。当然，要查找\\本身，你也得用\\\\. 例如：deerchao\\.net匹配deerchao.net，C:\\\\Windows匹配C:\\Windows。</p>\n<h2 id=\"重复\"><a href=\"#重复\" class=\"headerlink\" title=\"重复\"></a>重复</h2><p>你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：</p>\n<p>表2.常用的限定符</p>\n<p>代码/语法</p>\n<p>说明</p>\n<p>*</p>\n<p>重复零次或更多次</p>\n<p>+</p>\n<p>重复一次或更多次</p>\n<p>?</p>\n<p>重复零次或一次</p>\n<p>{n}</p>\n<p>重复n次</p>\n<p>{n,}</p>\n<p>重复n次或更多次</p>\n<p>{n,m}</p>\n<p>重复n到m次</p>\n<p>下面是一些使用重复的例子：</p>\n<ul>\n<li>  Windows\\d+匹配Windows后面跟1个或更多数字</li>\n<li>  ^\\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</li>\n</ul>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？ 很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。 我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）。 下面是一个更复杂的表达式：\\(?0\\d{2}[) -]?\\d{8}。 这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符\\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。</p>\n<h2 id=\"分枝条件\"><a href=\"#分枝条件\" class=\"headerlink\" title=\"分枝条件\"></a>分枝条件</h2><p>不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用把不同的规则分隔开。听不明白？没关系，看例子： 0\\d{2}-\\d{8}0\\d{3}-\\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。 \\(0\\d{2}\\)[- ]?\\d{8}0\\d{2}[- ]?\\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。 \\d{5}-\\d{4}\\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：<strong>使用分枝条件时，要注意各个条件的顺序</strong>。如果你把它改成\\d{5}\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。 (\\d{1,3}\\.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}\\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。 不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\\d25[0-5][01]?\\d\\d?)\\.){3}(2[0-4]\\d25[0-5][01]?\\d\\d?)。 理解这个表达式的关键是理解2[0-4]\\d25[0-5][01]?\\d\\d?，这里我就不细说了，你自己应该能分析得出来它的意义。</p>\n<h2 id=\"反义\"><a href=\"#反义\" class=\"headerlink\" title=\"反义\"></a>反义</h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：</p>\n<p>表3.常用的反义代码</p>\n<p>代码/语法</p>\n<p>说明</p>\n<p>\\W</p>\n<p>匹配任意不是字母，数字，下划线，汉字的字符</p>\n<p>\\S</p>\n<p>匹配任意不是空白符的字符</p>\n<p>\\D</p>\n<p>匹配任意非数字的字符</p>\n<p>\\B</p>\n<p>匹配不是单词开头或结束的位置</p>\n<p>[^x]</p>\n<p>匹配除了x以外的任意字符</p>\n<p>[^aeiou]</p>\n<p>匹配除了aeiou这几个字母以外的任意字符</p>\n<p>例子：\\S+匹配不包含空白符的字符串。 &lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。</p>\n<h2 id=\"后向引用\"><a href=\"#后向引用\" class=\"headerlink\" title=\"后向引用\"></a>后向引用</h2><p>使用小括号指定一个子表达式后，<strong>匹配这个子表达式的文本</strong>(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 后向引用用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。难以理解？请看示例： \\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。 你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\\w+)(或者把尖括号换成’也行：(?’Word’\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k<Word>,所以上一个例子也可以写成这样：\\b(?<Word>\\w+)\\b\\s+\\k<Word>\\b。 使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</p>\n<p>表4.常用分组语法</p>\n<p>分类</p>\n<p>代码/语法</p>\n<p>说明</p>\n<p>捕获</p>\n<p>(exp)</p>\n<p>匹配exp,并捕获文本到自动命名的组里</p>\n<p>(?<name>exp)</p>\n<p>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</p>\n<p>(?:exp)</p>\n<p>匹配exp,不捕获匹配的文本，也不给此分组分配组号</p>\n<p>零宽断言</p>\n<p>(?=exp)</p>\n<p>匹配exp前面的位置</p>\n<p>(?&lt;=exp)</p>\n<p>匹配exp后面的位置</p>\n<p>(?!exp)</p>\n<p>匹配后面跟的不是exp的位置</p>\n<p>(?&lt;!exp)</p>\n<p>匹配前面不是exp的位置</p>\n<p>注释</p>\n<p>(?#comment)</p>\n<p>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</p>\n<p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？</p>\n<h2 id=\"零宽断言\"><a href=\"#零宽断言\" class=\"headerlink\" title=\"零宽断言\"></a>零宽断言</h2><p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧： (?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。 (?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。 假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\\d)\\d{3})+\\b，用它对1234567890进行查找时结果是234567890。 下面这个例子同时使用了这两种断言：(?&lt;=\\s)\\d+(?=\\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>\n<h2 id=\"负向零宽断言\"><a href=\"#负向零宽断言\" class=\"headerlink\" title=\"负向零宽断言\"></a>负向零宽断言</h2><p>前面我们提到过怎么查找<strong>不是某个字符或不在某个字符类里</strong>的字符的方法(反义)。但是如果我们只是想要<strong>确保某个字符没有出现，但并不想去匹配它</strong>时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样： \\b\\w*q[^u]\\w*\\b匹配包含<strong>后面不是字母u的字母q</strong>的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像<strong>Iraq</strong>,<strong>Benq</strong>，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w*\\b将会匹配下一个单词，于是\\b\\w*q[^u]\\w*\\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不<strong>消费</strong>任何字符。现在，我们可以这样来解决这个问题：\\b\\w*q(?!u)\\w*\\b。 零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\\d{3}(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。 同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字。 一个更复杂的例子：(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是一个后缀(?=&lt;\\/\\1&gt;)。注意后缀里的\\/，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的(\\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。</p>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)25[0-5](?#250-255)[01]?\\d\\d?(?#0-199)。 要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：</p>\n<p>(?&lt;=    # 断言要匹配的文本的前缀<br>&lt;(\\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)<br>)       # 前缀结束<br>.*      # 匹配任意文本<br>(?=     # 断言要匹配的文本的后缀<br>&lt;\\/\\1&gt;  # 查找尖括号括起来的内容：前面是一个”/“，后面是先前捕获的标签<br>)       # 后缀结束</p>\n<h2 id=\"贪婪与懒惰\"><a href=\"#贪婪与懒惰\" class=\"headerlink\" title=\"贪婪与懒惰\"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。 有时，我们更需要懒惰匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧： a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p>\n<p>表5.懒惰限定符</p>\n<p>代码/语法</p>\n<p>说明</p>\n<p>*?</p>\n<p>重复任意次，但尽可能少重复</p>\n<p>+?</p>\n<p>重复1次或更多次，但尽可能少重复</p>\n<p>??</p>\n<p>重复0次或1次，但尽可能少重复</p>\n<p>{n,m}?</p>\n<p>重复n到m次，但尽可能少重复</p>\n<p>{n,}?</p>\n<p>重复n次以上，但尽可能少重复</p>\n<h2 id=\"处理选项\"><a href=\"#处理选项\" class=\"headerlink\" title=\"处理选项\"></a>处理选项</h2><p>上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：</p>\n<p>表6.常用的处理选项</p>\n<p>名称</p>\n<p>说明</p>\n<p>IgnoreCase(忽略大小写)</p>\n<p>匹配时不区分大小写。</p>\n<p>Multiline(多行模式)</p>\n<p>更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\\n之前的位置以及字符串结束前的位置.)</p>\n<p>Singleline(单行模式)</p>\n<p>更改.的含义，使它与每一个字符匹配（包括换行符\\n）。</p>\n<p>IgnorePatternWhitespace(忽略空白)</p>\n<p>忽略表达式中的非转义空白并启用由#标记的注释。</p>\n<p>ExplicitCapture(显式捕获)</p>\n<p>仅捕获已被显式命名的组。</p>\n<p>一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。</p>\n<h2 id=\"平衡组-递归匹配\"><a href=\"#平衡组-递归匹配\" class=\"headerlink\" title=\"平衡组/递归匹配\"></a>平衡组/递归匹配</h2><p>有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用\\(.+\\)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？ 为了避免(和\\(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把xx &lt;aa <bbb> <bbb> aa&gt; yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？ 这里需要用到以下的语法构造：</p>\n<ul>\n<li>  (?’group’) 把捕获的内容命名为group,并压入堆栈(Stack)</li>\n<li>  (?’-group’) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li>\n<li>  (?(group)yesno) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</li>\n<li>  (?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li>\n</ul>\n<p>我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。</p>\n<p>&lt;                         #最外层的左括号<br>    [^&lt;&gt;]*                #最外层的左括号后面的不是括号的内容<br>    (<br>        (<br>            (?’Open’&lt;)    #碰到了左括号，在黑板上写一个”Open”<br>            [^&lt;&gt;]*       #匹配左括号后面的不是括号的内容<br>        )+<br>        (<br>            (?’-Open’&gt;)   #碰到了右括号，擦掉一个”Open”<br>            [^&lt;&gt;]*        #匹配右括号后面不是括号的内容<br>        )+<br>    )*<br>    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的”Open”；如果还有，则匹配失败</p>\n<blockquote>\n<pre><code>                    #最外层的右括号\n</code></pre>\n</blockquote>\n<p>平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：&lt;div[^&gt;]*&gt;[^&lt;&gt;]*(((?’Open’&lt;div[^&gt;]*&gt;)[^&lt;&gt;]*)+((?’-Open’</div>)[^&lt;&gt;]*)+)*(?(Open)(?!))</div>.</p>\n<h2 id=\"还有些什么东西没提到\"><a href=\"#还有些什么东西没提到\" class=\"headerlink\" title=\"还有些什么东西没提到\"></a>还有些什么东西没提到</h2><p>上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们–当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.net下正则表达式详细的文档。这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看<a href=\"http://msdn.microsoft.com/zh-cn/library/az24scfc.aspx\">关于正则表达式语言元素的MSDN在线文档</a>。</p>\n<p>表7.尚未详细讨论的语法</p>\n<p>代码/语法</p>\n<p>说明</p>\n<p>\\a</p>\n<p>报警字符(打印它的效果是电脑嘀一声)</p>\n<p>\\b</p>\n<p>通常是单词分界位置，但如果在字符类里使用代表退格</p>\n<p>\\t</p>\n<p>制表符，Tab</p>\n<p>\\r</p>\n<p>回车</p>\n<p>\\v</p>\n<p>竖向制表符</p>\n<p>\\f</p>\n<p>换页符</p>\n<p>\\n</p>\n<p>换行符</p>\n<p>\\e</p>\n<p>Escape</p>\n<p>\\0nn</p>\n<p>ASCII代码中八进制代码为nn的字符</p>\n<p>\\xnn</p>\n<p>ASCII代码中十六进制代码为nn的字符</p>\n<p>\\unnnn</p>\n<p>Unicode代码中十六进制代码为nnnn的字符</p>\n<p>\\cN</p>\n<p>ASCII控制字符。比如\\cC代表Ctrl+C</p>\n<p>\\A</p>\n<p>字符串开头(类似^，但不受处理多行选项的影响)</p>\n<p>\\Z</p>\n<p>字符串结尾或行尾(不受处理多行选项的影响)</p>\n<p>\\z</p>\n<p>字符串结尾(类似$，但不受处理多行选项的影响)</p>\n<p>\\G</p>\n<p>当前搜索的开头</p>\n<p>\\p{name}</p>\n<p>Unicode中命名为name的字符类，例如\\p{IsGreek}</p>\n<p>(?&gt;exp)</p>\n<p>贪婪子表达式</p>\n<p>(?<x>-<y>exp)</p>\n<p>平衡组</p>\n<p>(?im-nsx:exp)</p>\n<p>在子表达式exp中改变处理选项</p>\n<p>(?im-nsx)</p>\n<p>为表达式后面的部分改变处理选项</p>\n<p>(?(exp)yesno)</p>\n<p>把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no</p>\n<p>(?(exp)yes)</p>\n<p>同上，只是使用空表达式作为no</p>\n<p>(?(name)yesno)</p>\n<p>如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no</p>\n<p>(?(name)yes)</p>\n<p>同上，只是使用空表达式作为no</p>\n<h2 id=\"网上的资源及本文参考文献\"><a href=\"#网上的资源及本文参考文献\" class=\"headerlink\" title=\"网上的资源及本文参考文献\"></a>网上的资源及本文参考文献</h2><ul>\n<li>  <a href=\"https://item.jd.com/11070361.html\">精通正则表达式(第3版)</a></li>\n<li>  <a href=\"https://msdn.microsoft.com/zh-cn/library/hs600312.aspx\">微软的正则表达式教程</a></li>\n<li>  <a href=\"http://msdn2.microsoft.com/zh-cn/library/system.text.regularexpressions.regex.aspx\">System.Text.RegularExpressions.Regex类(MSDN)</a></li>\n<li>  <a href=\"http://www.regular-expressions.info/\">专业的正则表达式教学网站(英文)</a></li>\n<li>  <a href=\"http://weblogs.asp.net/whaggard/archive/2005/02/20/377025.aspx\">关于.Net下的平衡组的详细讨论（英文）</a></li>\n</ul>\n<p>来源：<a href=\"http://deerchao.net/tutorials/regex/regex.htm\">http://deerchao.net/tutorials/regex/regex.htm</a></p>\n","categories":["JavaScript"],"tags":["regex","正则","正则表达式"]},{"title":"CSS Grid 布局完全指南教程","url":"/2018/09/22/css-grid-%E5%B8%83%E5%B1%80%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%E6%95%99%E7%A8%8B/","content":"<p>CSS Grid 布局是 CSS 中最强大的布局系统。与 <a href=\"http://www.w3cbest.com/490.html\">flexbox</a> 的一维布局系统不同，CSS Grid 布局是一个二维布局系统，也就意味着它可以同时处理列和行。通过将 CSS 规则应用于 父元素 (成为 Grid Container 网格容器)和其 子元素（成为 Grid Items 网格项），你就可以轻松使用 Grid(网格) 布局。 这篇文章最初是从<a href=\"http://chris.house/blog/a-complete-guide-css-grid-layout/\">Chris House</a>的指南中移植过来的，并且一直由CSS-Tricks工作人员和付费作家保持最新。 CSS网格布局(又称“网格”)，是一个二维的基于网格的布局系统，旨在完全改变我们设计基于网格的用户界面的方式。CSS一直被用来布局我们的网页，但它从来没有做得很好。一开始我们用表格（table），然后是浮动（float），再是定位（postion）和内嵌块（inline-block），但是所有这些方法本质上都是一些技巧，忽略了许多重要的功能(例如，垂直居中)。Flexbox 的出现很大程度上改善了我们的布局方式，但它的目的是为了解决更简单的一维布局，而不是复杂的二维布局(Flexbox和Grid实际上配合得很好)。Grid是第一个专门为解决布局问题而创建的CSS模块，自从我们创建网站以来，我们一直在努力解决布局问题。 有两个主要因素激发了我创建本指南的灵感。第一个是 Rachel Andrew 出色的书籍 为 <a href=\"http://abookapart.com/products/get-ready-for-css-grid-layout\">CSS Grid</a> 布局做好准备。这本书对 Grid 布局做了全面，清晰的介绍 ，也是本指南的基础。我强烈建议你购买并阅读。另一个灵感来自 Chris Coyier 的 <a href=\"http://www.w3cbest.com/490.html\">Flexbox 布局完整指南</a>，这也是我学习 flexbox 首选的资源。这篇文章是帮助了很多人，这点从 Google “flexbox” 排名第一就可以看出来。你会发现那篇文章和我的文章有很多相似之处，为什么不跟随最好的文章呢？ 本指南的目的是介绍存在于最新版本的规范中 Grid(网格) 概念。所以我不会覆盖过时的 IE 语法，而且随着规范的逐渐成熟，我会尽我最大的努力去更新这个指南。</p>\n<h2 id=\"基础知识和浏览器支持\"><a href=\"#基础知识和浏览器支持\" class=\"headerlink\" title=\"基础知识和浏览器支持\"></a>基础知识和浏览器支持</h2><p>首先，你必须使用 display: grid 将容器元素定义为一个 grid(网格) 布局，使用 grid-template-columns 和 grid-template-rows 设置 列 和 行 的尺寸大小，然后通过 grid-column 和 grid-row 将其子元素放入这个 grid(网格) 中。与 flexbox 类似，网格项（grid items）的源(HTML结构)顺序无关紧要。你的 CSS 可以以任何顺序放置它们，这使得使用 媒体查询（media queries）重新排列网格变得非常容易。定义整个页面的布局，然后完全重新排列布局以适应不同的屏幕宽度，这些都只需要几行 CSS ，想象一下就让人兴奋。Grid(网格) 布局是有史以来最强大的 CSS 模块之一。 截至2017年3月，许多浏览器都提供了对 CSS Grid 的原生支持，而且无需加浏览器前缀：Chrome（包括 Android ），Firefox，Edge，Safari（包括iOS）和 Opera 。 另一方面，Internet Explorer 10和11支持它，但是是一个过时的语法实现。 现在是时候使用 Grid 布局网页了！ 这个浏览器支持数据来自Caniuse，它有更多细节。数字表示浏览器支持该版本及以上版本的功能。</p>\n<p>复制代码</p>\n<h2 id=\"重要术语\"><a href=\"#重要术语\" class=\"headerlink\" title=\"重要术语\"></a>重要术语</h2><p>在深入了解 Grid 的概念之前，理解术语是很重要的。由于这里涉及的术语在概念上都很相似，如果不先记住 Grid 规范定义的含义，很容易混淆它们。但是别担心，术语并不多。</p>\n<h3 id=\"网格容器-Grid-Container\"><a href=\"#网格容器-Grid-Container\" class=\"headerlink\" title=\"网格容器(Grid Container)\"></a>网格容器(Grid Container)</h3><p>应用 display: grid 的元素。这是所有 网格项（grid item）的直接父级元素。在这个例子中，container 就是 网格容器(Grid Container)。</p>\n<div class=\"container\">\n  <div class=\"item item-1\"></div>\n  <div class=\"item item-2\"></div>\n  <div class=\"item item-3\"></div>\n</div>\n\n<h3 id=\"网格项-Grid-Item\"><a href=\"#网格项-Grid-Item\" class=\"headerlink\" title=\"网格项(Grid Item)\"></a>网格项(Grid Item)</h3><p>网格容器（Grid Container）的子元素（例如直接子元素）。这里 item 元素就是网格项(Grid Item)，但是 sub-item 不是。</p>\n<div class=\"container\">\n  <div class=\"item\"></div> \n  <div class=\"item\">\n    <p class=\"sub-item\"></p>\n  </div>\n  <div class=\"item\"></div>\n</div>\n\n<h3 id=\"网格线-Grid-Line\"><a href=\"#网格线-Grid-Line\" class=\"headerlink\" title=\"网格线(Grid Line)\"></a>网格线(Grid Line)</h3><p>构成网格结构的分界线。它们既可以是垂直的（“列网格线(column grid lines)”），也可以是水平的（“行网格线(row grid lines)”），并位于行或列的任一侧。例如，这里的黄线就是一条列网格线。 <img src=\"http://file.w3cbest.com/file/images/terms-grid-line.svg\"></p>\n<h3 id=\"网格轨道-Grid-Track\"><a href=\"#网格轨道-Grid-Track\" class=\"headerlink\" title=\"网格轨道(Grid Track)\"></a>网格轨道(Grid Track)</h3><p>两条相邻网格线之间的空间。你可以把它们想象成网格的列或行。下图是第二条和第三条 行网格线 之间的 网格轨道(Grid Track)。 <img src=\"http://file.w3cbest.com/file/images/terms-grid-track.svg\"></p>\n<h3 id=\"网格单元格-Grid-Cell\"><a href=\"#网格单元格-Grid-Cell\" class=\"headerlink\" title=\"网格单元格(Grid Cell)\"></a>网格单元格(Grid Cell)</h3><p>两个相邻的行和两个相邻的列网格线之间的空间。这是 Grid(网格) 系统的一个“单元”。下图是第 1 至第 2 条 行网格线 和第 2 至第 3 条 列网格线 交汇构成的 网格单元格(Grid Cell)。 <img src=\"http://file.w3cbest.com/file/images/terms-grid-cell.svg\"></p>\n<h3 id=\"网格区域-Grid-Area\"><a href=\"#网格区域-Grid-Area\" class=\"headerlink\" title=\"网格区域(Grid Area)\"></a>网格区域(Grid Area)</h3><p>4条网格线包围的总空间。一个 网格区域(Grid Area) 可以由任意数量的 网格单元格(Grid Cell) 组成。下图是 行网格线1和3，以及列网格线1和3 之间的网格区域。 <img src=\"http://file.w3cbest.com/file/images/terms-grid-area.svg\"></p>\n<h3 id=\"Grid-网格-属性目录\"><a href=\"#Grid-网格-属性目录\" class=\"headerlink\" title=\"Grid(网格) 属性目录\"></a>Grid(网格) 属性目录</h3><p>网格容器(Grid Container) 属性</p>\n<p>格项(Grid Items) 属性</p>\n<p><a href=\"#prop-display\">display</a></p>\n<p><a href=\"#prop-grid-column-row-start-end\">grid-column-start</a></p>\n<p><a href=\"#prop-grid-template-columns-rows\">grid-template-columns</a></p>\n<p><a href=\"#prop-grid-column-row-start-end\">grid-column-end</a></p>\n<p><a href=\"#prop-grid-template-columns-rows\">grid-template-rows</a></p>\n<p><a href=\"#prop-grid-column-row-start-end\">grid-row-start</a></p>\n<p><a href=\"#prop-grid-template-areas\">grid-template-areas</a></p>\n<p><a href=\"#prop-grid-column-row-start-end\">grid-row-end</a></p>\n<p><a href=\"#prop-grid-template\">grid-template</a></p>\n<p><a href=\"#prop-grid-column-row\">grid-column</a></p>\n<p><a href=\"#prop-grid-column-row-gap\">grid-column-gap</a></p>\n<p><a href=\"#prop-grid-column-row\">grid-row</a></p>\n<p><a href=\"#prop-grid-column-row-gap\">grid-row-gap</a></p>\n<p><a href=\"#prop-grid-area\">grid-area</a></p>\n<p><a href=\"#prop-justify-items\">justify-items</a></p>\n<p><a href=\"#prop-justify-self\">justify-self</a></p>\n<p><a href=\"#prop-justify-items\">justify-items</a></p>\n<p><a href=\"#prop-align-self\">align-self</a></p>\n<p><a href=\"#prop-justify-items\">justify-items</a></p>\n<p><a href=\"#prop-place-self\">place-self</a></p>\n<p><a href=\"#prop-align-items\">align-items</a></p>\n<p><a href=\"#prop-place-items\">place-items</a></p>\n<p><a href=\"#prop-justify-content\">justify-content</a></p>\n<p><a href=\"#prop-align-content\">align-content</a></p>\n<p><a href=\"#prop-place-content\">place-content</a></p>\n<p><a href=\"#prop-grid-auto-columns-rows\">grid-auto-columns</a></p>\n<p><a href=\"#prop-grid-auto-columns-rows\">grid-auto-rows</a></p>\n<p><a href=\"#prop-grid-auto-flow\">grid-auto-flow</a></p>\n<p><a href=\"#prop-grid\">grid</a></p>\n<h3 id=\"父元素-网格容器-Grid-Container-属性\"><a href=\"#父元素-网格容器-Grid-Container-属性\" class=\"headerlink\" title=\"父元素 网格容器(Grid Container) 属性\"></a>父元素 网格容器(Grid Container) 属性</h3><p> </p>\n<h3 id=\"display\"><a href=\"#display\" class=\"headerlink\" title=\"display\"></a>display</h3><p>将元素定义为网格容器，并为其内容建立新的 网格格式上下文。 值：</p>\n<ul>\n<li>  <strong>grid</strong> ：生成一个块级网格</li>\n<li>  <strong>inline-grid</strong> ：生成一个内联网格</li>\n</ul>\n<p>.container {<br>  display: grid  inline-grid;<br>}</p>\n<p>注意：通过嵌套元素（也称为子网格，即 subgrid ）向下传递网格参数的能力已移至<a href=\"https://www.w3.org/TR/css-grid-2/#subgrids\">CSS Grid 规范的Level 2</a> 版本。这里有<a href=\"https://css-tricks.com/grid-level-2-and-subgrid/\">一个快速解释</a>。</p>\n<h3 id=\"grid-template-columns-grid-template-rows\"><a href=\"#grid-template-columns-grid-template-rows\" class=\"headerlink\" title=\"grid-template-columns/grid-template-rows\"></a>grid-template-columns/grid-template-rows</h3><p>使用空格分隔的值列表，用来定义网格的列和行。这些值表示 网格轨道(Grid Track) 大小，它们之间的空格表示网格线。 值：</p>\n<ul>\n<li>  <track-size>： 可以是长度值，百分比，或者等份网格容器中可用空间（使用 fr 单位）</li>\n<li>  <line-name>：你可以选择的任意名称</li>\n</ul>\n<p>.container {<br>  grid-template-columns: <track-size> …  <line-name> <track-size> …;<br>  grid-template-rows: <track-size> …  <line-name> <track-size> …;<br>}</p>\n<p>例子： 当你在 网格轨道(Grid Track) 值之间留出空格时，网格线会自动分配正数和负数名称：</p>\n<p>.container {<br>  grid-template-columns: 40px 50px auto 50px 40px;<br>  grid-template-rows: 25% 100px auto;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/template-columns-rows-01.svg\"> 但是你可以明确的指定网格线(Grid Line)名称，例如 <line-name> 值。请注意网格线名称的括号语法：</p>\n<p>.container {<br>  grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];<br>  grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/template-column-rows-02.svg\"> 请注意，一条网格线(Grid Line)可以有多个名称。例如，这里的第二条 行网格线(row grid lines) 将有两个名字：row1-end 和 row2-start ：</p>\n<p>.container {<br>  grid-template-rows: [row1-start] 25% [row1-end row2-start] 25% [row2-end];<br>}</p>\n<p>如果你的定义包含多个重复值，则可以使用 repeat() 表示法来简化定义：</p>\n<p>.container {<br>  grid-template-columns: repeat(3, 20px [col-start]);<br>}</p>\n<p>上面的代码等价于：</p>\n<p>.container {<br>  grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start];<br>}</p>\n<p>如果多行共享相同的名称，则可以通过其网格线名称和计数来引用它们。</p>\n<p>.item {<br>  grid-column-start: col-start 2;<br>}</p>\n<p>fr 单元允许你用等分网格容器剩余可用空间来设置 网格轨道(Grid Track) 的大小 。例如，下面的代码会将每个网格项设置为网格容器宽度的三分之一：</p>\n<p>.container {<br>  grid-template-columns: 1fr 1fr 1fr;<br>}</p>\n<p>剩余可用空间是除去所有非灵活网格项 之后 计算得到的。在这个例子中，可用空间总量减去 50px 后，再给 fr 单元的值 3 等分：</p>\n<p>.container {<br>  grid-template-columns: 1fr 50px 1fr 1fr;<br>}</p>\n<h3 id=\"grid-template-areas\"><a href=\"#grid-template-areas\" class=\"headerlink\" title=\"grid-template-areas\"></a>grid-template-areas</h3><p>通过引用 grid-area 属性指定的 网格区域(Grid Area) 名称来定义网格模板。重复网格区域的名称导致内容跨越这些单元格。一个点号（.）代表一个空单元格。这个语法本身可视作网格的可视化结构。 值：</p>\n<ul>\n<li>  <grid-area-name>：由网格项的 grid-area 指定的网格区域名称</li>\n<li>  .（点号） ：代表一个空的网格单元</li>\n<li>  none：不定义网格区域</li>\n</ul>\n<p>.container {<br>  grid-template-areas:<br>    “<grid-area-name>  .  none  …”<br>    “…”;<br>}</p>\n<p>示例：</p>\n<p>.item-a {<br>  grid-area: header;<br>}<br>.item-b {<br>  grid-area: main;<br>}<br>.item-c {<br>  grid-area: sidebar;<br>}<br>.item-d {<br>  grid-area: footer;<br>}</p>\n<p>.container {<br>  grid-template-columns: 50px 50px 50px 50px;<br>  grid-template-rows: auto;<br>  grid-template-areas:<br>    “header header header header”<br>    “main main . sidebar”<br>    “footer footer footer footer”;<br>}</p>\n<p>上面的代码将创建一个 4 列宽 3 行高的网格。整个顶行将由 header 区域组成。中间一排将由两个 main 区域，一个是空单元格，一个 sidebar 区域组成。最后一行全是 footer 区域组成。 <img src=\"http://file.w3cbest.com/file/images/dddgrid-template-areas.svg\"> 你的声明中的每一行都需要有相同数量的单元格。 你可以使用任意数量的相邻的 点. 来声明单个空单元格。 只要这些点.之间没有空隙隔开，他们就代表一个单独的单元格。 注意你 不能 用这个语法来命名网格线，只是命名 网格区域 。当你使用这种语法时，区域两端的网格线实际上会自动命名。如果你的网格区域的名字是 foo，该区域的起始行网格线 和 起始列网格线 的名称将为 foo-start，而最后一条行网格线 和 最后一条列网格线 的名称将为 foo-end。这意味着某些网格线可能有多个名字，如上例中最左边的网格线，它将有三个名称：header-start，main-start 和 footer-start 。 </p>\n<h3 id=\"grid-template\"><a href=\"#grid-template\" class=\"headerlink\" title=\"grid-template\"></a>grid-template</h3><p>用于定义grid-template-rows ，grid-template-columns ，grid-template-areas 简写属性。 值：</p>\n<ul>\n<li>  none：将所有三个属性设置为其初始值</li>\n<li>  <grid-template-rows> / <grid-template-columns>：将 grid-template-columns 和 grid-template-rows 设置为相应地特定的值，并且设置grid-template-areas为none</li>\n</ul>\n<p>.container {<br>  grid-template: none  <grid-template-rows> / <grid-template-columns>;<br>}</p>\n<p>这个属性也接受一个更复杂但非常方便的语法来指定三个上诉属性。这里有一个例子：</p>\n<p>.container {<br>  grid-template:<br>    [row1-start] “header header header” 25px [row1-end]<br>    [row2-start] “footer footer footer” 25px [row2-end]<br>    / auto 50px auto;<br>}</p>\n<p>等价于：</p>\n<p>.container {<br>  grid-template-rows: [row1-start] 25px [row1-end row2-start] 25px [row2-end];<br>  grid-template-columns: auto 50px auto;<br>  grid-template-areas:<br>    “header header header”<br>    “footer footer footer”;<br>}</p>\n<p>由于 grid-template 不会重置 隐式 网格属性（grid-auto-columns， grid-auto-rows， 和 grid-auto-flow），这可能是你想在大多数情况下做的，建议使用 grid 属性而不是 grid-template。</p>\n<h3 id=\"grid-column-gap-grid-row-gap\"><a href=\"#grid-column-gap-grid-row-gap\" class=\"headerlink\" title=\"grid-column-gap / grid-row-gap\"></a>grid-column-gap / grid-row-gap</h3><p>指定网格线(grid lines)的大小。你可以把它想象为设置列/行之间间距的宽度。 值：</p>\n<ul>\n<li>  <line-size> ：长度值</li>\n</ul>\n<p>.container {<br>  grid-column-gap: <line-size>;<br>  grid-row-gap: <line-size>;<br>}</p>\n<p>示例：</p>\n<p>.container {<br>  grid-template-columns: 100px 50px 100px;<br>  grid-template-rows: 80px auto 80px;<br>  grid-column-gap: 10px;<br>  grid-row-gap: 15px;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/dddgrid-gap.svg\"> 只能在 列/行 之间创建间距，网格外部边缘不会有这个间距。 注意：这两个属性将删除 grid- 前缀，就是将 grid-column-gap 和 grid-row-gap重命名为 column-gap 和 row-gap。 Chrome 68+，Safari 11.2 Release 50+ 和Opera 54+ 已经支持无前缀的属性。  </p>\n<h3 id=\"grid-gap\"><a href=\"#grid-gap\" class=\"headerlink\" title=\"grid-gap\"></a>grid-gap</h3><p>grid-column-gap 和 grid-row-gap 的简写语法 值：</p>\n<ul>\n<li>  <grid-row-gap> <grid-column-gap>：长度值</li>\n</ul>\n<p>.container {<br>  grid-gap: <grid-row-gap> <grid-column-gap>;<br>}</p>\n<p>示例：</p>\n<p>.container {<br>  grid-template-columns: 100px 50px 100px;<br>  grid-template-rows: 80px auto 80px;<br>  grid-gap: 15px 10px;<br>}</p>\n<p>如果grid-row-gap没有定义，那么就会被设置为等同于 grid-column-gap 的值。例如下面的代码是等价的：</p>\n<p>.container{<br>  /* 设置 grid-column-gap 和 grid-row-gap */<br>  grid-column-gap: 10px;<br>  grid-row-gap: 10px; </p>\n<p>  /* 等价于 */<br>  grid-gap: 10px 10px;</p>\n<p>  /* 等价于 */<br>  grid-gap: 10px;<br>}</p>\n<p>注意：这个属性将删除 grid- 前缀，就是将 grid-gap 重命名为 gap。 Chrome 68+，Safari 11.2 Release 50+ 和Opera 54+ 已经支持无前缀的属性。</p>\n<h3 id=\"justify-items\"><a href=\"#justify-items\" class=\"headerlink\" title=\"justify-items\"></a>justify-items</h3><p>沿着 inline（行）轴线对齐网格项(grid items)（相反的属性是 align-items 沿着 block（列）轴线对齐）。此值适用于容器内的所有网格项。 值：</p>\n<ul>\n<li>  start：将网格项对齐到其单元格的左侧起始边缘（左侧对齐）</li>\n<li>  end：将网格项对齐到其单元格的右侧结束边缘（右侧对齐）</li>\n<li>  center：将网格项对齐到其单元格的水平中间位置（水平居中对齐）</li>\n<li>  stretch：填满单元格的宽度（默认值）</li>\n</ul>\n<p>.container {<br>  justify-items: start  end  center  stretch;<br>}</p>\n<p>示例：</p>\n<p>.container {<br>  justify-items: start;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-items-start.svg\"></p>\n<p>.container{<br>  justify-items: end;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-items-end.svg\"></p>\n<p>.container{<br>  justify-items: center;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-items-center.svg\"></p>\n<p>.container{<br>  justify-items: stretch;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-items-stretch.svg\"> 这些行为也可以通过每个单独网格项(grid items) 的 justify-self 属性设置。 </p>\n<h3 id=\"align-items\"><a href=\"#align-items\" class=\"headerlink\" title=\"align-items\"></a>align-items</h3><p>沿着 block（列）轴线对齐网格项(grid items)（相反的属性是 justify-items 沿着 inline（行）轴线对齐）。此值适用于容器内的所有网格项。 值：</p>\n<ul>\n<li>  start：将网格项对齐到其单元格的顶部起始边缘（顶部对齐）</li>\n<li>  end：将网格项对齐到其单元格的底部结束边缘（底部对齐）</li>\n<li>  center：将网格项对齐到其单元格的垂直中间位置（垂直居中对齐）</li>\n<li>  stretch：填满单元格的高度（默认值）</li>\n</ul>\n<p>.container {<br>  align-items: start  end  center  stretch;<br>}</p>\n<p>示例：</p>\n<p>.container {<br>  align-items: start;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-items-start.svg\"></p>\n<p>.container {<br>  align-items: end;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-items-end.svg\"></p>\n<p>.container {<br>  align-items: center;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-items-center.svg\"></p>\n<p>.container {<br>  align-items: stretch;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-items-stretch.svg\"> 这些行为也可以通过每个单独网格项(grid items) 的 align-self 属性设置。 </p>\n<h3 id=\"place-items\"><a href=\"#place-items\" class=\"headerlink\" title=\"place-items\"></a>place-items</h3><p>place-items 是设置 align-items 和 justify-items 的简写形式。 值：</p>\n<ul>\n<li>  <align-items> <justify-items>：第一个值设置 align-items 属性，第二个值设置 justify-items 属性。如果省略第二个值，则将第一个值同时分配给这两个属性。</li>\n</ul>\n<p>除 Edge 之外的所有主要浏览器都支持 place-items 简写属性。 有关更多详细信息，请参阅<a href=\"#prop-align-items\">align-items</a> 和 <a href=\"#prop-justify-items\">justify-items</a>。  </p>\n<h3 id=\"justify-content\"><a href=\"#justify-content\" class=\"headerlink\" title=\"justify-content\"></a>justify-content</h3><p>有时，你的网格合计大小可能小于其 网格容器(grid container) 大小。 如果你的所有 网格项(grid items) 都使用像 px 这样的非灵活单位设置大小，就可能出现这种情况。在这种情况下，您可以设置网格容器内的网格的对齐方式。 此属性沿着 inline（行）轴线对齐网格（相反的属性是 align-content ，沿着 block（列）轴线对齐网格）。 值：</p>\n<ul>\n<li>  start：将网格对齐到 网格容器(grid container) 的左侧起始边缘（左侧对齐）</li>\n<li>  end：将网格对齐到 网格容器 的右侧结束边缘（右侧对齐）</li>\n<li>  center：将网格对齐到 网格容器 的水平中间位置（水平居中对齐）</li>\n<li>  stretch：调整 网格项(grid items) 的宽度，允许该网格填充满整个 网格容器 的宽度</li>\n<li>  space-around：在每个网格项之间放置一个均匀的空间，左右两端放置一半的空间</li>\n<li>  space-between：在每个网格项之间放置一个均匀的空间，左右两端没有空间</li>\n<li>  space-evenly：在每个网格项目之间放置一个均匀的空间，左右两端放置一个均匀的空间</li>\n</ul>\n<p>.container {<br>  justify-content: start  end  center  stretch  space-around  space-between  space-evenly;<br>}</p>\n<p>示例：</p>\n<p>.container {<br>  justify-content: start;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-content-start.svg\"></p>\n<p>.container {<br>  justify-content: end;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-content-end.svg\"></p>\n<p>.container {<br>  justify-content: center;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-content-center.svg\"></p>\n<p>.container {<br>  justify-content: stretch;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-content-stretch.svg\"></p>\n<p>.container {<br>  justify-content: space-around;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-content-space-around.svg\"></p>\n<p>.container {<br>  justify-content: space-between;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-content-space-between.svg\"></p>\n<p>.container {<br>  justify-content: space-evenly;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-content-space-evenly.svg\"> </p>\n<h3 id=\"align-content\"><a href=\"#align-content\" class=\"headerlink\" title=\"align-content\"></a>align-content</h3><p>有时，你的网格合计大小可能小于其 网格容器(grid container) 大小。 如果你的所有 网格项(grid items) 都使用像 px 这样的非灵活单位设置大小，就可能出现这种情况。在这种情况下，您可以设置网格容器内的网格的对齐方式。 此属性沿着 block（列）轴线对齐网格（相反的属性是 justify-content ，沿着 inline（行）轴线对齐网格）。 值：</p>\n<ul>\n<li>  start：将网格对齐到 网格容器(grid container) 的顶部起始边缘（顶部对齐）</li>\n<li>  end：将网格对齐到 网格容器 的底部结束边缘（底部对齐）</li>\n<li>  center：将网格对齐到 网格容器 的垂直中间位置（垂直居中对齐）</li>\n<li>  stretch：调整 网格项(grid items) 的高度，允许该网格填充满整个 网格容器 的高度</li>\n<li>  space-around：在每个网格项之间放置一个均匀的空间，上下两端放置一半的空间</li>\n<li>  space-between：在每个网格项之间放置一个均匀的空间，上下两端没有空间</li>\n<li>  space-evenly：在每个网格项目之间放置一个均匀的空间，上下两端放置一个均匀的空间</li>\n</ul>\n<p>.container {<br>  align-content: start  end  center  stretch  space-around  space-between  space-evenly;<br>}</p>\n<p>示例：</p>\n<p>.container {<br>  align-content: start;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-content-start.svg\"></p>\n<p>.container {<br>  align-content: end;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-content-end.svg\"></p>\n<p>.container {<br>  align-content: center;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-content-center.svg\"></p>\n<p>.container {<br>  align-content: stretch;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-content-stretch.svg\"></p>\n<p>.container {<br>  align-content: space-around;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-content-space-around.svg\"></p>\n<p>.container {<br>  align-content: space-between;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-content-space-between.svg\"></p>\n<p>.container {<br>align-content: space-evenly;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-content-space-evenly.svg\"> </p>\n<h2 id=\"place-content\"><a href=\"#place-content\" class=\"headerlink\" title=\"place-content\"></a>place-content</h2><p>place-content 是设置 align-content 和 justify-content 的简写形式。 值：</p>\n<ul>\n<li>  <align-content> <justify-content>：第一个值设置 align-content 属性，第二个值设置 justify-content 属性。如果省略第二个值，则将第一个值同时分配给这两个属性。</li>\n</ul>\n<p>除 Edge 之外的所有主要浏览器都支持 place-content 简写属性。 有关更多详细信息，请参阅align-content 和 justify-content。</p>\n<h3 id=\"grid-auto-columns-grid-auto-rows\"><a href=\"#grid-auto-columns-grid-auto-rows\" class=\"headerlink\" title=\"grid-auto-columns / grid-auto-rows\"></a>grid-auto-columns / grid-auto-rows</h3><p>指定任何自动生成的网格轨道(grid tracks)（又名隐式网格轨道）的大小。当网格中的网格项多于单元格时，或者当网格项位于显式网格之外时，就会创建隐式轨道。（<a href=\"http://www.w3cbest.com/504.html\">参见显式网格和隐式网格之间的区别</a>） 值：</p>\n<ul>\n<li>  <track-size>：可以是长度值，百分比，或者等份网格容器中可用空间的分数（使用 fr 单位）</li>\n</ul>\n<p>.container {<br>  grid-auto-columns: <track-size> …;<br>  grid-auto-rows: <track-size> …;<br>}</p>\n<p>为了说明如何创建隐式网格轨道，请考虑一下以下的代码：</p>\n<p>.container {<br>  grid-template-columns: 60px 60px;<br>  grid-template-rows: 90px 90px<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/grid-auto-columns-rows-01.svg\"> 这将生成了一个 2×2 的网格。 但现在想象一下，你使用 grid-column 和 grid-row 来定位你的网格项，像这样：</p>\n<p>.item-a {<br>  grid-column: 1 / 2;<br>  grid-row: 2 / 3;<br>}<br>.item-b {<br>  grid-column: 5 / 6;<br>  grid-row: 2 / 3;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/grid-auto-columns-rows-02.svg\"> 我们告诉 .item-b 从第 5 条列网格线开始到第 6 条列网格线结束，但我们从来没有定义过 第5 或 第6 列网格线。 因为我们引用的网格线不存在，所以创建宽度为 0 的隐式网格轨道以填补空缺。我们可以使用 grid-auto-columns 和 grid-auto-rows 来指定这些隐式轨道的大小：</p>\n<p>.container {<br>  grid-auto-columns: 60px;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/grid-auto-columns-rows-03.svg\">  </p>\n<h3 id=\"grid-auto-flow\"><a href=\"#grid-auto-flow\" class=\"headerlink\" title=\"grid-auto-flow\"></a>grid-auto-flow</h3><p>如果你有一些没有明确放置在网格上的网格项(grid items)，自动放置算法 会自动放置这些网格项。该属性控制自动布局算法如何工作。 值：</p>\n<ul>\n<li>  row：告诉自动布局算法依次填充每行，根据需要添加新行 （默认）</li>\n<li>  column：告诉自动布局算法依次填入每列，根据需要添加新列</li>\n<li>  dense：告诉自动布局算法在稍后出现较小的网格项时，尝试填充网格中较早的空缺</li>\n</ul>\n<p>.container {<br>  grid-auto-flow: row  column  row dense  column dense<br>}</p>\n<p>请注意，dense 只会更改网格项的可视顺序，并可能导致它们出现乱序，这对可访问性不利。 示例： 考虑以下 HTML :</p>\n<section class=\"container\">\n  <div class=\"item-a\">item-a</div>\n  <div class=\"item-b\">item-b</div>\n  <div class=\"item-c\">item-c</div>\n  <div class=\"item-d\">item-d</div>\n  <div class=\"item-e\">item-e</div>\n</section>\n\n<p>你定义一个有 5 列和 2 行的网格，并将 grid-auto-flow 设置为 row（也就是默认值）：</p>\n<p>.container {<br>  display: grid;<br>  grid-template-columns: 60px 60px 60px 60px 60px;<br>  grid-template-rows: 30px 30px;<br>  grid-auto-flow: row;<br>}</p>\n<p>将网格项放在网格上时，只能为其中的两个指定位置：</p>\n<p>.item-a {<br>  grid-column: 1;<br>  grid-row: 1 / 3;<br>}<br>.item-e {<br>  grid-column: 5;<br>  grid-row: 1 / 3;<br>}</p>\n<p>因为我们把 grid-auto-flow 设成了 row ，所以我们的网格看起来会是这样。注意 我们没有进行定位的网格项（item-b，item-c，item-d）会这样排列在可用的行中： <img src=\"http://file.w3cbest.com/file/images/grid-auto-flow-01.svg\"> 相反地，如果我们把 grid-auto-flow 设成了 column ，那么 item-b，item-c，item-d 会沿着列向下排列：</p>\n<p>.container {<br>  display: grid;<br>  grid-template-columns: 60px 60px 60px 60px 60px;<br>  grid-template-rows: 30px 30px;<br>  grid-auto-flow: column;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/grid-auto-flow-02.svg\"> </p>\n<h3 id=\"grid\"><a href=\"#grid\" class=\"headerlink\" title=\"grid\"></a>grid</h3><p>在一个声明中设置所有以下属性的简写： grid-template-rows, grid-template-columns, grid-template-areas, grid-auto-rows, grid-auto-columns, 和 grid-auto-flow 。（注意：您只能在单个网格声明中指定显式或隐式网格属性）。 值：</p>\n<ul>\n<li>  none：将所有子属性设置为其初始值。</li>\n<li>  <grid-template>：与grid-template 简写的工作方式相同。</li>\n<li>  <grid-template-rows> / [ auto-flow &amp;&amp; dense? ] <grid-auto-columns>? ：将grid-template-rows 设置为指定的值。 如果 auto-flow 关键字位于斜杠的右侧，则会将 grid-auto-flow 设置为 column。 如果另外指定了 dense 关键字，则自动放置算法使用 “dense” 算法。 如果省略 grid-auto-columns ，则将其设置为 auto。</li>\n<li>  [ auto-flow &amp;&amp; dense? ] <grid-auto-rows>? / <grid-template-columns>：将 grid-template-columns 设置为指定值。 如果 auto-flow 关键字位于斜杠的左侧，则会将grid-auto-flow 设置为 row 。 如果另外指定了 dense 关键字，则自动放置算法使用 “dense” 打包算法。 如果省略 grid-auto-rows ，则将其设置为 auto。</li>\n</ul>\n<p>例子： 以下两个代码块是等效的：</p>\n<p>.container {<br>  grid: 100px 300px / 3fr 1fr;<br>}</p>\n<p>.container {<br>  grid-template-rows: 100px 300px;<br>  grid-template-columns: 3fr 1fr;<br>}</p>\n<p>以下两个代码块是等效的：</p>\n<p>.container {<br>  grid: auto-flow / 200px 1fr;<br>}</p>\n<p>.container {<br>  grid-auto-flow: row;<br>  grid-template-columns: 200px 1fr;<br>}</p>\n<p>以下两个代码块是等效的：</p>\n<p>.container {<br>  grid: auto-flow dense 100px / 1fr 2fr;<br>}</p>\n<p>.container {<br>  grid-auto-flow: row dense;<br>  grid-auto-rows: 100px;<br>  grid-template-columns: 1fr 2fr;<br>}</p>\n<p>以下两个代码块是等效的：</p>\n<p>.container {<br>  grid: 100px 300px / auto-flow 200px;<br>}</p>\n<p>.container {<br>  grid-template-rows: 100px 300px;<br>  grid-auto-flow: column;<br>  grid-auto-columns: 200px;<br>}</p>\n<p>它也接受一个更复杂但相当方便的语法来一次设置所有内容。您可以指定 grid-template-areas，grid-template-rows和grid-template-columns，并所有其他的子属性都被设置为它们的初始值。这么做可以在它们网格区域内相应地指定网格线名字和网格轨道的大小。用最简单的例子来描述：</p>\n<p>.container {<br>  grid: [row1-start] “header header header” 1fr [row1-end]<br>        [row2-start] “footer footer footer” 25px [row2-end]<br>        / auto 50px auto;<br>}</p>\n<p>等价于：</p>\n<p>.container {<br>  grid-template-areas:<br>    “header header header”<br>    “footer footer footer”;<br>  grid-template-rows: [row1-start] 1fr [row1-end row2-start] 25px [row2-end];<br>  grid-template-columns: auto 50px auto;<br>}</p>\n<h3 id=\"子元素-网格项-Grid-Items-属性\"><a href=\"#子元素-网格项-Grid-Items-属性\" class=\"headerlink\" title=\"子元素 网格项(Grid Items) 属性\"></a>子元素 网格项(Grid Items) 属性</h3><p>注意：float，display: inline-block，display: table-cell，vertical-align 和 column-* 属性对网格项无效。</p>\n<h3 id=\"grid-column-start-grid-column-end-grid-row-start-grid-row-end\"><a href=\"#grid-column-start-grid-column-end-grid-row-start-grid-row-end\" class=\"headerlink\" title=\"grid-column-start / grid-column-end / grid-row-start / grid-row-end\"></a>grid-column-start / grid-column-end / grid-row-start / grid-row-end</h3><p>通过引用特定网格线(grid lines) 来确定 网格项(grid item) 在网格内的位置。 grid-column-start / grid-row-start 是网格项开始的网格线，grid-column-end / grid-row-end 是网格项结束的网格线。 值：</p>\n<ul>\n<li>  <line> ：可以是一个数字引用一个编号的网格线，或者一个名字来引用一个命名的网格线</li>\n<li>  span <number> ：该网格项将跨越所提供的网格轨道数量</li>\n<li>  span <name> ：该网格项将跨越到它与提供的名称位置</li>\n<li>  auto：表示自动放置，自动跨度，默认会扩展一个网格轨道的宽度或者高度</li>\n</ul>\n<p>.item {<br>  grid-column-start: <number>  <name>  span <number>  span <name>  auto<br>  grid-column-end: <number>  <name>  span <number>  span <name>  auto<br>  grid-row-start: <number>  <name>  span <number>  span <name>  auto<br>  grid-row-end: <number>  <name>  span <number>  span <name>  auto<br>}</p>\n<p>示例：</p>\n<p>.item-a {<br>  grid-column-start: 2;<br>  grid-column-end: five;<br>  grid-row-start: row1-start<br>  grid-row-end: 3;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/grid-column-row-start-end-01.svg\"></p>\n<p>.item-b {<br>  grid-column-start: 1;<br>  grid-column-end: span col4-start;<br>  grid-row-start: 2<br>  grid-row-end: span 2<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/grid-column-row-start-end-02.svg\"> 如果没有声明指定 grid-column-end / grid-row-end，默认情况下，该网格项将占据 1 个轨道。 项目可以相互重叠。您可以使用 z-index 来控制它们的重叠顺序。  </p>\n<h3 id=\"grid-column-grid-row\"><a href=\"#grid-column-grid-row\" class=\"headerlink\" title=\"grid-column / grid-row\"></a>grid-column / grid-row</h3><p>分别为 grid-column-start + grid-column-end 和 grid-row-start + grid-row-end 的简写形式。 值：</p>\n<ul>\n<li>  <start-line> / <end-line>：每个网格项都接受所有相同的值，作为普通书写的版本，包括跨度</li>\n</ul>\n<p>.item {<br>  grid-column: <start-line> / <end-line>  <start-line> / span <value>;<br>  grid-row: <start-line> / <end-line>  <start-line> / span <value>;<br>}</p>\n<p>示例：</p>\n<p>.item-c {<br>  grid-column: 3 / span 2;<br>  grid-row: third-line / 4;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/grid-column-row.svg\"> 如果没有声明分隔线结束位置，则该网格项默认占据 1 个网格轨道。 </p>\n<h3 id=\"grid-area\"><a href=\"#grid-area\" class=\"headerlink\" title=\"grid-area\"></a>grid-area</h3><p>为网格项提供一个名称，以便可以 被使用网格容器 grid-template-areas 属性创建的模板进行引用。 另外，这个属性可以用作grid-row-start + grid-column-start + grid-row-end + grid-column-end 的简写。 值：</p>\n<ul>\n<li>  <name>：你所选的名称</li>\n<li>  <row-start> / <column-start> / <row-end> / <column-end>：数字或分隔线名称</li>\n</ul>\n<p>.item {<br>  grid-area: <name>  <row-start> / <column-start> / <row-end> / <column-end>;<br>}</p>\n<p>示例： 作为为网格项分配名称的一种方法：</p>\n<p>.item-d {<br>  grid-area: header<br>}</p>\n<p>作为grid-row-start + grid-column-start + grid-row-end + grid-column-end 属性的简写形式</p>\n<p>.item-d {<br>    grid-area: 1 / col4-start / last-line / 6<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/grid-area.svg\"> </p>\n<h3 id=\"justify-self\"><a href=\"#justify-self\" class=\"headerlink\" title=\"justify-self\"></a>justify-self</h3><p>沿着 inline（行）轴线对齐网格项（ 相反的属性是 align-self ，沿着 block（列）轴线对齐）。此值适用于单个网格项内的内容。 值：</p>\n<ul>\n<li>  start：将网格项对齐到其单元格的左侧起始边缘（左侧对齐）</li>\n<li>  end：将网格项对齐到其单元格的右侧结束边缘（右侧对齐）</li>\n<li>  center：将网格项对齐到其单元格的水平中间位置（水平居中对齐）</li>\n<li>  stretch：填满单元格的宽度（默认值）</li>\n</ul>\n<p>.item {<br>  justify-self: start  end  center  stretch;<br>}</p>\n<p>示例：</p>\n<p>.item-a {<br>  justify-self: start;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-self-start.svg\"></p>\n<p>.item-a {<br>  justify-self: end;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-self-end.svg\"></p>\n<p>.item-a {<br>  justify-self: center;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-self-center.svg\"></p>\n<p>.item-a {<br>  justify-self: stretch;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/justify-self-stretch.svg\"> 要为网格中的所有网格项设置 行轴线(row axis) 线上对齐方式，也可以在 网格容器 上设置 <a href=\"#prop-justify-items\">justify-items</a> 属性。 </p>\n<h3 id=\"align-self\"><a href=\"#align-self\" class=\"headerlink\" title=\"align-self\"></a>align-self</h3><p>沿着 block（列）轴线对齐网格项(grid items)（ 相反的属性是 justify-self ，沿着 inline（行）轴线对齐）。此值适用于单个网格项内的内容。 值：</p>\n<ul>\n<li>  start：将网格项对齐到其单元格的顶部起始边缘（顶部对齐）</li>\n<li>  end：将网格项对齐到其单元格的底部结束边缘（底部对齐）</li>\n<li>  center：将网格项对齐到其单元格的垂直中间位置（垂直居中对齐）</li>\n<li>  stretch：填满单元格的高度（默认值）</li>\n</ul>\n<p>.item{<br>  align-self: start  end  center  stretch;<br>}</p>\n<p>示例：</p>\n<p>.item-a {<br>  align-self: start;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-self-start.svg\"></p>\n<p>.item-a {<br>  align-self: end;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-self-end.svg\"></p>\n<p>.item-a {<br>  align-self: center;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-self-center.svg\"></p>\n<p>.item-a {<br>  align-self: stretch;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/align-self-stretch.svg\"> 要为网格中的所有网格项设置 列轴线(column axis) 上的对齐方式，也可以在 网格容器 上设置<a href=\"#prop-align-items\">align-items</a>属性。  </p>\n<h3 id=\"place-self\"><a href=\"#place-self\" class=\"headerlink\" title=\"place-self\"></a>place-self</h3><p>place-self 是设置 align-self 和 justify-self 的简写形式。 值：</p>\n<ul>\n<li>  auto – 布局模式的 “默认” 对齐方式。</li>\n<li>  <align-self> <justify-self>：第一个值设置 align-self 属性，第二个值设置 justify-self 属性。如果省略第二个值，则将第一个值同时分配给这两个属性。</li>\n</ul>\n<p>示例：</p>\n<p>.item-a {<br>  place-self: center;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/place-self-center.svg\"></p>\n<p>.item-a {<br>  place-self: center stretch;<br>}</p>\n<p><img src=\"http://file.w3cbest.com/file/images/place-self-center-stretch.svg\"> 除 Edge 之外的所有主要浏览器都支持 place-self 简写属性。</p>\n<h2 id=\"动画（Animation）\"><a href=\"#动画（Animation）\" class=\"headerlink\" title=\"动画（Animation）\"></a>动画（Animation）</h2><p>根据 CSS Grid 布局模块 Level 1 规范，有 5 个可应用动画的网格属性：</p>\n<ul>\n<li>  grid-gap， grid-row-gap，grid-column-gap 作为长度，百分比或 calc。</li>\n<li>  grid-template-columns，grid-template-rows 作为长度，百分比或 calc 的简单列表，只要列表中长度、百分比或calc组件的值不同即可。</li>\n</ul>\n<h3 id=\"浏览器支持CSS网格属性\"><a href=\"#浏览器支持CSS网格属性\" class=\"headerlink\" title=\"浏览器支持CSS网格属性\"></a>浏览器支持CSS网格属性</h3><p>截至今天（2018年5月7日），在测试的几个浏览器中仅实现 (grid-)gap，(grid-)row-gap，(grid-)column-gap 的动画。 浏览器支持可设置动画的网格属性：</p>\n<p>Browser</p>\n<p><code>(grid-)gap</code>, <code>(grid-)row-gap</code>, <code>(grid-)column-gap</code></p>\n<p><code>grid-template-columns</code></p>\n<p><code>grid-template-rows</code></p>\n<p>Firefox</p>\n<p>supported ✅ 53+</p>\n<p>supported ✅ 66+</p>\n<p>supported ✅ 66+</p>\n<p>Safari 12.0</p>\n<p>not supported ❌</p>\n<p>not supported ❌</p>\n<p>not supported ❌</p>\n<p>Chrome</p>\n<p>supported ✅ 66+</p>\n<p>not supported ❌</p>\n<p>not supported ❌</p>\n<p>Chrome for Android 66+, Opera Mini 33+</p>\n<p>supported ✅</p>\n<p>not supported ❌</p>\n<p>not supported ❌</p>\n<p>Edge</p>\n<p>supported ✅ 16+</p>\n<p>not supported ❌</p>\n<p>not supported ❌</p>\n<p>See the Pen <a href=\"https://codepen.io/matuzo/pen/rmQvMG/\">CSS Grid Layout: Animation</a> by Manuel Matuzovic (<a href=\"https://codepen.io/matuzo\">@matuzo</a>) on <a href=\"https://codepen.io/\">CodePen</a>.</p>\n<p>文章来源：<a href=\"https://css-tricks.com/snippets/css/complete-guide-grid/#prop-align-items\">https://css-tricks.com/</a></p>\n","categories":["HTML/CSS"],"tags":["css教程","grid-area","grid-template-areas","grid-template-columns","grid-template-rows","grid教程","html教程","前端教程","grid-gap","grid布局"]}]